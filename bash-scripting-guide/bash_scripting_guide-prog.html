<html>
  <head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
    <meta
     name="generator"
     content=
    "HTML Tidy for Linux/x86 (vers 1st July 2002), see www.w3.org">

    <title>Исскуство написания Bash-скриптов</title>
    
    <meta
     name="GENERATOR"
     content="Modular DocBook HTML Stylesheet Version 1.7">
    <link
     rel="NEXT"
     title="Введение"
     href="p112.html">
  </head>

  <body bgcolor="#DDE1C2">
<!--#include virtual="/header.raw"-->
<h3>Версия для печати</h3>
<b><a href="http://www.opennet.ru/docs/">Архив документации на OpenNet.ru</a> / 
Раздел "<a href="http://www.opennet.ru/docs/124.shtml">Программирование, языки</a>"
</b>
 <small>(<a href="./">Многостраничная версия</a>)</small>
<hr noshade size=1>

<a name="index_html"></a>
<div
     class="BOOK">
      <a
       name="index_html_AEN1"></a>

      <div
       class="TITLEPAGE">
        <h1
         class="TITLE"><a
         name="index_html_AEN2"></a>Advanced Bash-Scripting Guide</h1>

        <h2
         class="SUBTITLE">Искусство программирования на языке сценариев
        командной оболочки</h2>

        <h3
         class="AUTHOR"><a
         name="index_html_AEN5"></a>Автор: Mendel Cooper</h3>

        <div
         class="AFFILIATION">
          <span
           class="ORGNAME"><br>
          </span>

          <div
           class="ADDRESS">
            <p
             class="ADDRESS"><tt
             class="EMAIL">&lt;<a
             href=
            "mailto:thegrendel@theriver.com">thegrendel@theriver.com</a>&gt;</tt></p>
          </div>
        </div>

        <h3
         class="AUTHOR"><a
         name="index_html_AEN14"></a>Перевод: Андрей Киселев</h3>

        <div
         class="AFFILIATION">
          <span
           class="ORGNAME"><br>
          </span>

          <div
           class="ADDRESS">
            <p
             class="ADDRESS"><tt
             class="EMAIL">&lt;<a
             href=
            "mailto:kis_an@mail.ru">kis_an@mail.ru</a>&gt;</tt></p>
          </div>
        </div>
	<br>Оригинал: <a href="http://gazette.linux.ru.net/rus/articles/index-abs-guide.html">Russian Linux Gazette</a>
	<br><a href="#abs_guide_flat_tar_gz">Архив руководства в html-формате (~380Кб)</a>
        <br><a href="#abs_guide_sgml_tar_gz">Архив руководства в sgml-формате (~380Кб)</a>
    <hr>
        <div>
          <div
           class="ABSTRACT">
            <a
             name="index_html_AEN102"></a>

            <p>Данное руководство не предполагает наличие у читателя
            познаний в области программирования на языке сценариев,
            однако, быстро восполняет этот недостаток <span
             class="emphasis"><em
             class="EMPHASIS">. . . постепенно, шаг за шагом раскрывая
            мудрость и красоту UNIX</em></span>. Это руководство может
            рассматриваться как учебник, предназначенный для
            самостоятельного изучения или как справочник по
            программированию на shell. Руководство снабжено серией
            хорошо прокомментированных примеров, поскольку <tt
             class="USERINPUT"><strong>лучший путь к изучению языка
            сценариев -- это написание сценариев</strong></tt>.</p>

            <p>Последнюю версию документа, в виде <a
             href="#x7794_html_BZIPREF">.bz2</a> архива, содержащем
            исходные тексты в формате SGML и HTML, вы найдете на <a
             href=
            "http://personal.riverusers.com/~thegrendel/abs-guide-1.8.tar.bz2"
             target="_top">домашней страничке автора</a>. Там же вы
            найдете и <a
             href=
            "http://personal.riverusers.com/~thegrendel/Change.log"
             target="_top">change log</a>.</p>
          </div>
        </div>
        <hr>
      </div>

      <h1><a
       name="index_html_AEN110"></a>Посвящения</h1>

      <p>Посвящается Аните -- источнику очарования</p>

      <div
       class="TOC">
        <dl>
          <dt><strong>Содержание</strong></dt>

          <dt>Часть 1. <a
           href="#p112_html">Введение</a></dt>

          <dd>
            <dl>
              <dt>1. <a
               href="#c118_html">Зачем необходимо знание языка
              Shell?</a></dt>

              <dt>2. <a
               href="#c178_html">Для начала о Sha-Bang</a></dt>

              <dd>
                <dl>
                  <dt>2.1. <a
                   href="#c178_html_INVOKING">Запуск сценария</a></dt>

                  <dt>2.2. <a
                   href="#x288_html">Упражнения</a></dt>
                </dl>
              </dd>
            </dl>
          </dd>

          <dt>Часть 2. <a
           href="#p299_html">Основы</a></dt>

          <dd>
            <dl>
              <dt>3. <a
               href="#c301_html">Служебные символы</a></dt>

              <dt>4. <a
               href="#c1613_html">Переменные и параметры.
              Введение.</a></dt>

              <dd>
                <dl>
                  <dt>4.1. <a
                   href="#c1613_html_VARSUBN">Подстановка
                  переменных</a></dt>

                  <dt>4.2. <a
                   href="#x1673_html">Присваивание значений
                  переменным</a></dt>

                  <dt>4.3. <a
                   href="#x1705_html">Переменные Bash не имеют
                  типа</a></dt>

                  <dt>4.4. <a
                   href="#x1716_html">Специальные типы
                  переменных</a></dt>
                </dl>
              </dd>

              <dt>5. <a
               href="#c1833_html">Кавычки</a></dt>

              <dt>6. <a
               href="#c2105_html">Завершение и код завершения</a></dt>

              <dt>7. <a
               href="#c2171_html">Проверка условий</a></dt>

              <dd>
                <dl>
                  <dt>7.1. <a
                   href="#c2171_html_TESTCONSTRUCTS">Конструкции
                  проверки условий</a></dt>

                  <dt>7.2. <a
                   href="#x2389_html">Операции проверки файлов</a></dt>

                  <dt>7.3. <a
                   href="#x2565_html">Операции сравнения</a></dt>

                  <dt>7.4. <a
                   href="#x2770_html">Вложенные условные операторы
                  if/then</a></dt>

                  <dt>7.5. <a
                   href="#x2780_html">Проверка степени усвоения
                  материала</a></dt>
                </dl>
              </dd>

              <dt>8. <a
               href="#c2792_html">Операции и смежные темы</a></dt>

              <dd>
                <dl>
                  <dt>8.1. <a
                   href="#c2792_html_OPS">Операторы</a></dt>

                  <dt>8.2. <a
                   href="#x3255_html">Числовые константы</a></dt>
                </dl>
              </dd>
            </dl>
          </dd>

          <dt>Часть 3. <a
           href="#p3268_html">Углубленный материал</a></dt>

          <dd>
            <dl>
              <dt>9. <a
               href="#c3270_html">К вопросу о переменных</a></dt>

              <dd>
                <dl>
                  <dt>9.1. <a
                   href="#c3270_html_INTERNALVARIABLES">Внутренние
                  переменные</a></dt>

                  <dt>9.2. <a
                   href="#x4171_html">Работа со строками</a></dt>

                  <dt>9.3. <a
                   href="#x4462_html">Подстановка параметров</a></dt>

                  <dt>9.4. <a
                   href="#x4704_html">Объявление переменных: <strong
                   class="COMMAND">declare</strong> и <strong
                   class="COMMAND">typeset</strong></a></dt>

                  <dt>9.5. <a
                   href="#x4788_html">Косвенные ссылки на
                  переменные</a></dt>

                  <dt>9.6. <a
                   href="#x4812_html">$RANDOM: генерация псевдослучайных
                  целых чисел</a></dt>

                  <dt>9.7. <a
                   href="#x4862_html">Двойные круглые скобки</a></dt>
                </dl>
              </dd>

              <dt>10. <a
               href="#c4875_html">Циклы и ветвления</a></dt>

              <dd>
                <dl>
                  <dt>10.1. <a
                   href="#c4875_html_LOOPS1">Циклы</a></dt>

                  <dt>10.2. <a
                   href="#x5140_html">Вложенные циклы</a></dt>

                  <dt>10.3. <a
                   href="#x5153_html">Управление ходом выполнения
                  цикла</a></dt>

                  <dt>10.4. <a
                   href="#x5210_html">Операторы выбора</a></dt>
                </dl>
              </dd>

              <dt>11. <a
               href="#c5358_html">Внутренние команды</a></dt>

              <dd>
                <dl>
                  <dt>11.1. <a
                   href="#c5358_html_AEN6110">Команды управления
                  заданиями</a></dt>
                </dl>
              </dd>

              <dt>12. <a
               href="#c6407_html">Внешние команды, программы и
              утилиты</a></dt>

              <dd>
                <dl>
                  <dt>12.1. <a
                   href="#c6407_html_BASIC">Базовые команды</a></dt>

                  <dt>12.2. <a
                   href="#x6646_html">Более сложные команды</a></dt>

                  <dt>12.3. <a
                   href="#x6837_html">Команды для работы с датой и
                  временем</a></dt>

                  <dt>12.4. <a
                   href="#x7050_html">Команды обработки текста</a></dt>

                  <dt>12.5. <a
                   href="#x7794_html">Команды для работы с файлами и
                  архивами</a></dt>

                  <dt>12.6. <a
                   href="#x8707_html">Команды для работы с
                  сетью</a></dt>

                  <dt>12.7. <a
                   href="#x9117_html">Команды управления
                  терминалом</a></dt>

                  <dt>12.8. <a
                   href="#x9199_html">Команды выполнения математических
                  операций</a></dt>

                  <dt>12.9. <a
                   href="#x9307_html">Прочие команды</a></dt>
                </dl>
              </dd>

              <dt>13. <a
               href="#c9708_html">Команды системного
              администрирования</a></dt>

              <dt>14. <a
               href="#c11441_html">Подстановка команд</a></dt>

              <dt>15. <a
               href="#c11565_html">Арифметические подстановки</a></dt>

              <dt>16. <a
               href="#c11620_html">Перенаправление ввода/вывода</a></dt>

              <dd>
                <dl>
                  <dt>16.1. <a
                   href="#c11620_html_AEN11702">С помощью команды
                  <strong
                   class="COMMAND">exec</strong></a></dt>

                  <dt>16.2. <a
                   href="#x11731_html">Перенаправление для блоков
                  кода</a></dt>

                  <dt>16.3. <a
                   href="#x11778_html">Область применения</a></dt>
                </dl>
              </dd>

              <dt>17. <a
               href="#c11785_html">Встроенные документы</a></dt>
            </dl>
          </dd>

          <dt>Часть 4. <a
           href="#p11889_html">Материал повышенной сложности</a></dt>

          <dd>
            <dl>
              <dt>18. <a
               href="#c11895_html">Регулярные выражения</a></dt>

              <dd>
                <dl>
                  <dt>18.1. <a
                   href="#c11895_html_AEN11904">Краткое введение в
                  регулярные выражения</a></dt>

                  <dt>18.2. <a
                   href="#x12282_html">Globbing -- Подстановка имен
                  файлов</a></dt>
                </dl>
              </dd>

              <dt>19. <a
               href="#c12330_html">Подоболочки, или Subshells</a></dt>

              <dt>20. <a
               href="#c12376_html">Ограниченный режим командной
              оболочки</a></dt>

              <dt>21. <a
               href="#c12434_html">Подстановка процессов</a></dt>

              <dt>22. <a
               href="#c12483_html">Функции</a></dt>

              <dd>
                <dl>
                  <dt>22.1. <a
                   href="#c12483_html_COMPLEXFUNCT">Сложные функции и
                  сложности с функциями</a></dt>

                  <dt>22.2. <a
                   href="#x12644_html">Локальные переменные</a></dt>
                </dl>
              </dd>

              <dt>23. <a
               href="#c12683_html">Псевдонимы</a></dt>

              <dt>24. <a
               href="#c12716_html">Списки команд</a></dt>

              <dt>25. <a
               href="#c12790_html">Массивы</a></dt>

              <dt>26. <a
               href="#c12891_html">Файлы</a></dt>

              <dt>27. <a
               href="#c12942_html">/dev и /proc</a></dt>

              <dd>
                <dl>
                  <dt>27.1. <a
                   href="#c12942_html_DEVREF1"><tt
                   class="FILENAME">/dev</tt></a></dt>

                  <dt>27.2. <a
                   href="#x12987_html"><tt
                   class="FILENAME">/proc</tt></a></dt>
                </dl>
              </dd>

              <dt>28. <a
               href="#c13041_html">/dev/zero и /dev/null</a></dt>

              <dt>29. <a
               href="#c13099_html">Отладка сценариев</a></dt>

              <dt>30. <a
               href="#c13228_html">Необязательные параметры
              (ключи)</a></dt>

              <dt>31. <a
               href="#c13371_html">Широко распространенные
              ошибки</a></dt>

              <dt>32. <a
               href="#c13468_html">Стиль программирования</a></dt>

              <dd>
                <dl>
                  <dt>32.1. <a
                   href="#c13468_html_UNOFFICIALST">Неофициальные
                  рекомендации по оформлению сценариев</a></dt>
                </dl>
              </dd>

              <dt>33. <a
               href="#c13505_html">Разное</a></dt>

              <dd>
                <dl>
                  <dt>33.1. <a
                   href="#c13505_html_INTANDNONINT">Интерактивный и
                  неинтерактивный режим работы</a></dt>

                  <dt>33.2. <a
                   href="#x13541_html">Сценарии-обертки</a></dt>

                  <dt>33.3. <a
                   href="#x13602_html">Операции сравнения:
                  Альтернативные решения</a></dt>

                  <dt>33.4. <a
                   href="#x13609_html">Рекурсия</a></dt>

                  <dt>33.5. <a
                   href="#x13621_html"><span
                   class="QUOTE">&quot;Цветные&quot;</span>
                  сценарии</a></dt>

                  <dt>33.6. <a
                   href="#x13734_html">Оптимизация</a></dt>

                  <dt>33.7. <a
                   href="#x13753_html">Разные советы</a></dt>

                  <dt>33.8. <a
                   href="#x13884_html">Проблемы безопасности</a></dt>

                  <dt>33.9. <a
                   href="#x13898_html">Проблемы переносимости</a></dt>

                  <dt>33.10. <a
                   href="#x13930_html">Сценарии командной оболочки под
                  Windows</a></dt>
                </dl>
              </dd>

              <dt>34. <a
               href="#c13936_html">Bash, версия 2</a></dt>
            </dl>
          </dd>

          <dt>35. <a
           href="#c13962_html">Замечания и дополнения</a></dt>

          <dd>
            <dl>
              <dt>35.1. <a
               href="#c13962_html_AUTHORSNOTE">От автора</a></dt>

              <dt>35.2. <a
               href="#x13968_html">Об авторе</a></dt>

              <dt>35.3. <a
               href="#x13981_html">Инструменты, использовавшиеся при
              создании книги</a></dt>

              <dd>
                <dl>
                  <dt>35.3.1. <a
                   href=
                  "#x13981_html_SOFTWARE_HARDWARE">Аппаратура</a></dt>

                  <dt>35.3.2. <a
                   href="#x13981_html_SOFTWARE_PRINTWARE">Программное
                  обеспечение</a></dt>
                </dl>
              </dd>

              <dt>35.4. <a
               href="#x14001_html">Благодарности</a></dt>
            </dl>
          </dd>

          <dt><a
           href="#b14059_html">Литература</a></dt>

          <dt>A. <a
           href="#a14477_html">Дополнительные примеры сценариев</a></dt>

          <dt>B. <a
           href="#a14586_html">Маленький учебник по Sed и Awk</a></dt>

          <dd>
            <dl>
              <dt>B.1. <a
               href="#a14586_html_AEN14605">Sed</a></dt>

              <dt>B.2. <a
               href="#x14802_html">Awk</a></dt>
            </dl>
          </dd>

          <dt>C. <a
           href="#a14876_html">Коды завершения, имеющие предопределенный
          смысл</a></dt>

          <dt>D. <a
           href="#a14967_html">Подробное введение в операции
          ввода-вывода и перенаправление ввода-вывода</a></dt>

          <dt>E. <a
           href="#a15021_html">Локализация</a></dt>

          <dt>F. <a
           href="#a15070_html">История команд</a></dt>

          <dt>G. <a
           href="#a15124_html">Пример файла <tt
           class="FILENAME">.bashrc</tt></a></dt>

          <dt>H. <a
           href="#a15138_html">Преобразование пакетных (*.bat) файлов
          DOS в сценарии командной оболочки</a></dt>

          <dt>I. <a
           href="#a15523_html">Упражнения</a></dt>

          <dd>
            <dl>
              <dt>I.1. <a
               href="#a15523_html_SCRIPTANALYSIS">Анализ
              сценариев</a></dt>

              <dt>I.2. <a
               href="#x15542_html">Создание сценариев</a></dt>
            </dl>
          </dd>

          <dt>J. <a
           href="#a15860_html">Авторские права</a></dt>
        </dl>
      </div>

      <div
       class="LOT">
        <dl
         class="LOT">
          <dt><strong>Перечень таблиц</strong></dt>

          <dt>11-1. <a
           href="#c5358_html_JOBIDTABLE">Идентификация заданий</a></dt>

          <dt>30-1. <a
           href="#c13228_html_AEN13260">Ключи Bash</a></dt>

          <dt>33-1. <a
           href="#x13621_html_AEN13673">Числовые значения цвета в
          escape-последовательностях</a></dt>

          <dt>B-1. <a
           href="#a14586_html_AEN14623">Основные операции sed</a></dt>

          <dt>B-2. <a
           href="#a14586_html_AEN14681">Примеры операций в sed</a></dt>

          <dt>C-1. <a
           href="#a14876_html_AEN14880"><span
           class="QUOTE">&quot;Зарезервированные&quot;</span> коды
          завершения</a></dt>

          <dt>H-1. <a
           href="#a15138_html_AEN15143">Ключевые
          слова/переменные/операторы пакетных файлов DOS и их аналоги
          командной оболочки</a></dt>

          <dt>H-2. <a
           href="#a15138_html_AEN15350">Команды DOS и их эквиваленты в
          UNIX</a></dt>
        </dl>
      </div>

      <div
       class="LOT">
        <dl
         class="LOT">
          <dt><strong>Перечень приложений</strong></dt>

          <dt>2-1. <a
           href="#c178_html_EX1"><strong
           class="COMMAND">cleanup</strong>: Сценарий очистки
          лог-файлов в /var/log</a></dt>

          <dt>2-2. <a
           href="#c178_html_EX2"><strong
           class="COMMAND">cleanup</strong>: Расширенная версия
          предыдущего сценария.</a></dt>

          <dt>3-1. <a
           href="#c301_html_EX8">Вложенные блоки и перенаправление
          ввода-вывода</a></dt>

          <dt>3-2. <a
           href="#c301_html_RPMCHECK">Сохранение результата исполнения
          вложенного блока в файл</a></dt>

          <dt>3-3. <a
           href="#c301_html_BGLOOP">Запуск цикла в фоновом
          режиме</a></dt>

          <dt>3-4. <a
           href="#c301_html_EX58">Резервное архивирование всех файлов,
          которые были изменены в течение последних суток</a></dt>

          <dt>4-1. <a
           href="#c1613_html_EX9">Присваивание значений переменным и
          подстановка значений переменных</a></dt>

          <dt>4-2. <a
           href="#x1673_html_EX15">Простое присваивание</a></dt>

          <dt>4-3. <a
           href="#x1673_html_EX16">Присваивание значений переменным
          простое и замаскированное</a></dt>

          <dt>4-4. <a
           href="#x1705_html_INTORSTRING">Целое число или
          строка?</a></dt>

          <dt>4-5. <a
           href="#x1716_html_EX17">Позиционные параметры</a></dt>

          <dt>4-6. <a
           href="#x1716_html_EX18"><strong
           class="COMMAND">wh</strong>,</a> <a
           href="#x8707_html_WHOISREF">whois</a> выяснение имени
          домена</dt>

          <dt>4-7. <a
           href="#x1716_html_EX19">Использование команды <strong
           class="COMMAND">shift</strong></a></dt>

          <dt>5-1. <a
           href="#c1833_html_WEIRDVARS">Вывод &quot;причудливых&quot;
          переменных</a></dt>

          <dt>5-2. <a
           href="#c1833_html_ESCAPED">Экранированные символы</a></dt>

          <dt>6-1. <a
           href="#c2105_html_EX5">завершение / код завершения</a></dt>

          <dt>6-2. <a
           href="#c2105_html_NEGCOND">Использование символа <span
           class="TOKEN">!</span> для логической инверсии кода
          возврата</a></dt>

          <dt>7-1. <a
           href="#c2171_html_EX10">Что есть &quot;истина&quot;?</a></dt>

          <dt>7-2. <a
           href="#c2171_html_EX11">Эквиваленты команды <span
           class="TOKEN">test</span> -- <tt
           class="FILENAME">/usr/bin/test</tt>, <span
           class="TOKEN">[ ]</span>, и <tt
           class="FILENAME">/usr/bin/[</tt></a></dt>

          <dt>7-3. <a
           href="#c2171_html_ARITHTESTS">Арифметические выражения внутри
          <span
           class="TOKEN">(( ))</span></a></dt>

          <dt>7-4. <a
           href="#x2389_html_BROKENLINK">Проверка &quot;битых&quot;
          ссылок</a></dt>

          <dt>7-5. <a
           href="#x2565_html_EX13">Операции сравнения</a></dt>

          <dt>7-6. <a
           href="#x2565_html_STRTEST">Проверка -- является ли строка
          <span
           class="emphasis"><em
           class="EMPHASIS">пустой</em></span></a></dt>

          <dt>7-7. <a
           href="#x2565_html_EX14"><strong
           class="COMMAND">zmost</strong></a></dt>

          <dt>8-1. <a
           href="#c2792_html_GCD">Наибольший общий делитель</a></dt>

          <dt>8-2. <a
           href="#c2792_html_ARITHOPS">Арифметические операции</a></dt>

          <dt>8-3. <a
           href="#c2792_html_ANDOR">Построение сложных условий,
          использующих &amp;&amp; и ||</a></dt>

          <dt>8-4. <a
           href="#x3255_html_NUMBERS">Различные представления числовых
          констант</a></dt>

          <dt>9-1. <a
           href="#c3270_html_IFSH">$IFS и пробельные символы</a></dt>

          <dt>9-2. <a
           href="#c3270_html_TMDIN">Ограничения времени ожидания
          ввода</a></dt>

          <dt>9-3. <a
           href="#c3270_html_TIMEOUT">Еще один пример ограничения
          времени ожидания ввода от пользователя</a></dt>

          <dt>9-4. <a
           href="#c3270_html_TOUT">Ограничение времени ожидания команды
          <strong
           class="COMMAND">read</strong></a></dt>

          <dt>9-5. <a
           href="#c3270_html_AMIROOT">Я -- root?</a></dt>

          <dt>9-6. <a
           href="#c3270_html_ARGLIST"><strong
           class="COMMAND">arglist</strong>: Вывод списка аргументов с
          помощью переменных $* и $@</a></dt>

          <dt>9-7. <a
           href="#c3270_html_INCOMPAT">Противоречия в переменных <tt
           class="VARNAME">$*</tt> и <tt
           class="VARNAME">$@</tt></a></dt>

          <dt>9-8. <a
           href="#c3270_html_IFSEMPTY">Содержимое <tt
           class="VARNAME">$*</tt> и <tt
           class="VARNAME">$@</tt>, когда переменная <tt
           class="VARNAME">$IFS</tt> -- пуста</a></dt>

          <dt>9-9. <a
           href="#c3270_html_USCREF">Переменная
          &quot;подчеркивание&quot;</a></dt>

          <dt>9-10. <a
           href="#x4171_html_PARAGRAPHSPACE">Вставка пустых строк между
          параграфами в текстовом файле</a></dt>

          <dt>9-11. <a
           href="#x4171_html_CVT">Преобразование графических файлов из
          одного формата в другой, с изменением имени файла</a></dt>

          <dt>9-12. <a
           href="#x4171_html_SUBSTRINGEX">Альтернативный способ
          извлечения подстрок</a></dt>

          <dt>9-13. <a
           href="#x4462_html_EX6">Подстановка параметров и сообщения об
          ошибках</a></dt>

          <dt>9-14. <a
           href="#x4462_html_USAGEMESSAGE">Подстановка параметров и
          сообщение о <span
           class="QUOTE">&quot;порядке
          использования&quot;</span></a></dt>

          <dt>9-15. <a
           href="#x4462_html_LENGTH">Длина переменной</a></dt>

          <dt>9-16. <a
           href="#x4462_html_PATTMATCHING">Поиск по шаблону в
          подстановке параметров</a></dt>

          <dt>9-17. <a
           href="#x4462_html_RFE">Изменение расширений в именах
          файлов<span
           class="TOKEN">:</span></a></dt>

          <dt>9-18. <a
           href="#x4462_html_EX7">Поиск по шаблону при анализе
          произвольных строк</a></dt>

          <dt>9-19. <a
           href="#x4462_html_VARMATCH">Поиск префиксов и суффиксов с
          заменой по шаблону</a></dt>

          <dt>9-20. <a
           href="#x4704_html_EX20">Объявление переменных с помощью
          инструкции <strong
           class="COMMAND">declare</strong></a></dt>

          <dt>9-21. <a
           href="#x4788_html_INDREF">Косвенные ссылки</a></dt>

          <dt>9-22. <a
           href="#x4788_html_COLTOTALER2">Передача косвенных ссылок в
          <tt
           class="REPLACEABLE"><em>awk</em></tt></a></dt>

          <dt>9-23. <a
           href="#x4812_html_EX21">Генерация случайных чисел</a></dt>

          <dt>9-24. <a
           href="#x4812_html_PICKCARD">Выбор случайной карты из
          колоды</a></dt>

          <dt>9-25. <a
           href="#x4812_html_RANDOMTEST">Имитация бросания кубика с
          помощью RANDOM</a></dt>

          <dt>9-26. <a
           href="#x4812_html_SEEDINGRANDOM">Переустановка
          RANDOM</a></dt>

          <dt>9-27. <a
           href="#x4812_html_RANDOM2">Получение псевдослучайных чисел с
          помощью</a> <a
           href="#x14802_html_AWKREF">awk</a></dt>

          <dt>9-28. <a
           href="#x4862_html_CVARS">Работа с переменными в стиле языка
          C</a></dt>

          <dt>10-1. <a
           href="#c4875_html_EX22">Простой цикл <strong
           class="COMMAND">for</strong></a></dt>

          <dt>10-2. <a
           href="#c4875_html_EX22A">Цикл <strong
           class="COMMAND">for</strong> с двумя параметрами в каждом из
          элементов списка</a></dt>

          <dt>10-3. <a
           href="#c4875_html_FILEINFO"><span
           class="emphasis"><em
           class="EMPHASIS">Fileinfo:</em></span> обработка списка
          файлов, находящегося в переменной</a></dt>

          <dt>10-4. <a
           href="#c4875_html_LISTGLOB">Обработка списка файлов в цикле
          <strong
           class="COMMAND">for</strong></a></dt>

          <dt>10-5. <a
           href="#c4875_html_EX23">Цикл <strong
           class="COMMAND">for</strong> без списка аргументов</a></dt>

          <dt>10-6. <a
           href="#c4875_html_FORLOOPCMD">Создание списка аргументов в
          цикле <strong
           class="COMMAND">for</strong> с помощью операции подстановки
          команд</a></dt>

          <dt>10-7. <a
           href="#c4875_html_BINGREP"></a><a
           href="#x7050_html_GREPREF">grep</a> для бинарных файлов</dt>

          <dt>10-8. <a
           href="#c4875_html_USERLIST">Список всех пользователей
          системы</a></dt>

          <dt>10-9. <a
           href="#c4875_html_FINDSTRING">Проверка авторства всех
          бинарных файлов в текущем каталоге</a></dt>

          <dt>10-10. <a
           href="#c4875_html_SYMLINKS">Список символических ссылок в
          каталоге</a></dt>

          <dt>10-11. <a
           href="#c4875_html_SYMLINKS2">Список символических ссылок в
          каталоге, сохраняемый в файле</a></dt>

          <dt>10-12. <a
           href="#c4875_html_FORLOOPC">C-подобный синтаксис оператора
          цикла <strong
           class="COMMAND">for</strong></a></dt>

          <dt>10-13. <a
           href="#c4875_html_EX24">Работа с командой <strong
           class="COMMAND">efax</strong> в пакетном режиме</a></dt>

          <dt>10-14. <a
           href="#c4875_html_EX25">Простой цикл <strong
           class="COMMAND">while</strong></a></dt>

          <dt>10-15. <a
           href="#c4875_html_EX26">Другой пример цикла <strong
           class="COMMAND">while</strong></a></dt>

          <dt>10-16. <a
           href="#c4875_html_EX26A">Цикл <strong
           class="COMMAND">while</strong> с несколькими
          условиями</a></dt>

          <dt>10-17. <a
           href="#c4875_html_WHLOOPC">C-подобный синтаксис оформления
          цикла <strong
           class="COMMAND">while</strong></a></dt>

          <dt>10-18. <a
           href="#c4875_html_EX27">Цикл <strong
           class="COMMAND">until</strong></a></dt>

          <dt>10-19. <a
           href="#x5140_html_NESTEDLOOP">Вложенный цикл</a></dt>

          <dt>10-20. <a
           href="#x5153_html_EX28">Команды <strong
           class="COMMAND">break</strong> и <strong
           class="COMMAND">continue</strong> в цикле</a></dt>

          <dt>10-21. <a
           href="#x5153_html_BREAKLEVELS">Прерывание многоуровневых
          циклов</a></dt>

          <dt>10-22. <a
           href="#x5153_html_CONTINUELEVELS">Передача управление в
          начало внешнего цикла</a></dt>

          <dt>10-23. <a
           href="#x5153_html_CONTINUENEX">Живой пример использования
          <span
           class="QUOTE">&quot;continue N&quot;</span></a></dt>

          <dt>10-24. <a
           href="#x5210_html_EX29">Использование <strong
           class="COMMAND">case</strong></a></dt>

          <dt>10-25. <a
           href="#x5210_html_EX30">Создание меню с помощью <strong
           class="COMMAND">case</strong></a></dt>

          <dt>10-26. <a
           href="#x5210_html_CASECMD">Оператор <strong
           class="COMMAND">case</strong> допускает использовать
          подстановку команд вместо анализируемой переменной</a></dt>

          <dt>10-27. <a
           href="#x5210_html_MATCHSTRING">Простой пример сравнения
          строк</a></dt>

          <dt>10-28. <a
           href="#x5210_html_ISALPHA">Проверка ввода</a></dt>

          <dt>10-29. <a
           href="#x5210_html_EX31">Создание меню с помощью <strong
           class="COMMAND">select</strong></a></dt>

          <dt>10-30. <a
           href="#x5210_html_EX32">Создание меню с помощью <strong
           class="COMMAND">select</strong> в функции</a></dt>

          <dt>11-1. <a
           href="#c5358_html_EX47"><strong
           class="COMMAND">printf</strong> в действии</a></dt>

          <dt>11-2. <a
           href="#c5358_html_EX36">Ввод значений переменных с помощью
          <strong
           class="COMMAND">read</strong></a></dt>

          <dt>11-3. <a
           href="#c5358_html_READNOVAR">Пример использования команды
          <strong
           class="COMMAND">read</strong> без указания переменной для
          ввода</a></dt>

          <dt>11-4. <a
           href="#c5358_html_READR">Ввод многострочного текста с помощью
          <strong
           class="COMMAND">read</strong></a></dt>

          <dt>11-5. <a
           href="#c5358_html_ARROWDETECT">Обнаружение нажатия на
          курсорные клавиши</a></dt>

          <dt>11-6. <a
           href="#c5358_html_READREDIR">Чтение командой <strong
           class="COMMAND">read</strong> из файла через</a> <a
           href="#c11620_html_IOREDIRREF">перенаправление</a></dt>

          <dt>11-7. <a
           href="#c5358_html_EX37">Смена текущего каталога</a></dt>

          <dt>11-8. <a
           href="#c5358_html_EX46">Команда <strong
           class="COMMAND">let</strong>, арифметические
          операции.</a></dt>

          <dt>11-9. <a
           href="#c5358_html_EX43">Демонстрация команды <strong
           class="COMMAND">eval</strong></a></dt>

          <dt>11-10. <a
           href="#c5358_html_EX44">Принудительное завершение
          сеанса</a></dt>

          <dt>11-11. <a
           href="#c5358_html_ROT14">Шифрование по алгоритму <span
           class="QUOTE">&quot;rot13&quot;</span></a></dt>

          <dt>11-12. <a
           href="#c5358_html_EVALEX">Замена имени переменной на ее
          значение, в исходном тексте программы на языке Perl, с
          помощью <strong
           class="COMMAND">eval</strong></a></dt>

          <dt>11-13. <a
           href="#c5358_html_EX34">Установка значений аргументов с
          помощью команды <strong
           class="COMMAND">set</strong></a></dt>

          <dt>11-14. <a
           href="#c5358_html_SETPOS">Изменение значений позиционных
          параметров (аргументов)</a></dt>

          <dt>11-15. <a
           href="#c5358_html_UNS"><span
           class="QUOTE">&quot;Сброс&quot;</span> переменной</a></dt>

          <dt>11-16. <a
           href="#c5358_html_COLTOTALER3">Передача переменных во
          вложенный сценарий</a> <a
           href="#x14802_html_AWKREF">awk</a>, с помощью <strong
           class="COMMAND">export</strong></dt>

          <dt>11-17. <a
           href="#c5358_html_EX33">Прием опций/аргументов, передаваемых
          сценарию, с помощью <strong
           class="COMMAND">getopts</strong></a></dt>

          <dt>11-18. <a
           href="#c5358_html_EX38"><span
           class="QUOTE">&quot;Подключение&quot;</span> внешнего
          файла</a></dt>

          <dt>11-19. <a
           href="#c5358_html_SELFSOURCE">Пример (бесполезный) сценария,
          который подключает себя самого.</a></dt>

          <dt>11-20. <a
           href="#c5358_html_EX54">Команда <strong
           class="COMMAND">exec</strong></a></dt>

          <dt>11-21. <a
           href="#c5358_html_SELFEXEC">Сценарий, который запускает себя
          самого</a></dt>

          <dt>11-22. <a
           href="#c5358_html_EX39">Ожидание завершения процесса перед
          тем как продолжить работу</a></dt>

          <dt>11-23. <a
           href="#c5358_html_SELFDESTRUCT">Сценарий, завершающий себя
          сам с помощью команды kill</a></dt>

          <dt>12-1. <a
           href="#c6407_html_EX40">Создание оглавления диска для записи
          <span
           class="ABBREV">CDR</span>, с помощью команды <strong
           class="COMMAND">ls</strong></a></dt>

          <dt>12-2. <a
           href="#x6646_html_EX57"><strong
           class="COMMAND">Badname</strong>, удаление файлов в текущем
          каталоге, имена которых содержат недопустимые символы и</a>
          <a
           href="#c301_html_WHITESPACEREF">пробелы</a>.</dt>

          <dt>12-3. <a
           href="#x6646_html_IDELETE">Удаление файла по его номеру <span
           class="emphasis"><em
           class="EMPHASIS">inode</em></span></a></dt>

          <dt>12-4. <a
           href="#x6646_html_EX41">Использование команды <strong
           class="COMMAND">xargs</strong> для мониторинга системного
          журнала</a></dt>

          <dt>12-5. <a
           href="#x6646_html_EX42"><strong
           class="COMMAND">copydir</strong>, копирование файлов из
          текущего каталога в другое место, с помощью <strong
           class="COMMAND">xargs</strong></a></dt>

          <dt>12-6. <a
           href="#x6646_html_EX45">Пример работы с <strong
           class="COMMAND">expr</strong></a></dt>

          <dt>12-7. <a
           href="#x6837_html_EX51">Команда <strong
           class="COMMAND">date</strong></a></dt>

          <dt>12-8. <a
           href="#x7050_html_WF">Частота встречаемости отдельных
          слов</a></dt>

          <dt>12-9. <a
           href="#x7050_html_SCRIPTDETECTOR">Какие из файлов являются
          сценариями?</a></dt>

          <dt>12-10. <a
           href="#x7050_html_RND">Генератор 10-значных случайных
          чисел</a></dt>

          <dt>12-11. <a
           href="#x7050_html_EX12">Мониторинг системного журнала с
          помощью <strong
           class="COMMAND">tail</strong></a></dt>

          <dt>12-12. <a
           href="#x7050_html_GRP">Сценарий-эмулятор <span
           class="QUOTE">&quot;grep&quot;</span></a></dt>

          <dt>12-13. <a
           href="#x7050_html_LOOKUP">Поиск слов в словаре</a></dt>

          <dt>12-14. <a
           href="#x7050_html_EX49"><strong
           class="COMMAND">toupper</strong>: Преобразование символов в
          верхний регистр.</a></dt>

          <dt>12-15. <a
           href="#x7050_html_LOWERCASE"><strong
           class="COMMAND">lowercase</strong>: Изменение имен всех
          файлов в текущем каталоге в нижний регистр.</a></dt>

          <dt>12-16. <a
           href="#x7050_html_DU"><strong
           class="COMMAND">du</strong>: Преобразование текстового файла
          из формата DOS в формат UNIX.</a></dt>

          <dt>12-17. <a
           href="#x7050_html_ROT13"><strong
           class="COMMAND">rot13</strong>: Сверхслабое шифрование по
          алгоритму rot13.</a></dt>

          <dt>12-18. <a
           href="#x7050_html_CRYPTOQUOTE">Более <span
           class="QUOTE">&quot;сложный&quot;</span> шифр</a></dt>

          <dt>12-19. <a
           href="#x7050_html_EX50">Отформатированный список
          файлов.</a></dt>

          <dt>12-20. <a
           href="#x7050_html_COL">Пример форматирования списка файлов в
          каталоге</a></dt>

          <dt>12-21. <a
           href="#x7050_html_LNUM"><strong
           class="COMMAND">nl</strong>: Самонумерующийся
          сценарий.</a></dt>

          <dt>12-22. <a
           href="#x7794_html_EX48">Пример перемещения дерева каталогов с
          помощью <strong
           class="COMMAND">cpio</strong></a></dt>

          <dt>12-23. <a
           href="#x7794_html_DERPM">Распаковка архива <span
           class="emphasis"><em
           class="EMPHASIS">rpm</em></span></a></dt>

          <dt>12-24. <a
           href="#x7794_html_STRIPC">Удаление комментариев из файла с
          текстом программы на языке C</a></dt>

          <dt>12-25. <a
           href="#x7794_html_WHAT"><strong
           class="COMMAND">Исследование каталога <tt
           class="FILENAME">/usr/X11R6/bin</tt></strong></a></dt>

          <dt>12-26. <a
           href="#x7794_html_WSTRINGS"><span
           class="QUOTE">&quot;Расширенная&quot;</span> команда <span
           class="emphasis"><em
           class="EMPHASIS">strings</em></span></a></dt>

          <dt>12-27. <a
           href="#x7794_html_FILECOMP">Пример сравнения двух файлов с
          помощью <strong
           class="COMMAND">cmp</strong>.</a></dt>

          <dt>12-28. <a
           href="#x7794_html_EX35">Утилиты <strong
           class="COMMAND">basename</strong> и <strong
           class="COMMAND">dirname</strong></a></dt>

          <dt>12-29. <a
           href="#x7794_html_FILEINTEGRITY">Проверка целостности
          файла</a></dt>

          <dt>12-30. <a
           href="#x7794_html_EX52">Декодирование файлов</a></dt>

          <dt>12-31. <a
           href="#x8707_html_SELFMAILER">Сценарий, отправляющий себя
          самого по электронной почте</a></dt>

          <dt>12-32. <a
           href="#x9199_html_MONTHLYPMT">Ежемесячные выплаты по
          займу</a></dt>

          <dt>12-33. <a
           href="#x9199_html_BASE">Перевод чисел из одной системы
          счисления в другую</a></dt>

          <dt>12-34. <a
           href="#x9199_html_ALTBC">Пример взаимодействия <strong
           class="COMMAND">bc</strong> со <span
           class="QUOTE">&quot;встроенным
          документом&quot;</span></a></dt>

          <dt>12-35. <a
           href="#x9199_html_CANNON">Вычисление числа
          &quot;пи&quot;</a></dt>

          <dt>12-36. <a
           href="#x9199_html_HEXCONVERT">Преобразование чисел из
          десятичной в шестнадцатиричную систему счисления</a></dt>

          <dt>12-37. <a
           href="#x9199_html_FACTR">Разложение числа на простые
          множители</a></dt>

          <dt>12-38. <a
           href="#x9199_html_HYPOT">Расчет гипотенузы прямоугольного
          треугольника</a></dt>

          <dt>12-39. <a
           href="#x9307_html_EX53">Использование <strong
           class="COMMAND">seq</strong> для генерации списка аргументов
          цикла for</a></dt>

          <dt>12-40. <a
           href="#x9307_html_EX33A">Использование <strong
           class="COMMAND">getopt</strong> для разбора аргументов
          командной строки</a></dt>

          <dt>12-41. <a
           href="#x9307_html_DDKEYPRESS">Захват нажатых клавиш</a></dt>

          <dt>12-42. <a
           href="#x9307_html_BLOTOUT">Надежное удаление файла</a></dt>

          <dt>12-43. <a
           href="#x9307_html_TEMPFILENAME">Генератор имен
          файлов</a></dt>

          <dt>12-44. <a
           href="#x9307_html_UNITCONVERSION">Преобразование метров в
          мили</a></dt>

          <dt>12-45. <a
           href="#x9307_html_M4">Пример работы с m4</a></dt>

          <dt>13-1. <a
           href="#c9708_html_ERASE">Установка символа
          &quot;забоя&quot;</a></dt>

          <dt>13-2. <a
           href="#c9708_html_SECRETPW"><strong
           class="COMMAND">невидимый пароль</strong>: Отключение
          эхо-вывода на терминал</a></dt>

          <dt>13-3. <a
           href="#c9708_html_KEYPRESS"></a></dt>

          <dt>13-4. <a
           href="#c9708_html_KILLPROCESS">Использование команды <strong
           class="COMMAND">pidof</strong> при остановке
          процесса</a></dt>

          <dt>13-5. <a
           href="#c9708_html_ISOMOUNTREF">Проверка образа CD</a></dt>

          <dt>13-6. <a
           href="#c9708_html_CREATEFS">Создание файловой системы в
          обычном файле</a></dt>

          <dt>13-7. <a
           href="#c9708_html_ADDDRV">Добавление нового жесткого
          диска</a></dt>

          <dt>13-8. <a
           href="#c9708_html_EX55">Сценарий <strong
           class="COMMAND">killall</strong>, из каталога <tt
           class="FILENAME">/etc/rc.d/init.d</tt></a></dt>

          <dt>14-1. <a
           href="#c11441_html_STUPSCR">Глупая выходка</a></dt>

          <dt>14-2. <a
           href="#c11441_html_CSUBLOOP">Запись результатов выполнения
          цикла в переменную</a></dt>

          <dt>16-1. <a
           href="#c11620_html_REDIR1">Перенаправление <tt
           class="FILENAME">stdin</tt> с помощью <strong
           class="COMMAND">exec</strong></a></dt>

          <dt>16-2. <a
           href="#c11620_html_REASSIGNSTDOUT">Перенаправление <tt
           class="FILENAME">stdout</tt> с помощью <strong
           class="COMMAND">exec</strong></a></dt>

          <dt>16-3. <a
           href="#c11620_html_UPPERCONV">Одновременное перенаправление
          устройств, <tt
           class="FILENAME">stdin</tt> и <tt
           class="FILENAME">stdout</tt>, с помощью команды <strong
           class="COMMAND">exec</strong></a></dt>

          <dt>16-4. <a
           href="#x11731_html_REDIR2">Перенаправление в цикл <span
           class="emphasis"><em
           class="EMPHASIS">while</em></span></a></dt>

          <dt>16-5. <a
           href="#x11731_html_REDIR2A">Альтернативная форма
          перенаправления в цикле <span
           class="emphasis"><em
           class="EMPHASIS">while</em></span></a></dt>

          <dt>16-6. <a
           href="#x11731_html_REDIR3">Перенаправление в цикл <span
           class="emphasis"><em
           class="EMPHASIS">until</em></span></a></dt>

          <dt>16-7. <a
           href="#x11731_html_REDIR4">Перенаправление в цикл <span
           class="emphasis"><em
           class="EMPHASIS">for</em></span></a></dt>

          <dt>16-8. <a
           href="#x11731_html_REDIR4A">Перенаправление устройств (<tt
           class="FILENAME">stdin</tt> и <tt
           class="FILENAME">stdout</tt>) в цикле <span
           class="emphasis"><em
           class="EMPHASIS">for</em></span></a></dt>

          <dt>16-9. <a
           href="#x11731_html_REDIR5">Перенаправление в конструкции
          <span
           class="emphasis"><em
           class="EMPHASIS">if/then</em></span></a></dt>

          <dt>16-10. <a
           href="#x11731_html_NAMESDATA">Файл с именами <span
           class="QUOTE">&quot;names.data&quot;</span>, для примеров
          выше</a></dt>

          <dt>16-11. <a
           href="#x11778_html_LOGEVENTS">Регистрация событий</a></dt>

          <dt>17-1. <a
           href="#c11785_html_EX69"><strong
           class="COMMAND">dummyfile</strong>: Создание 2-х строчного
          файла-заготовки</a></dt>

          <dt>17-2. <a
           href="#c11785_html_EX70"><strong
           class="COMMAND">broadcast</strong>: Передача сообщения всем,
          работающим в системе, пользователям</a></dt>

          <dt>17-3. <a
           href="#c11785_html_EX71">Вывод многострочных сообщений с
          помощью <strong
           class="COMMAND">cat</strong></a></dt>

          <dt>17-4. <a
           href="#c11785_html_EX71A">Вывод многострочных сообщений с
          подавлением символов табуляции</a></dt>

          <dt>17-5. <a
           href="#c11785_html_EX71B">Встроенные документы и подстановка
          параметров</a></dt>

          <dt>17-6. <a
           href="#c11785_html_EX71C">Отключение подстановки
          параметров</a></dt>

          <dt>17-7. <a
           href="#c11785_html_EX72">Передача пары файлов во входящий
          каталог на <span
           class="QUOTE">&quot;Sunsite&quot;</span></a></dt>

          <dt>17-8. <a
           href="#c11785_html_HF">Встроенные документы и
          функции</a></dt>

          <dt>17-9. <a
           href="#c11785_html_ANONHEREDOC"><span
           class="QUOTE">&quot;Анонимный&quot;</span> Встроенный
          Документ</a></dt>

          <dt>17-10. <a
           href="#c11785_html_COMMENTBLOCK">Блочный комментарий</a></dt>

          <dt>17-11. <a
           href="#c11785_html_SELFDOCUMENT">Встроенная справка к
          сценарию</a></dt>

          <dt>19-1. <a
           href="#c12330_html_SUBSHELL">Область видимости
          переменных</a></dt>

          <dt>19-2. <a
           href="#c12330_html_ALLPROFS">Личные настройки
          пользователей</a></dt>

          <dt>19-3. <a
           href="#c12330_html_PARALLEL_PROCESSES">Запуск нескольких
          процессов в подоболочках</a></dt>

          <dt>20-1. <a
           href="#c12376_html_RESTRICTED">Запуск сценария в ограниченном
          режиме</a></dt>

          <dt>22-1. <a
           href="#c12483_html_EX59">Простая функция</a></dt>

          <dt>22-2. <a
           href="#c12483_html_EX60">Функция с аргументами</a></dt>

          <dt>22-3. <a
           href="#c12483_html_MAX">Наибольшее из двух чисел</a></dt>

          <dt>22-4. <a
           href="#c12483_html_EX61">Преобразование чисел в римскую форму
          записи</a></dt>

          <dt>22-5. <a
           href="#c12483_html_RETURNTEST">Проверка возможности возврата
          функциями больших значений</a></dt>

          <dt>22-6. <a
           href="#c12483_html_MAX2">Сравнение двух больших целых
          чисел</a></dt>

          <dt>22-7. <a
           href="#c12483_html_REALNAME">Настоящее имя
          пользователя</a></dt>

          <dt>22-8. <a
           href="#x12644_html_EX62">Область видимости локальных
          переменных</a></dt>

          <dt>22-9. <a
           href="#x12644_html_EX63">Использование локальных переменных
          при рекурсии</a></dt>

          <dt>23-1. <a
           href="#c12683_html_AL">Псевдонимы в сценарии</a></dt>

          <dt>23-2. <a
           href="#c12683_html_UNAL"><strong
           class="COMMAND">unalias</strong>: Объявление и удаление
          псевдонимов</a></dt>

          <dt>24-1. <a
           href="#c12716_html_EX64">Проверка аргументов командной строки
          с помощью <span
           class="QUOTE">&quot;И-списка&quot;</span></a></dt>

          <dt>24-2. <a
           href="#c12716_html_ANDLIST2">Еще один пример проверки
          аргументов с помощью <span
           class="QUOTE">&quot;И-списков&quot;</span></a></dt>

          <dt>24-3. <a
           href="#c12716_html_EX65">Комбинирование <span
           class="QUOTE">&quot;ИЛИ-списков&quot;</span> и <span
           class="QUOTE">&quot;И-списков&quot;</span></a></dt>

          <dt>25-1. <a
           href="#c12790_html_EX66">Простой массив</a></dt>

          <dt>25-2. <a
           href="#c12790_html_POEM">Форматирование
          стихотворения</a></dt>

          <dt>25-3. <a
           href="#c12790_html_EX67">Некоторые специфичные особенности
          массивов</a></dt>

          <dt>25-4. <a
           href="#c12790_html_EMPTYARRAY">Пустые массивы и пустые
          элементы</a></dt>

          <dt>25-5. <a
           href="#c12790_html_COPYARRAY">Копирование и конкатенация
          массивов</a></dt>

          <dt>25-6. <a
           href="#c12790_html_BUBBLE">Старая, добрая: <span
           class="emphasis"><em
           class="EMPHASIS">&quot;Пузырьковая&quot;
          сортировка</em></span></a></dt>

          <dt>25-7. <a
           href="#c12790_html_EMBARR">Вложенные массивы и косвенные
          ссылки</a></dt>

          <dt>25-8. <a
           href="#c12790_html_EX68">Пример реализации алгоритма <span
           class="emphasis"><em
           class="EMPHASIS">Решето Эратосфена</em></span></a></dt>

          <dt>25-9. <a
           href="#c12790_html_STACKEX">Эмуляция структуры
          &quot;СТЕК&quot; (&quot;первый вошел -- последний
          вышел&quot;)</a></dt>

          <dt>25-10. <a
           href="#c12790_html_QFUNCTION"><span
           class="emphasis"><em
           class="EMPHASIS">Исследование математических
          последовательностей</em></span></a></dt>

          <dt>25-11. <a
           href="#c12790_html_TWODIM">Эмуляция массива с двумя
          измерениями</a></dt>

          <dt>27-1. <a
           href="#x12987_html_PIDID">Поиск файла программы по
          идентификатору процесса</a></dt>

          <dt>27-2. <a
           href="#x12987_html_CONSTAT">Проверка состояния
          соединения</a></dt>

          <dt>28-1. <a
           href="#c13041_html_COOKIES">Удаление cookie-файлов</a></dt>

          <dt>28-2. <a
           href="#c13041_html_EX73">Создание файла подкачки (swapfile),
          с помощью <tt
           class="FILENAME">/dev/zero</tt></a></dt>

          <dt>28-3. <a
           href="#c13041_html_RAMDISK">Создание электронного
          диска</a></dt>

          <dt>29-1. <a
           href="#c13099_html_EX74">Сценарий, содержащий ошибку</a></dt>

          <dt>29-2. <a
           href="#c13099_html_MISSINGKEYWORD">Пропущено</a> <a
           href="#c5358_html_KEYWORDREF">ключевое слово</a></dt>

          <dt>29-3. <a
           href="#c13099_html_EX75">test24</a></dt>

          <dt>29-4. <a
           href="#c13099_html_ASSERT">Проверка условия с помощью функции
          <span
           class="QUOTE">&quot;assert&quot;</span></a></dt>

          <dt>29-5. <a
           href="#c13099_html_EX76">Ловушка на выходе</a></dt>

          <dt>29-6. <a
           href="#c13099_html_ONLINE">Удаление временного файла при
          нажатии на Control-C</a></dt>

          <dt>29-7. <a
           href="#c13099_html_VARTRACE">Трассировка переменной</a></dt>

          <dt>31-1. <a
           href="#c13371_html_SUBPIT">Западня в подоболочке</a></dt>

          <dt>31-2. <a
           href="#c13371_html_BADREAD">Передача вывода от команды
          <strong
           class="COMMAND">echo</strong> команде <strong
           class="COMMAND">read</strong>, по конвейеру</a></dt>

          <dt>33-1. <a
           href="#x13541_html_EX3"><strong
           class="COMMAND">сценарий-обертка</strong></a></dt>

          <dt>33-2. <a
           href="#x13541_html_EX4">Более сложный пример <strong
           class="COMMAND">сценария-обертки</strong></a></dt>

          <dt>33-3. <a
           href="#x13541_html_COLTOTALER"><strong
           class="COMMAND">Сценарий-обертка</strong> вокруг сценария
          awk</a></dt>

          <dt>33-4. <a
           href="#x13541_html_EX56">Сценарий на языке Perl, встроенный в
          <strong
           class="COMMAND">Bash</strong>-скрипт</a></dt>

          <dt>33-5. <a
           href="#x13541_html_BASHANDPERL">Комбинирование сценария Bash
          и Perl в одном файле</a></dt>

          <dt>33-6. <a
           href="#x13609_html_RECURSE">Сценарий (бесполезный), который
          вызывает себя сам</a></dt>

          <dt>33-7. <a
           href="#x13609_html_PBOOK">Сценарий имеющий практическую
          ценность), который вызывает себя сам</a></dt>

          <dt>33-8. <a
           href="#x13621_html_EX30A"><span
           class="QUOTE">&quot;Цветная&quot;</span> адресная
          книга</a></dt>

          <dt>33-9. <a
           href="#x13621_html_COLORECHO">Вывод цветного текста</a></dt>

          <dt>33-10. <a
           href="#x13753_html_MULTIPLICATION">Необычный способ передачи
          возвращаемого значения</a></dt>

          <dt>33-11. <a
           href="#x13753_html_SUMPRODUCT">Необычный способ получения
          нескольких возвращаемых значений</a></dt>

          <dt>33-12. <a
           href="#x13753_html_ARRFUNC">Передача массива в функцию и
          возврат массива из функции</a></dt>

          <dt>33-13. <a
           href="#x13753_html_AGRAM">Игры с анаграммами</a></dt>

          <dt>34-1. <a
           href="#c13936_html_EX77">Расширение строк</a></dt>

          <dt>34-2. <a
           href="#c13936_html_EX78">Косвенные ссылки на переменные --
          новый метод</a></dt>

          <dt>34-3. <a
           href="#c13936_html_RESISTOR">Простая база данных, с
          применением косвенных ссылок</a></dt>

          <dt>34-4. <a
           href="#c13936_html_EX79">Массивы и другие хитрости для
          раздачи колоды карт в четыре руки</a></dt>

          <dt>A-1. <a
           href="#a14477_html_MANVIEW"><strong
           class="COMMAND">manview</strong>: Просмотр страниц
          руководств man</a></dt>

          <dt>A-2. <a
           href="#a14477_html_MAILFORMAT"><strong
           class="COMMAND">mailformat</strong>: Форматирование
          электронных писем</a></dt>

          <dt>A-3. <a
           href="#a14477_html_RN"><strong
           class="COMMAND">rn</strong>: Очень простая утилита для
          переименования файлов</a></dt>

          <dt>A-4. <a
           href="#a14477_html_BLANKRENAME"><strong
           class="COMMAND">blank-rename</strong>: переименование
          файлов, чьи имена содержат пробелы</a></dt>

          <dt>A-5. <a
           href="#a14477_html_ENCRYPTEDPW"><strong
           class="COMMAND">encryptedpw</strong>: Передача файла на
          ftp-сервер, с использованием пароля</a></dt>

          <dt>A-6. <a
           href="#a14477_html_COPYCD"><strong
           class="COMMAND">copy-cd</strong>: Копирование компакт-дисков
          с данными</a></dt>

          <dt>A-7. <a
           href="#a14477_html_COLLATZ">Последовательности Коллаца
          (Collatz)</a></dt>

          <dt>A-8. <a
           href="#a14477_html_DAYSBETWEEN"><strong
           class="COMMAND">days-between</strong>: Подсчет числа дней
          между двумя датами</a></dt>

          <dt>A-9. <a
           href="#a14477_html_MAKEDICT">Создание <span
           class="QUOTE">&quot;словаря&quot;</span></a></dt>

          <dt>A-10. <a
           href="#a14477_html_SOUNDEX">Расчет индекса
          &quot;созвучности&quot;</a></dt>

          <dt>A-11. <a
           href="#a14477_html_LIFESLOW"><span
           class="QUOTE">&quot;Игра
          &quot;Жизнь&quot;&quot;</span></a></dt>

          <dt>A-12. <a
           href="#a14477_html_GEN0DATA">Файл с первым поколением для
          игры <span
           class="QUOTE">&quot;Жизнь&quot;</span></a></dt>

          <dt>A-13. <a
           href="#a14477_html_BEHEAD"><strong
           class="COMMAND">behead</strong>: Удаление заголовков из
          электронных писем и новостей</a></dt>

          <dt>A-14. <a
           href="#a14477_html_FTPGET"><strong
           class="COMMAND">ftpget</strong>: Скачивание файлов по
          ftp</a></dt>

          <dt>A-15. <a
           href="#a14477_html_MORCOPY">Указание на авторские
          права</a></dt>

          <dt>A-16. <a
           href="#a14477_html_PW"><strong
           class="COMMAND">password</strong>: Генератор случайного 8-ми
          символьного пароля</a></dt>

          <dt>A-17. <a
           href="#a14477_html_FIFO"><strong
           class="COMMAND">fifo</strong>: Создание резервных копий с
          помощью именованных каналов</a></dt>

          <dt>A-18. <a
           href="#a14477_html_PRIMES">Генерация простых чисел, с
          использованием оператора деления по модулю (остаток от
          деления)</a></dt>

          <dt>A-19. <a
           href="#a14477_html_TREE"><strong
           class="COMMAND">tree</strong>: Вывод дерева
          каталогов</a></dt>

          <dt>A-20. <a
           href="#a14477_html_STRING"><strong
           class="COMMAND">Функции для работы со
          строками</strong></a></dt>

          <dt>A-21. <a
           href="#a14477_html_DIRECTORYINFO">Directory
          information</a></dt>

          <dt>A-22. <a
           href="#a14477_html_OBJORIENTED">Объектно ориентированная база
          данных</a></dt>

          <dt>G-1. <a
           href="#a15124_html_BASHRC">Пример файла <tt
           class="FILENAME">.bashrc</tt></a></dt>

          <dt>H-1. <a
           href="#a15138_html_VIEWDAT">VIEWDATA.BAT: пакетный файл
          DOS</a></dt>

          <dt>H-2. <a
           href="#a15138_html_VIEWDATA">viewdata.sh: Результат
          преобразования VIEWDATA.BAT в сценарий командной
          оболочки</a></dt>
        </dl>
      </div>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"> </td>

          <td
           width="34%"
           align="center"
           valign="top"> </td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#p112_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top"> </td>

          <td
           width="34%"
           align="center"
           valign="top"> </td>

          <td
           width="33%"
           align="right"
           valign="top">Введение</td>
        </tr>
      </table>
    </div>
<hr>

<a name="a14477_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#b14059_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#a14586_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="APPENDIX">
      <h1><a
       name="a14477_html_CONTRIBUTED-SCRIPTS"></a>Приложение A. Дополнительные
      примеры сценариев</h1>

      <p>В этом приложении собраны сценарии, которые не попали в
      основной текст документа. Однако, они определенно стоят того, что
      бы вы потратили время на их изучение.</p>

      <div
       class="EXAMPLE">
        <a
         name="a14477_html_MANVIEW"></a>

        <p><strong>Пример A-1. manview: Просмотр страниц руководств
        man</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# manview.sh: Просмотр страниц руководств man в форматированном виде.

#  Полезен писателям страниц руководств, позволяет просмотреть страницы в исходном коде
#+ как они будут выглядеть в конечном виде.

E_WRONGARGS=65

if [ -z &quot;$1&quot; ]
then
  echo &quot;Порядок использования: `basename $0` имя_файла&quot;
  exit $E_WRONGARGS
fi

groff -Tascii -man $1 | less

# Если страница руководства включает в себя таблицы и/или выражения,
# то этот сценарий &quot;стошнит&quot;.
# Для таких случаев можно использовать следующую строку.
#
#   gtbl &lt; &quot;$1&quot; | geqn -Tlatin1 | groff -Tlatin1 -mtty-char -man
#
#   Спасибо S.C.

exit 0
</pre>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="a14477_html_MAILFORMAT"></a>

        <p><strong>Пример A-2. mailformat: Форматирование электронных
        писем</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# mail-format.sh: Форматирование электронных писем.

# Удаляет символы &quot;^&quot;, табуляции и ограничивает чрезмерно длинные строки.

# =================================================================
#                 Стандартная проверка аргументов
ARGS=1
E_BADARGS=65
E_NOFILE=66

if [ $# -ne $ARGS ]  # Проверка числа аргументов
then
  echo &quot;Порядок использования: `basename $0` имя_файла&quot;
  exit $E_BADARGS
fi

if [ -f &quot;$1&quot; ]       # Проверка наличия файла.
then
    file_name=$1
else
    echo &quot;Файл \&quot;$1\&quot; не найден.&quot;
    exit $E_NOFILE
fi
# =================================================================

MAXWIDTH=70          # Максимальная длина строки.

#  Удаление символов &quot;^&quot; начиная с первого символа строки,
#+ и ограничить длину строки 70-ю символами.
sed &#39;
s/^&gt;//
s/^  *&gt;//
s/^  *//
s/              *//
&#39; $1 | fold -s --width=$MAXWIDTH
          # ключ -s команды &quot;fold&quot; разрывает, если это возможно, строку по пробельному символу.

#  Этот сценарий был написан после прочтения статьи, в котором расхваливалась
#+ утилита под Windows, размером в 164K, с подобной функциональностью.
#
#  Хороший набор утилит для обработки текста и эффективный
#+ скриптовый язык -- это все, что необходимо, чтобы составить серьезную конкуренцию
#+ чрезмерно &quot;раздутым&quot; программам.

exit 0
</pre>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="a14477_html_RN"></a>

        <p><strong>Пример A-3. rn: Очень простая утилита для
        переименования файлов</strong></p>

        <p>Этот сценарий является модификацией <a
         href="#x7050_html_LOWERCASE">Пример 12-15</a>.</p>
<pre
 class="PROGRAMLISTING">
#! /bin/bash
#
# Очень простая утилита для переименования файлов
#
#  Утилита &quot;ren&quot;, автор Vladimir Lanin (lanin@csd2.nyu.edu),
#+ выполняет эти же действия много лучше.


ARGS=2
E_BADARGS=65
ONE=1                     # Единственное или множественное число (см. ниже).

if [ $# -ne &quot;$ARGS&quot; ]
then
  echo &quot;Порядок использования: `basename $0` старый_шаблон новый_шаблон&quot;
  # Например: &quot;rn gif jpg&quot;, поменяет расширения всех файлов в текущем каталоге с gif на jpg.
  exit $E_BADARGS
fi

number=0                  # Количество переименованных файлов.


for filename in *$1*      # Проход по списку файлов в текущем каталоге.
do
   if [ -f &quot;$filename&quot; ]
   then
     fname=`basename $filename`            # Удалить путь к файлу из имени.
     n=`echo $fname | sed -e &quot;s/$1/$2/&quot;`   # Поменять старое имя на новое.
     mv $fname $n                          # Переименовать.
     let &quot;number += 1&quot;
   fi
done

if [ &quot;$number&quot; -eq &quot;$ONE&quot; ]                # Соблюдение правил грамматики.
then
 echo &quot;$number файл переименован.&quot;
else
 echo &quot;Переименовано файлов: $number.&quot;
fi

exit 0


# Упражнения:
# ----------
# С какими типами файлов этот сценарий не будет работать?
# Как это исправить?
#
#  Переделайте сценарий таким образом, чтобы он мог обрабатывать все файлы в каталоге,
#+ в именах которых содержатся пробелы, заменяя пробелы символом подчеркивания.
</pre>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="a14477_html_BLANKRENAME"></a>

        <p><strong>Пример A-4. blank-rename: переименование файлов, чьи
        имена содержат пробелы</strong></p>

        <p>Это даже более простая версия предыдущего примера.</p>
<pre
 class="PROGRAMLISTING">
#! /bin/bash
# blank-rename.sh
#
# Заменяет пробелы символом подчеркивания в именах файлов в текущем каталоге.

ONE=1                     # единственное или множественное число (см. ниже).
number=0                  # Количество переименованных файлов.
FOUND=0                   # Код завершения в случае успеха.

for filename in *         # Перебор всех файлов в текущем каталоге.
do
     echo &quot;$filename&quot; | grep -q &quot; &quot;         #  Проверить -- содержит ли имя файла
     if [ $? -eq $FOUND ]                   #+ пробелы.
     then
       fname=$filename                      # Удалить путь из имени файла.
       n=`echo $fname | sed -e &quot;s/ /_/g&quot;`   # Заменить пробелы символом подчеркивания.
       mv &quot;$fname&quot; &quot;$n&quot;                     # Переименование.
       let &quot;number += 1&quot;
     fi
done

if [ &quot;$number&quot; -eq &quot;$ONE&quot; ]
then
 echo &quot;$number файл переименован.&quot;
else
 echo &quot;Переименовано файлов: $number&quot;
fi

exit 0
</pre>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="a14477_html_ENCRYPTEDPW"></a>

        <p><strong>Пример A-5. encryptedpw: Передача файла на
        ftp-сервер, с использованием пароля</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Модификация примера &quot;ex72.sh&quot;, добавлено шифрование пароля.

#  Обратите внимание: этот вариант все еще нельзя считать безопасным,
#+ поскольку в сеть пароль уходит в незашифрованном виде.
# Используйте &quot;ssh&quot;, если вас это беспокоит.

E_BADARGS=65

if [ -z &quot;$1&quot; ]
then
  echo &quot;Порядок использования: `basename $0` имя_файла&quot;
  exit $E_BADARGS
fi

Username=bozo           # Измените на свой.
pword=/home/bozo/secret/password_encrypted.file
# Файл, содержащий пароль в зашифрованном виде.

Filename=`basename $1`  # Удалить путь из имени файла

Server=&quot;XXX&quot;
Directory=&quot;YYY&quot;         # Подставьте фактические имя сервера и каталога.


Password=`cruft &lt;$pword`          # Расшифровка.
#  Используется авторская программа &quot;cruft&quot;,
#+ основанная на алгоритме &quot;onetime pad&quot;,
#+ ее можно скачать с :
#+ Primary-site:   ftp://ibiblio.org/pub/Linux/utils/file
#+                 cruft-0.2.tar.gz [16k]


ftp -n $Server &lt;&lt;End-Of-Session
user $Username $Password
binary
bell
cd $Directory
put $Filename
bye
End-Of-Session
# ключ -n, команды &quot;ftp&quot;, запрещает автоматический вход.
# &quot;bell&quot; -- звонок (звуковой сигнал) после передачи каждого файла.

exit 0
</pre>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="a14477_html_COPYCD"></a>

        <p><strong>Пример A-6. copy-cd: Копирование компакт-дисков с
        данными</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# copy-cd.sh: copying a data CD

CDROM=/dev/cdrom                           # устройство CD ROM
OF=/home/bozo/projects/cdimage.iso         # промежуточный файл
#       /xxxx/xxxxxxx/                     измените для своей системы.
BLOCKSIZE=2048
SPEED=2                                    # Можно задать более высокую скорость, если поддерживается.

echo; echo &quot;Вставьте исходный CD, но *НЕ* монтируйте его.&quot;
echo &quot;Нажмите ENTER, когда будете готовы. &quot;
read ready                                 # Ожидание.

echo; echo &quot;Создается промежуточный файл $OF.&quot;
echo &quot;Это может занять какое-то время. Пожалуйста подождите.&quot;

dd if=$CDROM of=$OF bs=$BLOCKSIZE          # Копирование.


echo; echo &quot;Выньте исходный CD.&quot;
echo &quot;Вставьте чистую болванку CDR.&quot;
echo &quot;Нажмите ENTER, когда будете готовы. &quot;
read ready                                 # Ожидание.

echo &quot;Копируется файл $OF на болванку.&quot;

cdrecord -v -isosize speed=$SPEED dev=0,0 $OF
# Используется пакет Joerg Schilling -- &quot;cdrecord&quot; .
# http://www.fokus.gmd.de/nthp/employees/schilling/cdrecord.html


echo; echo &quot;Копирование завершено.&quot;

echo &quot;Желаете удалить промежуточный файл (y/n)? &quot;  # Наверняка большой файл получился.
read answer

case &quot;$answer&quot; in
[yY]) rm -f $OF
      echo &quot;Файл $OF удален.&quot;
      ;;
*)    echo &quot;Файл $OF не был удален.&quot;;;
esac

echo

# Упражнение:
# Добавьте в оператор &quot;case&quot; возможность обработки, введенных пользователем, &quot;yes&quot; и &quot;Yes&quot;.

exit 0
</pre>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="a14477_html_COLLATZ"></a>

        <p><strong>Пример A-7. Последовательности Коллаца
        (Collatz)</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# collatz.sh

#  Широко известная последовательность Коллаца (Collatz) (гипотеза Коллаца).
#  -------------------------------------------
#  1) Принимает из командной строки &quot;начальное&quot; целое число.
#  2) ЧИСЛО &lt;--- НАЧАЛЬНОЕ ЗНАЧЕНИЕ
#  3) Вывести ЧИСЛО.
#  4)  Если ЧИСЛО четное, разделить на 2,
#  5)+ Если не четное -- умножить на 3 и прибавить 1.
#  6) ЧИСЛО &lt;--- РЕЗУЛЬТАТ
#  7) Повторить, начиная с п. 3, заданное число раз.
#
#  Теоретически, такая последовательность должна сходиться,
#+ не зависимо от величины начального значения,
#+ к повторению циклов &quot;4,2,1...&quot;,
#+ даже после значительных флуктуаций в самом начале.


MAX_ITERATIONS=200
# Для больших начальных значений (&gt;32000), это значение придется увеличить.

h=${1:-$$}                      #  Начальное значение
                                #  если из командной строки ничего не задано, то берется $PID,

echo
echo &quot;C($h) --- $MAX_ITERATIONS итераций&quot;
echo

for ((i=1; i&lt;=MAX_ITERATIONS; i++))
do

echo -n &quot;$h     &quot;
#          ^^^^^
#           табуляция

  let &quot;remainder = h % 2&quot;
  if [ &quot;$remainder&quot; -eq 0 ]   # Четное?
  then
    let &quot;h /= 2&quot;              # Разделить на 2.
  else
    let &quot;h = h*3 + 1&quot;         # Умножить на 3 и прибавить 1.
  fi


COLUMNS=10                    # Выводить по 10 значений в строке.
let &quot;line_break = i % $COLUMNS&quot;
if [ &quot;$line_break&quot; -eq 0 ]
then
  echo
fi

done

echo

exit 0
</pre>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="a14477_html_DAYSBETWEEN"></a>

        <p><strong>Пример A-8. days-between: Подсчет числа дней между
        двумя датами</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# days-between.sh:    Подсчет числа дней между двумя датами.
# Порядок использования: ./days-between.sh [M]M/[D]D/YYYY [M]M/[D]D/YYYY

ARGS=2                # Ожидается два аргумента из командной строки.
E_PARAM_ERR=65        # Ошибка в числе ожидаемых аргументов.

REFYR=1600            # Начальный год.
CENTURY=100
DIY=365
ADJ_DIY=367           # Корректировка на високосный год + 1.
MIY=12
DIM=31
LEAPCYCLE=4

MAXRETVAL=255         # Максимально возможное возвращаемое значение
                      # для положительных чисел.

diff=                         # Количество дней между датами.
value=                # Абсолютное значение.
day=                  # день, месяц, год.
month=
year=


Param_Error ()        # Ошибка в пвраметрах командной строки.
{
  echo &quot;Порядок использования: `basename $0` [M]M/[D]D/YYYY [M]M/[D]D/YYYY&quot;
  echo &quot;       (даты должны быть после 1/3/1600)&quot;
  exit $E_PARAM_ERR
}


Parse_Date ()                 # Разбор даты.
{
  month=${1%%/**}
  dm=${1%/**}                 # День и месяц.
  day=${dm#*/}
  let &quot;year = `basename $1`&quot;  # Хотя это и не имя файла, но результат тот же.
}


check_date ()                 # Проверка даты.
{
  [ &quot;$day&quot; -gt &quot;$DIM&quot; ] || [ &quot;$month&quot; -gt &quot;$MIY&quot; ] || [ &quot;$year&quot; -lt &quot;$REFYR&quot; ] &amp;&amp; Param_Error
  # Выход из сценария при обнаружении ошибки.
  # Используется комбинация &quot;ИЛИ-списка / И-списка&quot;.
  #
  # Упражнение: Реализуйте более строгую проверку даты.
}


strip_leading_zero () # Удалить ведущий ноль
{
  val=${1#0}          # иначе Bash будет считать числа
  return $val         # восьмеричными (POSIX.2, sect 2.9.2.1).
}


day_index ()          # Формула Гаусса:
{                     # Количество дней от 3 Янв. 1600 до заданной даты.

  day=$1
  month=$2
  year=$3

  let &quot;month = $month - 2&quot;
  if [ &quot;$month&quot; -le 0 ]
  then
    let &quot;month += 12&quot;
    let &quot;year -= 1&quot;
  fi

  let &quot;year -= $REFYR&quot;
  let &quot;indexyr = $year / $CENTURY&quot;


  let &quot;Days = $DIY*$year + $year/$LEAPCYCLE - $indexyr + $indexyr/$LEAPCYCLE + $ADJ_DIY*$month/$MIY + $day - $DIM&quot;
  # Более подробное объяснение алгоритма вы найдете в
  # http://home.t-online.de/home/berndt.schwerdtfeger/cal.htm


  if [ &quot;$Days&quot; -gt &quot;$MAXRETVAL&quot; ]  # Если больше 255,
  then                             # то поменять знак
    let &quot;dindex = 0 - $Days&quot;       # чтобы функция смогла вернуть полное значение.
  else let &quot;dindex = $Days&quot;
  fi

  return $dindex

}


calculate_difference ()            # Разница между двумя датами.
{
  let &quot;diff = $1 - $2&quot;             # Глобальная переменная.
}


abs ()                             # Абсолютное значение
{                                  # Используется глобальная переменная &quot;value&quot;.
  if [ &quot;$1&quot; -lt 0 ]                # Если число отрицательное
  then                             # то
    let &quot;value = 0 - $1&quot;           # изменить знак,
  else                             # иначе
    let &quot;value = $1&quot;               # оставить как есть.
  fi
}



if [ $# -ne &quot;$ARGS&quot; ]              # Требуется два аргумента командной строки.
then
  Param_Error
fi

Parse_Date $1
check_date $day $month $year      # Проверка даты.

strip_leading_zero $day           # Удалить ведущие нули
day=$?                            # в номере дня и/или месяца.
strip_leading_zero $month
month=$?

day_index $day $month $year
date1=$?

abs $date1                         # Абсолютное значение
date1=$value

Parse_Date $2
check_date $day $month $year

strip_leading_zero $day
day=$?
strip_leading_zero $month
month=$?

day_index $day $month $year
date2=$?

abs $date2                         # Абсолютное значение
date2=$value

calculate_difference $date1 $date2

abs $diff                          # Абсолютное значение
diff=$value

echo $diff

exit 0
# Сравните этот сценарий с реализацией формулы Гаусса на C
# http://buschencrew.hypermart.net/software/datedif
</pre>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="a14477_html_MAKEDICT"></a>

        <p><strong>Пример A-9. Создание <span
         class="QUOTE">&quot;словаря&quot;</span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# makedict.sh  [создание словаря]

# Модификация сценария /usr/sbin/mkdict.
# Авторские права на оригинальный сценарий принадлежат Alec Muffett.
#
#  Этот модифицированный вариант включен в документ на основе
#+ документа &quot;LICENSE&quot; из пакета &quot;Crack&quot;
#+ с которым распространяется оригинальный сценарий.

#  Этот скрипт обрабатывает текстовые файлы и создает отсортированный список
#+ слов, найденных в этих файлах.
#  Он может оказаться полезным для сборки словарей
#+ и проведения лексикографического анализа.


E_BADARGS=65

if [ ! -r &quot;$1&quot; ]                     #  Необходим хотя бы один аргумент --
then                                 #+ имя файла.
  echo &quot;Порядок использования: $0 имена_файлов&quot;
  exit $E_BADARGS
fi


# SORT=&quot;sort&quot;                        #  Необходимость задания ключей сортировки отпала.
                                     #+ Изменено, по отношению к оригинальному сценарию.

cat $* |                             # Выдать содержимое файлов на stdout.
        tr A-Z a-z |                 # Преобразовать в нижний регистр.
        tr &#39; &#39; &#39;\012&#39; |              # Новое: заменить пробелы символами перевода строки.
#       tr -cd &#39;\012[a-z][0-9]&#39; |    #  В оригинальном сценарии: удалить все символы,
                                     #+ которые не являются буквами или цифрами.
        tr -c &#39;\012a-z&#39;  &#39;\012&#39; |    #  Вместо удаления
                                     #+ неалфавитно-цифровые символы заменяются на перевод строки.
        sort |
        uniq |                       # Удалить повторяющиеся слова.
        grep -v &#39;^#&#39; |               # Удалить строки, начинающиеся с &quot;#&quot;.
        grep -v &#39;^$&#39;                 # Удалить пустые строки.

exit 0
</pre>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="a14477_html_SOUNDEX"></a>

        <p><strong>Пример A-10. Расчет индекса
        &quot;созвучности&quot;</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# soundex.sh: Расчет индекса &quot;созвучности&quot;

# =======================================================
#       Сценарий Soundex
#            Автор
#         Mendel Cooper
#     thegrendel@theriver.com
#       23 Января 2002 г.
#
#   Условия распространения: Public Domain.
#
# Несколько отличающаяся версия этого сценария была опубликована
#+ Эдом Шэфером (Ed Schaefer) в Июле 2002 года в колонке &quot;Shell Corner&quot;
#+ &quot;Unix Review&quot; on-line,
#+ http://www.unixreview.com/documents/uni1026336632258/
# =======================================================


ARGCOUNT=1                     # Требуется аргумент командной строки.
E_WRONGARGS=70

if [ $# -ne &quot;$ARGCOUNT&quot; ]
then
  echo &quot;Порядок использования: `basename $0` имя&quot;
  exit $E_WRONGARGS
fi


assign_value ()                #  Присвоить числовые значения
{                              #+ символам в имени.

  val1=bfpv                    # &#39;b,f,p,v&#39; = 1
  val2=cgjkqsxz                # &#39;c,g,j,k,q,s,x,z&#39; = 2
  val3=dt                      #  и т.п.
  val4=l
  val5=mn
  val6=r

# Попробуйте разобраться в том, что здесь происходит.

value=$( echo &quot;$1&quot; \
| tr -d wh \
| tr $val1 1 | tr $val2 2 | tr $val3 3 \
| tr $val4 4 | tr $val5 5 | tr $val6 6 \
| tr -s 123456 \
| tr -d aeiouy )

# Символам в имени присваиваются числовые значения.
# Удаляются повторяющиеся числа, если они не разделены гласными.
# Гласные игнорируются, если они не являются разделителями, которые удаляются в последнюю очередь.
# Символы &#39;w&#39; и &#39;h&#39; удаляются в первую очередь.
}


input_name=&quot;$1&quot;
echo
echo &quot;Имя = $input_name&quot;


# Перевести все символы в имени в нижний регистр.
# ------------------------------------------------
name=$( echo $input_name | tr A-Z a-z )
# ------------------------------------------------


# Начальный символ в индекса &quot;созвучия&quot;: первая буква в имени.
# --------------------------------------------


char_pos=0                     # Начальная позиция в имени.
prefix0=${name:$char_pos:1}
prefix=`echo $prefix0 | tr a-z A-Z`
                               # Первую букву в имени -- в верхний регистр.

let &quot;char_pos += 1&quot;            # Передвинуть &quot;указатель&quot; на один символ.
name1=${name:$char_pos}


# ++++++++++++++++++++++++++++ Исключение отдельных ситуаций +++++++++++++++++++++++++++++++
#  Теперь мы передвинулись на один символ вправо.
#  Если второй символ в имени совпадает с первым
#+ то его нужно отбросить.
#  Кроме того, мы должны проверить -- не является ли первый символ
#+ гласной, &#39;w&#39; или &#39;h&#39;.

char1=`echo $prefix | tr A-Z a-z`    # Первый символ -- в нижний регистр.

assign_value $name
s1=$value
assign_value $name1
s2=$value
assign_value $char1
s3=$value
s3=9$s3                              #  Если первый символ в имени -- гласная буква
                                     #+ или &#39;w&#39; или &#39;h&#39;,
                                     #+ то ее &quot;значение&quot; нужно отбросить.
                                     #+ Поэтому ставим 9, или другое
                                     #+ неиспользуемое значение, которое можно будет проверить.


if [[ &quot;$s1&quot; -ne &quot;$s2&quot; || &quot;$s3&quot; -eq 9 ]]
then
  suffix=$s2
else
  suffix=${s2:$char_pos}
fi
# ++++++++++++++++++++++++ Конец исключения отдельных ситуаций +++++++++++++++++++++++++++++++


padding=000                    # Дополнить тремя нулями.


soun=$prefix$suffix$padding    # Нули добавить в конец получившегося индекса.

MAXLEN=4                       # Ограничить длину индекса 4-мя символами.
soundex=${soun:0:$MAXLEN}

echo &quot;Индекс созвучия = $soundex&quot;

echo

#  Индекс &quot;созвучия&quot; - это метод индексации и классификации имен
#+ по подобию звучания.
#  Индекс &quot;созвучия&quot; начинается с первого символа в имени,
#+ за которым следуют 3-значный расчетный код.
#  Имена, которые произносятся примерно одинаково, имеют близкие индексы &quot;созвучия&quot;.

#   Например:
#   Smith и Smythe -- оба имеют индекс &quot;созвучия&quot; &quot;S530&quot;.
#   Harrison = H625
#   Hargison = H622
#   Harriman = H655

#  Как правило эта методика дает неплохой результат, но имеются и аномалии.
#
#
#  Дополнительную информацию вы найдете на
#+ &quot;National Archives and Records Administration home page&quot;,
#+ http://www.nara.gov/genealogy/soundex/soundex.html



# Упражнение:
# ----------
# Упростите блок &quot;Исключение отдельных ситуаций&quot; .

exit 0
</pre>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="a14477_html_LIFESLOW"></a>

        <p><strong>Пример A-11. <span
         class="QUOTE">&quot;Игра
        &quot;Жизнь&quot;&quot;</span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# life.sh: Игра &quot;Жизнь&quot;

# ##################################################################### #
# Это Bash-версия известной игры Джона Конвея (John Conway) &quot;Жизнь&quot;.    #
# --------------------------------------------------------------------- #
# Прямоугольное игровое поле разбито на ячейки, в каждой ячейке может   #
#+ располагаться живая особь.                                           #
# Соответственно, ячейка с живой особью отмечается точкой,              #
#+ не занятая ячейка -- остается пустой.                                #
#  Изначально, ячейки заполняются из файла --                           #
#+ это первое поколение, или &quot;поколение 0&quot;                              #
# Воспроизводство особей, в каждом последующем поколении,               #
#+ определяется следующими правилами                                    #
# 1) Каждая ячейка имеет &quot;соседей&quot;                                      #
#+   слева, справа, сверху, снизу и 4 по диагоналям.                    #
#                       123                                             #
#                       4*5                                             #
#                       678                                             #
#                                                                       #
# 2) Если живая особь имеет 2 или 3 живых соседей, то она остается жить.#
# 3) Если пустая ячейка имеет 3 живых соседей --                        #
#+   в ней &quot;рождается&quot; новая особь                                      #
SURVIVE=2                                                               #
BIRTH=3                                                                 #
# 4) В любом другом случае, живая особь &quot;погибает&quot;                      #
# ##################################################################### #


startfile=gen0   # Начальное поколение из файла по-умолчанию -- &quot;gen0&quot;.
                 # если не задан другой файл, из командной строки.
                 #
if [ -n &quot;$1&quot; ]   # Проверить аргумент командной строки -- файл с &quot;поколениемn 0&quot;.
then
  if [ -e &quot;$1&quot; ] # Проверка наличия файла.
  then
    startfile=&quot;$1&quot;
  fi
fi


ALIVE1=.
DEAD1=_
                 # Представление &quot;живых&quot; особей и пустых ячеек в файле с &quot;поколением 0&quot;.

#  Этот сценарий работает с игровым полем 10 x 10 grid (может быть увеличено,
#+ но большое игровое поле будет обрабатываться очень медленно).
ROWS=10
COLS=10

GENERATIONS=10          #  Максимальное число поколений.

NONE_ALIVE=80           #  Код завершения на случай,
                        #+ если не осталось ни одной &quot;живой&quot; особи.
TRUE=0
FALSE=1
ALIVE=0
DEAD=1

avar=                   # Текущее поколение.
generation=0            # Инициализация счетчика поколений.

# =================================================================


let &quot;cells = $ROWS * $COLS&quot;
                        # Количество ячеек на игровом поле.

declare -a initial      # Массивы ячеек.
declare -a current

display ()
{

alive=0                 # Количество &quot;живых&quot; особей.
                        # Изначально -- ноль.

declare -a arr
arr=( `echo &quot;$1&quot;` )     # Преобразовать аргумент в массив.

element_count=${#arr[*]}

local i
local rowcheck

for ((i=0; i&lt;$element_count; i++))
do

  # Символ перевода строки -- в конец каждой строки.
  let &quot;rowcheck = $i % ROWS&quot;
  if [ &quot;$rowcheck&quot; -eq 0 ]
  then
    echo                # Перевод строки.
    echo -n &quot;      &quot;    # Выравнивание.
  fi

  cell=${arr[i]}

  if [ &quot;$cell&quot; = . ]
  then
    let &quot;alive += 1&quot;
  fi

  echo -n &quot;$cell&quot; | sed -e &#39;s/_/ /g&#39;
  # Вывести массив, по пути заменяя символы подчеркивания на пробелы.
done

return

}

IsValid ()                            # Проверка корректности координат ячейки.
{

  if [ -z &quot;$1&quot;  -o -z &quot;$2&quot; ]          # Проверка наличия входных аргументов.
  then
    return $FALSE
  fi

local row
local lower_limit=0                   # Запрет на отрицательные координаты.
local upper_limit
local left
local right

let &quot;upper_limit = $ROWS * $COLS - 1&quot; # Номер последней ячейки на игровом поле.


if [ &quot;$1&quot; -lt &quot;$lower_limit&quot; -o &quot;$1&quot; -gt &quot;$upper_limit&quot; ]
then
  return $FALSE                       # Выход за границы массива.
fi

row=$2
let &quot;left = $row * $ROWS&quot;             # Левая граница.
let &quot;right = $left + $COLS - 1&quot;       # Правая граница.

if [ &quot;$1&quot; -lt &quot;$left&quot; -o &quot;$1&quot; -gt &quot;$right&quot; ]
then
  return $FALSE                       # Выхол за нижнюю строку.
fi

return $TRUE                          # Координаты корректны.

}


IsAlive ()              # Проверка наличия &quot;живой&quot; особи в ячейке.
                        # Принимает массив и номер ячейки в качестве входных аргументов.
{
  GetCount &quot;$1&quot; $2      # Подсчитать кол-во &quot;живых&quot; соседей.
  local nhbd=$?


  if [ &quot;$nhbd&quot; -eq &quot;$BIRTH&quot; ]  # &quot;Живая&quot;.
  then
    return $ALIVE
  fi

  if [ &quot;$3&quot; = &quot;.&quot; -a &quot;$nhbd&quot; -eq &quot;$SURVIVE&quot; ]
  then                  # &quot;Живая&quot; если перед этим была &quot;живая&quot;.
    return $ALIVE
  fi

  return $DEAD          # По-умолчанию.

}


GetCount ()             # Подсчет &quot;живых&quot; соседей.
                        # Необходимо 2 аргумента:
                        # $1) переменная-массив
                        # $2) cell номер ячейки
{
  local cell_number=$2
  local array
  local top
  local center
  local bottom
  local r
  local row
  local i
  local t_top
  local t_cen
  local t_bot
  local count=0
  local ROW_NHBD=3

  array=( `echo &quot;$1&quot;` )

  let &quot;top = $cell_number - $COLS - 1&quot;    # Номера соседних ячеек.
  let &quot;center = $cell_number - 1&quot;
  let &quot;bottom = $cell_number + $COLS - 1&quot;
  let &quot;r = $cell_number / $ROWS&quot;

  for ((i=0; i&lt;$ROW_NHBD; i++))           # Просмотр слева-направо.
  do
    let &quot;t_top = $top + $i&quot;
    let &quot;t_cen = $center + $i&quot;
    let &quot;t_bot = $bottom + $i&quot;


    let &quot;row = $r&quot;                        # Пройти по соседям в средней строке.
    IsValid $t_cen $row                   # Координаты корректны?
    if [ $? -eq &quot;$TRUE&quot; ]
    then
      if [ ${array[$t_cen]} = &quot;$ALIVE1&quot; ] # &quot;Живая&quot;?
      then                                # Да!
        let &quot;count += 1&quot;                  # Нарастить счетчик.
      fi
    fi

    let &quot;row = $r - 1&quot;                    # По верхней строке.
    IsValid $t_top $row
    if [ $? -eq &quot;$TRUE&quot; ]
    then
      if [ ${array[$t_top]} = &quot;$ALIVE1&quot; ]
      then
        let &quot;count += 1&quot;
      fi
    fi

    let &quot;row = $r + 1&quot;                    # По нижней строке.
    IsValid $t_bot $row
    if [ $? -eq &quot;$TRUE&quot; ]
    then
      if [ ${array[$t_bot]} = &quot;$ALIVE1&quot; ]
      then
        let &quot;count += 1&quot;
      fi
    fi

  done


  if [ ${array[$cell_number]} = &quot;$ALIVE1&quot; ]
  then
    let &quot;count -= 1&quot;        #  Убедиться, что сама проверяемая ячейка
  fi                        #+ не была подсчитана.


  return $count

}

next_gen ()               # Обновить массив, в котором содержится информация о новом &quot;поколении&quot;.
{

local array
local i=0

array=( `echo &quot;$1&quot;` )     # Преобразовать в массив.

while [ &quot;$i&quot; -lt &quot;$cells&quot; ]
do
  IsAlive &quot;$1&quot; $i ${array[$i]}   # &quot;Живая&quot;?
  if [ $? -eq &quot;$ALIVE&quot; ]
  then                           #  Если &quot;живая&quot;, то
    array[$i]=.                  #+ записать точку.
  else
    array[$i]=&quot;_&quot;                #  Иначе -- символ подчеркивания
   fi                            #+ (который позднее заменится на пробел).
  let &quot;i += 1&quot;
done


# let &quot;generation += 1&quot;   # Увеличить счетчик поколений.

# Подготовка переменных, для передачи в функцию &quot;display&quot;.
avar=`echo ${array[@]}`   # Преобразовать массив в строку.
display &quot;$avar&quot;           # Вывести его.
echo; echo
echo &quot;Поколение $generation -- живых особей $alive&quot;

if [ &quot;$alive&quot; -eq 0 ]
then
  echo
  echo &quot;Преждеверменное завершение: не осталось ни одной живой особи!&quot;
  exit $NONE_ALIVE        #  Нет смысла продолжать
fi                        #+ если не осталось ни одной живой особи

}


# =========================================================

# main ()

# Загрузить начальное поколение из файла.
initial=( `cat &quot;$startfile&quot; | sed -e &#39;/#/d&#39; | tr -d &#39;\n&#39; |\
sed -e &#39;s/\./\. /g&#39; -e &#39;s/_/_ /g&#39;` )
# Удалить строки, начинающиеся с символа &#39;#&#39; -- комментарии.
# Удалить строки перевода строки и вставить пробелы между элементами.

clear          # Очистка экрана.

echo #       Заголовок
echo &quot;=======================&quot;
echo &quot;    $GENERATIONS поколений&quot;
echo &quot;           в&quot;
echo &quot;      игре \&quot; ЖИЗНЬ\&quot;&quot;
echo &quot;=======================&quot;


# -------- Вывести первое поколение. --------
Gen0=`echo ${initial[@]}`
display &quot;$Gen0&quot;           # Тлько вывод.
echo; echo
echo &quot;Поколение $generation -- живых особей $alive&quot;
# -------------------------------------------


let &quot;generation += 1&quot;     # Нарастить счетчик поколений.
echo

# ------- Вывести второе поколение. -------
Cur=`echo ${initial[@]}`
next_gen &quot;$Cur&quot;          # Обновить и вывести.
# ------------------------------------------

let &quot;generation += 1&quot;     # Нарастить счетчик поколений.

# ------ Основной цикл игры ------
while [ &quot;$generation&quot; -le &quot;$GENERATIONS&quot; ]
do
  Cur=&quot;$avar&quot;
  next_gen &quot;$Cur&quot;
  let &quot;generation += 1&quot;
done
# ==============================================================

echo

exit 0

# --------------------------------------------------------------
# Этот сценарий имеет недоработку.
# Граничные ячейки сверху, снизу и сбоков  остаются пустыми.
# Упражнение: Доработайте сценарий таким образом, чтобы ,
# +         левая и правая стороны как бы &quot;соприкасались&quot;,
# +         так же и верхняя и нижняя стороны.
</pre>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="a14477_html_GEN0DATA"></a>

        <p><strong>Пример A-12. Файл с первым поколением для игры <span
         class="QUOTE">&quot;Жизнь&quot;</span></strong></p>
<pre
 class="PROGRAMLISTING">
# Это файл-пример, содержащий &quot;поколение 0&quot;, для сценария &quot;life.sh&quot;.
# --------------------------------------------------------------
#  Игровое поле имеет размер 10 x 10, точкой обозначается &quot;живая&quot; особь,
#+ символом подчеркивания -- пустая ячейка. Мы не можем использовать пробелы,
#+ для обозначения пустых ячеек, из-за особенностей строения массивов в Bash.
#  [Упражнение для читателей: объясните, почему?.]
#
# Строки, начинающиеся с символа &#39;#&#39; считаются комментариями, сценарий их игнорирует.
__.__..___
___._.____
____.___..
_._______.
____._____
..__...___
____._____
___...____
__.._..___
_..___..__
</pre>
      </div>

      <p>+++</p>

      <p>Следующие два сценария предоставил Mark Moraes, из
      университета в Торонто. См. файл <span
       class="QUOTE">&quot;Moraes-COPYRIGHT&quot;</span>, который
      содержит указание на авторские права.</p>

      <div
       class="EXAMPLE">
        <a
         name="a14477_html_BEHEAD"></a>

        <p><strong>Пример A-13. behead: Удаление заголовков из
        электронных писем и новостей</strong></p>
<pre
 class="PROGRAMLISTING">
#! /bin/sh
# Удаление заголовков из электронных писем и новостей т.е. до первой
# пустой строки
# Mark Moraes, Университет в Торонто

# ==&gt; Такие комментарии добавлены автором документа.

if [ $# -eq 0 ]; then
# ==&gt; Если входной аргумент не задан (файл), то выводить результат на stdin.
        sed -e &#39;1,/^$/d&#39; -e &#39;/^[        ]*$/d&#39;
        # --&gt; Удалить пустые строки и все строки предшествующие им
else
# ==&gt; Если аргумент командной строки задан, то использовать его как имя файла.
        for i do
                sed -e &#39;1,/^$/d&#39; -e &#39;/^[        ]*$/d&#39; $i
                # --&gt; То же, что и выше.
        done
fi

# ==&gt; Упражнение: Добавьте проверку на наличие ошибок.
# ==&gt;
# ==&gt; Обратите внимание -- как похожи маленькие сценарии sed, за исключением передачи аргумента.
# ==&gt; Можно ли его оформит в виде функции? Почему да или почему нет?
</pre>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="a14477_html_FTPGET"></a>

        <p><strong>Пример A-14. ftpget: Скачивание файлов по
        ftp</strong></p>
<pre
 class="PROGRAMLISTING">
#! /bin/sh
# $Id: ftpget,v 1.2 91/05/07 21:15:43 moraes Exp $
# Сценарий устанавливает анонимное соединение с ftp-сервером.
# Простой и быстрый - написан как дополнение к ftplist
# -h -- удаленный сервер (по-умолчанию prep.ai.mit.edu)
# -d -- каталог на сервере - вы можете указать последовательность из нескольких ключей -d
# Если вы используете относительные пути,
# будьте внимательны при задании последовательности.
# (по-умолчанию -- каталог пользователя ftp)
# -v -- &quot;многословный&quot; режим, будет показывать все ответы ftp-сервера
# -f -- file[:localfile] скачивает удаленный file и записывает под именем localfile
# -m -- шаблон для mget. Не забудьте взять в кавычки!
# -c -- локальный каталог
# Например,
#       ftpget -h expo.lcs.mit.edu -d contrib -f xplaces.shar:xplaces.sh \
#               -d ../pub/R3/fixes -c ~/fixes -m &#39;fix*&#39;
# Эта команда загрузит файл xplaces.shar из ~ftp/contrib с expo.lcs.mit.edu
# и сохранит под именем xplaces.sh в текущем каталоге, затем заберет все исправления (fixes)
# из ~ftp/pub/R3/fixes и поместит их в каталог ~/fixes.
# Очевидно, что последовательность ключей и аргументов очень важна, поскольку
# она определяет последовательность операций, выполняемых с удаленным ftp-сервером
#
# Mark Moraes (moraes@csri.toronto.edu), Feb 1, 1989
#


# ==&gt; Эти комментарии добавлены автором документа.

# PATH=/local/bin:/usr/ucb:/usr/bin:/bin
# export PATH
# ==&gt; Первые две строки в оригинальном сценарии вероятно излишни.

TMPFILE=/tmp/ftp.$$
# ==&gt; Создан временный файл

SITE=`domainname`.toronto.edu
# ==&gt; &#39;domainname&#39; подобен &#39;hostname&#39;

usage=&quot;Порядок использования: $0 [-h удаленный_сервер] [-d удаленный_каталог]... [-f удаленный_файл:локальный_файл]... \
                [-c локальный_каталог] [-m шаблон_имен_файлов] [-v]&quot;
ftpflags=&quot;-i -n&quot;
verbflag=
set -f          # разрешить подстановку имен файлов (globbing) для опции -m
set x `getopt vh:d:c:m:f: $*`
if [ $? != 0 ]; then
        echo $usage
        exit 65
fi
shift
trap &#39;rm -f ${TMPFILE} ; exit&#39; 0 1 2 3 15
echo &quot;user anonymous ${USER-gnu}@${SITE} &gt; ${TMPFILE}&quot;
# ==&gt; Добавлены кавычки (рекомендуется).
echo binary &gt;&gt; ${TMPFILE}
for i in $*   # ==&gt; Разбор командной строки.
do
        case $i in
        -v) verbflag=-v; echo hash &gt;&gt; ${TMPFILE}; shift;;
        -h) remhost=$2; shift 2;;
        -d) echo cd $2 &gt;&gt; ${TMPFILE};
            if [ x${verbflag} != x ]; then
                echo pwd &gt;&gt; ${TMPFILE};
            fi;
            shift 2;;
        -c) echo lcd $2 &gt;&gt; ${TMPFILE}; shift 2;;
        -m) echo mget &quot;$2&quot; &gt;&gt; ${TMPFILE}; shift 2;;
        -f) f1=`expr &quot;$2&quot; : &quot;\([^:]*\).*&quot;`; f2=`expr &quot;$2&quot; : &quot;[^:]*:\(.*\)&quot;`;
            echo get ${f1} ${f2} &gt;&gt; ${TMPFILE}; shift 2;;
        --) shift; break;;
        esac
done
if [ $# -ne 0 ]; then
        echo $usage
        exit 65   # ==&gt; В оригинале было &quot;exit 2&quot;, изменено в соответствии со стандартами.
fi
if [ x${verbflag} != x ]; then
        ftpflags=&quot;${ftpflags} -v&quot;
fi
if [ x${remhost} = x ]; then
        remhost=prep.ai.mit.edu
        # ==&gt; Здесь можете указать свой ftp-сервер по-умолчанию.
fi
echo quit &gt;&gt; ${TMPFILE}
# ==&gt; Все команды сохранены во временном файле.

ftp ${ftpflags} ${remhost} &lt; ${TMPFILE}
# ==&gt; Теперь обработать пакетный файл.

rm -f ${TMPFILE}
# ==&gt; В заключение, удалить временный файл (можно скопировать его в системный журнал).


# ==&gt; Упражнения:
# ==&gt; ----------
# ==&gt; 1) Добавьте обработку ошибок.
# ==&gt; 2) Добавьте уведомление звуковым сигналом.
</pre>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="a14477_html_MORCOPY"></a>

        <p><strong>Пример A-15. Указание на авторские
        права</strong></p>
<pre
 class="PROGRAMLISTING">
Следующее соглащение об авторских правах относится к двум, включенным в книгу,
сценариям от Mark Moraes: &quot;behead.sh&quot; и &quot;ftpget.sh&quot;

/*
 * Copyright University of Toronto 1988, 1989.
 * Автор: Mark Moraes
 *
 * Автор дает право на использование этого программного обеспечения
 * его изменение и рапространение со следующими ограничениями:
 *
 * 1. Автор и Университет Торонто не отвечают
 *    за последствия использования этого программного обеспечения,
 *    какими ужасными бы они ни были,
 *    даже если они вызваны ошибками в нем.
 *
 * 2. Указание на происхождение программного обеспечения не должно подвергаться изменениям,
 *    явно или по оплошности. Так как некоторые пользователи обращаются к исходным текстам,
 *    они обязательно должны быть включены в документацию.
 *
 * 3. Измененная версия должна содержать явное упоминание об этом и не должна
 *    выдаваться за оригинал. Так как некоторые пользователи обращаются к исходным текстам,
 *    они обязательно должны быть включены в документацию.
 *
 * 4. Это соглашение не может удаляться и/или изменяться.
 */
</pre>
      </div>

      <p>+</p>

      <p>Antek Sawicki предоставил следующий сценарий, который
      демонстрирует операцию подстановки параметров, обсуждавшуюся в <a
       href="#x4462_html">Section 9.3</a>.</p>

      <div
       class="EXAMPLE">
        <a
         name="a14477_html_PW"></a>

        <p><strong>Пример A-16. password: Генератор случайного 8-ми
        символьного пароля</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Для старых систем может потребоваться указать  #!/bin/bash2.
#
# Генератор случайных паролей для bash 2.x
# Автор: Antek Sawicki &lt;tenox@tenox.tc&gt;,
# который великодушно позволил использовать его в данном документе.
#
# ==&gt; Комментарии, добавленные автором документа ==&gt;


MATRIX=&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;
LENGTH=&quot;8&quot;
# ==&gt; &#39;LENGTH&#39; можно увеличить, для генерации более длинных паролей.


while [ &quot;${n:=1}&quot; -le &quot;$LENGTH&quot; ]
# ==&gt; Напоминаю, что &quot;:=&quot; -- это оператор &quot;подстановки значения по-умолчанию&quot;.
# ==&gt; Таким образом, если &#39;n&#39; не инициализирована, то в нее заносится 1.
do
        PASS=&quot;$PASS${MATRIX:$(($RANDOM%${#MATRIX})):1}&quot;
        # ==&gt; Хитро, хитро....

        # ==&gt; Начнем с самых внутренних скобок...
        # ==&gt; ${#MATRIX} -- возвращает длину массива MATRIX.

        # ==&gt; $RANDOM%${#MATRIX} -- возвращает случайное число
        # ==&gt; в диапазоне 1 .. ДЛИНА_МАССИВА(MATRIX) - 1.

        # ==&gt; ${MATRIX:$(($RANDOM%${#MATRIX})):1}
        # ==&gt; возвращает символ из MATRIX, из случайной позиции (найденной выше).
        # ==&gt; См. подстановку параметров {var:pos:len} в Разделе 3.3.1
        # ==&gt; и примеры в этом разделе.

        # ==&gt; PASS=... -- добавление символа к строке PASS, полученной на предыдущих итерациях.

        # ==&gt; Чтобы детальнее проследить ход работы цикла, раскомментируйте следующую строку
        # ==&gt;             echo &quot;$PASS&quot;
        # ==&gt; Вы увидите, как на каждом проходе цикла,
        # ==&gt; к строке PASS добавляется по одному символу.

        let n+=1
        # ==&gt; Увеличить &#39;n&#39; перед началом следующей итерации.
done

echo &quot;$PASS&quot;      # ==&gt; Или перенаправьте в файл, если пожелаете.

exit 0
</pre>
      </div>

      <p>+</p>

      <p>James R. Van Zandt предоставил следующий сценарий, который
      демонстрирует применение именованных каналов, по его словам,
      <span
       class="QUOTE">&quot;на самом деле -- упражнение на применение
      кавычек и на экранирование&quot;</span>.</p>

      <div
       class="EXAMPLE">
        <a
         name="a14477_html_FIFO"></a>

        <p><strong>Пример A-17. fifo: Создание резервных копий с
        помощью именованных каналов</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# ==&gt; Автор:James R. Van Zandt
# ==&gt; используется с его разрешения.

# ==&gt; Комментарии, добавленные автором документа.


  HERE=`uname -n`    # ==&gt; hostname
  THERE=bilbo
  echo &quot;начало создания резервной копии на $THERE, за `date +%r`&quot;
  # ==&gt; `date +%r` возвращает время в 12-ти часовом формате, т.е. &quot;08:08:34 PM&quot;.

  # убедиться в том, что /pipe -- это действительно канал, а не простой файл
  rm -rf /pipe
  mkfifo /pipe       # ==&gt; Создание &quot;именованного канала&quot;, с именем &quot;/pipe&quot;.

  # ==&gt; &#39;su xyz&#39; -- запускает команду от имени порльзователя &quot;xyz&quot;.
  # ==&gt; &#39;ssh&#39; -- вызов secure shell (вход на удаленную систему).
  su xyz -c &quot;ssh $THERE \&quot;cat &gt;/home/xyz/backup/${HERE}-daily.tar.gz\&quot; &lt; /pipe&quot;&amp;
  cd /
  tar -czf - bin boot dev etc home info lib man root sbin share usr var &gt;/pipe
  # ==&gt; Именованный канал /pipe, используется для передачи данных между процессами:
  # ==&gt; &#39;tar/gzip&#39; пишет в /pipe, а &#39;ssh&#39; -- читает из /pipe.

  # ==&gt; В результате будет получена резервная копия всех основных каталогов.

  # ==&gt; В чем состоит преимущество именованного канала, в данной ситуации,
        # ==&gt; перед неименованным каналом &quot;|&quot; ?
  # ==&gt; Будет ли работать неименованный канал в данной ситуации?


  exit 0
</pre>
      </div>

      <p>+</p>

      <p>Stephane Chazelas предоставил следующий сценарий, который
      демонстрирует возможность генерации простых чисел без
      использования массивов.</p>

      <div
       class="EXAMPLE">
        <a
         name="a14477_html_PRIMES"></a>

        <p><strong>Пример A-18. Генерация простых чисел, с
        использованием оператора деления по модулю (остаток от
        деления)</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# primes.sh: Генерация простых чисел, без использования массивов.
# Автор: Stephane Chazelas.

#  Этот сценарий не использует класический алгоритм &quot;Решето Эратосфена&quot;,
#+ вместо него используется более понятный метод проверки каждого кандидата в простые числа
#+ путем поиска делителей, с помощью оператора нахождения остатка от деления &quot;%&quot;.


LIMIT=1000                    # Простые от 2 до 1000

Primes()
{
 (( n = $1 + 1 ))             # Перейти к следующему числу.
 shift                        # Следующий параметр в списке.
#  echo &quot;_n=$n i=$i_&quot;

 if (( n == LIMIT ))
 then echo $*
 return
 fi

 for i; do                    # &quot;i&quot; устанавливается в &quot;@&quot;, предыдущее значение $n.
#   echo &quot;-n=$n i=$i-&quot;
   (( i * i &gt; n )) &amp;&amp; break   # Оптимизация.
   (( n % i )) &amp;&amp; continue    # Отсечь составное число с помощью оператора &quot;%&quot;.
   Primes $n $@               # Рекурсивный вызов внутри цикла.
   return
   done

   Primes $n $@ $n            # Рекурсивный вызов за пределами цикла.
                              # Последовательное накопление позиционных параметров.
                              # в &quot;$@&quot; накапливаются простые числа.
}

Primes 1

exit 0

# Раскомментарьте строки 16 и 24, это поможет понять суть происходящего.

# Сравните скоростные характеристики этого сценария и сценария (ex68.sh),
# реализующего алгоритм &quot;Решето Эратосфена&quot;.

# Упражнение: Попробуйте реализовать этот сценарий без использования рекурсии.
#             Это даст некоторый выигрыш в скорости.
</pre>
      </div>

      <p>+</p>

      <p>Jordi Sanfeliu дал согласие на публикацию своего сценария
      <span
       class="emphasis"><em
       class="EMPHASIS">tree</em></span>.</p>

      <div
       class="EXAMPLE">
        <a
         name="a14477_html_TREE"></a>

        <p><strong>Пример A-19. tree: Вывод дерева
        каталогов</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/sh
#         @(#) tree      1.1  30/11/95       by Jordi Sanfeliu
#                                         email: mikaku@fiwix.org
#
#         Начальная версия:  1.0  30/11/95
#         Следующая версия:  1.1  24/02/97   Now, with symbolic links
#         Исправления     :  Ian Kjos, поддержка недоступных каталогов
#                           email: beth13@mail.utexas.edu
#
#         Tree -- средство просмотра дерева каталогов (очевидно :-) )
#

# ==&gt; Используется в данном документе с разрешения автора сценария, Jordi Sanfeliu.
# ==&gt; Комментарии, добавленные автором документа.
# ==&gt; Добавлено &quot;окавычивание&quot; аргументов.


search () {
   for dir in `echo *`
   # ==&gt; `echo *` список всех файлов в текущем каталоге, без символов перевода строки.
   # ==&gt; Тот же эффект дает     for dir in *
   # ==&gt; но &quot;dir in `echo *`&quot; не обрабатывет файлы, чьи имена содержат пробелы.
   do
      if [ -d &quot;$dir&quot; ] ; then   # ==&gt; Если это каталог (-d)...
         zz=0   # ==&gt; Временная переменная, для сохранения уровня вложенности каталога.
         while [ $zz != $deep ]    # Keep track of inner nested loop.
         do
            echo -n &quot;|   &quot;    # ==&gt; Показать символ вертикальной связи,
                              # ==&gt; с 2 пробелами и без перевода строки.
            zz=`expr $zz + 1` # ==&gt; Нарастить zz.
         done
         if [ -L &quot;$dir&quot; ] ; then   # ==&gt; Если символическая ссылка на каталог...
            echo &quot;+---$dir&quot; `ls -l $dir | sed &#39;s/^.*&#39;$dir&#39; //&#39;`
            # ==&gt; Показать горизонтальный соединитель и имя связянного каталога, но...
            # ==&gt; без указания даты/времени.
         else
            echo &quot;+---$dir&quot;      # ==&gt; Вывести горизонтальный соединитель...
                                 # ==&gt; и название каталога.
            if cd &quot;$dir&quot; ; then  # ==&gt; Если можно войти в каталог...
               deep=`expr $deep + 1`   # ==&gt; Нарастить уровень вложенности.
               search     # рекурсия ;-)
               numdirs=`expr $numdirs + 1`   # ==&gt; Нарастить счетчик каталогов.
            fi
         fi
      fi
   done
   cd ..   # ==&gt; Подняться на один уровень вверх.
   if [ &quot;$deep&quot; ] ; then  # ==&gt; Если depth = 0 (возвращает TRUE)...
      swfi=1              # ==&gt; выставить признак окончания поиска.
   fi
   deep=`expr $deep - 1`  # ==&gt; Уменьшить уровень вложенности.
}

# - Main -
if [ $# = 0 ] ; then
   cd `pwd`    # ==&gt; Если аргумент командной строки отсутствует, то используется текущий каталог.
else
   cd $1       # ==&gt; иначе перейти в заданный каталог.
fi
echo &quot;Начальный каталог = `pwd`&quot;
swfi=0      # ==&gt; Признак завершения поиска.
deep=0      # ==&gt; Уровень вложенности.
numdirs=0
zz=0

while [ &quot;$swfi&quot; != 1 ]   # Пока поиск не закончен...
do
   search   # ==&gt; Вызвать функцию поиска.
done
echo &quot;Всего каталогов = $numdirs&quot;

exit 0
# ==&gt; Попробуйте разобраться в том как этот сценарий работает.
</pre>
      </div>

      <p>Noah Friedman дал разрешение на публикацию своей библиотеки
      <span
       class="emphasis"><em
       class="EMPHASIS">функций для работы со строками</em></span>,
      которая, по сути, воспроизводит некоторые библиотечные функции
      языка C.</p>

      <div
       class="EXAMPLE">
        <a
         name="a14477_html_STRING"></a>

        <p><strong>Пример A-20. Функции для работы со
        строками</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# string.bash --- эмуляция библиотеки функций string(3)
# Автор: Noah Friedman &lt;friedman@prep.ai.mit.edu&gt;
# ==&gt;     Используется с его разрешения.
# Дата создания: 1992-07-01
# Дата последней модификации: 1993-09-29
# Public domain

# Преобразование в синтаксис bash v2 выполнил Chet Ramey

# Комментарий:
# Код:

#:docstring strcat:
# Порядок использования: strcat s1 s2
#
# Strcat добавляет содержимое переменной s2 к переменной s1.
#
# Пример:
#    a=&quot;foo&quot;
#    b=&quot;bar&quot;
#    strcat a b
#    echo $a
#    =&gt; foobar
#
#:end docstring:

###;;;autoload
function strcat ()
{
    local s1_val s2_val

    s1_val=${!1}                        # косвенная ссылка
    s2_val=${!2}
    eval &quot;$1&quot;=\&#39;&quot;${s1_val}${s2_val}&quot;\&#39;
    # ==&gt; eval $1=&#39;${s1_val}${s2_val}&#39; во избежание проблем,
    # ==&gt; если одна из переменных содержит одиночную кавычку.
}

#:docstring strncat:
# Порядок использования: strncat s1 s2 $n
#
# Аналог strcat, но добавляет не более n символов из
# переменной s2. Результат выводится на stdout.
#
# Пример:
#    a=foo
#    b=barbaz
#    strncat a b 3
#    echo $a
#    =&gt; foobar
#
#:end docstring:

###;;;autoload
function strncat ()
{
    local s1=&quot;$1&quot;
    local s2=&quot;$2&quot;
    local -i n=&quot;$3&quot;
    local s1_val s2_val

    s1_val=${!s1}                       # ==&gt; косвенная ссылка
    s2_val=${!s2}

    if [ ${#s2_val} -gt ${n} ]; then
       s2_val=${s2_val:0:$n}            # ==&gt; выделение подстроки
    fi

    eval &quot;$s1&quot;=\&#39;&quot;${s1_val}${s2_val}&quot;\&#39;
    # ==&gt; eval $1=&#39;${s1_val}${s2_val}&#39; во избежание проблем,
    # ==&gt; если одна из переменных содержит одиночную кавычку.
}

#:docstring strcmp:
# Порядок использования: strcmp $s1 $s2
#
# Strcmp сравнивает две строки и возвращает число меньше, равно
# или больше нуля, в зависимости от результатов сравнения.
#:end docstring:

###;;;autoload
function strcmp ()
{
    [ &quot;$1&quot; = &quot;$2&quot; ] &amp;&amp; return 0

    [ &quot;${1}&quot; &#39;&lt;&#39; &quot;${2}&quot; ] &gt; /dev/null &amp;&amp; return -1

    return 1
}

#:docstring strncmp:
# Порядок использования: strncmp $s1 $s2 $n
#
# Подобна strcmp, но сравнивает не более n символов
#:end docstring:

###;;;autoload
function strncmp ()
{
    if [ -z &quot;${3}&quot; -o &quot;${3}&quot; -le &quot;0&quot; ]; then
       return 0
    fi

    if [ ${3} -ge ${#1} -a ${3} -ge ${#2} ]; then
       strcmp &quot;$1&quot; &quot;$2&quot;
       return $?
    else
       s1=${1:0:$3}
       s2=${2:0:$3}
       strcmp $s1 $s2
       return $?
    fi
}

#:docstring strlen:
# Порядок использования: strlen s
#
# возвращает количество символов в строке s.
#:end docstring:

###;;;autoload
function strlen ()
{
    eval echo &quot;\${#${1}}&quot;
    # ==&gt; Возвращает длину переменной,
    # ==&gt; чье имя передается как аргумент.
}

#:docstring strspn:
# Порядок использования: strspn $s1 $s2
#
# Strspn возвращает максимальную длину сегмента в строке s1,
# который полностью состоит из символов строки s2.
#:end docstring:

###;;;autoload
function strspn ()
{
    # Сброс содержимого переменной IFS позволяет обрабатывать пробелы как обычные символы.
    local IFS=
    local result=&quot;${1%%[!${2}]*}&quot;

    echo ${#result}
}

#:docstring strcspn:
# Порядок использования: strcspn $s1 $s2
#
# Strcspn возвращает максимальную длину сегмента в строке s1,
# который полностью не содержит символы из строки s2.
#:end docstring:

###;;;autoload
function strcspn ()
{
    # Сброс содержимого переменной IFS позволяет обрабатывать пробелы как обычные символы.
    local IFS=
    local result=&quot;${1%%[${2}]*}&quot;

    echo ${#result}
}

#:docstring strstr:
# Порядок использования: strstr s1 s2
#
# Strstr выводит подстроку первого вхождения строки s2
# в строке s1, или ничего не выводит, если подстрока s2 в строке s1 не найдена.
# Если s2 содержит строку нулевой длины, то strstr выводит строку s1.
#:end docstring:

###;;;autoload
function strstr ()
{
    # Если s2 -- строка нулевой длины, то вывести строку s1
    [ ${#2} -eq 0 ] &amp;&amp; { echo &quot;$1&quot; ; return 0; }

    # не выводить ничего, если s2 не найдена в s1
    case &quot;$1&quot; in
    *$2*) ;;
    *) return 1;;
    esac

    # использовать шаблон, для удаления всех несоответствий после s2 в s1
    first=${1/$2*/}

    # Затем удалить все несоответствия с начала строки
    echo &quot;${1##$first}&quot;
}

#:docstring strtok:
# Порядок использования: strtok s1 s2
#
# Strtok рассматривает строку s1, как последовательность из 0, или более,
# лексем (токенов), разделенных символами строки s2
# При первом вызове (с непустым аргументом s1)
# выводит первую лексему на stdout.
# Функция запоминает свое положение в строке s1 от вызова к вызову,
# так что последующие вызовы должны производиться с пустым первым аргументом,
# чтобы продолжить выделение лексем из строки s1.
# После вывода последней лексемы, все последующие вызовы будут выводить на stdout
# пустое значение. Строка-разделитель может изменяться от вызова к вызову.
#:end docstring:

###;;;autoload
function strtok ()
{
 :
}

#:docstring strtrunc:
# Порядок использования: strtrunc $n $s1 {$s2} {$...}
#
# Используется многими функциями, такими как strncmp, чтобы отсечь &quot;лишние&quot; символы.
# Выводит первые n символов в каждой из строк s1 s2 ... на stdout.
#:end docstring:

###;;;autoload
function strtrunc ()
{
    n=$1 ; shift
    for z; do
        echo &quot;${z:0:$n}&quot;
    done
}

# provide string

# string.bash конец библиотеки


# ========================================================================== #
# ==&gt; Все, что находится ниже, добавлено автором документа.

# ==&gt; Чтобы этот сценарий можно было использовать как &quot;библиотеку&quot;, необходимо
# ==&gt; удалить все, что находится ниже и &quot;source&quot; этот файл в вашем сценарии.

# strcat
string0=one
string1=two
echo
echo &quot;Проверка функции \&quot;strcat\&quot; :&quot;
echo &quot;Изначально \&quot;string0\&quot; = $string0&quot;
echo &quot;\&quot;string1\&quot; = $string1&quot;
strcat string0 string1
echo &quot;Теперь \&quot;string0\&quot; = $string0&quot;
echo

# strlen
echo
echo &quot;Проверка функции  \&quot;strlen\&quot; :&quot;
str=123456789
echo &quot;\&quot;str\&quot; = $str&quot;
echo -n &quot;Длина строки \&quot;str\&quot; = &quot;
strlen str
echo



# Упражнение:
# ---------
# Добавьте проверку остальных функций.


exit 0
</pre>
      </div>

      <p>Michael Zick предоставил очень сложный пример работы с
      массивами и утилитой <a
       href="#x7794_html_MD5SUMREF">md5sum</a>, используемой для
      кодирования сведений о каталоге.</p>

      <p>От переводчика:</p>

      <p>К своему стыду вынужден признаться, что перевод комментариев
      оказался мне не &quot;по зубам&quot;, поэтому оставляю этот
      сценарий без перевода.</p>

      <div
       class="EXAMPLE">
        <a
         name="a14477_html_DIRECTORYINFO"></a>

        <p><strong>Пример A-21. Directory information</strong></p>
<pre
 class="PROGRAMLISTING">
#! /bin/bash
# directory-info.sh
# Parses and lists directory information.

# NOTE: Change lines 273 and 353 per &quot;README&quot; file.

# Michael Zick is the author of this script.
# Used here with his permission.

# Controls
# If overridden by command arguments, they must be in the order:
#   Arg1: &quot;Descriptor Directory&quot;
#   Arg2: &quot;Exclude Paths&quot;
#   Arg3: &quot;Exclude Directories&quot;
#
# Environment Settings override Defaults.
# Command arguments override Environment Settings.

# Default location for content addressed file descriptors.
MD5UCFS=${1:-${MD5UCFS:-&#39;/tmpfs/ucfs&#39;}}

# Directory paths never to list or enter
declare -a \
  EXCLUDE_PATHS=${2:-${EXCLUDE_PATHS:-&#39;(/proc /dev /devfs /tmpfs)&#39;}}

# Directories never to list or enter
declare -a \
  EXCLUDE_DIRS=${3:-${EXCLUDE_DIRS:-&#39;(ucfs lost+found tmp wtmp)&#39;}}

# Files never to list or enter
declare -a \
  EXCLUDE_FILES=${3:-${EXCLUDE_FILES:-&#39;(core &quot;Name with Spaces&quot;)&#39;}}


# Here document used as a comment block.
: &lt;&lt; LSfieldsDoc
# # # # # List Filesystem Directory Information # # # # #
#
#       ListDirectory &quot;FileGlob&quot; &quot;Field-Array-Name&quot;
# or
#       ListDirectory -of &quot;FileGlob&quot; &quot;Field-Array-Filename&quot;
#       &#39;-of&#39; meaning &#39;output to filename&#39;
# # # # #

String format description based on: ls (GNU fileutils) version 4.0.36

Produces a line (or more) formatted:
inode permissions hard-links owner group ...
32736 -rw-------    1 mszick   mszick

size    day month date hh:mm:ss year path
2756608 Sun Apr 20 08:53:06 2003 /home/mszick/core

Unless it is formatted:
inode permissions hard-links owner group ...
266705 crw-rw----    1    root  uucp

major minor day month date hh:mm:ss year path
4,  68 Sun Apr 20 09:27:33 2003 /dev/ttyS4
NOTE: that pesky comma after the major number

NOTE: the &#39;path&#39; may be multiple fields:
/home/mszick/core
/proc/982/fd/0 -&gt; /dev/null
/proc/982/fd/1 -&gt; /home/mszick/.xsession-errors
/proc/982/fd/13 -&gt; /tmp/tmpfZVVOCs (deleted)
/proc/982/fd/7 -&gt; /tmp/kde-mszick/ksycoca
/proc/982/fd/8 -&gt; socket:[11586]
/proc/982/fd/9 -&gt; pipe:[11588]

If that isn&#39;t enough to keep your parser guessing,
either or both of the path components may be relative:
../Built-Shared -&gt; Built-Static
../linux-2.4.20.tar.bz2 -&gt; ../../../SRCS/linux-2.4.20.tar.bz2

The first character of the 11 (10?) character permissions field:
&#39;s&#39; Socket
&#39;d&#39; Directory
&#39;b&#39; Block device
&#39;c&#39; Character device
&#39;l&#39; Symbolic link
NOTE: Hard links not marked - test for identical inode numbers
on identical filesystems.
All information about hard linked files are shared, except
for the names and the name&#39;s location in the directory system.
NOTE: A &quot;Hard link&quot; is known as a &quot;File Alias&quot; on some systems.
&#39;-&#39; An undistingushed file

Followed by three groups of letters for: User, Group, Others
Character 1: &#39;-&#39; Not readable; &#39;r&#39; Readable
Character 2: &#39;-&#39; Not writable; &#39;w&#39; Writable
Character 3, User and Group: Combined execute and special
&#39;-&#39; Not Executable, Not Special
&#39;x&#39; Executable, Not Special
&#39;s&#39; Executable, Special
&#39;S&#39; Not Executable, Special
Character 3, Others: Combined execute and sticky (tacky?)
&#39;-&#39; Not Executable, Not Tacky
&#39;x&#39; Executable, Not Tacky
&#39;t&#39; Executable, Tacky
&#39;T&#39; Not Executable, Tacky

Followed by an access indicator
Haven&#39;t tested this one, it may be the eleventh character
or it may generate another field
&#39; &#39; No alternate access
&#39;+&#39; Alternate access
LSfieldsDoc


ListDirectory()
{
        local -a T
        local -i of=0           # Default return in variable
#       OLD_IFS=$IFS            # Using BASH default &#39; \t\n&#39;

        case &quot;$#&quot; in
        3)      case &quot;$1&quot; in
                -of)    of=1 ; shift ;;
                 * )    return 1 ;;
                esac ;;
        2)      : ;;            # Poor man&#39;s &quot;continue&quot;
        *)      return 1 ;;
        esac

        # NOTE: the (ls) command is NOT quoted (&quot;)
        T=( $(ls --inode --ignore-backups --almost-all --directory \
        --full-time --color=none --time=status --sort=none \
        --format=long $1) )

        case $of in
        # Assign T back to the array whose name was passed as $2
                0) eval $2=\( \&quot;\$\{T\[@\]\}\&quot; \) ;;
        # Write T into filename passed as $2
                1) echo &quot;${T[@]}&quot; &gt; &quot;$2&quot; ;;
        esac
        return 0
   }

# # # # # Is that string a legal number? # # # # #
#
#       IsNumber &quot;Var&quot;
# # # # # There has to be a better way, sigh...

IsNumber()
{
        local -i int
        if [ $# -eq 0 ]
        then
                return 1
        else
                (let int=$1)  2&gt;/dev/null
                return $?       # Exit status of the let thread
        fi
}

# # # # # Index Filesystem Directory Information # # # # #
#
#       IndexList &quot;Field-Array-Name&quot; &quot;Index-Array-Name&quot;
# or
#       IndexList -if Field-Array-Filename Index-Array-Name
#       IndexList -of Field-Array-Name Index-Array-Filename
#       IndexList -if -of Field-Array-Filename Index-Array-Filename
# # # # #

: &lt;&lt; IndexListDoc
Walk an array of directory fields produced by ListDirectory

Having suppressed the line breaks in an otherwise line oriented
report, build an index to the array element which starts each line.

Each line gets two index entries, the first element of each line
(inode) and the element that holds the pathname of the file.

The first index entry pair (Line-Number==0) are informational:
Index-Array-Name[0] : Number of &quot;Lines&quot; indexed
Index-Array-Name[1] : &quot;Current Line&quot; pointer into Index-Array-Name

The following index pairs (if any) hold element indexes into
the Field-Array-Name per:
Index-Array-Name[Line-Number * 2] : The &quot;inode&quot; field element.
NOTE: This distance may be either +11 or +12 elements.
Index-Array-Name[(Line-Number * 2) + 1] : The &quot;pathname&quot; element.
NOTE: This distance may be a variable number of elements.
Next line index pair for Line-Number+1.
IndexListDoc



IndexList()
{
        local -a LIST                   # Local of listname passed
        local -a -i INDEX=( 0 0 )       # Local of index to return
        local -i Lidx Lcnt
        local -i if=0 of=0              # Default to variable names

        case &quot;$#&quot; in                    # Simplistic option testing
                0) return 1 ;;
                1) return 1 ;;
                2) : ;;                 # Poor man&#39;s continue
                3) case &quot;$1&quot; in
                        -if) if=1 ;;
                        -of) of=1 ;;
                         * ) return 1 ;;
                   esac ; shift ;;
                4) if=1 ; of=1 ; shift ; shift ;;
                *) return 1
        esac

        # Make local copy of list
        case &quot;$if&quot; in
                0) eval LIST=\( \&quot;\$\{$1\[@\]\}\&quot; \) ;;
                1) LIST=( $(cat $1) ) ;;
        esac

        # Grok (grope?) the array
        Lcnt=${#LIST[@]}
        Lidx=0
        until (( Lidx &gt;= Lcnt ))
        do
        if IsNumber ${LIST[$Lidx]}
        then
                local -i inode name
                local ft
                inode=Lidx
                local m=${LIST[$Lidx+2]}        # Hard Links field
                ft=${LIST[$Lidx+1]:0:1}         # Fast-Stat
                case $ft in
                b)      ((Lidx+=12)) ;;         # Block device
                c)      ((Lidx+=12)) ;;         # Character device
                *)      ((Lidx+=11)) ;;         # Anything else
                esac
                name=Lidx
                case $ft in
                -)      ((Lidx+=1)) ;;          # The easy one
                b)      ((Lidx+=1)) ;;          # Block device
                c)      ((Lidx+=1)) ;;          # Character device
                d)      ((Lidx+=1)) ;;          # The other easy one
                l)      ((Lidx+=3)) ;;          # At LEAST two more fields
#  A little more elegance here would handle pipes,
#+ sockets, deleted files - later.
                *)      until IsNumber ${LIST[$Lidx]} || ((Lidx &gt;= Lcnt))
                        do
                                ((Lidx+=1))
                        done
                        ;;                      # Not required
                esac
                INDEX[${#INDEX[*]}]=$inode
                INDEX[${#INDEX[*]}]=$name
                INDEX[0]=${INDEX[0]}+1          # One more &quot;line&quot; found
# echo &quot;Line: ${INDEX[0]} Type: $ft Links: $m Inode: \
# ${LIST[$inode]} Name: ${LIST[$name]}&quot;

        else
                ((Lidx+=1))
        fi
        done
        case &quot;$of&quot; in
                0) eval $2=\( \&quot;\$\{INDEX\[@\]\}\&quot; \) ;;
                1) echo &quot;${INDEX[@]}&quot; &gt; &quot;$2&quot; ;;
        esac
        return 0                                # What could go wrong?
}

# # # # # Content Identify File # # # # #
#
#       DigestFile Input-Array-Name Digest-Array-Name
# or
#       DigestFile -if Input-FileName Digest-Array-Name
# # # # #

# Here document used as a comment block.
: &lt;&lt;DigestFilesDoc

The key (no pun intended) to a Unified Content File System (UCFS)
is to distinguish the files in the system based on their content.
Distinguishing files by their name is just, so, 20th Century.

The content is distinguished by computing a checksum of that content.
This version uses the md5sum program to generate a 128 bit checksum
representative of the file&#39;s contents.
There is a chance that two files having different content might
generate the same checksum using md5sum (or any checksum).  Should
that become a problem, then the use of md5sum can be replace by a
cyrptographic signature.  But until then...

The md5sum program is documented as outputting three fields (and it
does), but when read it appears as two fields (array elements).  This
is caused by the lack of whitespace between the second and third field.
So this function gropes the md5sum output and returns:
        [0]     32 character checksum in hexidecimal (UCFS filename)
        [1]     Single character: &#39; &#39; text file, &#39;*&#39; binary file
        [2]     Filesystem (20th Century Style) name
        Note: That name may be the character &#39;-&#39; indicating STDIN read.

DigestFilesDoc



DigestFile()
{
        local if=0              # Default, variable name
        local -a T1 T2

        case &quot;$#&quot; in
        3)      case &quot;$1&quot; in
                -if)    if=1 ; shift ;;
                 * )    return 1 ;;
                esac ;;
        2)      : ;;            # Poor man&#39;s &quot;continue&quot;
        *)      return 1 ;;
        esac

        case $if in
        0) eval T1=\( \&quot;\$\{$1\[@\]\}\&quot; \)
           T2=( $(echo ${T1[@]} | md5sum -) )
           ;;
        1) T2=( $(md5sum $1) )
           ;;
        esac

        case ${#T2[@]} in
        0) return 1 ;;
        1) return 1 ;;
        2) case ${T2[1]:0:1} in         # SanScrit-2.0.5
           \*) T2[${#T2[@]}]=${T2[1]:1}
               T2[1]=\*
               ;;
            *) T2[${#T2[@]}]=${T2[1]}
               T2[1]=&quot; &quot;
               ;;
           esac
           ;;
        3) : ;; # Assume it worked
        *) return 1 ;;
        esac

        local -i len=${#T2[0]}
        if [ $len -ne 32 ] ; then return 1 ; fi
        eval $2=\( \&quot;\$\{T2\[@\]\}\&quot; \)
}

# # # # # Locate File # # # # #
#
#       LocateFile [-l] FileName Location-Array-Name
# or
#       LocateFile [-l] -of FileName Location-Array-FileName
# # # # #

# A file location is Filesystem-id and inode-number

# Here document used as a comment block.
: &lt;&lt;StatFieldsDoc
        Based on stat, version 2.2
        stat -t and stat -lt fields
        [0]     name
        [1]     Total size
                File - number of bytes
                Symbolic link - string length of pathname
        [2]     Number of (512 byte) blocks allocated
        [3]     File type and Access rights (hex)
        [4]     User ID of owner
        [5]     Group ID of owner
        [6]     Device number
        [7]     Inode number
        [8]     Number of hard links
        [9]     Device type (if inode device) Major
        [10]    Device type (if inode device) Minor
        [11]    Time of last access
                May be disabled in &#39;mount&#39; with noatime
                atime of files changed by exec, read, pipe, utime, mknod (mmap?)
                atime of directories changed by addition/deletion of files
        [12]    Time of last modification
                mtime of files changed by write, truncate, utime, mknod
                mtime of directories changed by addtition/deletion of files
        [13]    Time of last change
                ctime reflects time of changed inode information (owner, group
                permissions, link count
-*-*- Per:
        Return code: 0
        Size of array: 14
        Contents of array
        Element 0: /home/mszick
        Element 1: 4096
        Element 2: 8
        Element 3: 41e8
        Element 4: 500
        Element 5: 500
        Element 6: 303
        Element 7: 32385
        Element 8: 22
        Element 9: 0
        Element 10: 0
        Element 11: 1051221030
        Element 12: 1051214068
        Element 13: 1051214068

        For a link in the form of linkname -&gt; realname
        stat -t  linkname returns the linkname (link) information
        stat -lt linkname returns the realname information

        stat -tf and stat -ltf fields
        [0]     name
        [1]     ID-0?           # Maybe someday, but Linux stat structure
        [2]     ID-0?           # does not have either LABEL nor UUID
                                # fields, currently information must come
                                # from file-system specific utilities
        These will be munged into:
        [1]     UUID if possible
        [2]     Volume Label if possible
        Note: &#39;mount -l&#39; does return the label and could return the UUID

        [3]     Maximum length of filenames
        [4]     Filesystem type
        [5]     Total blocks in the filesystem
        [6]     Free blocks
        [7]     Free blocks for non-root user(s)
        [8]     Block size of the filesystem
        [9]     Total inodes
        [10]    Free inodes

-*-*- Per:
        Return code: 0
        Size of array: 11
        Contents of array
        Element 0: /home/mszick
        Element 1: 0
        Element 2: 0
        Element 3: 255
        Element 4: ef53
        Element 5: 2581445
        Element 6: 2277180
        Element 7: 2146050
        Element 8: 4096
        Element 9: 1311552
        Element 10: 1276425

StatFieldsDoc


#       LocateFile [-l] FileName Location-Array-Name
#       LocateFile [-l] -of FileName Location-Array-FileName

LocateFile()
{
        local -a LOC LOC1 LOC2
        local lk=&quot;&quot; of=0

        case &quot;$#&quot; in
        0) return 1 ;;
        1) return 1 ;;
        2) : ;;
        *) while (( &quot;$#&quot; &gt; 2 ))
           do
              case &quot;$1&quot; in
               -l) lk=-1 ;;
              -of) of=1 ;;
                *) return 1 ;;
              esac
           shift
           done ;;
        esac

# More Sanscrit-2.0.5
      # LOC1=( $(stat -t $lk $1) )
      # LOC2=( $(stat -tf $lk $1) )
      # Uncomment above two lines if system has &quot;stat&quot; command installed.
        LOC=( ${LOC1[@]:0:1} ${LOC1[@]:3:11}
              ${LOC2[@]:1:2} ${LOC2[@]:4:1} )

        case &quot;$of&quot; in
                0) eval $2=\( \&quot;\$\{LOC\[@\]\}\&quot; \) ;;
                1) echo &quot;${LOC[@]}&quot; &gt; &quot;$2&quot; ;;
        esac
        return 0
# Which yields (if you are lucky, and have &quot;stat&quot; installed)
# -*-*- Location Discriptor -*-*-
#       Return code: 0
#       Size of array: 15
#       Contents of array
#       Element 0: /home/mszick         20th Century name
#       Element 1: 41e8                 Type and Permissions
#       Element 2: 500                  User
#       Element 3: 500                  Group
#       Element 4: 303                  Device
#       Element 5: 32385                inode
#       Element 6: 22                   Link count
#       Element 7: 0                    Device Major
#       Element 8: 0                    Device Minor
#       Element 9: 1051224608           Last Access
#       Element 10: 1051214068          Last Modify
#       Element 11: 1051214068          Last Status
#       Element 12: 0                   UUID (to be)
#       Element 13: 0                   Volume Label (to be)
#       Element 14: ef53                Filesystem type
}



# And then there was some test code

ListArray() # ListArray Name
{
        local -a Ta

        eval Ta=\( \&quot;\$\{$1\[@\]\}\&quot; \)
        echo
        echo &quot;-*-*- List of Array -*-*-&quot;
        echo &quot;Size of array $1: ${#Ta[*]}&quot;
        echo &quot;Contents of array $1:&quot;
        for (( i=0 ; i&lt;${#Ta[*]} ; i++ ))
        do
            echo -e &quot;\tElement $i: ${Ta[$i]}&quot;
        done
        return 0
}

declare -a CUR_DIR
# For small arrays
ListDirectory &quot;${PWD}&quot; CUR_DIR
ListArray CUR_DIR

declare -a DIR_DIG
DigestFile CUR_DIR DIR_DIG
echo &quot;The new \&quot;name\&quot; (checksum) for ${CUR_DIR[9]} is ${DIR_DIG[0]}&quot;

declare -a DIR_ENT
# BIG_DIR # For really big arrays - use a temporary file in ramdisk
# BIG-DIR # ListDirectory -of &quot;${CUR_DIR[11]}/*&quot; &quot;/tmpfs/junk2&quot;
ListDirectory &quot;${CUR_DIR[11]}/*&quot; DIR_ENT

declare -a DIR_IDX
# BIG-DIR # IndexList -if &quot;/tmpfs/junk2&quot; DIR_IDX
IndexList DIR_ENT DIR_IDX

declare -a IDX_DIG
# BIG-DIR # DIR_ENT=( $(cat /tmpfs/junk2) )
# BIG-DIR # DigestFile -if /tmpfs/junk2 IDX_DIG
DigestFile DIR_ENT IDX_DIG
# Small (should) be able to parallize IndexList &amp; DigestFile
# Large (should) be able to parallize IndexList &amp; DigestFile &amp; the assignment
echo &quot;The \&quot;name\&quot; (checksum) for the contents of ${PWD} is ${IDX_DIG[0]}&quot;

declare -a FILE_LOC
LocateFile ${PWD} FILE_LOC
ListArray FILE_LOC

exit 0
</pre>
      </div>

      <p>Stephane Chazelas демонстрирует возможность объектно
      ориентированного подхода к программированию в Bash-сценариях.</p>

      <div
       class="EXAMPLE">
        <a
         name="a14477_html_OBJORIENTED"></a>

        <p><strong>Пример A-22. Объектно ориентированная база
        данных</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# obj-oriented.sh: Объектно ориентрованный подход к программированию в сценариях.
# Автор: Stephane Chazelas.


person.new()        # Очень похоже на объявление класса в C++.
{
  local obj_name=$1 name=$2 firstname=$3 birthdate=$4

  eval &quot;$obj_name.set_name() {
          eval \&quot;$obj_name.get_name() {
                   echo \$1
                 }\&quot;
        }&quot;

  eval &quot;$obj_name.set_firstname() {
          eval \&quot;$obj_name.get_firstname() {
                   echo \$1
                 }\&quot;
        }&quot;

  eval &quot;$obj_name.set_birthdate() {
          eval \&quot;$obj_name.get_birthdate() {
            echo \$1
          }\&quot;
          eval \&quot;$obj_name.show_birthdate() {
            echo \$(date -d \&quot;1/1/1970 0:0:\$1 GMT\&quot;)
          }\&quot;
          eval \&quot;$obj_name.get_age() {
            echo \$(( (\$(date +%s) - \$1) / 3600 / 24 / 365 ))
          }\&quot;
        }&quot;

  $obj_name.set_name $name
  $obj_name.set_firstname $firstname
  $obj_name.set_birthdate $birthdate
}

echo

person.new self Bozeman Bozo 101272413
# Создается экземпляр класса &quot;person.new&quot; (фактически -- вызов функции с аргументами).

self.get_firstname       #   Bozo
self.get_name            #   Bozeman
self.get_age             #   28
self.get_birthdate       #   101272413
self.show_birthdate      #   Sat Mar 17 20:13:33 MST 1973

echo

# typeset -f
# чтобы просмотреть перечень созданных функций.

exit 0
</pre>
      </div>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#b14059_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#a14586_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Литература</td>

          <td
           width="34%"
           align="center"
           valign="top"> </td>

          <td
           width="33%"
           align="right"
           valign="top">Маленький учебник по Sed и Awk</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="a14586_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#a14477_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x14802_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="APPENDIX">
      <h1><a
       name="a14586_html_SEDAWK"></a>Приложение B. Маленький учебник по Sed и
      Awk</h1>

      <p><a
       name="a14586_html_SEDREF"></a></p>

      <p>В этом приложении содержится очень краткое описание приемов
      работы с утилитами обработки текста <strong
       class="COMMAND">sed</strong> и <strong
       class="COMMAND">awk</strong>. Здесь будут рассмотрены лишь
      несколько базовых команд, которых, в принципе, будет достаточно,
      чтобы научиться понимать простейшие конструкции sed и awk внутри
      сценариев на языке командной оболочки.</p>

      <p><strong
       class="COMMAND">sed</strong>: неинтерактивный редактор текстовых
      файлов</p>

      <p><strong
       class="COMMAND">awk</strong>: язык обработки шаблонов с
      C-подобным синтаксисом</p>

      <p>При всех своих различиях, эти две утилиты обладают похожим
      синтаксисом, они обе умеют работать с <a
       href="#c11895_html_REGEXREF">регулярными выражениями</a>, обе,
      по-умолчанию, читают данные с устройства <tt
       class="FILENAME">stdin</tt> и обе выводят результат обработки на
      устройство <tt
       class="FILENAME">stdout</tt>. Обе являются утилитами
      UNIX-систем, и прекрасно могут взаимодействовать между собой.
      Вывод от одной может быть перенаправлен, по конвейеру, на вход
      другой. Их комбинирование придает сценариям, на языке командной
      оболочки, мощь и гибкость языка Perl.</p>

      <div
       class="NOTE">
        <table
         class="NOTE"
         width="100%"
         border="0">
          <tr>
            <td
             width="25"
             align="center"
             valign="top"><img
             src="misc/abs-book/images/note.gif"
             hspace="5"
             alt="Note"></td>

            <td
             align="left"
             valign="top">
              <p>Одно важное отличие состоит в том, что в случае с sed,
              сценарий легко может передавать дополнительные аргументы
              этой утилите, в то время, как в случае с awk (см. <a
               href="#x13541_html_COLTOTALER">Пример 33-3</a> и <a
               href="#x4788_html_COLTOTALER2">Пример 9-22</a>), это
              более сложная задача .</p>
            </td>
          </tr>
        </table>
      </div>

      <div
       class="SECT1">
        <h1
         class="SECT1"><a
         name="a14586_html_AEN14605"></a>B.1. Sed</h1>

        <p>Sed -- это неинтерактивный строчный редактор. Он принимает
        текст либо с устройства <tt
         class="FILENAME">stdin</tt>, либо из текстового файла,
        выполняет некоторые операции над строками и затем выводит
        результат на устройство <tt
         class="FILENAME">stdout</tt> или в файл. Как правило, в
        сценариях, sed используется в конвейерной обработке данных,
        совместно с другими командами и утилитами.</p>

        <p>Sed определяет, по заданному <span
         class="emphasis"><em
         class="EMPHASIS">адресному пространству</em></span>, над
        какими строками следует выполнить операции. <a
         name="AEN14612"
         href="#a14586_html_FTN_AEN14612"><span
         class="footnote">[1]</span></a> Адресное пространство строк
        задается либо их порядковыми номерами, либо шаблоном. Например,
        команда <tt
         class="REPLACEABLE"><em>3d</em></tt> заставит sed удалить
        третью строку, а команда <tt
         class="REPLACEABLE"><em>/windows/d</em></tt> означает, что все
        строки, содержащие <span
         class="QUOTE">&quot;windows&quot;</span>, должны быть
        удалены.</p>

        <p>Из всего разнообразия операций, мы остановимся на трех,
        используемых наиболее часто. Это <strong
         class="COMMAND">p</strong> -- печать (на <tt
         class="FILENAME">stdout</tt>), <strong
         class="COMMAND">d</strong> -- удаление и <strong
         class="COMMAND">s</strong> -- замена.</p>

        <div
         class="TABLE">
          <a
           name="a14586_html_AEN14623"></a>

          <p><strong>Таблица B-1. Основные операции sed</strong></p>

          <table
           border="1"
           class="CALSTABLE">
            <thead>
              <tr>
                <th
                 align="left"
                 valign="top">Операция</th>

                <th
                 align="left"
                 valign="top">Название</th>

                <th
                 align="left"
                 valign="top">Описание</th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">[диапазон строк]/p</tt></td>

                <td
                 align="left"
                 valign="top">print</td>

                <td
                 align="left"
                 valign="top">Печать [указанного диапазона строк]</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">[диапазон строк]/d</tt></td>

                <td
                 align="left"
                 valign="top">delete</td>

                <td
                 align="left"
                 valign="top">Удалить [указанный диапазон строк]</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">s/pattern1/pattern2/</tt></td>

                <td
                 align="left"
                 valign="top">substitute</td>

                <td
                 align="left"
                 valign="top">Заменить первое встреченное соответствие
                шаблону pattern1, в строке, на pattern2</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">[диапазон
                строк]/s/pattern1/pattern2/</tt></td>

                <td
                 align="left"
                 valign="top">substitute</td>

                <td
                 align="left"
                 valign="top">Заменить первое встреченное соответствие
                шаблону pattern1, на pattern2, в указанном <tt
                 class="REPLACEABLE"><em>диапазоне строк</em></tt></td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">[диапазон
                строк]/y/pattern1/pattern2/</tt></td>

                <td
                 align="left"
                 valign="top">transform</td>

                <td
                 align="left"
                 valign="top">заменить любые символы из шаблона
                pattern1 на соответствующие символы из pattern2, в
                указанном <tt
                 class="REPLACEABLE"><em>диапазоне строк</em></tt>
                (эквивалент команды <strong
                 class="COMMAND">tr</strong>)</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">g</tt></td>

                <td
                 align="left"
                 valign="top">global</td>

                <td
                 align="left"
                 valign="top">Операция выполняется над <span
                 class="emphasis"><em
                 class="EMPHASIS">всеми</em></span> найденными
                соответствиями внутри каждой из заданных строк</td>
              </tr>
            </tbody>
          </table>
        </div>

        <div
         class="NOTE">
          <table
           class="NOTE"
           width="100%"
           border="0">
            <tr>
              <td
               width="25"
               align="center"
               valign="top"><img
               src="misc/abs-book/images/note.gif"
               hspace="5"
               alt="Note"></td>

              <td
               align="left"
               valign="top">
                <p>Без оператора <tt
                 class="OPTION">g</tt> (<span
                 class="emphasis"><em
                 class="EMPHASIS">global</em></span>), операция замены
                будет производиться только для первого найденного
                совпадения, с заданным шаблоном, в каждой строке.</p>
              </td>
            </tr>
          </table>
        </div>

        <p>В отдельных случаях, операции sed необходимо заключать в
        кавычки.</p>
<pre
 class="PROGRAMLISTING">
sed -e &#39;/^$/d&#39; $filename
#  Ключ -e говорит о том, что далее следует строка, которая должна интерпретироваться
#+ как набор инструкций редактирования.
# (При передаче одной инструкции, ключ &quot;-e&quot; является необязательным.)
#  &quot;Строгие&quot; кавычки (&#39;&#39;) предотвращают интерпретацию символов регулярного выражения,
#+ как специальных символов, командным интерпретатором.
#
# Действия производятся над строками, содержащимися в файле $filename.
</pre>
        <br>
        <br>

        <p>В отдельных случаях, команды редактирования не работают в
        одиночных кавычках.</p>
<pre
 class="PROGRAMLISTING">
filename=file1.txt
pattern=BEGIN

  sed &quot;/^$pattern/d&quot; &quot;$filename&quot;  # Результат вполне предсказуем.
# sed &#39;/^$pattern/d&#39; &quot;$filename&quot;    дает иной результат.
#        В данном случае, в &quot;строгих&quot; кавычках (&#39; ... &#39;),
#+      не происходит подстановки значения переменной &quot;$pattern&quot;.
</pre>
        <br>
        <br>

        <div
         class="NOTE">
          <table
           class="NOTE"
           width="100%"
           border="0">
            <tr>
              <td
               width="25"
               align="center"
               valign="top"><img
               src="misc/abs-book/images/note.gif"
               hspace="5"
               alt="Note"></td>

              <td
               align="left"
               valign="top">
                <p>Sed использует ключ <tt
                 class="OPTION">-e</tt> для того, чтобы определить, что
                следующая строка является инструкцией, или набором
                инструкций, редактирования. Если инструкция является
                единственной, то использование этого ключа не является
                обязательным.</p>
              </td>
            </tr>
          </table>
        </div>
<pre
 class="PROGRAMLISTING">
sed -n &#39;/xzy/p&#39; $filename
# Ключ -n заставляет sed вывести только те строки, которые совпадают с указанным шаблоном.
# В противном случае (без ключа -n), будут выведены все строки.
# Здесь, ключ -e не является обязательным, поскольку здесь стоит единственная команда.
</pre>
        <br>
        <br>

        <div
         class="TABLE">
          <a
           name="a14586_html_AEN14681"></a>

          <p><strong>Таблица B-2. Примеры операций в sed</strong></p>

          <table
           border="1"
           class="CALSTABLE">
            <thead>
              <tr>
                <th
                 align="left"
                 valign="top">Операция</th>

                <th
                 align="left"
                 valign="top">Описание</th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">8d</tt></td>

                <td
                 align="left"
                 valign="top">Удалить 8-ю строку.</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">/^$/d</tt></td>

                <td
                 align="left"
                 valign="top">Удалить все пустые строки.</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">1,/^$/d</tt></td>

                <td
                 align="left"
                 valign="top">Удалить все строки до первой пустой
                строки, включительно.</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">/Jones/p</tt></td>

                <td
                 align="left"
                 valign="top">Вывести строки, содержащие <span
                 class="QUOTE">&quot;Jones&quot;</span> (с ключом <span
                 class="TOKEN">-n</span>).</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">s/Windows/Linux/</tt></td>

                <td
                 align="left"
                 valign="top">В каждой строке, заменить первое
                встретившееся слово <span
                 class="QUOTE">&quot;Windows&quot;</span> на слово
                <span
                 class="QUOTE">&quot;Linux&quot;</span>.</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">s/BSOD/stability/g</tt></td>

                <td
                 align="left"
                 valign="top">В каждой строке, заменить все
                встретившиеся слова <span
                 class="QUOTE">&quot;BSOD&quot;</span> на <span
                 class="QUOTE">&quot;stability&quot;</span>.</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">s/ *$//</tt></td>

                <td
                 align="left"
                 valign="top">Удалить все пробелы в конце каждой
                строки.</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">s/00*/0/g</tt></td>

                <td
                 align="left"
                 valign="top">Заменить все последовательности ведущих
                нулей одним символом &quot;0&quot;.</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">/GUI/d</tt></td>

                <td
                 align="left"
                 valign="top">Удалить все строки, содержащие <span
                 class="QUOTE">&quot;GUI&quot;</span>.</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">s/GUI//g</tt></td>

                <td
                 align="left"
                 valign="top">Удалить все найденные <span
                 class="QUOTE">&quot;GUI&quot;</span>, оставляя
                остальную часть строки без изменений.</td>
              </tr>
            </tbody>
          </table>
        </div>

        <p>Замена строки пустой строкой, эквивалентна удалению части
        строки, совпадающей с шаблоном. Остальная часть строки остается
        без изменений. Например, <tt
         class="USERINPUT"><strong>s/GUI//</strong></tt>, изменит
        следующую строку</p>
<pre
 class="SCREEN">
<tt
 class=
"USERINPUT"><strong>The most important parts of any application are its GUI and sound effects</strong></tt>
</pre>
        на 
<pre
 class="SCREEN">
<tt
 class=
"COMPUTEROUTPUT">The most important parts of any application are its  and sound effects</tt>
</pre>
        <br>
        <br>

        <p>Символ обратного слэша представляет символ перевода строки,
        как символ замены. В этом случае, замещающее выражение
        продолжается на следующей строке.</p>
<pre
 class="PROGRAMLISTING">
s/^  */\
/g
</pre>
        Эта инструкция заменит начальные пробелы в строке на символ
        перевода строки. Ожидаемый результат -- замена отступов в
        начале параграфа пустыми строками.<br>
        <br>

        <p>Указание диапазона строк, предшествующее одной, или более,
        инструкции может потребовать заключения инструкций в фигурные
        скобки, с соответствующими символами перевода строки.</p>
<pre
 class="PROGRAMLISTING">
/[0-9A-Za-z]/,/^$/{
/^$/d
}
</pre>
        В этом случае будут удалены только первые из нескольких, идущих
        подряд, пустых строк. Это может использоваться для установки
        однострочных интервалов в файле, оставляя, при этом, пустые
        строки между параграфами.<br>
        <br>

        <div
         class="TIP">
          <table
           class="TIP"
           width="100%"
           border="0">
            <tr>
              <td
               width="25"
               align="center"
               valign="top"><img
               src="misc/abs-book/images/tip.gif"
               hspace="5"
               alt="Tip"></td>

              <td
               align="left"
               valign="top">
                <p>Быстрый способ установки двойных межстрочных
                интервалов в текстовых файлах -- <tt
                 class="USERINPUT"><strong>sed G
                filename</strong></tt>.</p>
              </td>
            </tr>
          </table>
        </div>

        <p>Примеры использования sed в сценариях командной оболочки, вы
        найдете в:</p>

        <ol
         type="1">
          <li>
            <p><a
             href="#x13541_html_EX3">Пример 33-1</a></p>
          </li>

          <li>
            <p><a
             href="#x13541_html_EX4">Пример 33-2</a></p>
          </li>

          <li>
            <p><a
             href="#x6646_html_EX57">Пример 12-2</a></p>
          </li>

          <li>
            <p><a
             href="#a14477_html_RN">Пример A-3</a></p>
          </li>

          <li>
            <p><a
             href="#x7050_html_GRP">Пример 12-12</a></p>
          </li>

          <li>
            <p><a
             href="#x7050_html_COL">Пример 12-20</a></p>
          </li>

          <li>
            <p><a
             href="#a14477_html_BEHEAD">Пример A-13</a></p>
          </li>

          <li>
            <p><a
             href="#a14477_html_TREE">Пример A-19</a></p>
          </li>

          <li>
            <p><a
             href="#x7794_html_STRIPC">Пример 12-24</a></p>
          </li>

          <li>
            <p><a
             href="#c4875_html_FINDSTRING">Пример 10-9</a></p>
          </li>

          <li>
            <p><a
             href="#x9199_html_BASE">Пример 12-33</a></p>
          </li>

          <li>
            <p><a
             href="#a14477_html_MAILFORMAT">Пример A-2</a></p>
          </li>

          <li>
            <p><a
             href="#x7050_html_RND">Пример 12-10</a></p>
          </li>

          <li>
            <p><a
             href="#x7050_html_WF">Пример 12-8</a></p>
          </li>

          <li>
            <p><a
             href="#a14477_html_LIFESLOW">Пример A-11</a></p>
          </li>

          <li>
            <p><a
             href="#c11785_html_SELFDOCUMENT">Пример 17-11</a></p>
          </li>
        </ol>
        <br>
        <br>

        <p>Ссылки на дополнительные сведения о sed, вы найдете в
        разделе <a
         href="#b14059_html"><em>Литература</em></a>.</p>
      </div>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN14612"
         href="#a14586_html_AEN14612"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Если адресное пространство не указано, то, по-умолчанию, к
          обработке принимаются <span
           class="emphasis"><em
           class="EMPHASIS">все</em></span> строки.</p>
        </td>
      </tr>
    </table>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#a14477_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x14802_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Дополнительные примеры сценариев</td>

          <td
           width="34%"
           align="center"
           valign="top"> </td>

          <td
           width="33%"
           align="right"
           valign="top">Awk</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="a14876_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x14802_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#a14967_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="APPENDIX">
      <h1><a
       name="a14876_html_EXITCODES"></a>Приложение C. Коды завершения, имеющие
      предопределенный смысл</h1>

      <p><a
       name="a14876_html_EXITCODESREF"></a></p>

      <div
       class="TABLE">
        <a
         name="a14876_html_AEN14880"></a>

        <p><strong>Таблица C-1. <span
         class="QUOTE">&quot;Зарезервированные&quot;</span> коды
        завершения</strong></p>

        <table
         border="1"
         class="CALSTABLE">
          <thead>
            <tr>
              <th
               align="left"
               valign="top">Код завершения</th>

              <th
               align="left"
               valign="top">Смысл</th>

              <th
               align="left"
               valign="top">Пример</th>

              <th
               align="left"
               valign="top">Примечание</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">1</tt></td>

              <td
               align="left"
               valign="top">разнообразные ошибки</td>

              <td
               align="left"
               valign="top">let &quot;var1 = 1/0&quot;</td>

              <td
               align="left"
               valign="top">различные ошибки, такие как <span
               class="QUOTE">&quot;деление на ноль&quot;</span> и
              пр.</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">2</tt></td>

              <td
               align="left"
               valign="top">согласно документации к Bash -- неверное
              использование встроенных команд</td>

              <td
               align="left"
               valign="top"> </td>

              <td
               align="left"
               valign="top">Встречаются довольно редко, обычно код
              завершения возвращается равным 1</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">126</tt></td>

              <td
               align="left"
               valign="top">вызываемая команда не может быть
              выполнена</td>

              <td
               align="left"
               valign="top"> </td>

              <td
               align="left"
               valign="top">возникает из-за проблем с правами доступа
              или когда вызван на исполнение неисполняемый файл</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">127</tt></td>

              <td
               align="left"
               valign="top"><span
               class="QUOTE">&quot;команда не найдена&quot;</span></td>

              <td
               align="left"
               valign="top"> </td>

              <td
               align="left"
               valign="top">Проблема связана либо с переменной
              окружения <tt
               class="VARNAME">$PATH</tt>, либо с неверным написанием
              имени команды</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">128</tt></td>

              <td
               align="left"
               valign="top">неверный аргумент команды <a
               href="#c2105_html_EXITCOMMANDREF">exit</a></td>

              <td
               align="left"
               valign="top">exit 3.14159</td>

              <td
               align="left"
               valign="top">команда <strong
               class="COMMAND">exit</strong> может принимать только
              целочисленные значения, в диапазоне 0 - 255</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">128+n</tt></td>

              <td
               align="left"
               valign="top">фатальная ошибка по сигналу <span
               class="QUOTE">&quot;n&quot;</span></td>

              <td
               align="left"
               valign="top"><strong
               class="COMMAND">kill -9</strong> <tt
               class="VARNAME">$PPID</tt> сценария</td>

              <td
               align="left"
               valign="top"><tt
               class="USERINPUT"><strong>$?</strong></tt> вернет 137
              (128 + 9)</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">130</tt></td>

              <td
               align="left"
               valign="top">завершение по Control-C</td>

              <td
               align="left"
               valign="top"> </td>

              <td
               align="left"
               valign="top">Control-C -- это выход по сигналу 2, (130 =
              128 + 2, см. выше)</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">255*</tt></td>

              <td
               align="left"
               valign="top">код завершения вне допустимого
              диапазона</td>

              <td
               align="left"
               valign="top">exit -1</td>

              <td
               align="left"
               valign="top"><strong
               class="COMMAND">exit</strong> может принимать только
              целочисленные значения, в диапазоне 0 - 255</td>
            </tr>
          </tbody>
        </table>
      </div>

      <p>Согласно этой таблице, коды завершения 1 - 2, 126 - 165 и 255
      <a
       name="AEN14950"
       href="#a14876_html_FTN_AEN14950"><span
       class="footnote">[1]</span></a> имеют предопределенное значение,
      поэтому вам следует избегать употребления этих кодов для своих
      нужд. Завершение сценария с кодом возврата <strong
       class="COMMAND">exit 127</strong>, может привести в
      замешательство при поиске ошибок в сценарии (действительно ли он
      означает ошибку <span
       class="QUOTE">&quot;команда не найдена&quot;</span>? Или это
      предусмотренный программистом код завершения?). В большинстве
      случаев, программисты вставляют <strong
       class="COMMAND">exit 1</strong>, в качестве реакции на ошибку.
      Так как код завершения <span
       class="RETURNVALUE">1</span> подразумевает целый
      &quot;букет&quot; ошибок, то в данном случае трудно говорить о
      какой либо двусмысленности, хотя и об информативности --
      тоже.</p>

      <p>Не раз предпринимались попытки систематизировать коды
      завершения (см. <tt
       class="FILENAME">/usr/include/sysexits.h</tt>), но эта
      систематизация предназначена для программистов, пишущих на языках
      C и C++. Автор документа предлагает ограничить коды завершения,
      определяемые пользователем, диапазоном 64 - 113 (и, само собой
      разумеется -- 0, для обозначения успешного завершения), в
      соответствии со стандартом C/C++. Это сделало бы поиск ошибок
      более простым.</p>

      <p>Все сценарии, прилагаемые к данному документу, приведены в
      соответствие с этим стандартом, за исключением случаев, когда
      существуют отменяющие обстоятельства, например в <a
       href="#c3270_html_TMDIN">Пример 9-2</a>.</p>

      <div
       class="NOTE">
        <table
         class="NOTE"
         width="100%"
         border="0">
          <tr>
            <td
             width="25"
             align="center"
             valign="top"><img
             src="misc/abs-book/images/note.gif"
             hspace="5"
             alt="Note"></td>

            <td
             align="left"
             valign="top">
              <p>Обращение к переменной <a
               href="#c3270_html_XSTATVARREF">$?</a>, из командной
              строки, после завершения работы сценария, дает результат,
              в соответствии с таблицей, приведенной выше, но только
              для Bash или <span
               class="emphasis"><em
               class="EMPHASIS">sh</em></span>. Под управлением csh или
              <span
               class="emphasis"><em
               class="EMPHASIS">tcsh</em></span> значения могут в
              некоторых случаях отличаться.</p>
            </td>
          </tr>
        </table>
      </div>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN14950"
         href="#a14876_html_AEN14950"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Указание кода завершения за пределами установленного
          диапазона, приводит к возврату ошибочных кодов. Например,
          <strong
           class="COMMAND">exit 3809</strong> вернет код завершения,
          равный <span
           class="ERRORCODE">225</span>.</p>
        </td>
      </tr>
    </table>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x14802_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#a14967_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Awk</td>

          <td
           width="34%"
           align="center"
           valign="top"> </td>

          <td
           width="33%"
           align="right"
           valign="top">Подробное введение в операции ввода-вывода и
          перенаправление ввода-вывода</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="a14967_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#a14876_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#a15021_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="APPENDIX">
      <h1><a
       name="a14967_html_IOREDIRINTRO"></a>Приложение D. Подробное введение в
      операции ввода-вывода и перенаправление ввода-вывода</h1>

      <p><span
       class="emphasis"><em
       class="EMPHASIS">написано Stephane Chazelas и дополнено автором
      документа</em></span></p>

      <p>Практически любая команда предполагает доступность 3-х <a
       href="#c11620_html_FDREF">файловых дескрипторов</a>. Первый --
      <span
       class="emphasis"><em
       class="EMPHASIS">0</em></span> (стандвртный ввод, <tt
       class="FILENAME">stdin</tt>), доступный для чтения. И два других
      -- <span
       class="emphasis"><em
       class="EMPHASIS">1</em></span> (<tt
       class="FILENAME">stdout</tt>) и <span
       class="emphasis"><em
       class="EMPHASIS">2</em></span> (<tt
       class="FILENAME">stderr</tt>), доступные для записи.</p>

      <p>Запись, типа <tt
       class="USERINPUT"><strong>ls 2&gt;&amp;1</strong></tt>, означает
      временное перенаправление вывода, с устройства <tt
       class="FILENAME">stderr</tt> на устройство <tt
       class="FILENAME">stdout</tt>.</p>

      <p>В соответствии с соглашениями, команды принимают ввод из файла
      с дескриптором 0 (<tt
       class="FILENAME">stdin</tt>), выводят результат работы в файл с
      дескриптором 1 (<tt
       class="FILENAME">stdout</tt>), а сообщения об ошибках -- в файл
      с дескриптором 2 (<tt
       class="FILENAME">stderr</tt>). Если какой либо из этих трех
      дескрипторов окажется закрытым, то могут возникнуть определенные
      проблемы:</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>cat /etc/passwd &gt;&amp;-</strong></tt>
<tt
 class="COMPUTEROUTPUT">cat: standard output: Bad file descriptor</tt>
     
</pre>

      <p>К примеру, когда пользователь запускает <strong
       class="COMMAND">xterm</strong>, то он сначала выполняет
      процедуру инициализации, а затем, перед запуском командной
      оболочки, <strong
       class="COMMAND">xterm</strong> трижды открывает терминальные
      устройства (/dev/pts/&lt;n&gt;, или нечто подобное).</p>

      <p>После этого, командная оболочка наследует эти три дескриптора,
      и любая команда, запускаемая в этой оболочке, так же наследует
      их. Термин <a
       href="#c11620_html_IOREDIRREF">перенаправление</a> -- означает
      переназначение одного файлового дескриптора на другой (канал
      (конвейер) или что-то другое). Переназначение может быть
      выполнено локально (для отдельной команды, для группы команд, для
      подоболочки, для операторов <a
       href="#x11731_html_REDIRREF">while, if, case, for</a>...) или
      глобально (с помощью <a
       href="#c5358_html_EXECREF">exec</a>).</p>

      <p><tt
       class="USERINPUT"><strong>ls &gt; /dev/null</strong></tt> --
      означает запуск команды <strong
       class="COMMAND">ls</strong> с файловым дескриптором 1,
      присоединенным к устройству <tt
       class="FILENAME">/dev/null</tt>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>lsof -a -p $$ -d0,1,2</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">COMMAND PID     USER   FD   TYPE DEVICE SIZE NODE NAME
 bash    363 bozo        0u   CHR  136,1         3 /dev/pts/1
 bash    363 bozo        1u   CHR  136,1         3 /dev/pts/1
 bash    363 bozo        2u   CHR  136,1         3 /dev/pts/1</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>exec 2&gt; /dev/null</strong></tt>
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>lsof -a -p $$ -d0,1,2</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">COMMAND PID     USER   FD   TYPE DEVICE SIZE NODE NAME
 bash    371 bozo        0u   CHR  136,1         3 /dev/pts/1
 bash    371 bozo        1u   CHR  136,1         3 /dev/pts/1
 bash    371 bozo        2w   CHR    1,3       120 /dev/null</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>bash -c &#39;lsof -a -p $$ -d0,1,2&#39; | cat</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">COMMAND PID USER   FD   TYPE DEVICE SIZE NODE NAME
 lsof    379 root    0u   CHR  136,1         3 /dev/pts/1
 lsof    379 root    1w  FIFO    0,0      7118 pipe
 lsof    379 root    2u   CHR  136,1         3 /dev/pts/1</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>echo &quot;$(bash -c &#39;lsof -a -p $$ -d0,1,2&#39; 2&gt;&amp;1)&quot;</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">COMMAND PID USER   FD   TYPE DEVICE SIZE NODE NAME
 lsof    426 root    0u   CHR  136,1         3 /dev/pts/1
 lsof    426 root    1w  FIFO    0,0      7520 pipe
 lsof    426 root    2w  FIFO    0,0      7520 pipe</tt>
</pre>
      <br>
      <br>

      <p><tt
       class="USERINPUT"><strong>Упражнение:</strong></tt>
      Проанализируйте следующий сценарий.</p>
<pre
 class="PROGRAMLISTING">
#! /usr/bin/env bash

mkfifo /tmp/fifo1 /tmp/fifo2
while read a; do echo &quot;FIFO1: $a&quot;; done &lt; /tmp/fifo1 &amp;
exec 7&gt; /tmp/fifo1
exec 8&gt; &gt;(while read a; do echo &quot;FD8: $a, to fd7&quot;; done &gt;&amp;7)

exec 3&gt;&amp;1
(
 (
  (
   while read a; do echo &quot;FIFO2: $a&quot;; done &lt; /tmp/fifo2 | tee /dev/stderr | tee /dev/fd/4 | tee /dev/fd/5 | tee /dev/fd/6 &gt;&amp;7 &amp;
   exec 3&gt; /tmp/fifo2

   echo 1st, to stdout
   sleep 1
   echo 2nd, to stderr &gt;&amp;2
   sleep 1
   echo 3rd, to fd 3 &gt;&amp;3
   sleep 1
   echo 4th, to fd 4 &gt;&amp;4
   sleep 1
   echo 5th, to fd 5 &gt;&amp;5
   sleep 1                                                                                              
   echo 6th, through a pipe | sed &#39;s/.*/PIPE: &amp;, to fd 5/&#39; &gt;&amp;5                                          
   sleep 1                                                                                              
   echo 7th, to fd 6 &gt;&amp;6                                                                                
   sleep 1                                                                                              
   echo 8th, to fd 7 &gt;&amp;7
   sleep 1                                                                                              
   echo 9th, to fd 8 &gt;&amp;8                                                                                
                                                                                                        
  ) 4&gt;&amp;1 &gt;&amp;3 3&gt;&amp;- | while read a; do echo &quot;FD4: $a&quot;; done 1&gt;&amp;3 5&gt;&amp;- 6&gt;&amp;-                                
 ) 5&gt;&amp;1 &gt;&amp;3 | while read a; do echo &quot;FD5: $a&quot;; done 1&gt;&amp;3 6&gt;&amp;-
) 6&gt;&amp;1 &gt;&amp;3 | while read a; do echo &quot;FD6: $a&quot;; done 3&gt;&amp;-                                                 
                                                                                                        
rm -f /tmp/fifo1 /tmp/fifo2


# Выясните, куда переназначены файловые дескрипторы каждой команды и подоболочки.

exit 0
</pre>
      <br>
      <br>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#a14876_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#a15021_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Коды завершения, имеющие предопределенный
          смысл</td>

          <td
           width="34%"
           align="center"
           valign="top"> </td>

          <td
           width="33%"
           align="right"
           valign="top">Локализация</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="a15021_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#a14967_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#a15070_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="APPENDIX">
      <h1><a
       name="a15021_html_LOCALIZATION"></a>Приложение E. Локализация</h1>

      <p>Возможность локализации сценариев Bash нигде в документации не
      описана.</p>

      <p>Локализованные сценарии выводят текст на том языке, который
      используется системой, в соответствии с настройками. Пользователь
      Linux, живущий в Берлине (Германия), будет видеть сообщения на
      немецком языке, в то время как другой пользователь, проживающий в
      Берлине штата Мэриленд (США) -- на английском.</p>

      <p>Для создания локализованых сценариев можно использовать
      следующий шаблон, предусматривающий вывод всех сообщений на языке
      пользователя (сообщения об ошибках, приглашения к вводу и
      т.п.).</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# localized.sh

E_CDERROR=65

error()
{
  printf &quot;$@&quot; &gt;&amp;2
  exit $E_CDERROR
}

cd $var || error $&quot;Can&#39;t cd to %s.&quot; &quot;$var&quot;
read -p $&quot;Enter the value: &quot; var
# ...
</pre>
      <br>
      <br>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>bash -D localized.sh</strong></tt>
<tt
 class="COMPUTEROUTPUT">&quot;Can&#39;t cd to %s.&quot;
&quot;Enter the value: &quot;</tt>
</pre>
      Это список всех текстовых сообщений, которые подлежат
      локализации. (Ключ <tt
       class="OPTION">-D</tt> выводит список строк в двойных кавычках,
      которым предшествует символ <span
       class="TOKEN">$</span>, без запуска сценария на исполнение.)<br>
      <br>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>bash --dump-po-strings localized.sh</strong></tt>
<tt
 class="COMPUTEROUTPUT">#: a:6
 msgid &quot;Can&#39;t cd to %s.&quot;
 msgstr &quot;&quot;
 #: a:7
 msgid &quot;Enter the value: &quot;
 msgstr &quot;&quot;</tt>
</pre>
      Ключ <tt
       class="OPTION">--dump-po-strings</tt> в Bash напоминает ключ <tt
       class="OPTION">-D</tt>, но выводит строки в формате <span
       class="QUOTE">&quot;po&quot;</span>, с помощью утилиты <a
       href="#x7050_html_GETTEXTREF">gettext</a>. <br>
      <br>

      <p>Теперь построим файл <tt
       class="FILENAME">language.po</tt>, для каждого языка, на которые
      предполагается перевести сообщения сценария. Например:</p>

      <p>Файл ru.po сделан переводчиком, в оригинальном документе
      локализация выполнена на примере французского языка</p>

      <p>ru.po:</p>
<pre
 class="PROGRAMLISTING">
#: a:6
msgid &quot;Can&#39;t cd to %s.&quot;
msgstr &quot;Невозможно перейти в каталог %s.&quot;
#: a:7
msgid &quot;Enter the value: &quot;
msgstr &quot;Введите число: &quot;
</pre>
      <br>
      <br>

      <p>Затем запустите <strong
       class="COMMAND">msgfmt</strong>.</p>

      <p><tt
       class="USERINPUT"><strong>msgfmt -o localized.sh.mo
      ru.po</strong></tt></p>

      <p>Перепишите получившийся файл <tt
       class="FILENAME">localized.sh.mo</tt> в каталог <tt
       class="FILENAME">/usr/share/locale/ru/LC_MESSAGES</tt> и
      добавьте в начало сценария строки:</p>
<pre
 class="PROGRAMLISTING">
TEXTDOMAINDIR=/usr/share/locale
TEXTDOMAIN=localized.sh
</pre>
      <br>
      <br>

      <p>Если система корректно настроена на русскую локаль, то
      пользователь, запустивший сценарий, будет видеть сообщения на
      русском языке.</p>

      <div
       class="NOTE">
        <table
         class="NOTE"
         width="100%"
         border="0">
          <tr>
            <td
             width="25"
             align="center"
             valign="top"><img
             src="misc/abs-book/images/note.gif"
             hspace="5"
             alt="Note"></td>

            <td
             align="left"
             valign="top">
              <p>В старых версиях Bash или в других командных
              оболочках, потребуется воспользоваться услугами утилиты
              <a
               href="#x7050_html_GETTEXTREF">gettext</a>, с ключом <tt
               class="OPTION">-s</tt>. В этом случае наш сценарий будет
              выглядеть так:</p>

              <p><a
               name="a15021_html_GETTEXTEXAMPLE"></a></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# localized.sh

E_CDERROR=65

error() {
  local format=$1
  shift
  printf &quot;$(gettext -s &quot;$format&quot;)&quot; &quot;$@&quot; &gt;&amp;2
  exit $E_CDERROR
}
cd $var || error &quot;Can&#39;t cd to %s.&quot; &quot;$var&quot;
read -p &quot;$(gettext -s &quot;Enter the value: &quot;)&quot; var
# ...
</pre>
              <br>
              <br>
            </td>
          </tr>
        </table>
      </div>

      <p>А переменные <tt
       class="VARNAME">TEXTDOMAIN</tt> и <tt
       class="VARNAME">TEXTDOMAINDIR</tt>, необходимо будет
      экспортировать в окружение.</p>

      <p>---</p>

      <p>Автор этого приложения: Stephane Chazelas.</p>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#a14967_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#a15070_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Подробное введение в операции ввода-вывода и
          перенаправление ввода-вывода</td>

          <td
           width="34%"
           align="center"
           valign="top"> </td>

          <td
           width="33%"
           align="right"
           valign="top">История команд</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="a15070_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#a15021_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#a15124_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="APPENDIX">
      <h1><a
       name="a15070_html_HISTCOMMANDS"></a>Приложение F. История команд</h1>

      <p>Командная оболочка Bash предоставляет в распоряжение
      пользователя инструментарий командной строки, позволяющий
      управлять <span
       class="emphasis"><em
       class="EMPHASIS">историей команд</em></span>. История команд --
      это, прежде всего, очень удобный инструмент, сокращающий ручной
      ввод.</p>

      <p>История команд Bash:</p>

      <ol
       type="1">
        <li>
          <p><strong
           class="COMMAND">history</strong></p>
        </li>

        <li>
          <p><strong
           class="COMMAND">fc</strong></p>
        </li>
      </ol>
      <br>
      <br>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>history</strong></tt>
<tt
 class="COMPUTEROUTPUT">1  mount /mnt/cdrom
2  cd /mnt/cdrom
3  ls
     ...</tt>
             
</pre>
      <br>
      <br>

      <p>Внутренние переменные Bash, связанные с историей команд:</p>

      <ol
       type="1">
        <li>
          <p>$HISTCMD</p>
        </li>

        <li>
          <p>$HISTCONTROL</p>
        </li>

        <li>
          <p>$HISTIGNORE</p>
        </li>

        <li>
          <p>$HISTFILE</p>
        </li>

        <li>
          <p>$HISTFILESIZE</p>
        </li>

        <li>
          <p>$HISTSIZE</p>
        </li>

        <li>
          <p>!!</p>
        </li>

        <li>
          <p>!$</p>
        </li>

        <li>
          <p>!#</p>
        </li>

        <li>
          <p>!N</p>
        </li>

        <li>
          <p>!-N</p>
        </li>

        <li>
          <p>!STRING</p>
        </li>

        <li>
          <p>!?STRING?</p>
        </li>

        <li>
          <p>^STRING^string^</p>
        </li>
      </ol>
      <br>
      <br>

      <p>К сожалению, инструменты истории команд, в Bash, совершенно
      бесполезны в сценариях.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# history.sh
# Попытка воспользоваться &#39;историей&#39; команд в сценарии.

history

# На экран ничего не выводится.
# История команд не работает в сценариях.
</pre>
      <br>
      <br>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>./history.sh</strong></tt>
<tt
 class="COMPUTEROUTPUT">(ничего не выводится)</tt>
             
</pre>
      <br>
      <br>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#a15021_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#a15124_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Локализация</td>

          <td
           width="34%"
           align="center"
           valign="top"> </td>

          <td
           width="33%"
           align="right"
           valign="top">Пример файла <tt
           class="FILENAME">.bashrc</tt></td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="a15124_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#a15070_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#a15138_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="APPENDIX">
      <h1><a
       name="a15124_html_SAMPLE-BASHRC"></a>Приложение G. Пример файла <tt
       class="FILENAME">.bashrc</tt></h1>

      <p>Файл <tt
       class="FILENAME">~/.bashrc</tt> определяет поведение командной
      оболочки. Внимательное изучение этого примера поможет вам
      значительно продвинуться в понимании Bash.</p>

      <p><a
       href="mailto:emmanuel.rouat@wanadoo.fr"
       target="_top">Emmanuel Rouat</a> представил следующий, очень
      сложный, файл <tt
       class="FILENAME">.bashrc</tt>, написанный для операционной
      системы Linux. Предложения и замечания приветствуются.</p>

      <p>Внимательно изучите этот файл. Отдельные участки этого файла
      вы свободно можете использовать в своем собственном <tt
       class="FILENAME">.bashrc</tt> или, даже в своих сценариях!</p>

      <div
       class="EXAMPLE">
        <a
         name="a15124_html_BASHRC"></a>

        <p><strong>Пример G-1. Пример файла <tt
         class="FILENAME">.bashrc</tt></strong></p>
<pre
 class="PROGRAMLISTING">
#===============================================================
#
# ЛИЧНЫЙ ФАЙЛ $HOME/.bashrc для bash-2.05a (или выше)
#
# Время последней модификации: Втр Апр 15 20:32:34 CEST 2003
#
# Этот файл содержит настройки интерактивной командной оболочки.
# Здесь размещены определения псевдонимов, функций
# и других элементов Bash, таких как prompt (приглашение к вводу).
#
# Изначально, этот файл был создан в операционной системе Solaris,
# но позднее был переделан под Redhat
# --&gt; Модифицирован под Linux.
# Большая часть кода, который находится здесь, была взята из
# Usenet (или Интернет).
# Этот файл содержит слишком много определений -- помните, это всего лишь пример.
#
#
#===============================================================

# --&gt; Комментарии, добавленные автором HOWTO.
# --&gt; И дополнены автором сценария Emmanuel Rouat :-)

#-----------------------------------
# Глобальные определения
#-----------------------------------

if [ -f /etc/bashrc ]; then
        . /etc/bashrc   # --&gt; Прочитать настройки из /etc/bashrc, если таковой имеется.
fi

#-------------------------------------------------------------
# Настройка переменной $DISPLAY (если еще не установлена)
# Это срабатывает под linux - в вашем случае все может быть по другому....
# Проблема в том, что различные типы терминалов
# дают разные ответы на запрос &#39;who am i&#39;......
# я не нашел &#39;универсального&#39; метода
#-------------------------------------------------------------

function get_xserver ()
{
    case $TERM in
        xterm )
            XSERVER=$(who am i | awk &#39;{print $NF}&#39; | tr -d &#39;)&#39;&#39;(&#39; )
            XSERVER=${XSERVER%%:*}
            ;;
        aterm | rxvt)
        # добавьте здесь свой код.....
            ;;
    esac
}

if [ -z ${DISPLAY:=&quot;&quot;} ]; then
    get_xserver
    if [[ -z ${XSERVER}  || ${XSERVER} == $(hostname) || ${XSERVER} == &quot;unix&quot; ]]; then
        DISPLAY=&quot;:0.0&quot;          # для локального хоста
    else
        DISPLAY=${XSERVER}:0.0  # для удаленного хоста
    fi
fi

export DISPLAY

#---------------
# Некоторые настройки
#---------------

ulimit -S -c 0          # Запрет на создание файлов coredump
set -o notify
set -o noclobber
set -o ignoreeof
set -o nounset
#set -o xtrace          # полезно для отладки

# Разрешающие настройки:
shopt -s cdspell
shopt -s cdable_vars
shopt -s checkhash
shopt -s checkwinsize
shopt -s mailwarn
shopt -s sourcepath
shopt -s no_empty_cmd_completion  # только для bash&gt;=2.04
shopt -s cmdhist
shopt -s histappend histreedit histverify
shopt -s extglob

# Запрещающие настройки:
shopt -u mailwarn
unset MAILCHECK         # Я не желаю, чтобы командная оболочка сообщала мне о прибытии почты


export TIMEFORMAT=$&#39;\nreal %3R\tuser %3U\tsys %3S\tpcpu %P\n&#39;
export HISTIGNORE=&quot;&amp;:bg:fg:ll:h&quot;
export HOSTFILE=$HOME/.hosts    # Поместить список удаленных хостов в файл ~/.hosts



#-----------------------
# Greeting, motd etc...
#-----------------------

# Для начала определить некоторые цвета:
red=&#39;\e[0;31m&#39;
RED=&#39;\e[1;31m&#39;
blue=&#39;\e[0;34m&#39;
BLUE=&#39;\e[1;34m&#39;
cyan=&#39;\e[0;36m&#39;
CYAN=&#39;\e[1;36m&#39;
NC=&#39;\e[0m&#39;              # No Color (нет цвета)
# --&gt; Прекрасно. Имеет тот же эффект, что и &quot;ansi.sys&quot; в DOS.

# Лучше выглядит на черном фоне.....
echo -e &quot;${CYAN}This is BASH ${RED}${BASH_VERSION%.*}${CYAN} - DISPLAY on ${RED}$DISPLAY${NC}\n&quot;
date
if [ -x /usr/games/fortune ]; then
    /usr/games/fortune -s     # сделает наш день более интересным.... :-)
fi

function _exit()        # функция, запускающаяся при выходе из оболочки
{
    echo -e &quot;${RED}Аста ла виста, бэби ${NC}&quot;
}
trap _exit EXIT

#---------------
# Prompt
#---------------

if [[ &quot;${DISPLAY#$HOST}&quot; != &quot;:0.0&quot; &amp;&amp;  &quot;${DISPLAY}&quot; != &quot;:0&quot; ]]; then
    HILIT=${red}   # на удаленной системе: prompt будет частично красным
else
    HILIT=${cyan}  # на локальной системе: prompt будет частично циановым
fi

#  --&gt; Замените \W на \w в функциях ниже
#+ --&gt; чтобы видеть в оболочке полный путь к текущему каталогу.

function fastprompt()
{
    unset PROMPT_COMMAND
    case $TERM in
        *term | rxvt )
            PS1=&quot;${HILIT}[\h]$NC \W &gt; \[\033]0;\${TERM} [\u@\h] \w\007\]&quot; ;;
        linux )
            PS1=&quot;${HILIT}[\h]$NC \W &gt; &quot; ;;
        *)
            PS1=&quot;[\h] \W &gt; &quot; ;;
    esac
}

function powerprompt()
{
    _powerprompt()
    {
        LOAD=$(uptime|sed -e &quot;s/.*: \([^,]*\).*/\1/&quot; -e &quot;s/ //g&quot;)
    }

    PROMPT_COMMAND=_powerprompt
    case $TERM in
        *term | rxvt  )
            PS1=&quot;${HILIT}[\A \$LOAD]$NC\n[\h \#] \W &gt; \[\033]0;\${TERM} [\u@\h] \w\007\]&quot; ;;
        linux )
            PS1=&quot;${HILIT}[\A - \$LOAD]$NC\n[\h \#] \w &gt; &quot; ;;
        * )
            PS1=&quot;[\A - \$LOAD]\n[\h \#] \w &gt; &quot; ;;
    esac
}

powerprompt     # это prompt по-умолчанию - может работать довольно медленно
                # Если это так, то используйте fastprompt....

#===============================================================
#
# ПСЕВДОНИМЫ И ФУНКЦИИ
#
# Возможно некоторые из функций, приведенных здесь, окажутся для вас слишком большими,
# но на моей рабочей станции установлено 512Mb ОЗУ, так что.....
# Если пожелаете уменьшить размер этого файла, то можете оформить эти функции
# в виде отдельных сценариев.
#
# Большинство функций были взяты, почти без переделки, из примеров
# к bash-2.04.
#
#===============================================================

#-------------------
# Псевдонимы
#-------------------

alias rm=&#39;rm -i&#39;
alias cp=&#39;cp -i&#39;
alias mv=&#39;mv -i&#39;
# -&gt; Предотвращает случайное удаление файлов.
alias mkdir=&#39;mkdir -p&#39;

alias h=&#39;history&#39;
alias j=&#39;jobs -l&#39;
alias r=&#39;rlogin&#39;
alias which=&#39;type -all&#39;
alias ..=&#39;cd ..&#39;
alias path=&#39;echo -e ${PATH//:/\\n}&#39;
alias print=&#39;/usr/bin/lp -o nobanner -d $LPDEST&#39;   # Предполагается, что LPDEST определен
alias pjet=&#39;enscript -h -G -fCourier9 -d $LPDEST&#39;  # Печать через enscript
alias background=&#39;xv -root -quit -max -rmode 5&#39;    # Положить картинку в качестве фона
alias du=&#39;du -kh&#39;
alias df=&#39;df -kTh&#39;

# Различные варианты &#39;ls&#39; (предполагается, что установлена GNU-версия ls)
alias la=&#39;ls -Al&#39;               # показать скрытые файлы
alias ls=&#39;ls -hF --color&#39;       # выделить различные типы файлов цветом
alias lx=&#39;ls -lXB&#39;              # сортировка по расширению
alias lk=&#39;ls -lSr&#39;              # сортировка по размеру
alias lc=&#39;ls -lcr&#39;              # сортировка по времени изменения
alias lu=&#39;ls -lur&#39;              # сортировка по времени последнего обращения
alias lr=&#39;ls -lR&#39;               # рекурсивный обход подкаталогов
alias lt=&#39;ls -ltr&#39;              # сортировка по дате
alias lm=&#39;ls -al |more&#39;         # вывод через &#39;more&#39;
alias tree=&#39;tree -Csu&#39;          # альтернатива &#39;ls&#39;

# подготовка &#39;less&#39;
alias more=&#39;less&#39;
export PAGER=less
export LESSCHARSET=&#39;latin1&#39;
export LESSOPEN=&#39;|/usr/bin/lesspipe.sh %s 2&gt;&amp;-&#39; # если существует lesspipe.sh
export LESS=&#39;-i -N -w  -z-4 -g -e -M -X -F -R -P%t?f%f \
:stdin .?pb%pb\%:?lbLine %lb:?bbByte %bb:-...&#39;

# проверка правописания - настоятельно рекомендую :-)
alias xs=&#39;cd&#39;
alias vf=&#39;cd&#39;
alias moer=&#39;more&#39;
alias moew=&#39;more&#39;
alias kk=&#39;ll&#39;

#----------------
# добавим немножко &quot;приятностей&quot;
#----------------

function xtitle ()
{
    case &quot;$TERM&quot; in
        *term | rxvt)
            echo -n -e &quot;\033]0;$*\007&quot; ;;
        *)
            ;;
    esac
}

# псевдонимы...
alias top=&#39;xtitle Processes on $HOST &amp;&amp; top&#39;
alias make=&#39;xtitle Making $(basename $PWD) ; make&#39;
alias ncftp=&quot;xtitle ncFTP ; ncftp&quot;

# .. и функции
function man ()
{
    for i ; do
        xtitle The $(basename $1|tr -d .[:digit:]) manual
        command man -F -a &quot;$i&quot;
    done
}

function ll(){ ls -l &quot;$@&quot;| egrep &quot;^d&quot; ; ls -lXB &quot;$@&quot; 2&gt;&amp;-| egrep -v &quot;^d|total &quot;; }
function te()  # &quot;обертка&quot; вокруг xemacs/gnuserv
{
    if [ &quot;$(gnuclient -batch -eval t 2&gt;&amp;-)&quot; == &quot;t&quot; ]; then
        gnuclient -q &quot;$@&quot;;
    else
        ( xemacs &quot;$@&quot; &amp;);
    fi
}

#-----------------------------------
# Функции для работы с файлами и строками:
#-----------------------------------

# Поиск файла по шаблону:
function ff() { find . -type f -iname &#39;*&#39;$*&#39;*&#39; -ls ; }
# Поиск файла по шаблону в $1 и запуск команды в $2 с ним:
function fe() { find . -type f -iname &#39;*&#39;$1&#39;*&#39; -exec &quot;${2:-file}&quot; {} \;  ; }
# поиск строки по файлам:
function fstr()
{
    OPTIND=1
    local case=&quot;&quot;
    local usage=&quot;fstr: поиск строки в файлах.
Порядок использования: fstr [-i] \&quot;шаблон\&quot; [\&quot;шаблон_имени_файла\&quot;] &quot;
    while getopts :it opt
    do
        case &quot;$opt&quot; in
        i) case=&quot;-i &quot; ;;
        *) echo &quot;$usage&quot;; return;;
        esac
    done
    shift $(( $OPTIND - 1 ))
    if [ &quot;$#&quot; -lt 1 ]; then
        echo &quot;$usage&quot;
        return;
    fi
    local SMSO=$(tput smso)
    local RMSO=$(tput rmso)
    find . -type f -name &quot;${2:-*}&quot; -print0 | xargs -0 grep -sn ${case} &quot;$1&quot; 2&gt;&amp;- | \
sed &quot;s/$1/${SMSO}\0${RMSO}/gI&quot; | more
}

function cuttail() # удалить последние n строк в файле, по-умолчанию 10
{
    nlines=${2:-10}
    sed -n -e :a -e &quot;1,${nlines}!{P;N;D;};N;ba&quot; $1
}

function lowercase()  # перевести имя файла в нижний регистр
{
    for file ; do
        filename=${file##*/}
        case &quot;$filename&quot; in
        */*) dirname==${file%/*} ;;
        *) dirname=.;;
        esac
        nf=$(echo $filename | tr A-Z a-z)
        newname=&quot;${dirname}/${nf}&quot;
        if [ &quot;$nf&quot; != &quot;$filename&quot; ]; then
            mv &quot;$file&quot; &quot;$newname&quot;
            echo &quot;lowercase: $file --&gt; $newname&quot;
        else
            echo &quot;lowercase: имя файла $file не было изменено.&quot;
        fi
    done
}

function swap()         # меняет 2 файла местами
{
    local TMPFILE=tmp.$$
    mv &quot;$1&quot; $TMPFILE
    mv &quot;$2&quot; &quot;$1&quot;
    mv $TMPFILE &quot;$2&quot;
}


#-----------------------------------
# Функции для работы с процессами/системой:
#-----------------------------------

function my_ps() { ps $@ -u $USER -o pid,%cpu,%mem,bsdtime,command ; }
function pp() { my_ps f | awk &#39;!/awk/ &amp;&amp; $0~var&#39; var=${1:-&quot;.*&quot;} ; }

# Эта функция является грубым аналогом &#39;killall&#39; в linux
# но не эквивалентна (насколько я знаю) &#39;killall&#39; в Solaris
function killps()   # &quot;Прибить&quot; процесс по его имени
{
    local pid pname sig=&quot;-TERM&quot;   # сигнал, рассылаемый по-умолчанию
    if [ &quot;$#&quot; -lt 1 ] || [ &quot;$#&quot; -gt 2 ]; then
        echo &quot;Порядок использования: killps [-SIGNAL] шаблон_имени_процесса&quot;
        return;
    fi
    if [ $# = 2 ]; then sig=$1 ; fi
    for pid in $(my_ps| awk &#39;!/awk/ &amp;&amp; $0~pat { print $1 }&#39; pat=${!#} ) ; do
        pname=$(my_ps | awk &#39;$1~var { print $5 }&#39; var=$pid )
        if ask &quot;Послать сигнал $sig процессу $pid &lt;$pname&gt;?&quot;
            then kill $sig $pid
        fi
    done
}

function my_ip() # IP адрес
{
    MY_IP=$(/sbin/ifconfig ppp0 | awk &#39;/inet/ { print $2 } &#39; | sed -e s/addr://)
    MY_ISP=$(/sbin/ifconfig ppp0 | awk &#39;/P-t-P/ { print $3 } &#39; | sed -e s/P-t-P://)
}

function ii()   # Дополнительные сведения о системе
{
    echo -e &quot;\nВы находитесь на ${RED}$HOST&quot;
    echo -e &quot;\nДополнительная информация:$NC &quot; ; uname -a
    echo -e &quot;\n${RED}В системе работают пользователи:$NC &quot; ; w -h
    echo -e &quot;\n${RED}Дата:$NC &quot; ; date
    echo -e &quot;\n${RED}Время, прошедшее с момента последней перезагрузки :$NC &quot; ; uptime
    echo -e &quot;\n${RED}Память :$NC &quot; ; free
    my_ip 2&gt;&amp;- ;
    echo -e &quot;\n${RED}IP адрес:$NC&quot; ; echo ${MY_IP:-&quot;Соединение не установлено&quot;}
    echo -e &quot;\n${RED}Адрес провайдера (ISP):$NC&quot; ; echo ${MY_ISP:-&quot;Соединение не установлено&quot;}
    echo
}

# Разные утилиты:

function repeat()       # повторить команду n раз
{
    local i max
    max=$1; shift;
    for ((i=1; i &lt;= max ; i++)); do  # --&gt; C-подобный синтаксис
        eval &quot;$@&quot;;
    done
}

function ask()
{
    echo -n &quot;$@&quot; &#39;[y/n] &#39; ; read ans
    case &quot;$ans&quot; in
        y*|Y*) return 0 ;;
        *) return 1 ;;
    esac
}

#=========================================================================
#
# ПРОГРАММНЫЕ ДОПОЛНЕНИЯ - ТОЛЬКО НАЧИНАЯ С ВЕРСИИ BASH-2.04
# Большая часть дополнений взята из докуентации к bash 2.05  и из
# пакета &#39;Bash completion&#39; (http://www.caliban.org/bash/index.shtml#completion)
# автор -- Ian McDonalds
# Фактически, у вас должен стоять bash-2.05a
#
#=========================================================================

if [ &quot;${BASH_VERSION%.*}&quot; \&lt; &quot;2.05&quot; ]; then
    echo &quot;Вам необходимо обновиться до версии 2.05&quot;
    return
fi

shopt -s extglob        # необходимо
set +o nounset          # иначе некоторые дополнения не будут работать

complete -A hostname   rsh rcp telnet rlogin r ftp ping disk
complete -A export     printenv
complete -A variable   export local readonly unset
complete -A enabled    builtin
complete -A alias      alias unalias
complete -A function   function
complete -A user       su mail finger

complete -A helptopic  help
complete -A shopt      shopt
complete -A stopped -P &#39;%&#39; bg
complete -A job -P &#39;%&#39;     fg jobs disown

complete -A directory  mkdir rmdir
complete -A directory   -o default cd

# Архивация
complete -f -o default -X &#39;*.+(zip|ZIP)&#39;  zip
complete -f -o default -X &#39;!*.+(zip|ZIP)&#39; unzip
complete -f -o default -X &#39;*.+(z|Z)&#39;      compress
complete -f -o default -X &#39;!*.+(z|Z)&#39;     uncompress
complete -f -o default -X &#39;*.+(gz|GZ)&#39;    gzip
complete -f -o default -X &#39;!*.+(gz|GZ)&#39;   gunzip
complete -f -o default -X &#39;*.+(bz2|BZ2)&#39;  bzip2
complete -f -o default -X &#39;!*.+(bz2|BZ2)&#39; bunzip2
# Postscript,pdf,dvi.....
complete -f -o default -X &#39;!*.ps&#39;  gs ghostview ps2pdf ps2ascii
complete -f -o default -X &#39;!*.dvi&#39; dvips dvipdf xdvi dviselect dvitype
complete -f -o default -X &#39;!*.pdf&#39; acroread pdf2ps
complete -f -o default -X &#39;!*.+(pdf|ps)&#39; gv
complete -f -o default -X &#39;!*.texi*&#39; makeinfo texi2dvi texi2html texi2pdf
complete -f -o default -X &#39;!*.tex&#39; tex latex slitex
complete -f -o default -X &#39;!*.lyx&#39; lyx
complete -f -o default -X &#39;!*.+(htm*|HTM*)&#39; lynx html2ps
# Multimedia
complete -f -o default -X &#39;!*.+(jp*g|gif|xpm|png|bmp)&#39; xv gimp
complete -f -o default -X &#39;!*.+(mp3|MP3)&#39; mpg123 mpg321
complete -f -o default -X &#39;!*.+(ogg|OGG)&#39; ogg123



complete -f -o default -X &#39;!*.pl&#39;  perl perl5

# Эти &#39;универсальные&#39; дополнения работают тогда, когда команды вызываются
# с, так называемыми, &#39;длинными ключами&#39;, например: &#39;ls --all&#39; вместо &#39;ls -a&#39;

_get_longopts ()
{
    $1 --help | sed  -e &#39;/--/!d&#39; -e &#39;s/.*--\([^[:space:].,]*\).*/--\1/&#39;| \
grep ^&quot;$2&quot; |sort -u ;
}

_longopts_func ()
{
    case &quot;${2:-*}&quot; in
        -*)     ;;
        *)      return ;;
    esac

    case &quot;$1&quot; in
        \~*)    eval cmd=&quot;$1&quot; ;;
        *)      cmd=&quot;$1&quot; ;;
    esac
    COMPREPLY=( $(_get_longopts ${1} ${2} ) )
}
complete  -o default -F _longopts_func configure bash
complete  -o default -F _longopts_func wget id info a2ps ls recode


_make_targets ()
{
    local mdef makef gcmd cur prev i

    COMPREPLY=()
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}

    # Если аргумент prev это -f, то вернуть возможные варианты имен файлов.
    # будем великодушны и вернем несколько вариантов
    # `makefile Makefile *.mk&#39;
    case &quot;$prev&quot; in
        -*f)    COMPREPLY=( $(compgen -f $cur ) ); return 0;;
    esac

    # Если запрошены возможные ключи, то вернуть ключи posix
    case &quot;$cur&quot; in
        -)      COMPREPLY=(-e -f -i -k -n -p -q -r -S -s -t); return 0;;
    esac

    # попробовать передать make `makefile&#39; перед тем как попробовать передать `Makefile&#39;
    if [ -f makefile ]; then
        mdef=makefile
    elif [ -f Makefile ]; then
        mdef=Makefile
    else
        mdef=*.mk
    fi

    # прежде чем просмотреть &quot;цели&quot;, убедиться, что имя makefile было задано
    # ключом -f
    for (( i=0; i &lt; ${#COMP_WORDS[@]}; i++ )); do
        if [[ ${COMP_WORDS[i]} == -*f ]]; then
            eval makef=${COMP_WORDS[i+1]}
            break
        fi
    done

        [ -z &quot;$makef&quot; ] &amp;&amp; makef=$mdef

    # Если задан шаблон поиска, то ограничиться
    # этим шаблоном
    if [ -n &quot;$2&quot; ]; then gcmd=&#39;grep &quot;^$2&quot;&#39; ; else gcmd=cat ; fi

    # если мы не желаем использовать *.mk, то необходимо убрать cat и использовать
    # test -f $makef с перенаправлением ввода
    COMPREPLY=( $(cat $makef 2&gt;/dev/null | awk &#39;BEGIN {FS=&quot;:&quot;} /^[^.#   ][^=]*:/ {print $1}&#39; | tr -s &#39; &#39; &#39;\012&#39; | sort -u | eval $gcmd ) )
}

complete -F _make_targets -X &#39;+($*|*.[cho])&#39; make gmake pmake


# cvs(1) completion
_cvs ()
{
    local cur prev
    COMPREPLY=()
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}

    if [ $COMP_CWORD -eq 1 ] || [ &quot;${prev:0:1}&quot; = &quot;-&quot; ]; then
        COMPREPLY=( $( compgen -W &#39;add admin checkout commit diff \
        export history import log rdiff release remove rtag status \
        tag update&#39; $cur ))
    else
        COMPREPLY=( $( compgen -f $cur ))
    fi
    return 0
}
complete -F _cvs cvs

_killall ()
{
    local cur prev
    COMPREPLY=()
    cur=${COMP_WORDS[COMP_CWORD]}

    # получить список процессов
    COMPREPLY=( $( /usr/bin/ps -u $USER -o comm  | \
        sed -e &#39;1,1d&#39; -e &#39;s#[]\[]##g&#39; -e &#39;s#^.*/##&#39;| \
        awk &#39;{if ($0 ~ /^&#39;$cur&#39;/) print $0}&#39; ))

    return 0
}

complete -F _killall killall killps


# Функция обработки мета-команд
# В настоящее время недостаточно отказоустойчива (например, mount и umount
# обрабатываются некорректно), но все еще актуальна. Автор Ian McDonald, изменена мной.

_my_command()
{
    local cur func cline cspec

    COMPREPLY=()
    cur=${COMP_WORDS[COMP_CWORD]}

    if [ $COMP_CWORD = 1 ]; then
        COMPREPLY=( $( compgen -c $cur ) )
    elif complete -p ${COMP_WORDS[1]} &amp;&gt;/dev/null; then
        cspec=$( complete -p ${COMP_WORDS[1]} )
        if [ &quot;${cspec%%-F *}&quot; != &quot;${cspec}&quot; ]; then
            # complete -F &lt;function&gt;
            #
            # COMP_CWORD and COMP_WORDS() доступны на запись,
            # так что мы можем установить их перед тем,
            # как передать их дальше

            # уменьшить на 1 текущий номер лексемы
            COMP_CWORD=$(( $COMP_CWORD - 1 ))
            # получить имя функции
            func=${cspec#*-F }
            func=${func%% *}
            # получить командную строку, исключив первую команду
            cline=&quot;${COMP_LINE#$1 }&quot;
            # разбить на лексемы и поместить в массив
                COMP_WORDS=( $cline )
            $func $cline
        elif [ &quot;${cspec#*-[abcdefgjkvu]}&quot; != &quot;&quot; ]; then
            # complete -[abcdefgjkvu]
            #func=$( echo $cspec | sed -e &#39;s/^.*\(-[abcdefgjkvu]\).*$/\1/&#39; )
            func=$( echo $cspec | sed -e &#39;s/^complete//&#39; -e &#39;s/[^ ]*$//&#39; )
            COMPREPLY=( $( eval compgen $func $cur ) )
        elif [ &quot;${cspec#*-A}&quot; != &quot;$cspec&quot; ]; then
            # complete -A &lt;type&gt;
            func=${cspec#*-A }
        func=${func%% *}
        COMPREPLY=( $( compgen -A $func $cur ) )
        fi
    else
        COMPREPLY=( $( compgen -f $cur ) )
    fi
}


complete -o default -F _my_command nohup exec eval trace truss strace sotruss gdb
complete -o default -F _my_command command type which man nice

# Локальные переменные:
# mode:shell-script
# sh-shell:bash
# Конец:
</pre>
      </div>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#a15070_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#a15138_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">История команд</td>

          <td
           width="34%"
           align="center"
           valign="top"> </td>

          <td
           width="33%"
           align="right"
           valign="top">Преобразование пакетных (*.bat) файлов DOS в
          сценарии командной оболочки</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="a15138_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#a15124_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#a15523_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="APPENDIX">
      <h1><a
       name="a15138_html_DOSBATCH"></a>Приложение H. Преобразование пакетных
      (*.bat) файлов DOS в сценарии командной оболочки</h1>

      <p><a
       name="a15138_html_DOSBATCH1"></a></p>

      <p>Большое число программистов начинало изучать скриптовые языки
      на PC, работающих под управлением DOS. Даже на этом
      &quot;калеке&quot; удавалось создавать неплохие сценарии, хотя
      это и требовало значительных усилий. Иногда еще возникает
      потребность в переносе пекетных файлов DOS на платформу UNIX, в
      виде сценариев командной оболочки. Обычно это не сложно,
      поскольку набор операторов, доступных в DOS, представляет из себя
      ограниченное подмножество эквивалентных команд, доступных в
      командной оболочке.</p>

      <div
       class="TABLE">
        <a
         name="a15138_html_AEN15143"></a>

        <p><strong>Таблица H-1. Ключевые слова/переменные/операторы
        пакетных файлов DOS и их аналоги командной
        оболочки</strong></p>

        <table
         border="1"
         class="CALSTABLE">
          <thead>
            <tr>
              <th
               align="left"
               valign="top">Операторы пакетных файлов</th>

              <th
               align="left"
               valign="top">Эквивалентные команды в UNIX</th>

              <th
               align="left"
               valign="top">Описание</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">%</tt></td>

              <td
               align="left"
               valign="top">$</td>

              <td
               align="left"
               valign="top">префикс аргументов командной строки</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">/</tt></td>

              <td
               align="left"
               valign="top">-</td>

              <td
               align="left"
               valign="top">признак ключа (опции)</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">\</tt></td>

              <td
               align="left"
               valign="top">/</td>

              <td
               align="left"
               valign="top">разделитель имен каталогов в пути</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">==</tt></td>

              <td
               align="left"
               valign="top">=</td>

              <td
               align="left"
               valign="top">(равно) сравнение строк</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">!==!</tt></td>

              <td
               align="left"
               valign="top">!=</td>

              <td
               align="left"
               valign="top">(не равно) сравнение строк</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">|</tt></td>

              <td
               align="left"
               valign="top">|</td>

              <td
               align="left"
               valign="top">конвейер (канал)</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">@</tt></td>

              <td
               align="left"
               valign="top">set <tt
               class="OPTION">+v</tt></td>

              <td
               align="left"
               valign="top">не выводить текущую команду</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">*</tt></td>

              <td
               align="left"
               valign="top">*</td>

              <td
               align="left"
               valign="top"><span
               class="QUOTE">&quot;шаблонный символ&quot;</span> в
              имени файла</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">&gt;</tt></td>

              <td
               align="left"
               valign="top">&gt;</td>

              <td
               align="left"
               valign="top">перенаправление (с удалением существующего
              файла)</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">&gt;&gt;</tt></td>

              <td
               align="left"
               valign="top">&gt;&gt;</td>

              <td
               align="left"
               valign="top">перенаправление (с добавлением в конец
              существующего файла)</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">&lt;</tt></td>

              <td
               align="left"
               valign="top">&lt;</td>

              <td
               align="left"
               valign="top">перенаправление ввода <tt
               class="FILENAME">stdin</tt></td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">%VAR%</tt></td>

              <td
               align="left"
               valign="top">$VAR</td>

              <td
               align="left"
               valign="top">переменная окружения</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">REM</tt></td>

              <td
               align="left"
               valign="top">#</td>

              <td
               align="left"
               valign="top">комментарий</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">NOT</tt></td>

              <td
               align="left"
               valign="top">!</td>

              <td
               align="left"
               valign="top">отрицание последующего условия</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">NUL</tt></td>

              <td
               align="left"
               valign="top"><tt
               class="FILENAME">/dev/null</tt></td>

              <td
               align="left"
               valign="top"><span
               class="QUOTE">&quot;черная дыра&quot;</span> для того,
              чтобы &quot;спрятать&quot; вывод команды</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">ECHO</tt></td>

              <td
               align="left"
               valign="top">echo</td>

              <td
               align="left"
               valign="top">вывод (в Bash имеет большое число
              опций)</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">ECHO.</tt></td>

              <td
               align="left"
               valign="top">echo</td>

              <td
               align="left"
               valign="top">вывод пустой строки</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">ECHO OFF</tt></td>

              <td
               align="left"
               valign="top">set <tt
               class="OPTION">+v</tt></td>

              <td
               align="left"
               valign="top">не выводить последующие команды</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">FOR %%VAR IN (LIST) DO</tt></td>

              <td
               align="left"
               valign="top">for var in [list]; do</td>

              <td
               align="left"
               valign="top">цикл <span
               class="QUOTE">&quot;for&quot;</span></td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">:LABEL</tt></td>

              <td
               align="left"
               valign="top">эквивалент отсутствует (нет
              необходимости)</td>

              <td
               align="left"
               valign="top">метка</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">GOTO</tt></td>

              <td
               align="left"
               valign="top">эквивалент отсутствует (используйте
              функции)</td>

              <td
               align="left"
               valign="top">переход по заданной метке</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">PAUSE</tt></td>

              <td
               align="left"
               valign="top">sleep</td>

              <td
               align="left"
               valign="top">пауза, или ожидание, в течение заданного
              времени</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">CHOICE</tt></td>

              <td
               align="left"
               valign="top">case или select</td>

              <td
               align="left"
               valign="top">выбор из меню</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">IF</tt></td>

              <td
               align="left"
               valign="top">if</td>

              <td
               align="left"
               valign="top">условный оператор if</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">IF EXIST <tt
               class="REPLACEABLE"><em>FILENAME</em></tt></tt></td>

              <td
               align="left"
               valign="top">if [ -e filename ]</td>

              <td
               align="left"
               valign="top">проверка существования файла</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">IF !%N==!</tt></td>

              <td
               align="left"
               valign="top">if [ -z &quot;$N&quot; ]</td>

              <td
               align="left"
               valign="top">Проверка: параметр <span
               class="QUOTE">&quot;N&quot;</span> отсутствует</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">CALL</tt></td>

              <td
               align="left"
               valign="top">source или . (оператор
              &quot;точка&quot;)</td>

              <td
               align="left"
               valign="top"><span
               class="QUOTE">&quot;подключение&quot;</span> другого
              сценария</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">COMMAND /C</tt></td>

              <td
               align="left"
               valign="top">source или . (оператор
              &quot;точка&quot;)</td>

              <td
               align="left"
               valign="top"><span
               class="QUOTE">&quot;подключение&quot;</span> другого
              сценария (то же, что и CALL)</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">SET</tt></td>

              <td
               align="left"
               valign="top">export</td>

              <td
               align="left"
               valign="top">установить переменную окружения</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">SHIFT</tt></td>

              <td
               align="left"
               valign="top">shift</td>

              <td
               align="left"
               valign="top">сдвиг списка аргументов уомандной строки
              влево</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">SGN</tt></td>

              <td
               align="left"
               valign="top">-lt или -gt</td>

              <td
               align="left"
               valign="top">знак (целого числа)</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">ERRORLEVEL</tt></td>

              <td
               align="left"
               valign="top">$?</td>

              <td
               align="left"
               valign="top">код завершения</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">CON</tt></td>

              <td
               align="left"
               valign="top"><tt
               class="FILENAME">stdin</tt></td>

              <td
               align="left"
               valign="top"><span
               class="QUOTE">&quot;консоль&quot;</span> (<tt
               class="FILENAME">stdin</tt>)</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">PRN</tt></td>

              <td
               align="left"
               valign="top"><tt
               class="FILENAME">/dev/lp0</tt></td>

              <td
               align="left"
               valign="top">устройство принтера</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">LPT1</tt></td>

              <td
               align="left"
               valign="top"><tt
               class="FILENAME">/dev/lp0</tt></td>

              <td
               align="left"
               valign="top">устройство принтера</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">COM1</tt></td>

              <td
               align="left"
               valign="top"><tt
               class="FILENAME">/dev/ttyS0</tt></td>

              <td
               align="left"
               valign="top">первый последовательный порт</td>
            </tr>
          </tbody>
        </table>
      </div>

      <p>Пакетные файлы обычно содержат вызовы команд DOS. Они должны
      быть заменены эквивалентными командами UNIX.</p>

      <div
       class="TABLE">
        <a
         name="a15138_html_AEN15350"></a>

        <p><strong>Таблица H-2. Команды DOS и их эквиваленты в
        UNIX</strong></p>

        <table
         border="1"
         class="CALSTABLE">
          <thead>
            <tr>
              <th
               align="left"
               valign="top">Команды DOS</th>

              <th
               align="left"
               valign="top">Эувивалент в UNIX</th>

              <th
               align="left"
               valign="top">Описание</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">ASSIGN</tt></td>

              <td
               align="left"
               valign="top">ln</td>

              <td
               align="left"
               valign="top">ссылка на файл или каталог</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">ATTRIB</tt></td>

              <td
               align="left"
               valign="top">chmod</td>

              <td
               align="left"
               valign="top">изменить атрибуты файла (права
              доступа)</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">CD</tt></td>

              <td
               align="left"
               valign="top">cd</td>

              <td
               align="left"
               valign="top">сменить каталог</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">CHDIR</tt></td>

              <td
               align="left"
               valign="top">cd</td>

              <td
               align="left"
               valign="top">сменить каталог</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">CLS</tt></td>

              <td
               align="left"
               valign="top">clear</td>

              <td
               align="left"
               valign="top">очистить экран</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">COMP</tt></td>

              <td
               align="left"
               valign="top">diff, comm, cmp</td>

              <td
               align="left"
               valign="top">сравнить файлы</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">COPY</tt></td>

              <td
               align="left"
               valign="top">cp</td>

              <td
               align="left"
               valign="top">скопировать файл</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">Ctl-C</tt></td>

              <td
               align="left"
               valign="top">Ctl-C</td>

              <td
               align="left"
               valign="top">прервать исполнение сценария</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">Ctl-Z</tt></td>

              <td
               align="left"
               valign="top">Ctl-D</td>

              <td
               align="left"
               valign="top">EOF (конец-файла)</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">DEL</tt></td>

              <td
               align="left"
               valign="top">rm</td>

              <td
               align="left"
               valign="top">удалить файл(ы)</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">DELTREE</tt></td>

              <td
               align="left"
               valign="top">rm -rf</td>

              <td
               align="left"
               valign="top">удалить каталог с подкаталогами</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">DIR</tt></td>

              <td
               align="left"
               valign="top">ls -l</td>

              <td
               align="left"
               valign="top">вывести содержимое каталога</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">ERASE</tt></td>

              <td
               align="left"
               valign="top">rm</td>

              <td
               align="left"
               valign="top">удалить файл(ы)</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">EXIT</tt></td>

              <td
               align="left"
               valign="top">exit</td>

              <td
               align="left"
               valign="top">завершить текущий процесс</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">FC</tt></td>

              <td
               align="left"
               valign="top">comm, cmp</td>

              <td
               align="left"
               valign="top">сравнить файлы</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">FIND</tt></td>

              <td
               align="left"
               valign="top">grep</td>

              <td
               align="left"
               valign="top">найти строку в файлах</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">MD</tt></td>

              <td
               align="left"
               valign="top">mkdir</td>

              <td
               align="left"
               valign="top">создать каталог</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">MKDIR</tt></td>

              <td
               align="left"
               valign="top">mkdir</td>

              <td
               align="left"
               valign="top">создать каталог</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">MORE</tt></td>

              <td
               align="left"
               valign="top">more</td>

              <td
               align="left"
               valign="top">постраничный вывод</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">MOVE</tt></td>

              <td
               align="left"
               valign="top">mv</td>

              <td
               align="left"
               valign="top">переместить</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">PATH</tt></td>

              <td
               align="left"
               valign="top">$PATH</td>

              <td
               align="left"
               valign="top">путь поиска исполняемых файлов</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">REN</tt></td>

              <td
               align="left"
               valign="top">mv</td>

              <td
               align="left"
               valign="top">переименовать (переместить)</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">RENAME</tt></td>

              <td
               align="left"
               valign="top">mv</td>

              <td
               align="left"
               valign="top">переименовать (переместить)</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">RD</tt></td>

              <td
               align="left"
               valign="top">rmdir</td>

              <td
               align="left"
               valign="top">удалить каталог</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">RMDIR</tt></td>

              <td
               align="left"
               valign="top">rmdir</td>

              <td
               align="left"
               valign="top">удалить каталог</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">SORT</tt></td>

              <td
               align="left"
               valign="top">sort</td>

              <td
               align="left"
               valign="top">отсортировать файл</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">TIME</tt></td>

              <td
               align="left"
               valign="top">date</td>

              <td
               align="left"
               valign="top">вывести системное время</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">TYPE</tt></td>

              <td
               align="left"
               valign="top">cat</td>

              <td
               align="left"
               valign="top">вывести содержимое файла на <tt
               class="FILENAME">stdout</tt></td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">XCOPY</tt></td>

              <td
               align="left"
               valign="top">cp</td>

              <td
               align="left"
               valign="top">(расширенная команда) скопировать файл</td>
            </tr>
          </tbody>
        </table>
      </div>

      <div
       class="NOTE">
        <table
         class="NOTE"
         width="100%"
         border="0">
          <tr>
            <td
             width="25"
             align="center"
             valign="top"><img
             src="misc/abs-book/images/note.gif"
             hspace="5"
             alt="Note"></td>

            <td
             align="left"
             valign="top">
              <p>Фактически, команды и операторы командной оболочки
              UNIX имеют огромное количество дополнительных опций,
              расширяющих их функциональность, по сравнению с их
              эквивалентами в DOS. В большинстве своем, пакетные файлы
              DOS предполагают наличие вспомогательных утилит, таких
              как <strong
               class="COMMAND">ask.com</strong> (&quot;увечный&quot;
              аналог UNIX-вого <a
               href="#c5358_html_READREF">read</a>).</p>

              <p>DOS поддерживает крайне ограниченный набор шаблонных
              символов, учавствующих в операциях <a
               href="#x12282_html">подстановки имен файлов</a>,
              распознавая только два символа -- <span
               class="TOKEN">*</span> и <span
               class="TOKEN">?</span>.</p>
            </td>
          </tr>
        </table>
      </div>

      <p>Преобразование пакетных файлов DOS в сценарии командной
      оболочки, обычно не вызывает затруднений, а результат такого
      преобразования читается гораздо лучше, чем оригинал.</p>

      <div
       class="EXAMPLE">
        <a
         name="a15138_html_VIEWDAT"></a>

        <p><strong>Пример H-1. VIEWDATA.BAT: пакетный файл
        DOS</strong></p>
<pre
 class="PROGRAMLISTING">
REM VIEWDATA

REM INSPIRED BY AN EXAMPLE IN &quot;DOS POWERTOOLS&quot;
REM                           BY PAUL SOMERSON


@ECHO OFF

IF !%1==! GOTO VIEWDATA
REM  IF NO COMMAND-LINE ARG...
FIND &quot;%1&quot; C:\BOZO\BOOKLIST.TXT
GOTO EXIT0
REM  PRINT LINE WITH STRING MATCH, THEN EXIT.

:VIEWDATA
TYPE C:\BOZO\BOOKLIST.TXT | MORE
REM  SHOW ENTIRE FILE, 1 PAGE AT A TIME.

:EXIT0
</pre>
      </div>

      <p>Результат преобразования в сценарий командной оболочки,
      немного улучшенный.</p>

      <div
       class="EXAMPLE">
        <a
         name="a15138_html_VIEWDATA"></a>

        <p><strong>Пример H-2. viewdata.sh: Результат преобразования
        VIEWDATA.BAT в сценарий командной оболочки</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Результат преобразования пакетного файла VIEWDATA.BAT в сценарий командной оболочки.

DATAFILE=/home/bozo/datafiles/book-collection.data
ARGNO=1

# @ECHO OFF       Эта команда здесь не нужна.

if [ $# -lt &quot;$ARGNO&quot; ]    # IF !%1==! GOTO VIEWDATA
then
  less $DATAFILE          # TYPE C:\MYDIR\BOOKLIST.TXT | MORE
else
  grep &quot;$1&quot; $DATAFILE     # FIND &quot;%1&quot; C:\MYDIR\BOOKLIST.TXT
fi

exit 0                    # :EXIT0

# операторы перехода GOTO, метки и прочий &quot;мусор&quot; больше не нужны.
# Результат преобразования стал короче, чище и понятнее,
</pre>
      </div>

      <p>На сайте Тэда Дэвиса (Ted Davis) <a
       href="http://www.maem.umr.edu/~batch/"
       target="_top">Shell Scripts on the PC</a>, вы найдете большое
      число руководств по созданию пакетных файлов в DOS. Определенно,
      его изобретательность будет вам полезна, при создании ваших
      сценариев.</p>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#a15124_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#a15523_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Пример файла <tt
           class="FILENAME">.bashrc</tt></td>

          <td
           width="34%"
           align="center"
           valign="top"> </td>

          <td
           width="33%"
           align="right"
           valign="top">Упражнения</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="a15523_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#a15138_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x15542_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="APPENDIX">
      <h1><a
       name="a15523_html_EXERCISES"></a>Приложение I. Упражнения</h1>

      <div
       class="SECT1">
        <h1
         class="SECT1"><a
         name="a15523_html_SCRIPTANALYSIS"></a>I.1. Анализ сценариев</h1>

        <p>Просмотрите следующие сценарии. Попробуйте запустить их,
        затем объясните -- что они делают. Расставьте комментарии,
        затем попробуйте записать их в более компактном виде.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

MAX=10000


  for((nr=1; nr&lt;$MAX; nr++))
  do

    let &quot;t1 = nr % 5&quot;
    if [ &quot;$t1&quot; -ne 3 ]
    then
      continue
    fi

    let &quot;t2 = nr % 7&quot;
    if [ &quot;$t2&quot; -ne 4 ]
    then
      continue
    fi

    let &quot;t3 = nr % 9&quot;
    if [ &quot;$t3&quot; -ne 5 ]
    then
      continue
    fi

  break   # Что произойдет, если закомментировать эту строку? Почему?

  done

  echo &quot;Число = $nr&quot;


exit 0
</pre>
        <br>
        <br>

        <p>---</p>

        <p>Читатель прислал следующий кусок кода.</p>
<pre
 class="PROGRAMLISTING">
while read LINE
do
  echo $LINE
done &lt; `tail -f /var/log/messages`
</pre>
        Он предполагал написать сценарий, который отслеживал бы
        изменения в системном журнале <tt
         class="FILENAME">/var/log/messages</tt>. К сожалению, этот код
        &quot;зависает&quot; и не делает ничего полезного. Почему?
        Найдите ошибку и исправьте ее (подсказка: вместо операции <a
         href="#x11731_html_REDIRREF">перенаправления <tt
         class="FILENAME">stdin</tt> в цикл</a>, попробуйте
        использовать <a
         href="#c301_html_PIPEREF">конвейерную обработку</a>).<br>
        <br>

        <p>---</p>

        <p>Просмотрите сценарий <a
         href="#a14477_html_LIFESLOW">Пример A-11</a>, попробуйте
        изменить его таким образом, чтобы он выглядел проще и логичнее.
        Удалите все &quot;лишние&quot; переменные и попытайтесь
        оптимизировать сценарий по скорости исполнения.</p>

        <p>Измените сценарий таким образом, чтобы он мог принимать
        начальную установку &quot;поколения 0&quot; из любого
        текстового файла. Сценарий должен считать первые <tt
         class="VARNAME">$ROW*$COL</tt> символов, и на место гласных
        вставлять &quot;живые особи&quot;. Подсказка: не забудьте
        преобразовать пробелы в символы подчеркивания.</p>
      </div>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#a15138_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x15542_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Преобразование пакетных (*.bat) файлов DOS в
          сценарии командной оболочки</td>

          <td
           width="34%"
           align="center"
           valign="top"> </td>

          <td
           width="33%"
           align="right"
           valign="top">Создание сценариев</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="a15860_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x15542_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"> </td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="APPENDIX">
      <h1><a
       name="a15860_html_COPYRIGHT"></a>Приложение J. Авторские права</h1>

      <p>Авторские права на книгу <span
       class="QUOTE">&quot;Advanced Bash-Scripting Guide&quot;</span>,
      принадлежат Менделю Куперу (Mendel Cooper). Этот документ может
      распространяться исключительно на условиях Open Publication
      License (версия 1.0 или выше), <a
       href="%20http://www.opencontent.org/openpub/"
       target="_top">http://www.opencontent.org/openpub/</a>.
      Соблюдение следующих пунктов лицензии обязательно.</p>

      <ol
       type="1">
        <li>
          <p>Распространение существенно измененных версий этого
          документа, запрещено без явного разрешения держателя
          прав.</p>
        </li>

        <li>
          <p>Запрещено распространение твердых (бумажных) копий книги,
          или ее производных, без явного согласия держателя прав.</p>
        </li>
      </ol>

      <p><span
       class="emphasis"><em
       class="EMPHASIS">Пункт 1</em></span>, выше, явно запрещает
      вставлять в текст документа логотипы компаний или навигационные
      элементы, за исключением</p>

      <ol
       type="1">
        <li>
          <p>Некоммерческих организаций, таких как <a
           href="http://www.tldp.org"
           target="_top">Linux Documentation Project</a> и <a
           href="http://ibiblio.org"
           target="_top">Sunsite</a>.</p>
        </li>

        <li>
          <p>Не <span
           class="QUOTE">&quot;запятнавших&quot;</span> себя
          дистрибутивостроителей Linux, таких как Debian, Red Hat,
          Mandrake и других.</p>
        </li>
      </ol>

      <p>Практически, вы можете свободно распространять <span
       class="emphasis"><em
       class="EMPHASIS">неизмененную</em></span> электронную версию
      этой книги. Вы должны получить явное разрешение автора на
      распространение измененных версий книги или ее производных. Цель
      этого ограничения состоит в том, чтобы сохранить художественную
      целостность данного документа и предотвратить появление побочных
      <span
       class="QUOTE">&quot;ветвей&quot;</span>.</p>

      <p>Это очень либеральные условия и они не должны препятствовать
      законному распространению и использованию этой книги. Автор
      особенно поощряет использование этой книги в учебных целях.</p>

      <p>Права на коммерческое распространение книги могут быть
      получены у <a
       href="mailto:thegrendel@theriver.com"
       target="_top">автора</a>.</p>

      <p>Автор произвел этот документ в соответствии с буквой и духом
      <a
       href="http://www.tldp.org/manifesto.html"
       target="_top">LDP Manifesto</a>.</p>

      <p>Hyun Jin Cha завершил <a
       href="http://kldp.org/HOWTO/html/Adv-Bash-Scr-HOWTO/index.html"
       target="_top">перевод на Корейский язык</a> версию 1.0.11 этой
      книги. Переводы на Испанский, Португальский, Французский,
      Немецкий, Итальянский и Китайский языки находятся на стадии
      реализации. Если вы изъявите желание перевести этот документ на
      другой язык, то можете свободно выполнить этот перевод,
      основываясь на условиях, заявленных выше. В этом случае, автор
      хотел бы, чтобы его поставили в известность.</p>

      <table
       class="SIDEBAR"
       border="1"
       cellpadding="5">
        <tr>
          <td>
            <div
             class="SIDEBAR">
              <a
               name="a15860_html_AEN15890"></a>

              <p>Linux -- это торговая марка, принадлежащая Линусу
              Торвальдсу (Linus Torvalds).</p>

              <p>Unix и UNIX -- это торговая марка, принадлежащая Open
              Group.</p>

              <p>MS Windows -- это торговая марка, принадлежащая
              Microsoft Corp.</p>

              <p>Все другие коммерческие торговые марки, упомянутые в
              данном документе, принадлежат их владельцам.</p>
            </div>
          </td>
        </tr>
      </table>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x15542_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"> </td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Создание сценариев</td>

          <td
           width="34%"
           align="center"
           valign="top"> </td>

          <td
           width="33%"
           align="right"
           valign="top"> </td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="b14059_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x14001_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#a14477_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>
    <a
     name="b14059_html_BIBLIO"></a>

    <h1><a
     name="b14059_html_BIBLIO"></a>Литература</h1>
    <a
     name="b14059_html_BIBLIOREF"></a>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14061"></a>

      <p><span
       class="EDITOR">Edited by Peter Denning</span>, <em>Computers
      Under Attack: Intruders, Worms, and Viruses</em>, ACM Press,
      1990, 0-201-53067-8.</p>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Содержит несколько статей о вирусах, написаных на языке
          командной оболочки.</p>

          <p>*</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14075"></a>

      <p><span
       class="AUTHOR">Dale Dougherty</span> <span
       class="AUTHOR">and Arnold Robbins</span>, <em>Sed and Awk</em>,
      2nd edition, O&#39;Reilly and Associates, 1997,
      1-156592-225-5.</p>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Чтобы раскрыть всю мощь командной оболочки, вам наверняка
          потребуется знакомство с <strong
           class="COMMAND">sed</strong> и <strong
           class="COMMAND">awk</strong>. Это обычный учебник. Здесь вы
          найдете превосходное введение в <span
           class="QUOTE">&quot;регулярные выражения&quot;</span>.
          Обязательно прочитайте эту книгу.</p>

          <p>*</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14096"></a>

      <p><span
       class="AUTHOR">Aeleen Frisch</span>, <em>Essential System
      Administration</em>, 3rd edition, O&#39;Reilly and Associates,
      2002, 0-596-00343-9.</p>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Это замечательное руководство для системных
          администраторов. Может служить неплохим введением в
          программирование сценариев. Содержит подробные пояснения к
          сценариям загрузки и инициализации системы.</p>

          <p>*</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14111"></a>

      <p><span
       class="AUTHOR">Stephen Kochan</span> <span
       class="AUTHOR">and Patrick Woods</span>, <em>Unix Shell
      Programming</em>, Hayden, 1990, 067248448X.</p>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Стандартный справочник, хотя немного устаревший.</p>

          <p>*</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14128"></a>

      <p><span
       class="AUTHOR">Neil Matthew</span> <span
       class="AUTHOR">and Richard Stones</span>, <em>Beginning Linux
      Programming</em>, Wrox Press, 1996, 1874416680.</p>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Дает хороший, глубокий охват различных языков
          программирования, доступных в Linux, включая довольно сильную
          главу по программированию в командной оболочке.</p>

          <p>*</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_MAYERREF"></a>

      <p><span
       class="AUTHOR">Herbert Mayer</span>, <em>Advanced C Programming
      on the IBM PC</em>, Windcrest Books, 1989, 0830693637.</p>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Замечательная книга по алгоритмам и практическому
          программированию.</p>

          <p>*</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14159"></a>

      <p><span
       class="AUTHOR">David Medinets</span>, <em>Unix Shell Programming
      Tools</em>, McGraw-Hill, 1999, 0070397333.</p>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Отличная книга по программированию в командной оболочке, с
          примерами, и кратким введением в Tcl и Perl.</p>

          <p>*</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14173"></a>

      <p><span
       class="AUTHOR">Cameron Newham</span> <span
       class="AUTHOR">and Bill Rosenblatt</span>, <em>Learning the Bash
      Shell</em>, 2nd edition, O&#39;Reilly and Associates, 1998,
      1-56592-347-2.</p>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Это отважная попытка создать учебник для начинающих, но он
          получился несколько несовершенным, к тому же не изобилует
          примерами сценариев.</p>

          <p>*</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14191"></a>

      <p><span
       class="AUTHOR">Anatole Olczak</span>, <em>Bourne Shell Quick
      Reference Guide</em>, ASP, Inc., 1991, 093573922X.</p>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Очень удобный карманный справочник, несмотря на
          недостатки, при охвате специфичных свойств Bash.</p>

          <p>*</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14205"></a>

      <p><span
       class="AUTHOR">Jerry Peek,</span> <span
       class="AUTHOR">Tim O&#39;Reilly,</span> <span
       class="AUTHOR">and Mike Loukides</span>, <em>Unix Power
      Tools</em>, 2nd edition, O&#39;Reilly and Associates, Random
      House, 1997, 1-56592-260-3.</p>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Содержит ряд очень информативных разделов, посвященных
          программированию в командной оболочке, но не может
          рассматриваться как учебное пособие.</p>

          <p>*</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14228"></a>

      <p><span
       class="AUTHOR">Clifford Pickover</span>, <em>Computers, Pattern,
      Chaos, and Beauty</em>, St. Martin&#39;s Press, 1990,
      0-312-04123-3.</p>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Сокровищница идей и рецептов по машинным вычислениям.</p>

          <p>*</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14242"></a>

      <p><span
       class="AUTHOR">George Polya</span>, <em>How To Solve It</em>,
      Princeton University Press, 1973, 0-691-02356-5.</p>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Классический учебник по методам решения задач.</p>

          <p>*</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14256"></a>

      <p><span
       class="AUTHOR">Arnold Robbins</span>, <em>Bash Reference
      Card</em>, SSC, 1998, 1-58731-010-5.</p>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Замечательный карманный справочник по Bash. Стоит всего
          $4.95, но также доступен для свободного скачивания <a
           href="http://www.ssc.com/ssc/bash/"
           target="_top">on-line</a> в формате PDF.</p>

          <p>*</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14271"></a>

      <p><span
       class="AUTHOR">Arnold Robbins</span>, <em>Effective Awk
      Programming</em>, Free Software Foundation / O&#39;Reilly and
      Associates, 2000, 1-882114-26-4.</p>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Самое лучшее учебное руководство и справочник по <strong
           class="COMMAND">awk</strong>. Свободная электронная версия
          книги включена в состав документации к <strong
           class="COMMAND">awk</strong>. Печатное издание последней
          версии доступно на сайте O&#39;Reilly and Associates.</p>

          <p>Эта книга служила источником вдохновения для автора этой
          книги.</p>

          <p>*</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14288"></a>

      <p><span
       class="AUTHOR">Bill Rosenblatt</span>, <em>Learning the Korn
      Shell</em>, O&#39;Reilly and Associates, 1993, 1-56592-054-6.</p>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Эта, хорошо написанная книга, содержит массу указаний по
          созданию сценариев командной оболочки.</p>

          <p>*</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14302"></a>

      <p><span
       class="AUTHOR">Paul Sheer</span>, <em>LINUX: Rute User&#39;s
      Tutorial and Exposition</em>, 1st edition, , 2002,
      0-13-033351-4.</p>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Очень хорошее введение в системное администрирование
          Linux.</p>

          <p>Эта книга доступна в <a
           href="http://rute.sourceforge.net/"
           target="_top">on-line</a>.</p>

          <p>*</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14319"></a>

      <p><span
       class="AUTHOR">Ellen Siever</span> <span
       class="AUTHOR">and the staff of O&#39;Reilly and
      Associates</span>, <em>Linux in a Nutshell</em>, 2nd edition,
      O&#39;Reilly and Associates, 1999, 1-56592-585-8.</p>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Один из лучших справочников по командам Linux, имеет
          раздел, посвященный Bash.</p>

          <p>*</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14336"></a>

      <p><em>The UNIX CD Bookshelf</em>, 3rd edition, O&#39;Reilly and
      Associates, 2003, 0-596-00392-7.</p>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Сборник из 7-ми книг по UNIX на CD ROM. В состав сборника
          входят такие книги, как <span
           class="emphasis"><em
           class="EMPHASIS">UNIX Power Tools</em></span>, <span
           class="emphasis"><em
           class="EMPHASIS">Sed and Awk</em></span> и <span
           class="emphasis"><em
           class="EMPHASIS">Learning the Korn Shell</em></span>. Полный
          набор необходимых справочных и учебных материалов, который
          вам только может понадобиться. Стоит примерно $130.</p>

          <p>*</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14350"></a>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Книги издательства O&#39;Reilly, посвященные Perl.</p>

          <p>---</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14354"></a>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Ben Okopnik опубликовал серию отличных статей <span
           class="emphasis"><em
           class="EMPHASIS">introductory Bash scripting</em></span> в
          выпусках 53, 54, 55, 57 и 59 на сайте <a
           href="http://www.linuxgazette.com"
           target="_top">Linux Gazette</a> , и статью <span
           class="QUOTE">&quot;The Deep, Dark Secrets of
          Bash&quot;</span> в выпуске 56.</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14360"></a>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Chet Ramey <span
           class="emphasis"><em
           class="EMPHASIS">bash - The GNU Shell</em></span> -- серия
          статей в 3 и 4 выпусках <a
           href="http://www.linuxjournal.com"
           target="_top">Linux Journal</a>, Июль-Август 1994.</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14365"></a>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Mike G <a
           href="http://www.tldp.org/HOWTO/Bash-Prog-Intro-HOWTO.html"
           target="_top">Bash-Programming-Intro HOWTO</a>.</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14369"></a>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Richard <a
           href="http://www.injunea.demon.co.uk/index.htm"
           target="_top">UNIX Scripting Universe</a>.</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14373"></a>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Chet Ramey <a
           href="ftp://ftp.cwru.edu/pub/bash/FAQ"
           target="_top">Bash F.A.Q.</a></p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14377"></a>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Ed Schaefer <a
           href="http://www.unixreview.com/columns/schaefer/"
           target="_top">Shell Corner</a> на <a
           href="http://www.unixreview.com"
           target="_top">Unix Review</a>.</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14382"></a>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Примеры сценариев: <a
           href="http://alge.anart.no/linux/scripts/"
           target="_top">Lucc&#39;s Shell Scripts</a> .</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14386"></a>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Примеры сценариев: <a
           href="http://www.shelldorado.com"
           target="_top">SHELLdorado</a> .</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14390"></a>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Примеры сценариев: <a
           href=
          "http://clri6f.gsi.de/gnu/bash-2.01/examples/scripts.noah/"
           target="_top">Noah Friedman&#39;s script site</a>.</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14394"></a>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Steve Parker <a
           href="http://steve-parker.org/sh/sh.shtml"
           target="_top">Shell Programming Stuff</a>.</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14398"></a>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Примеры сценариев: <a
           href=
          "http://sourceforge.net/snippet/browse.php?by=lang&amp;lang=7"
           target="_top">SourceForge Snippet Library - shell
          scripts</a>.</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14402"></a>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Giles Orr <a
           href="http://www.tldp.org/HOWTO/Bash-Prompt-HOWTO/"
           target="_top">Bash-Prompt HOWTO</a>.</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14406"></a>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Замечательное руководство по регулярным выражениям,
          <strong
           class="COMMAND">sed</strong> и <strong
           class="COMMAND">awk</strong> <a
           href="http://www.grymoire.com/Unix/index.html"
           target="_top">The UNIX Grymoire</a>.</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14412"></a>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Eric Pement <a
           href="http://www.student.northpark.edu/pemente/sed/"
           target="_top">sed resources page</a>.</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14416"></a>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p><a
           href=
          "http://sunsite.ualberta.ca/Documentation/Gnu/gawk-3.0.6/gawk.html"
           target="_top">The GNU <strong
           class="COMMAND">gawk</strong> reference manual</a> (<strong
           class="COMMAND">gawk</strong> -- GNU-версия <strong
           class="COMMAND">awk</strong> для ОС Linux и BSD).</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14423"></a>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Trent Fisher <a
           href="http://www.cs.pdx.edu/~trent/gnu/groff/groff.html"
           target="_top">groff tutorial</a>.</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14427"></a>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Mark Komarinski <a
           href="http://www.tldp.org/HOWTO/Printing-Usage-HOWTO.html"
           target="_top">Printing-Usage HOWTO</a>.</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14431"></a>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Хороший материал по <a
           href="#c11620_html_IOREDIRREF">перенаправлению
          ввода/вывода</a> <a
           href=
          "http://sunsite.ualberta.ca/Documentation/Gnu/textutils-2.0/html_chapter/textutils_10.html"
           target="_top">глава 10</a> на сайте <a
           href="http://sunsite.ualberta.ca/Documentation"
           target="_top">University of Alberta</a>.</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14437"></a>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p><a
           href="mailto:humbubba@smarty.smart.net"
           target="_top">Rick Hohensee</a> <a
           href=
          "ftp://ftp.gwdg.de/pub/linux/install/clienux/interim/osimpa.tgz"
           target="_top">osimpa</a> -- ассемблер для процессора i386,
          написан полностью на Bash.</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14442"></a>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Rocky Bernstein ведет разработку <span
           class="QUOTE">&quot;полнофункционального&quot;</span> <a
           href="http://bashdb.sourceforge.net"
           target="_top">отладчика</a> для Bash.</p>

          <p>---</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14448"></a>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Отличное руководство &quot;Bash Reference Manual&quot;,
          авторы Chet Ramey и Brian Fox, распространяется в составе
          пакета &quot;bash-2-doc&quot; (доступен как rpm). В этом
          пакете вы найдете особенно поучительные примеры.</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14451"></a>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Группа новостей <a
           href="news:comp.unix.shell"
           target="_top">comp.os.unix.shell</a>.</p>
        </div>
      </div>
    </div>

    <div
     class="BIBLIOENTRY">
      <a
       name="b14059_html_AEN14455"></a>

      <div
       class="BIBLIOENTRYBLOCK"
       style="margin-left: 0.5in">
        <div
         class="ABSTRACT">
          <p>Страницы руководства man по <strong
           class="COMMAND">bash</strong> и <strong
           class="COMMAND">bash2</strong>, <strong
           class="COMMAND">date</strong>, <strong
           class="COMMAND">expect</strong>, <strong
           class="COMMAND">expr</strong>, <strong
           class="COMMAND">find</strong>, <strong
           class="COMMAND">grep</strong>, <strong
           class="COMMAND">gzip</strong>, <strong
           class="COMMAND">ln</strong>, <strong
           class="COMMAND">patch</strong>, <strong
           class="COMMAND">tar</strong>, <strong
           class="COMMAND">tr</strong>, <strong
           class="COMMAND">bc</strong>, <strong
           class="COMMAND">xargs</strong>. Странички info по <strong
           class="COMMAND">bash</strong>, <strong
           class="COMMAND">dd</strong>, <strong
           class="COMMAND">m4</strong>, <strong
           class="COMMAND">gawk</strong> и <strong
           class="COMMAND">sed</strong>.</p>
        </div>
      </div>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x14001_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#a14477_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Благодарности</td>

          <td
           width="34%"
           align="center"
           valign="top"> </td>

          <td
           width="33%"
           align="right"
           valign="top">Дополнительные примеры сценариев</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="c11441_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#c9708_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#c11565_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="CHAPTER">
      <h1><a
       name="c11441_html_COMMANDSUB"></a>Глава 14. Подстановка команд</h1>

      <p><a
       name="c11441_html_COMMANDSUBREF"></a><strong
       class="COMMAND">Подстановка команд</strong> -- это подстановка
      результатов выполнения команды <a
       name="AEN11451"
       href="#c11441_html_FTN_AEN11451"><span
       class="footnote">[1]</span></a> или даже серии команд;
      буквально, эта операция позволяет вызвать команду в другом
      окружении.</p>

      <p><a
       name="c11441_html_BACKQUOTESREF"></a>Классический пример подстановки команд
      -- использование обратных одиночных кавычек (`...`). Команды
      внутри этих кавычек представляют собой текст командной
      строки.</p>
<pre
 class="PROGRAMLISTING">
script_name=`basename $0`
echo &quot;Имя этого файла-сценария: $script_name.&quot;
</pre>
      <br>
      <br>

      <div
       class="FORMALPARA">
        <p><strong>Вывод от команд может использоваться: как аргумент
        другой команды, для установки значения переменной и даже для
        генерации списка аргументов цикла <a
         href="#c4875_html_FORLOOPREF1">for</a>.</strong></p>
      </div>
<pre
 class="PROGRAMLISTING">
rm `cat filename`   # здесь <span
 class=
"QUOTE">&quot;filename&quot;</span> содержит список удаляемых файлов.
#
# S. C. предупреждает, что в данном случае может возникнуть ошибка &quot;arg list too long&quot;.
# Такой вариант будет лучше:   xargs rm -- &lt; filename
# ( -- подходит для случая, когда <span
 class="QUOTE">&quot;filename&quot;</span> начинается с символа <span
 class="QUOTE">&quot;-&quot;</span> )

textfile_listing=`ls *.txt`
# Переменная содержит имена всех файлов *.txt в текущем каталоге.
echo $textfile_listing

textfile_listing2=$(ls *.txt)   # Альтернативный вариант.
echo $textfile_listing2
# Результат будет тем же самым.

# Проблема записи списка файлов в строковую переменную состоит в том,
# что символы перевода строки заменяются на пробел.
#
# Как вариант решения проблемы -- записывать список файлов в массив.
#      shopt -s nullglob    # При несоответствии, имя файла игнорируется.
#      textfile_listing=( *.txt )
#
# Спасибо S.C.
</pre>
      <br>
      <br>

      <div
       class="CAUTION">
        <table
         class="CAUTION"
         width="100%"
         border="0">
          <tr>
            <td
             width="25"
             align="center"
             valign="top"><img
             src="misc/abs-book/images/caution.gif"
             hspace="5"
             alt="Caution"></td>

            <td
             align="left"
             valign="top">
              <p>Подстанавливаемая команда может получиться разбитой на
              отдельные слова.</p>
<pre
 class="PROGRAMLISTING">
COMMAND `echo a b`     # 2 аргумента: a и b

COMMAND &quot;`echo a b`&quot;   # 1 аргумент: &quot;a b&quot;

COMMAND `echo`         # без аргументов

COMMAND &quot;`echo`&quot;       # один пустой аргумент


# Спасибо S.C.
</pre>
              <br>
              <br>

              <p>Даже когда не происходит разбиения на слова, операция
              подстановки команд может удалять завершающие символы
              перевода строки.</p>
<pre
 class="PROGRAMLISTING">
# cd &quot;`pwd`&quot;  # Должна выполняться всегда.
# Однако...

mkdir &#39;dir with trailing newline
&#39;

cd &#39;dir with trailing newline
&#39;

cd &quot;`pwd`&quot;  # Ошибка:
# bash: cd: /tmp/dir with trailing newline: No such file or directory

cd &quot;$PWD&quot;   # Выполняется без ошибки.





old_tty_setting=$(stty -g)   # Сохранить настройки терминала.
echo &quot;Нажмите клавишу &quot;
stty -icanon -echo           # Запретить &quot;канонический&quot; режим терминала.
                             # Также запрещает эхо-вывод.
key=$(dd bs=1 count=1 2&gt; /dev/null)   # Поймать нажатие на клавишу.
stty &quot;$old_tty_setting&quot;      # Восстановить настройки терминала.
echo &quot;Количество нажатых клавиш = ${#key}.&quot;  # ${#variable} = количество символов в переменной $variable
#
# Нажмите любую клавишу, кроме RETURN, на экране появится &quot;Количество нажатых клавиш = 1.&quot;
# Нажмите RETURN, и получите: &quot;Количество нажатых клавиш = 0.&quot;
# Символ перевода строки будет &quot;съеден&quot; операцией подстановки команды.

Спасибо S.C.
</pre>
              <br>
              <br>
            </td>
          </tr>
        </table>
      </div>

      <div
       class="CAUTION">
        <table
         class="CAUTION"
         width="100%"
         border="0">
          <tr>
            <td
             width="25"
             align="center"
             valign="top"><img
             src="misc/abs-book/images/caution.gif"
             hspace="5"
             alt="Caution"></td>

            <td
             align="left"
             valign="top">
              <p>При выводе значений переменных, полученных в
              результате подстановки команд, командой <strong
               class="COMMAND">echo</strong>, без кавычек, символы
              перевода строки будут удалены. Это может оказаться
              неприятным сюрпризом.</p>
<pre
 class="PROGRAMLISTING">
dir_listing=`ls -l`
echo $dir_listing     # без кавычек

# Вы наверно ожидали увидеть удобочитаемый список каталогов.

# Однако, вы получите:
# total 3 -rw-rw-r-- 1 bozo bozo 30 May 13 17:15 1.txt -rw-rw-r-- 1 bozo
# bozo 51 May 15 20:57 t2.sh -rwxr-xr-x 1 bozo bozo 217 Mar 5 21:13 wi.sh

# Символы перевода строки были заменены пробелами.


echo &quot;$dir_listing&quot;   # в кавычках
# -rw-rw-r--    1 bozo       30 May 13 17:15 1.txt
# -rw-rw-r--    1 bozo       51 May 15 20:57 t2.sh
# -rwxr-xr-x    1 bozo      217 Mar  5 21:13 wi.sh
</pre>
              <br>
              <br>
            </td>
          </tr>
        </table>
      </div>

      <p>Подстановка команд позволяет даже записывать в переменные
      содержимое целых файлов, с помощью <a
       href="#c11620_html_IOREDIRREF">перенаправления</a> или команды <a
       href="#c6407_html_CATREF">cat</a>.</p>
<pre
 class="PROGRAMLISTING">
variable1=`&lt;file1`      # Записать в переменную  &quot;variable1&quot; содержимое файла &quot;file1&quot;.
variable2=`cat file2`   # Записать в переменную &quot;variable2&quot; содержимое файла &quot;file2&quot;.

#  Замечание 1:
#  Удаляются символы перевода строки.
#
#  Замечание 2:
#  В переменные можно записать даже управляющие символы.
</pre>
      <br>
      <br>
<pre
 class="PROGRAMLISTING">
#  Выдержки из системного файла /etc/rc.d/rc.sysinit
#+ (Red Hat Linux)


if [ -f /fsckoptions ]; then
        fsckoptions=`cat /fsckoptions`
...
fi
#
#
if [ -e &quot;/proc/ide/${disk[$device]}/media&quot; ] ; then
             hdmedia=`cat /proc/ide/${disk[$device]}/media`
...
fi
#
#
if [ ! -n &quot;`uname -r | grep -- &quot;-&quot;`&quot; ]; then
       ktag=&quot;`cat /proc/version`&quot;
...
fi
#
#
if [ $usb = &quot;1&quot; ]; then
    sleep 5
    mouseoutput=`cat /proc/bus/usb/devices 2&gt;/dev/null|grep -E &quot;^I.*Cls=03.*Prot=02&quot;`
    kbdoutput=`cat /proc/bus/usb/devices 2&gt;/dev/null|grep -E &quot;^I.*Cls=03.*Prot=01&quot;`
...
fi
</pre>
      <br>
      <br>

      <div
       class="CAUTION">
        <table
         class="CAUTION"
         width="100%"
         border="0">
          <tr>
            <td
             width="25"
             align="center"
             valign="top"><img
             src="misc/abs-book/images/caution.gif"
             hspace="5"
             alt="Caution"></td>

            <td
             align="left"
             valign="top">
              <p>Не используйте переменные для хранения содержимого
              текстовых файлов <span
               class="emphasis"><em
               class="EMPHASIS">большого</em></span> объема, без веских
              на то оснований. Не записывайте в переменные содержимое
              <span
               class="emphasis"><em
               class="EMPHASIS">бинарных</em></span> файлов, даже шутки
              ради.</p>

              <div
               class="EXAMPLE">
                <a
                 name="c11441_html_STUPSCR"></a>

                <p><strong>Пример 14-1. Глупая выходка</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# stupid-script-tricks.sh: Люди! Будьте благоразумны!
# Из &quot;Глупые выходки&quot;, том I.


dangerous_variable=`cat /boot/vmlinuz`   # Сжатое ядро Linux.

echo &quot;длина строки \$dangerous_variable = ${#dangerous_variable}&quot;
# длина строки $dangerous_variable = 794151
# (&#39;wc -c /boot/vmlinuz&#39; даст другой результат.)

# echo &quot;$dangerous_variable&quot;
# Даже не пробуйте раскомментарить эту строку! Это приведет к зависанию сценария.


#  Автор этого документа не знает, где можно было бы использовать
#+ запись содержимого двоичных файлов в переменные.

exit 0
</pre>
              </div>

              <p>Обратите внимание: в данной ситуации не возникает
              ошибки <span
               class="emphasis"><em
               class="EMPHASIS">переполнения буфера</em></span>. Этот
              пример показывает превосходство защищенности
              интерпретирующих языков, таких как Bash, от ошибок
              программиста, над компилирующими языками
              программирования.</p>
            </td>
          </tr>
        </table>
      </div>

      <p>Подстановка команд, позволяет записать в переменную результаты
      выполнения <a
       href="#c4875_html_FORLOOPREF1">цикла</a>. Ключевым моментом здесь
      является команда <a
       href="#c5358_html_ECHOREF">echo</a>, в теле цикла.</p>

      <div
       class="EXAMPLE">
        <a
         name="c11441_html_CSUBLOOP"></a>

        <p><strong>Пример 14-2. Запись результатов выполнения цикла в
        переменную</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# csubloop.sh: Запись результатов выполнения цикла в переменную

variable1=`for i in 1 2 3 4 5
do
  echo -n &quot;$i&quot;                 #  Здесь &#39;echo&#39; -- это ключевой момент
done`

echo &quot;variable1 = $variable1&quot;  # variable1 = 12345


i=0
variable2=`while [ &quot;$i&quot; -lt 10 ]
do
  echo -n &quot;$i&quot;                 # Опять же, команда &#39;echo&#39; просто необходима.
  let &quot;i += 1&quot;                 # Увеличение на 1.
done`

echo &quot;variable2 = $variable2&quot;  # variable2 = 0123456789

exit 0
</pre>
      </div>

      <table
       class="SIDEBAR"
       border="1"
       cellpadding="5">
        <tr>
          <td>
            <div
             class="SIDEBAR">
              <a
               name="c11441_html_AEN11497"></a>

              <p>Подстановка команд позволяет существенно расширить
              набор инструментальных средств, которыми располагает
              Bash. Суть состоит в том, чтобы написать программу или
              сценарий, которая выводит результаты своей работы на <tt
               class="FILENAME">stdout</tt> (как это делает подавляющее
              большинство утилит в UNIX) и записать вывод от программы
              в переменную.</p>
<pre
 class="PROGRAMLISTING">
#include &lt;stdio.h&gt;

/*  Программа на C &quot;Hello, world.&quot;  */

int main()
{
  printf( &quot;Hello, world.&quot; );
  return (0);
}
</pre>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>gcc -o hello hello.c</strong></tt>
             
</pre>
              <br>
              <br>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# hello.sh

greeting=`./hello`
echo $greeting
</pre>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>sh hello.sh</strong></tt>
<tt
 class="COMPUTEROUTPUT">Hello, world.</tt>
               
</pre>
              <br>
              <br>
            </div>
          </td>
        </tr>
      </table>

      <div
       class="NOTE">
        <table
         class="NOTE"
         width="100%"
         border="0">
          <tr>
            <td
             width="25"
             align="center"
             valign="top"><img
             src="misc/abs-book/images/note.gif"
             hspace="5"
             alt="Note"></td>

            <td
             align="left"
             valign="top">
              <p>Альтернативой обратным одиночным кавычкам,
              используемым для подстановки команд, можно считать такую
              форму записи: <strong
               class="COMMAND">$(COMMAND)</strong>.</p>
<pre
 class="PROGRAMLISTING">
output=$(sed -n /&quot;$1&quot;/p $file)   # К примеру из &quot;grp.sh&quot;.

# Запись в переменную содержимого текстового файла.
File_contents1=$(cat $file1)
File_contents2=$(&lt;$file2)        # Bash допускает и такую запись.
</pre>
              <br>
              <br>
            </td>
          </tr>
        </table>
      </div>

      <p>Примеры подстановки команд в сценариях:</p>

      <ol
       type="1">
        <li>
          <p><a
           href="#c4875_html_BINGREP">Пример 10-7</a></p>
        </li>

        <li>
          <p><a
           href="#x5210_html_CASECMD">Пример 10-26</a></p>
        </li>

        <li>
          <p><a
           href="#x4812_html_SEEDINGRANDOM">Пример 9-26</a></p>
        </li>

        <li>
          <p><a
           href="#x6646_html_EX57">Пример 12-2</a></p>
        </li>

        <li>
          <p><a
           href="#x7050_html_LOWERCASE">Пример 12-15</a></p>
        </li>

        <li>
          <p><a
           href="#x7050_html_GRP">Пример 12-12</a></p>
        </li>

        <li>
          <p><a
           href="#x9307_html_EX53">Пример 12-39</a></p>
        </li>

        <li>
          <p><a
           href="#c4875_html_EX24">Пример 10-13</a></p>
        </li>

        <li>
          <p><a
           href="#c4875_html_SYMLINKS">Пример 10-10</a></p>
        </li>

        <li>
          <p><a
           href="#x7794_html_STRIPC">Пример 12-24</a></p>
        </li>

        <li>
          <p><a
           href="#x11731_html_REDIR4">Пример 16-7</a></p>
        </li>

        <li>
          <p><a
           href="#a14477_html_TREE">Пример A-19</a></p>
        </li>

        <li>
          <p><a
           href="#x12987_html_PIDID">Пример 27-1</a></p>
        </li>

        <li>
          <p><a
           href="#x9199_html_MONTHLYPMT">Пример 12-32</a></p>
        </li>

        <li>
          <p><a
           href="#x9199_html_BASE">Пример 12-33</a></p>
        </li>

        <li>
          <p><a
           href="#x9199_html_ALTBC">Пример 12-34</a></p>
        </li>
      </ol>
      <br>
      <br>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN11451"
         href="#c11441_html_AEN11451"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p><span
           class="emphasis"><em
           class="EMPHASIS">Замещающая команда</em></span> может быть
          внешней системной командой, внутренней (встроенной) командой
          или даже функцией в сценарии.</p>
        </td>
      </tr>
    </table>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#c9708_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#c11565_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Команды системного администрирования</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#p3268_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Арифметические подстановки</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="c11565_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#c11441_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#c11620_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="CHAPTER">
      <h1><a
       name="c11565_html_ARITHEXP"></a>Глава 15. Арифметические подстановки</h1>

      <p><a
       name="c11565_html_ARITHEXPREF"></a>Арифметические подстановки -- это мощный
      инструмент, предназначенный для выполнения арифметических
      операций в сценариях. Перевод строки в числовое выражение
      производится с помощью <a
       href="#c11441_html_BACKQUOTESREF">обратных одиночных кавычек</a>,
      <a
       href="#x4862_html">двойных круглых скобок</a> или предложения <a
       href="#c5358_html_LETREF">let</a>.</p>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="c11565_html_ARITHEXPVAR1"></a>Вариации</strong></p>

        <dl>
          <dt>Арифметические подстановки в обратных одиночных кавычках
          (часто используются совместно с командой <a
           href="#x6646_html_EXPRREF">expr</a>)</dt>

          <dd>
<pre
 class="PROGRAMLISTING">
z=`expr $z + 3`            # Команда &#39;expr&#39; вычисляет значение выражения.
</pre>
            <br>
            <br>
          </dd>

          <dt>Арифметические подстановки в двойных круглых скобках, и
          предложение <strong
           class="COMMAND">let</strong></dt>

          <dd>
            <p>В арифметических подстановках, обратные одиночные
            кавычки могут быть заменены на двойные круглые скобки <tt
             class="USERINPUT"><strong>$((...))</strong></tt> или очень
            удобной конструкцией, с применением предложения <strong
             class="COMMAND">let</strong>.</p>
<pre
 class="PROGRAMLISTING">
z=$(($z+3))
# $((EXPRESSION)) -- это подстановка арифметического выражения.  #  Не путайте с
                                                                 #+ подстановкой команд.

let z=z+3
let &quot;z += 3&quot;  # Кавычки позволяют вставляьб пробелы и специальные операторы.
#  Оператор &#39;let&#39; вычисляет арифметическое выражение,
#+ это не подстановка арифметического выражения.
</pre>
            Все вышеприведенные примеры эквивалентны. Вы можете
            использовать любую из этих форм записи <span
             class="QUOTE">&quot;по своему вкусу&quot;</span>. <br>
            <br>

            <p>Примеры арифметических подстановок в сценариях:</p>

            <ol
             type="1">
              <li>
                <p><a
                 href="#x6646_html_EX45">Пример 12-6</a></p>
              </li>

              <li>
                <p><a
                 href="#c4875_html_EX25">Пример 10-14</a></p>
              </li>

              <li>
                <p><a
                 href="#c12790_html_EX66">Пример 25-1</a></p>
              </li>

              <li>
                <p><a
                 href="#c12790_html_BUBBLE">Пример 25-6</a></p>
              </li>

              <li>
                <p><a
                 href="#a14477_html_TREE">Пример A-19</a></p>
              </li>
            </ol>
            <br>
            <br>
          </dd>
        </dl>
      </div>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#c11441_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#c11620_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Подстановка команд</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#p3268_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Перенаправление ввода/вывода</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="c11620_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#c11565_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x11731_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="CHAPTER">
      <h1><a
       name="c11620_html_IO-REDIRECTION"></a>Глава 16. Перенаправление
      ввода/вывода</h1>

      <p><a
       name="c11620_html_IOREDIRREF"></a></p>

      <p>В системе по-умолчанию всегда открыты три <span
       class="QUOTE">&quot;файла&quot;</span> -- <tt
       class="FILENAME">stdin</tt> (клавиатура), <tt
       class="FILENAME">stdout</tt> (экран) и <tt
       class="FILENAME">stderr</tt> (вывод сообщений об ошибках на
      экран). Эти, и любые другие открытые файлы, могут быть
      перенапрвлены. В данном случае, термин
      &quot;перенаправление&quot; означает получить вывод из файла,
      команды, программы, сценария или даже отдельного блока в сценарии
      (см. <a
       href="#c301_html_EX8">Пример 3-1</a> и <a
       href="#c301_html_RPMCHECK">Пример 3-2</a>) и передать его на вход
      в другой файл, команду, программу или сценарий.</p>

      <p><a
       name="c11620_html_FDREF"></a>С каждым открытым файлом связан дескриптор
      файла. <a
       name="AEN11633"
       href="#c11620_html_FTN_AEN11633"><span
       class="footnote">[1]</span></a> Дескрипторы файлов <tt
       class="FILENAME">stdin</tt>, <tt
       class="FILENAME">stdout</tt> и <tt
       class="FILENAME">stderr</tt> -- 0, 1 и 2, соответственно. При
      открытии дополнительных файлов, дескрипторы с 3 по 9 остаются
      незанятыми. Иногда дополнительные дескрипторы могут сослужить
      неплохую службу, временно сохраняя в себе ссылку на <tt
       class="FILENAME">stdin</tt>, <tt
       class="FILENAME">stdout</tt> или <tt
       class="FILENAME">stderr</tt>. <a
       name="AEN11642"
       href="#c11620_html_FTN_AEN11642"><span
       class="footnote">[2]</span></a> Это упрощает возврат
      дескрипторов в нормальное состояние после сложных манипуляций с
      перенаправлением и перестановками (см. <a
       href="#c11620_html_REDIR1">Пример 16-1</a>).</p>

      <p><a
       name="c11620_html_IOREDIRECTIONREF"></a></p>
<pre
 class="PROGRAMLISTING">
   COMMAND_OUTPUT &gt;
      # Перенаправление stdout (вывода) в файл.
      # Если файл отсутствовал, то он создется, иначе -- перезаписывается.

      ls -lR &gt; dir-tree.list
      # Создает файл, содержащий список дерева каталогов.

   : &gt; filename
      # Операция &gt; усекает файл &quot;filename&quot; до нулевой длины.
      # Если до выполнения операции файла не существовало,
      # то создается новый файл с нулевой длиной (тот же эффект дает команда &#39;touch&#39;).
      # Символ : выступает здесь в роли местозаполнителя, не выводя ничего.

   &gt; filename
      # Операция &gt; усекает файл &quot;filename&quot; до нулевой длины.
      # Если до выполнения операции файла не существовало,
      # то создается новый файл с нулевой длиной (тот же эффект дает команда &#39;touch&#39;).
      # (тот же результат, что и выше -- &quot;: &gt;&quot;, но этот вариант неработоспособен
      # в некоторых командных оболочках.)

   COMMAND_OUTPUT &gt;&gt;
      # Перенаправление stdout (вывода) в файл.
      # Создает новый файл, если он отсутствовал, иначе -- дописывает в конец файла.


      # Однострочные команды перенаправления
      # (затрагивают только ту строку, в которой они встречаются):
      # --------------------------------------------------------------------

   1&gt;filename
      # Перенаправление вывода (stdout) в файл &quot;filename&quot;.
   1&gt;&gt;filename
      # Перенаправление вывода (stdout) в файл &quot;filename&quot;, файл открывается в режиме добавления.
   2&gt;filename
      # Перенаправление stderr в файл &quot;filename&quot;.
   2&gt;&gt;filename
      # Перенаправление stderr в файл &quot;filename&quot;, файл открывается в режиме добавления.
   &amp;&gt;filename
      # Перенаправление stdout и stderr в файл &quot;filename&quot;.

      #==============================================================================
      # Перенаправление stdout, только для одной строки.
      LOGFILE=script.log

      echo &quot;Эта строка будет записана в файл \&quot;$LOGFILE\&quot;.&quot; 1&gt;$LOGFILE
      echo &quot;Эта строка будет добавлена в конец файла \&quot;$LOGFILE\&quot;.&quot; 1&gt;&gt;$LOGFILE
      echo &quot;Эта строка тоже будет добавлена в конец файла \&quot;$LOGFILE\&quot;.&quot; 1&gt;&gt;$LOGFILE
      echo &quot;Эта строка будет выведена на экран и не попадет в файл \&quot;$LOGFILE\&quot;.&quot;
      # После каждой строки, сделанное перенаправление автоматически &quot;сбрасывается&quot;.



      # Перенаправление stderr, только для одной строки.
      ERRORFILE=script.errors

      bad_command1 2&gt;$ERRORFILE       #  Сообщение об ошибке запишется в $ERRORFILE.
      bad_command2 2&gt;&gt;$ERRORFILE      #  Сообщение об ошибке добавится в конец $ERRORFILE.
      bad_command3                    #  Сообщение об ошибке будет выведено на stderr,
                                      #+ и не попадет в $ERRORFILE.
      # После каждой строки, сделанное перенаправление также автоматически &quot;сбрасывается&quot;.
      #==============================================================================



   2&gt;&amp;1
      # Перенаправляется stderr на stdout.
      # Сообщения об ошибках передаются туда же, куда и стандартный вывод.

   i&gt;&amp;j
      # Перенаправляется файл с дескриптором <span
 class="emphasis"><em
 class="EMPHASIS">i</em></span> в <span
 class="emphasis"><em
 class="EMPHASIS">j</em></span>.
      # Вывод в файл с дескриптором <span
 class="emphasis"><em
 class="EMPHASIS">i</em></span> передается в файл с дескриптором <span
 class="emphasis"><em
 class="EMPHASIS">j</em></span>.

   &gt;&amp;j
      # Перенаправляется  файл с дескриптором <span
 class="emphasis"><em
 class="EMPHASIS">1</em></span> (stdout) в файл с дескриптором <span
 class="emphasis"><em
 class="EMPHASIS">j</em></span>.
      # Вывод на stdout передается в файл с дескриптором <span
 class="emphasis"><em
 class="EMPHASIS">j</em></span>.

   0&lt; FILENAME
    &lt; FILENAME
      # Ввод из файла.
      # Парная команде <span
 class=
"QUOTE">&quot;&gt;&quot;</span>, часто встречается в комбинации с ней.
      #
      # grep search-word &lt;filename


   [j]&lt;&gt;filename
      # Файл &quot;filename&quot; открывается на чтение и запись, и связывается с дескриптором &quot;j&quot;.
      # Если &quot;filename&quot; отсутствует, то он создается.
      # Если дескриптор &quot;j&quot; не указан, то, по-умолчанию, бередся дескриптор 0, stdin.
      #
      # Как одно из применений этого -- запись в конкретную позицию в файле.
      echo 1234567890 &gt; File    # Записать строку в файл &quot;File&quot;.
      exec 3&lt;&gt; File       # Открыть &quot;File&quot; и связать с дескриптором 3.
      read -n 4 &lt;&amp;3             # Прочитать 4 символа.
      echo -n . &gt;&amp;3             # Записать символ точки.
      exec 3&gt;&amp;-                 # Закрыть дескриптор 3.
      cat File                  # ==&gt; 1234.67890
      # Произвольный доступ, да и только!



   |
      # Конвейер (канал).
      # Универсальное средство для объединения команд в одну цепочку.
      # Похоже на <span
 class=
"QUOTE">&quot;&gt;&quot;</span>, но на самом деле -- более обширная.
      # Используется для объединения команд, сценариев, файлов и программ в одну цепочку (конвейер).
      cat *.txt | sort | uniq &gt; result-file
      # Содержимое всех файлов .txt сортируется, удаляются повторяющиеся строки,
      # результат сохраняется в файле <span
 class="QUOTE">&quot;result-file&quot;</span>.
</pre>

      <p>Операции перенаправления и/или конвейеры могут комбинироваться
      в одной командной строке.</p>
<pre
 class="PROGRAMLISTING">
command &lt; input-file &gt; output-file

command1 | command2 | command3 &gt; output-file
</pre>
      См. <a
       href="#x7794_html_DERPM">Пример 12-23</a> и <a
       href="#a14477_html_FIFO">Пример A-17</a>.<br>
      <br>

      <p>Допускается перенаправление нескольких потоков в один
      файл.</p>
<pre
 class="PROGRAMLISTING">
ls -yz &gt;&gt; command.log 2&gt;&amp;1
# Сообщение о неверной опции &quot;yz&quot; в команде &quot;ls&quot; будет записано в файл &quot;command.log&quot;.
# Поскольку stderr перенаправлен в файл.
</pre>
      <br>
      <br>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="c11620_html_CFD"></a>Закрытие дескрипторов файлов</strong></p>

        <dl>
          <dt><span
           class="TOKEN">n&lt;&amp;-</span></dt>

          <dd>
            <p>Закрыть дескриптор входного файла <tt
             class="REPLACEABLE"><em>n</em></tt>.</p>
          </dd>

          <dt><span
           class="TOKEN">0&lt;&amp;-</span>, <span
           class="TOKEN">&lt;&amp;-</span></dt>

          <dd>
            <p>Закрыть <tt
             class="FILENAME">stdin</tt>.</p>
          </dd>

          <dt><span
           class="TOKEN">n&gt;&amp;-</span></dt>

          <dd>
            <p>Закрыть дескриптор выходного файла <tt
             class="REPLACEABLE"><em>n</em></tt>.</p>
          </dd>

          <dt><span
           class="TOKEN">1&gt;&amp;-</span>, <span
           class="TOKEN">&gt;&amp;-</span></dt>

          <dd>
            <p>Закрыть <tt
             class="FILENAME">stdout</tt>.</p>
          </dd>
        </dl>
      </div>

      <p>Дочерние процессы наследуют дескрипторы открытых файлов. По
      этой причине и работают конвейеры. Чтобы предотвратить
      наследование дескрипторов -- закройте их перед запуском дочернего
      процесса.</p>
<pre
 class="PROGRAMLISTING">
# В конвейер передается только stderr.

exec 3&gt;&amp;1                              # Сохранить текущее &quot;состояние&quot; stdout.
ls -l 2&gt;&amp;1 &gt;&amp;3 3&gt;&amp;- | grep bad 3&gt;&amp;-    # Закрыть дескр. 3 для &#39;grep&#39; (но не для &#39;ls&#39;).
#              ^^^^   ^^^^
exec 3&gt;&amp;-                              # Теперь закрыть его для оставшейся части сценария.

# Спасибо S.C.
</pre>
      <br>
      <br>

      <p>Дополнительные сведения о перенаправлении ввода/вывода вы
      найдете в <a
       href="#a14967_html">Приложение D</a>.</p>

      <div
       class="SECT1">
        <h1
         class="SECT1"><a
         name="c11620_html_AEN11702"></a>16.1. С помощью команды <strong
         class="COMMAND">exec</strong></h1>

        <p>Команда <strong
         class="COMMAND">exec &lt;filename</strong> перенаправляет ввод
        со <tt
         class="FILENAME">stdin</tt> на файл. С этого момента весь
        ввод, вместо <tt
         class="FILENAME">stdin</tt> (обычно это клавиатура), будет
        производиться из этого файла. Это дает возможность читать
        содержимое файла, строку за строкой, и анализировать каждую
        введенную строку с помощью <a
         href="#a14586_html_SEDREF">sed</a> и/или <a
         href="#x14802_html_AWKREF">awk</a>.</p>

        <div
         class="EXAMPLE">
          <a
           name="c11620_html_REDIR1"></a>

          <p><strong>Пример 16-1. Перенаправление <tt
           class="FILENAME">stdin</tt> с помощью exec</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Перенаправление stdin с помощью &#39;exec&#39;.


exec 6&lt;&amp;0          # Связать дескр. #6 со стандартным вводом (stdin).
                   # Сохраняя stdin.

exec &lt; data-file   # stdin заменяется файлом &quot;data-file&quot;

read a1            # Читается первая строка из &quot;data-file&quot;.
read a2            # Читается вторая строка из &quot;data-file.&quot;

echo
echo &quot;Следующие строки были прочитаны из файла.&quot;
echo &quot;-----------------------------------------&quot;
echo $a1
echo $a2

echo; echo; echo

exec 0&lt;&amp;6 6&lt;&amp;-
#  Восстанавливается stdin из дескр. #6, где он был предварительно сохранен,
#+ и дескр. #6 закрывается ( 6&lt;&amp;- ) освобождая его для других процессов.
#
# &lt;&amp;6 6&lt;&amp;-    дает тот же результат.

echo -n &quot;Введите строку  &quot;
read b1  # Теперь функция &quot;read&quot;, как и следовало ожидать, принимает данные с обычного stdin.
echo &quot;Строка, принятая со stdin.&quot;
echo &quot;--------------------------&quot;
echo &quot;b1 = $b1&quot;

echo

exit 0
</pre>
        </div>

        <p>Аналогично, конструкция <strong
         class="COMMAND">exec &gt;filename</strong> перенаправляет
        вывод на <tt
         class="FILENAME">stdout</tt> в заданный файл. После этого,
        весь вывод от команд, который обычно направляется на <tt
         class="FILENAME">stdout</tt>, теперь выводится в этот
        файл.</p>

        <div
         class="EXAMPLE">
          <a
           name="c11620_html_REASSIGNSTDOUT"></a>

          <p><strong>Пример 16-2. Перенаправление <tt
           class="FILENAME">stdout</tt> с помощью exec</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# reassign-stdout.sh

LOGFILE=logfile.txt

exec 6&gt;&amp;1           # Связать дескр. #6 со stdout.
                    # Сохраняя stdout.

exec &gt; $LOGFILE     # stdout замещается файлом &quot;logfile.txt&quot;.

# ----------------------------------------------------------- #
# Весь вывод от команд, в данном блоке, записывается в файл $LOGFILE.

echo -n &quot;Logfile: &quot;
date
echo &quot;-------------------------------------&quot;
echo

echo &quot;Вывод команды \&quot;ls -al\&quot;&quot;
echo
ls -al
echo; echo
echo &quot;Вывод команды \&quot;df\&quot;&quot;
echo
df

# ----------------------------------------------------------- #

exec 1&gt;&amp;6 6&gt;&amp;-      # Восстановить stdout и закрыть дескр. #6.

echo
echo &quot;== stdout восстановлено в значение по-умолчанию == &quot;
echo
ls -al
echo

exit 0
</pre>
        </div>

        <div
         class="EXAMPLE">
          <a
           name="c11620_html_UPPERCONV"></a>

          <p><strong>Пример 16-3. Одновременное перенаправление
          устройств, <tt
           class="FILENAME">stdin</tt> и <tt
           class="FILENAME">stdout</tt>, с помощью команды
          exec</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# upperconv.sh
# Преобразование символов во входном файле в верхний регистр.

E_FILE_ACCESS=70
E_WRONG_ARGS=71

if [ ! -r &quot;$1&quot; ]     # Файл доступен для чтения?
then
  echo &quot;Невозможно прочитать из заданного файла!&quot;
  echo &quot;Порядок использования: $0 input-file output-file&quot;
  exit $E_FILE_ACCESS
fi                   #  В случае, если входной файл ($1) не задан
                     #+ код завершения будет этим же.

if [ -z &quot;$2&quot; ]
then
  echo &quot;Необходимо задать выходной файл.&quot;
  echo &quot;Порядок использования: $0 input-file output-file&quot;
  exit $E_WRONG_ARGS
fi


exec 4&lt;&amp;0
exec &lt; $1            # Назначить ввод из входного файла.

exec 7&gt;&amp;1
exec &gt; $2            # Назначить вывод в выходной файл.
                     # Предполагается, что выходной файл доступен для записи
                     # (добавить проверку?).

# -----------------------------------------------
    cat - | tr a-z A-Z   # Перевод в верхний регистр
#   ^^^^^                # Чтение со stdin.
#           ^^^^^^^^^^   # Запись в stdout.
# Однако, и stdin и stdout были перенаправлены.
# -----------------------------------------------

exec 1&gt;&amp;7 7&gt;&amp;-       # Восстановить stdout.
exec 0&lt;&amp;4 4&lt;&amp;-       # Восстановить stdin.

# После восстановления, следующая строка выводится на stdout, чего и следовало ожидать.
echo &quot;Символы из \&quot;$1\&quot; преобразованы в верхний регистр, результат записан в \&quot;$2\&quot;.&quot;

exit 0
</pre>
        </div>
      </div>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN11633"
         href="#c11620_html_AEN11633"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p><span
           class="emphasis"><em
           class="EMPHASIS">дескриптор файла</em></span> -- это просто
          число, по которому система идентифицирует открытые файлы.
          Рассматривайте его как упрощенную версию указателя на
          файл.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN11642"
         href="#c11620_html_AEN11642"><span
         class="footnote">[2]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>При использрвании <tt
           class="REPLACEABLE"><em>дескриптора с номером 5</em></tt>
          могут возникать проблемы. Когда Bash порождает дочерний
          процесс, например командой <a
           href="#c5358_html_EXECREF">exec</a>, то дочерний процесс
          наследует дескриптор 5 как &quot;открытый&quot; (см. архив
          почты Чета Рамея (Chet Ramey), <a
           href=
          "http://www.geocrawler.com/archives/3/342/1996/1/0/1939805/"
           target="_top">SUBJECT: RE: File descriptor 5 is held
          open</a>) Поэтому, лучше не использовать этот дескриптор.</p>
        </td>
      </tr>
    </table>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#c11565_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x11731_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Арифметические подстановки</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#p3268_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Перенаправление для блоков кода</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="c11785_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x11778_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#p11889_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="CHAPTER">
      <h1><a
       name="c11785_html_HERE-DOCS"></a>Глава 17. Встроенные документы</h1>

      <p><a
       name="c11785_html_HEREDOCREF"></a></p>

      <p><em
       class="FIRSTTERM">Встроенный документ</em> (here document)
      является специальной формой <a
       href="#c11620_html_IOREDIRREF">перенаправления ввода/вывода</a>,
      которая позволяет передать список команд интерактивной программе
      или команде, например <a
       href="#x8707_html_FTPREF">ftp</a>, <a
       href="#x8707_html_TELNETREF">telnet</a> или <strong
       class="COMMAND">ex</strong>. Конец встроенного документа
      выделяется <span
       class="QUOTE">&quot;строкой-ограничителем&quot;</span>, которая
      задается с помощью специальной последовательности символов <span
       class="TOKEN">&lt;&lt;</span>. Эта последовательность -- есть
      перенаправление вывода из файла в программу, напоминает
      конструкцию <tt
       class="USERINPUT"><strong>interactive-program &lt;
      command-file</strong></tt>, где <tt
       class="FILENAME">command-file</tt> содержит строки:</p>
<pre
 class="PROGRAMLISTING">
command #1
command #2
...
</pre>
      <br>
      <br>

      <p>Сценарий, использующий <span
       class="QUOTE">&quot;встроенный документ&quot;</span> для тех же
      целей, может выглядеть примерно так:</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
interactive-program &lt;&lt;LimitString
command #1
command #2
...
LimitString
</pre>
      <br>
      <br>

      <p>В качестве строки-ограничителя должна выбираться такая
      последовательность символов, которая не будет встречаться в теле
      <span
       class="QUOTE">&quot;встроенного документа&quot;</span>.</p>

      <p>Обратите внимание: использование <span
       class="emphasis"><em
       class="EMPHASIS">встроенных документов</em></span> может иногда
      с успехом применяться и при работе с неинтерактивными командами и
      утилитами.</p>

      <div
       class="EXAMPLE">
        <a
         name="c11785_html_EX69"></a>

        <p><strong>Пример 17-1. dummyfile: Создание 2-х строчного
        файла-заготовки</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Неинтерактивное редактирование файла с помощью &#39;vi&#39;.
# Эмуляция &#39;sed&#39;.

E_BADARGS=65

if [ -z &quot;$1&quot; ]
then
  echo &quot;Порядок использования: `basename $0` filename&quot;
  exit $E_BADARGS
fi

TARGETFILE=$1

# Вставить 2 строки в файл и сохранить.
#--------Начало встроенного документа-----------#
vi $TARGETFILE &lt;&lt;x23LimitStringx23
i
Это строка 1.
Это строка 2.
^[
ZZ
x23LimitStringx23
#----------Конец встроенного документа-----------#

#  Обратите внимание: ^[, выше -- это escape-символ
#+ Control-V &lt;Esc&gt;.

#  Bram Moolenaar указывает, что этот скрипт может не работать с &#39;vim&#39;,
#+ из-за возможных проблем взаимодействия с терминалом.

exit 0
</pre>
      </div>

      <p>Этот сценарий, с тем же эффектом, мог бы быть реализован,
      основываясь не на <strong
       class="COMMAND">vi</strong>, а на <strong
       class="COMMAND">ex</strong>. Встроенные документы, содержащие
      команды для <strong
       class="COMMAND">ex</strong>, стали настолько обычным делом, что
      их уже смело можно вынести в отдельную категорию -- <em
       class="FIRSTTERM">ex-сценарии</em>.</p>

      <div
       class="EXAMPLE">
        <a
         name="c11785_html_EX70"></a>

        <p><strong>Пример 17-2. broadcast: Передача сообщения всем,
        работающим в системе, пользователям</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

wall &lt;&lt;zzz23EndOfMessagezzz23
Пошлите, по электронной почте, ваш заказ на пиццу, системному администратору.
    (Добавьте дополнительный доллар, если вы желаете положить на пиццу анчоусы или грибы.)
# Внимание: строки комментария тоже будут переданы команде &#39;wall&#39; как часть текста.
zzz23EndOfMessagezzz23

# Возможно, более эффективно это может быть сделано так:
#         wall &lt;message-file
# Однако, встроенный документ помогает сэкономить ваши силы и время.

exit 0
</pre>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="c11785_html_EX71"></a>

        <p><strong>Пример 17-3. Вывод многострочных сообщений с помощью
        cat</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Команда &#39;echo&#39; прекрасно справляется с выводом однострочных сообщений,
# но иногда необходимо вывести несколько строк.
# Команда &#39;cat&#39; и встроенный документ помогут вам в этом.

cat &lt;&lt;End-of-message
-------------------------------------
Это первая строка сообщения.
Это вторая строка сообщения.
Это третья строка сообщения.
Это четвертая строка сообщения.
Это последняя строка сообщения.
-------------------------------------
End-of-message

exit 0


#--------------------------------------------
# Команда &quot;exit 0&quot;, выше, не позволить исполнить нижележащие строки.

# S.C. отмечает, что следующий код работает точно так же.
echo &quot;-------------------------------------
Это первая строка сообщения.
Это вторая строка сообщения.
Это третья строка сообщения.
Это четвертая строка сообщения.
Это последняя строка сообщения.
-------------------------------------&quot;
# Однако, в этом случае, двойные кавычки в теле сообщения, должны экранироваться.
</pre>
      </div>

      <p>Если строка-ограничитель встроенного документа начинается с
      символа <tt
       class="OPTION">-</tt> (<tt
       class="USERINPUT"><strong>&lt;&lt;-LimitString</strong></tt>),
      то это приводит к подавлению вывода символов табуляции (но не
      пробелов). Это может оказаться полезным при форматировании текста
      сценария для большей удобочитаемости.</p>

      <div
       class="EXAMPLE">
        <a
         name="c11785_html_EX71A"></a>

        <p><strong>Пример 17-4. Вывод многострочных сообщений с
        подавлением символов табуляции</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# То же, что и предыдущий сценарий, но...

#  Символ &quot;-&quot;, начинающий строку-ограничитель встроенного документа: &lt;&lt;-
#  подавляет вывод символов табуляции, которые могут встречаться в теле документа,
#  но не пробелов.

cat &lt;&lt;-ENDOFMESSAGE
        Это первая строка сообщения.
        Это вторая строка сообщения.
        Это третья строка сообщения.
        Это четвертая строка сообщения.
        Это последняя строка сообщения.
ENDOFMESSAGE
# Текст, выводимый сценарием, будет смещен влево.
# Ведущие символы табуляции не будут выводиться.

# Вышеприведенные 5 строк текста &quot;сообщения&quot; начинаются с табуляции, а не с пробелов.


exit 0
</pre>
      </div>

      <p>Встроенные документы поддерживают подстановку команд и
      параметров. Что позволяет передавать различные параметры в тело
      встроенного документа.</p>

      <div
       class="EXAMPLE">
        <a
         name="c11785_html_EX71B"></a>

        <p><strong>Пример 17-5. Встроенные документы и подстановка
        параметров</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Вывод встроенного документа командой &#39;cat&#39;, с использованием подстановки параметров.

# Попробуйте запустить сценарий без аргументов,   ./scriptname
# Попробуйте запустить сценарий с одним аргументом,   ./scriptname Mortimer
# Попробуйте запустить сценарий с одним аргументом, из двух слов, в кавычках,
#                           ./scriptname &quot;Mortimer Jones&quot;

CMDLINEPARAM=1     # Минимальное число аргументов командной строки.

if [ $# -ge $CMDLINEPARAM ]
then
  NAME=$1          # Если аргументов больше одного,
                   # то рассматривается только первый.
else
  NAME=&quot;John Doe&quot;  # По-умолчанию, если сценарий запущен без аргументов.
fi

RESPONDENT=&quot;автора этого сценария&quot;


cat &lt;&lt;Endofmessage

Привет, $NAME!
Примите поздравления от $RESPONDENT.

# Этот комментарий тоже выводится (почему?).

Endofmessage

# Обратите внимание на то, что пустые строки тоже выводятся.

exit 0
</pre>
      </div>

      <p>Заключая строку-ограничитель в кавычки или экранируя ее, можно
      запретить подстановку параметров в теле встроенного
      документа.</p>

      <div
       class="EXAMPLE">
        <a
         name="c11785_html_EX71C"></a>

        <p><strong>Пример 17-6. Отключение подстановки
        параметров</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Вывод встроенного документа командой &#39;cat&#39;, с запретом подстановки параметров.

NAME=&quot;John Doe&quot;
RESPONDENT=&quot;автора этого сценария&quot;

cat &lt;&lt;&#39;Endofmessage&#39;

Привет, $NAME.
Примите поздравления от $RESPONDENT.

Endofmessage

#  Подстановка параметров не производится, если строка ограничитель
#  заключена в кавычки или экранирована.
#  Тот же эффект дают:
#  cat &lt;&lt;&quot;Endofmessage&quot;
#  cat &lt;&lt;\Endofmessage

exit 0
</pre>
      </div>

      <p>Еще один пример сценария, содержащего встроенный документ и
      подстановку параметров в его теле.</p>

      <div
       class="EXAMPLE">
        <a
         name="c11785_html_EX72"></a>

        <p><strong>Пример 17-7. Передача пары файлов во входящий
        каталог на <span
         class="QUOTE">&quot;Sunsite&quot;</span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# upload.sh

# Передача пары файлов (Filename.lsm, Filename.tar.gz)
# на Sunsite (ibiblio.org).

E_ARGERROR=65

if [ -z &quot;$1&quot; ]
then
  echo &quot;Порядок использования: `basename $0` filename&quot;
  exit $E_ARGERROR
fi


Filename=`basename $1`           # Отсечь имя файла от пути к нему.

Server=&quot;ibiblio.org&quot;
Directory=&quot;/incoming/Linux&quot;
# Вообще, эти строки должны бы не &quot;зашиваться&quot; жестко в сценарий,
# а приниматься в виде аргумента из командной строки.

Password=&quot;your.e-mail.address&quot;   # Измените на свой.

ftp -n $Server &lt;&lt;End-Of-Session
# Ключ -n запрещает автоматическую регистрацию (auto-logon)

user anonymous &quot;$Password&quot;
binary
bell                # &quot;Звякнуть&quot; после передачи каждого файла
cd $Directory
put &quot;$Filename.lsm&quot;
put &quot;$Filename.tar.gz&quot;
bye
End-Of-Session

exit 0
</pre>
      </div>

      <p>Встроенные документы могут передаваться на вход функции,
      находящейся в том же сценарии.</p>

      <div
       class="EXAMPLE">
        <a
         name="c11785_html_HF"></a>

        <p><strong>Пример 17-8. Встроенные документы и
        функции</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# here-function.sh

GetPersonalData ()
{
  read firstname
  read lastname
  read address
  read city
  read state
  read zipcode
} # Это немного напоминает интерактивную функцию, но...


# Передать ввод в функцию.
GetPersonalData &lt;&lt;RECORD001
Bozo
Bozeman
2726 Nondescript Dr.
Baltimore
MD
21226
RECORD001


echo
echo &quot;$firstname $lastname&quot;
echo &quot;$address&quot;
echo &quot;$city, $state $zipcode&quot;
echo

exit 0
</pre>
      </div>

      <p><a
       name="c11785_html_ANONHEREDOC0"></a></p>

      <p>Встроенный документ можно передать &quot;пустой команде&quot;
      <span
       class="TOKEN">:</span>. Такая конструкция, фактически, создает
      <span
       class="QUOTE">&quot;анонимный&quot;</span> встроенный
      документ.</p>

      <div
       class="EXAMPLE">
        <a
         name="c11785_html_ANONHEREDOC"></a>

        <p><strong>Пример 17-9. <span
         class="QUOTE">&quot;Анонимный&quot;</span> Встроенный
        Документ</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

: &lt;&lt;TESTVARIABLES
${HOSTNAME?}${USER?}${MAIL?}  # Если одна из переменных не определена, то выводится сообщение об ошибке.
TESTVARIABLES

exit 0
</pre>
      </div>

      <p><a
       name="c11785_html_CBLOCK1"></a></p>

      <div
       class="TIP">
        <table
         class="TIP"
         width="100%"
         border="0">
          <tr>
            <td
             width="25"
             align="center"
             valign="top"><img
             src="misc/abs-book/images/tip.gif"
             hspace="5"
             alt="Tip"></td>

            <td
             align="left"
             valign="top">
              <p>Подобную технику можно использовать для создания <span
               class="QUOTE">&quot;блочных
              комментариев&quot;</span>.</p>
            </td>
          </tr>
        </table>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="c11785_html_COMMENTBLOCK"></a>

        <p><strong>Пример 17-10. Блочный комментарий</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# commentblock.sh

: &lt;&lt; COMMENTBLOCK
echo &quot;Эта строка не будет выведена.&quot;
Эта строка комментария не начинается с символа &quot;#&quot;.
Это еще одна строка комментария, которая начинается не с символа &quot;#&quot;.

&amp;*@!!++=
Эта строка не вызовет ошибки,
поскольку Bash проигнорирует ее.
COMMENTBLOCK

echo &quot;Код завершения  \&quot;COMMENTBLOCK\&quot; = $?.&quot;   # 0
# Показывает, что ошибок не возникало.


#  Такая методика создания блочных комментариев
#+ может использоваться для комментирования блоков кода во время отладки.
#  Это экономит силы и время, т.к. не нужно втавлять символ &quot;#&quot; в начале каждой строки,
#+ а затем удалять их.

: &lt;&lt; DEBUGXXX
for file in *
do
 cat &quot;$file&quot;
done
DEBUGXXX

exit 0
</pre>
      </div>

      <div
       class="TIP">
        <table
         class="TIP"
         width="100%"
         border="0">
          <tr>
            <td
             width="25"
             align="center"
             valign="top"><img
             src="misc/abs-book/images/tip.gif"
             hspace="5"
             alt="Tip"></td>

            <td
             align="left"
             valign="top">
              <p>Еще одно остроумное применение встроенных документов
              -- встроенная справка к сценарию.</p>
            </td>
          </tr>
        </table>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="c11785_html_SELFDOCUMENT"></a>

        <p><strong>Пример 17-11. Встроенная справка к
        сценарию</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# self-document.sh: сценарий со встроенной справкой
# Модификация сценария &quot;colm.sh&quot;.

DOC_REQUEST=70

if [ &quot;$1&quot; = &quot;-h&quot;  -o &quot;$1&quot; = &quot;--help&quot; ]     # Request help.
then
  echo; echo &quot;Порядок использования: $0 [directory-name]&quot;; echo
  sed --silent -e &#39;/DOCUMENTATIONXX$/,/^DOCUMENTATION/p&#39; &quot;$0&quot; |
  sed -e &#39;/DOCUMENTATIONXX/d&#39;; exit $DOC_REQUEST; fi

: &lt;&lt; DOCUMENTATIONXX
Сценарий выводит сведения о заданном каталоге в виде таблице.
-------------------------------------------------------------
Сценарию необходимо передать имя каталога. Если каталог не
указан или он недоступен для чтения, то выводятся сведения
о текущем каталоге.

DOCUMENTATIONXX

if [ -z &quot;$1&quot; -o ! -r &quot;$1&quot; ]
then
  directory=.
else
  directory=&quot;$1&quot;
fi

echo &quot;Сведения о каталоге &quot;$directory&quot;:&quot;; echo
(printf &quot;PERMISSIONS LINKS OWNER GROUP SIZE MONTH DAY HH:MM PROG-NAME\n&quot; \
; ls -l &quot;$directory&quot; | sed 1d) | column -t

exit 0
</pre>
      </div>

      <div
       class="NOTE">
        <table
         class="NOTE"
         width="100%"
         border="0">
          <tr>
            <td
             width="25"
             align="center"
             valign="top"><img
             src="misc/abs-book/images/note.gif"
             hspace="5"
             alt="Note"></td>

            <td
             align="left"
             valign="top">
              <p>Для встроенных документов, во время исполнения,
              создаются временные файлы, но эти файлы удаляются после
              открытия и недоступны для других процессов.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>bash -c &#39;lsof -a -p $$ -d0&#39; &lt;&lt; EOF</strong></tt>
<tt
 class="PROMPT">&gt;</tt> <tt
 class="USERINPUT"><strong>EOF</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">lsof    1213 bozo    0r   REG    3,5    0 30386 /tmp/t1213-0-sh (deleted)</tt>
             
</pre>
              <br>
              <br>
            </td>
          </tr>
        </table>
      </div>

      <div
       class="CAUTION">
        <table
         class="CAUTION"
         width="100%"
         border="0">
          <tr>
            <td
             width="25"
             align="center"
             valign="top"><img
             src="misc/abs-book/images/caution.gif"
             hspace="5"
             alt="Caution"></td>

            <td
             align="left"
             valign="top">
              <p>Некоторые утилиты не могут работать внутри <span
               class="emphasis"><em
               class="EMPHASIS">встроенных документов</em></span>.</p>
            </td>
          </tr>
        </table>
      </div>

      <p>Если какая либо задача не может быть решена с помощью <span
       class="QUOTE">&quot;встроенного документа&quot;</span>, то вам
      следует попробовать язык сценариев <strong
       class="COMMAND">expect</strong>, который приспособлен для
      передачи параметров на вход интерактивных программ.</p>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x11778_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#p11889_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Область применения</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#p3268_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Материал повышенной сложности</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="c118_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#p112_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#c178_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="CHAPTER">
      <h1><a
       name="c118_html_WHY-SHELL"></a>Глава 1. Зачем необходимо знание языка
      Shell?</h1>

      <p>Знание языка командной оболочки является залогом успешного
      решения задач администрирования системы. Даже если вы не
      предполагаете заниматься написанием своих сценариев. Во время
      загрузки Linux выполняется целый ряд сценариев из <tt
       class="FILENAME">/etc/rc.d</tt>, которые настраивают
      конфигурацию операционной системы и запускают различные сервисы,
      поэтому очень важно четко понимать эти скрипты и иметь достаточно
      знаний, чтобы вносить в них какие либо изменения.</p>

      <p>Язык сценариев легок в изучении, в нем не так много
      специфических операторов и конструкций. <a
       name="AEN123"
       href="#c118_html_FTN_AEN123"><span
       class="footnote">[1]</span></a> Синтаксис языка достаточно прост
      и прямолинеен, он очень напоминает команды, которые приходится
      вводить в командной строке. Короткие скрипты практически не
      нуждаются в отладке, и даже отладка больших скриптов отнимает
      весьма незначительное время.</p>

      <p>Shell-скрипты очень хорошо подходят для быстрого создания
      прототипов сложных приложений, даже не смотря на ограниченный
      набор языковых конструкций и определенную
      &quot;медлительность&quot;. Такая метода позволяет детально
      проработать структуру будущего приложения, обнаружить возможные
      &quot;ловушки&quot; и лишь затем приступить к кодированию на C,
      C++, Java, или Perl.</p>

      <p>Скрипты возвращают нас к классической философии UNIX --
      &quot;разделяй и влавствуй&quot; т.е. разделение сложного проекта
      на ряд простых подзадач. Многие считают такой подход наилучшим
      или, по меньшей мере, наиболее эстетичным способом решения
      возникающих проблем, нежели использование нового поколения языков
      -- &quot;все-в-одном&quot;, таких как Perl.</p>

      <p>Для каких задач неприменимы скрипты</p>

      <ul>
        <li>
          <p>для ресурсоемких задач, особенно когда важна скорость
          исполнения (поиск, сортировка и т.п.)</p>
        </li>

        <li>
          <p>для задач, связанных с выполнением математических
          вычислений, особенно это касается вычислений с плавающей
          запятой, вычислений с повышенной точностью, комплексных чисел
          (для таких задач лучше использовать C++ или FORTRAN)</p>
        </li>

        <li>
          <p>для кросс-платформенного программирования (для этого лучше
          подходит язык C)</p>
        </li>

        <li>
          <p>для сложных приложений, когда структурирование является
          жизненной необходимостью (контроль за типами переменных,
          прототипами функций и т.п.)</p>
        </li>

        <li>
          <p>для целевых задач, от которых может зависеть успех
          предприятия.</p>
        </li>

        <li>
          <p>когда во главу угла поставлена безопасность системы, когда
          необходимо обеспечить целостность системы и защитить ее от
          вторжения, взлома и вандализма.</p>
        </li>

        <li>
          <p>для проектов, содержащих компоненты, очень тесно
          взаимодействующие между собой.</p>
        </li>

        <li>
          <p>для задач, выполняющих огромный объем работ с файлами</p>
        </li>

        <li>
          <p>для задач, работающих с многомерными массивами</p>
        </li>

        <li>
          <p>когда необходимо работать со структурами данных, такими
          как связанные списки или деревья</p>
        </li>

        <li>
          <p>когда необходимо предоставить графический интерфейс с
          пользователем (GUI)</p>
        </li>

        <li>
          <p>когда необходим прямой доступ к аппаратуре компьютера</p>
        </li>

        <li>
          <p>когда необходимо выполнять обмен через порты ввода-вывода
          или сокеты</p>
        </li>

        <li>
          <p>когда необходимо использовать внешние библиотеки</p>
        </li>

        <li>
          <p>для проприетарных, &quot;закрытых&quot; программ (скрипты
          представляют из себя исходные тексты программ, доступные для
          всеобщего обозрения)</p>
        </li>
      </ul>
      <br>
      <br>

      <p>Если выполняется хотя бы одно из вышеперечисленных условий, то
      вам лучше обратиться к более мощным скриптовым языкам
      программирования, например Perl, Tcl, Python, Ruby или к
      высокоуровневым компилирующим языкам -- C, C++ или Java. Но даже
      в этом случае, создание прототипа приложения на языке shell может
      существенно облегчить разработку.</p>

      <p>Название BASH -- это аббревиатура от <span
       class="QUOTE">&quot;Bourne-Again Shell&quot;</span> и игра слов
      от, ставшего уже классикой, <span
       class="QUOTE">&quot;Bourne Shell&quot;</span> Стефена Бурна
      (Stephen Bourne). В последние годы BASH достиг такой
      популярности, что стал стандартной командной оболочкой <em
       class="FOREIGNPHRASE">de facto</em> для многих разновидностей
      UNIX. Большинство принципов программирования на BASH одинаково
      хорошо применимы и в других командных оболочках, таких как Korn
      Shell (ksh), от которой Bash позаимствовал некоторые особенности,
      <a
       name="AEN165"
       href="#c118_html_FTN_AEN165"><span
       class="footnote">[2]</span></a> и C Shell и его производных.
      (Примечательно, что C Shell не рекомендуется к использованию
      из-за отдельных проблем, отмеченных Томом Кристиансеном (Tom
      Christiansen) в октябре 1993 года на <a
       href="http://www.etext.org/Quartz/computer/unix/csh.harmful.gz"
       target="_top">Usenet post</a></p>

      <p>Далее, в тексте документа вы найдете большое количество
      примеров скриптов, иллюстрирующих возможности shell. Все примеры
      -- работающие. Они были протестированы, причем некоторые из них
      могут пригодиться в повседневной работе. Уважаемый читатель
      можеть &quot;поиграть&quot; с рабочим кодом скриптов, сохраняя их
      в файлы, с именами <tt
       class="FILENAME">scriptname.sh</tt>. <a
       name="AEN172"
       href="#c118_html_FTN_AEN172"><span
       class="footnote">[3]</span></a> Не забудьте выдать этим файлам
      право на исполнение (<tt
       class="USERINPUT"><strong>chmod u+rx scriptname</strong></tt>),
      после чего сценарии можно будет запустить на исполнение и
      проверить результат их работы. Вам следует помнить, что описание
      некоторых примеров следует после исходного кода этого примера,
      поэтому, прежде чем запустить сценарий у себя -- ознакомьтесь с
      его описанием.</p>

      <p>Скрипты были написаны автором книги, если не оговаривается
      иное.</p>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN123"
         href="#c118_html_AEN123"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Их так же называют <a
           href="#c5358_html_BUILTINREF">встроенными</a> конструкциями
          языка командной оболочки shell.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN165"
         href="#c118_html_AEN165"><span
         class="footnote">[2]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Многие особенности <span
           class="emphasis"><em
           class="EMPHASIS">ksh88</em></span> и даже <span
           class="emphasis"><em
           class="EMPHASIS">ksh93</em></span> перекочевали в Bash.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN172"
         href="#c118_html_AEN172"><span
         class="footnote">[3]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>В соответствии с соглашениями, имена файлов с
          shell-скриптами, такими как Bourne shell и совместимыми,
          имеют расширение <tt
           class="FILENAME">.sh</tt>. Все стартовые скрипты, которые вы
          найдете в <tt
           class="FILENAME">/etc/rc.d</tt>, следуют этому
          соглашению.</p>
        </td>
      </tr>
    </table>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#p112_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#c178_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Введение</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#p112_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Для начала о Sha-Bang</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="c11895_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#p11889_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x12282_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="CHAPTER">
      <h1><a
       name="c11895_html_REGEXP"></a>Глава 18. Регулярные выражения</h1>

      <p><a
       name="c11895_html_REGEXREF"></a></p>

      <p>Для того, чтобы полностью реализовать потенциал командной
      оболочки, вам придется овладеть Регулярными Выражениями. Многие
      команды и утилиты, обычно используемые в сценариях, такие как <a
       href="#x7050_html_GREPREF">grep</a>, <a
       href="#x6646_html_EXPRREF">expr</a>, <a
       href="#a14586_html_SEDREF">sed</a> и <a
       href="#x14802_html_AWKREF">awk</a>, используют Регулярные
      Выражения.</p>

      <div
       class="SECT1">
        <h1
         class="SECT1"><a
         name="c11895_html_AEN11904"></a>18.1. Краткое введение в регулярные
        выражения</h1>

        <p>Выражение -- это строка символов. Символы, которые имеют
        особое назначение, называются <span
         class="emphasis"><em
         class="EMPHASIS">метасимволами</em></span>. Так, например,
        кавычки могут выделять прямую речь, т.е. быть <span
         class="emphasis"><em
         class="EMPHASIS">метасимволами</em></span> для строки,
        заключенной в эти кавычки. Регулярные выражения -- это набор
        символов и/или метасимволов, которые наделены особыми
        свойствами. <a
         name="AEN11909"
         href="#c11895_html_FTN_AEN11909"><span
         class="footnote">[1]</span></a></p>

        <p>Основное назначение регулярных выражений -- это поиск текста
        по шаблону и работа со строками.</p>

        <ul>
          <li>
            <p>Звездочка -- <span
             class="TOKEN">*</span> -- означает любое количество
            символов в строке, предшествующих &quot;звездочке&quot;,
            <span
             class="emphasis"><em
             class="EMPHASIS">в том числе и нулевое число
            символов</em></span>.</p>

            <p>Выражение <span
             class="QUOTE">&quot;1133*&quot;</span> -- означает <tt
             class="REPLACEABLE"><em>11 + один или более символов
            &quot;3&quot; + любые другие символы</em></tt>: <tt
             class="REPLACEABLE"><em>113</em></tt>, <tt
             class="REPLACEABLE"><em>1133</em></tt>, <tt
             class="REPLACEABLE"><em>113312</em></tt>, и так далее.</p>
          </li>

          <li>
            <p><a
             name="c11895_html_REGEXDOT"></a>Точка -- <span
             class="TOKEN">.</span> -- означает не менее одного любого
            символа, за исключением символа перевода строки (\n). <a
             name="AEN11937"
             href="#c11895_html_FTN_AEN11937"><span
             class="footnote">[2]</span></a></p>

            <p>Выражение <span
             class="QUOTE">&quot;13.&quot;</span> будет означать <tt
             class="REPLACEABLE"><em>13 + по меньшей мере один любой
            символ (включая пробел)</em></tt>: <tt
             class="REPLACEABLE"><em>1133</em></tt>, <tt
             class="REPLACEABLE"><em>11333</em></tt>, но не <tt
             class="REPLACEABLE"><em>13</em></tt> (отсутствуют
            дополнительные символы).</p>
          </li>

          <li>
            <p>Символ -- <span
             class="TOKEN">^</span> -- означает начало строки, но
            иногда, в зависимости от контекста, означает отрицание в
            регулярных выражениях.</p>
          </li>

          <li>
            <p><a
             name="c11895_html_DOLLARSIGNREF"></a></p>

            <p>Знак доллара -- <span
             class="TOKEN">$</span> -- в конце регулярного выражения
            соответствует концу строки.</p>

            <p>Выражение <span
             class="QUOTE">&quot;^$&quot;</span> соответствует пустой
            строке.</p>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Символы <span
                     class="TOKEN">^</span> и <span
                     class="TOKEN">$</span> иногда еще называют <span
                     class="emphasis"><em
                     class="EMPHASIS">якорями</em></span>, поскольку
                    они означают, или закрепляют, позицию в регулярных
                    выражениях.</p>
                  </td>
                </tr>
              </table>
            </div>
          </li>

          <li>
            <p><a
             name="c11895_html_BRACKETSREF"></a></p>

            <p>Квадратные скобки -- <span
             class="TOKEN">[...]</span> -- предназначены для задания
            подмножества символов. Квадратные скобки, внутри
            регулярного выражения, считаются одним символом, который
            может принимать значения, перечисленные внутри этих
            скобок..</p>

            <p>Выражение <span
             class="QUOTE">&quot;[xyz]&quot;</span> -- соответствует
            одному из символов <tt
             class="REPLACEABLE"><em>x</em></tt>, <tt
             class="REPLACEABLE"><em>y</em></tt> или <tt
             class="REPLACEABLE"><em>z</em></tt>.</p>

            <p>Выражение <span
             class="QUOTE">&quot;[c-n]&quot;</span> соответствует
            одному из символов в диапазоне от <tt
             class="REPLACEABLE"><em>c</em></tt> до <tt
             class="REPLACEABLE"><em>n</em></tt>, включительно.</p>

            <p>Выражение <span
             class="QUOTE">&quot;[B-Pk-y]&quot;</span> соответствует
            одному из символов в диапазоне от <tt
             class="REPLACEABLE"><em>B</em></tt> до <tt
             class="REPLACEABLE"><em>P</em></tt> или в диапазоне от <tt
             class="REPLACEABLE"><em>k</em></tt> до <tt
             class="REPLACEABLE"><em>y</em></tt>, включительно.</p>

            <p>Выражение <span
             class="QUOTE">&quot;[a-z0-9]&quot;</span> соответствует
            одному из символов латиницы в нижнем регистре или
            цифре.</p>

            <p>Выражение <span
             class="QUOTE">&quot;[^b-d]&quot;</span> соответствует
            любому символу, кроме символов из диапазона от <tt
             class="REPLACEABLE"><em>b</em></tt> до <tt
             class="REPLACEABLE"><em>d</em></tt>, включительно. В
            данном случае, метасимвол <span
             class="TOKEN">^</span> означает отрицание.</p>

            <p>Объединяя квадратные скобки в одну последовательность,
            можно задать шаблон искомого слова. Так, выражение <span
             class="QUOTE">&quot;[Yy][Ee][Ss]&quot;</span>
            соответствует словам <tt
             class="REPLACEABLE"><em>yes</em></tt>, <tt
             class="REPLACEABLE"><em>Yes</em></tt>, <tt
             class="REPLACEABLE"><em>YES</em></tt>, <tt
             class="REPLACEABLE"><em>yEs</em></tt> и так далее.
            Выражение <span
             class=
            "QUOTE">&quot;[0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9][0-9][0-9]&quot;</span>
            определяет шаблон для поиска любого номера карточки
            социального страхования (для США).</p>
          </li>

          <li>
            <p>Обратный слэш -- <span
             class="TOKEN">\</span> -- служит для <a
             href="#c1833_html_ESCP">экранирования</a> специальных
            символов, это означает, что экранированные символы должны
            интерпретироваться буквально, т.е. как простые символы.</p>

            <p>Комбинация <span
             class="QUOTE">&quot;\$&quot;</span> указывает на то, что
            символ <span
             class="QUOTE">&quot;$&quot;</span> трактуется как обычный
            символ, а не как признак конца строки в регулярных
            выражениях. Аналогично, комбинация <span
             class="QUOTE">&quot;\\&quot;</span> соответствует простому
            символу <span
             class="QUOTE">&quot;\&quot;</span>.</p>
          </li>

          <li>
            <p><a
             name="c11895_html_ANGLEBRAC"></a></p>

            <p><a
             href="#c1833_html_ESCP">Экранированные</a> <span
             class="QUOTE">&quot;угловые скобки&quot;</span> -- <span
             class="TOKEN">\&lt;...\&gt;</span> -- отмечают границы
            слова.</p>

            <p>Угловые скобки должны экранироваться, иначе они будут
            интерпретироваться как простые символы.</p>

            <p>Выражение <span
             class="QUOTE">&quot;\&lt;the\&gt;&quot;</span>
            соответствует слову <span
             class="QUOTE">&quot;the&quot;</span>, и не соответствует
            словам <span
             class="QUOTE">&quot;them&quot;</span>, <span
             class="QUOTE">&quot;there&quot;</span>, <span
             class="QUOTE">&quot;other&quot;</span> и т.п.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>cat textfile</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">This is line 1, of which there is only one instance.
This is the only instance of line 2.
This is line 3, another line.
This is line 4.</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>grep &#39;the&#39; textfile</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">This is line 1, of which there is only one instance.
This is the only instance of line 2.
This is line 3, another line.</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>grep &#39;\&lt;the\&gt;&#39; textfile</strong></tt>
<tt
 class="COMPUTEROUTPUT">This is the only instance of line 2.</tt>
             
</pre>
            <br>
            <br>
          </li>
        </ul>

        <ul>
          <li
           style="list-style-type: square">
            <div
             class="FORMALPARA">
              <p><strong><a
               name="c11895_html_EXTREGEX"></a>Дополнительные метасимволы.</strong>
              Использующиеся при работе с <a
               href="#x7050_html_EGREPREF">egrep</a>, <a
               href="#x14802_html_AWKREF">awk</a> и <a
               href="#x13541_html_PERLREF">Perl</a></p>
            </div>
          </li>

          <li>
            <p><a
             name="c11895_html_QUEXREGEX"></a></p>

            <p>Знак вопроса -- <span
             class="TOKEN">?</span> -- означает, что предыдущий символ
            или регулярное выражение встречается 0 или 1 раз. В
            основном используется для поиска одиночных символов.</p>
          </li>

          <li>
            <p><a
             name="c11895_html_PLUSREF"></a></p>

            <p>Знак &quot;плюс&quot; -- <span
             class="TOKEN">+</span> -- указывает на то, что предыдущий
            символ или выражение встречается 1 или более раз. Играет ту
            же роль, что и символ &quot;звездочка&quot; (<span
             class="TOKEN">*</span>), за исключением случая нулевого
            количества вхождений.</p>
<pre
 class="PROGRAMLISTING">
# GNU версии sed и awk допускают использование &quot;+&quot;,
# но его необходимо экранировать.

echo a111b | sed -ne &#39;/a1\+b/p&#39;
echo a111b | grep &#39;a1\+b&#39;
echo a111b | gawk &#39;/a1+b/&#39;
# Все три варианта эквивалентны.

# Спасибо S.C.
</pre>
            <br>
            <br>
          </li>

          <li>
            <p><a
             href="#c1833_html_ESCP">Экранированные</a> <span
             class="QUOTE">&quot;фигурные скобки&quot;</span> -- <span
             class="TOKEN">\{ \}</span> -- задают число вхождений
            предыдущего выражения.</p>

            <p>Экранирование фигурных скобок -- обязательное условие,
            иначе они будут интерпретироваться как простые символы.
            Такой порядок использования, технически, не является частью
            основного набора правил построения регулярных
            выражений.</p>

            <p>Выражение <span
             class="QUOTE">&quot;[0-9]\{5\}&quot;</span> -- в точности
            соответствует подстроке из пяти десятичных цифр (символов
            из диапазона от 0 до 9, включительно).</p>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>В <span
                     class="QUOTE">&quot;классической&quot;</span> (не
                    совместимой с POSIX) версии <a
                     href="#x14802_html_AWKREF">awk</a>, фигурные скобки
                    не могут быть использованы. Однако, в <strong
                     class="COMMAND">gawk</strong> предусмотрен ключ
                    <tt
                     class="OPTION">--re-interval</tt>, который
                    позволяет использовать (неэкранированные) фигурные
                    скобки.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>echo 2222 | gawk --re-interval &#39;/2{3}/&#39;</strong></tt>
<tt
 class="COMPUTEROUTPUT">2222</tt>
             
</pre>
                    <br>
                    <br>

                    <p>Язык программирования <strong
                     class="COMMAND">Perl</strong> и некоторые версии
                    <strong
                     class="COMMAND">egrep</strong> не требуют
                    экранирования фигурных скобок.</p>
                  </td>
                </tr>
              </table>
            </div>
          </li>

          <li>
            <p>Круглые скобки -- <strong
             class="COMMAND">( )</strong> -- предназначены для
            выделения групп регулярных выражений. Они полезны при
            использовании с оператором <span
             class="QUOTE">&quot;<span
             class="TOKEN">|</span>&quot;</span> и при <a
             href="#x4171_html_EXPRPAREN">извлечении подстроки</a> с
            помощью команды <a
             href="#x6646_html_EXPRREF">expr</a>.</p>
          </li>

          <li>
            <p>Вертикальная черта -- <strong
             class="COMMAND">|</strong> -- выполняет роль логического
            оператора <span
             class="QUOTE">&quot;ИЛИ&quot;</span> в регулярных
            выражениях и служит для задания набора альтернатив.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>egrep &#39;re(a|e)d&#39; misc.txt</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">People who read seem to be better informed than those who do not.
The clarinet produces sound by the vibration of its reed.</tt>
             
</pre>
            <br>
            <br>
          </li>
        </ul>

        <div
         class="NOTE">
          <table
           class="NOTE"
           width="100%"
           border="0">
            <tr>
              <td
               width="25"
               align="center"
               valign="top"><img
               src="misc/abs-book/images/note.gif"
               hspace="5"
               alt="Note"></td>

              <td
               align="left"
               valign="top">
                <p>Некоторые версии <strong
                 class="COMMAND">sed</strong>, <strong
                 class="COMMAND">ed</strong> и <strong
                 class="COMMAND">ex</strong> поддерживают
                экранированные версии регулярных выражений, описанных
                выше.</p>
              </td>
            </tr>
          </table>
        </div>

        <ul>
          <li
           style="list-style-type: square">
            <div
             class="FORMALPARA">
              <p><strong><a
               name="c11895_html_POSIXREF"></a>Классы символов POSIX.</strong> <tt
               class="USERINPUT"><strong>[:class:]</strong></tt></p>
            </div>

            <p>Это альтернативный способ указания диапазона
            символов.</p>
          </li>

          <li>
            <p>Класс <tt
             class="USERINPUT"><strong>[:alnum:]</strong></tt> --
            соответствует алфавитным символам и цифрам. Эквивалентно
            выражению <tt
             class="USERINPUT"><strong>[A-Za-z0-9]</strong></tt>.</p>
          </li>

          <li>
            <p>Класс <tt
             class="USERINPUT"><strong>[:alpha:]</strong></tt> --
            соответствует символам алфавита. Эквивалентно выражению <tt
             class="USERINPUT"><strong>[A-Za-z]</strong></tt>.</p>
          </li>

          <li>
            <p>Класс <tt
             class="USERINPUT"><strong>[:blank:]</strong></tt> --
            соответствует символу пробела или символу табуляции.</p>
          </li>

          <li>
            <p>Класс <tt
             class="USERINPUT"><strong>[:cntrl:]</strong></tt> --
            соответствует управляющим символам (control
            characters).</p>
          </li>

          <li>
            <p>Класс <tt
             class="USERINPUT"><strong>[:digit:]</strong></tt> --
            соответствует набору десятичных цифр. Эквивалентно
            выражению <tt
             class="USERINPUT"><strong>[0-9]</strong></tt>.</p>
          </li>

          <li>
            <p>Класс <tt
             class="USERINPUT"><strong>[:graph:]</strong></tt>
            (печатаемые и псевдографические символы) -- соответствует
            набору символов из диапазона ASCII 33 - 126. Это то же
            самое, что и класс <tt
             class="USERINPUT"><strong>[:print:]</strong></tt>, за
            исключением символа пробела.</p>
          </li>

          <li>
            <p>Класс <tt
             class="USERINPUT"><strong>[:lower:]</strong></tt> --
            соответствует набору алфавитных символов в нижнем регистре.
            Эквивалентно выражению <tt
             class="USERINPUT"><strong>[a-z]</strong></tt>.</p>
          </li>

          <li>
            <p>Класс <tt
             class="USERINPUT"><strong>[:print:]</strong></tt>
            (печатаемые символы) -- соответствует набору символов из
            диапазона ASCII 32 - 126. По своему составу этот класс
            идентичен классу <tt
             class="USERINPUT"><strong>[:graph:]</strong></tt>,
            описанному выше, за исключением того, что в этом классе
            дополнительно присутствует символ пробела.</p>
          </li>

          <li>
            <p>Класс <tt
             class="USERINPUT"><strong>[:space:]</strong></tt> --
            соответствует пробельным символам (пробел и горизонтальная
            табуляция).</p>
          </li>

          <li>
            <p>Класс <tt
             class="USERINPUT"><strong>[:upper:]</strong></tt> --
            соответствует набору символов алфавита в верхнем регистре.
            Эквивалентно выражению <tt
             class="USERINPUT"><strong>[A-Z]</strong></tt>.</p>
          </li>

          <li>
            <p>Класс <tt
             class="USERINPUT"><strong>[:xdigit:]</strong></tt> --
            соответствует набору шестнадцатиричных цифр. Эквивалентно
            выражению <tt
             class="USERINPUT"><strong>[0-9A-Fa-f]</strong></tt>.</p>

            <div
             class="IMPORTANT">
              <table
               class="IMPORTANT"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/important.gif"
                   hspace="5"
                   alt="Important"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Вообще, символьные классы POSIX требуют
                    заключения в кавычки или <a
                     href="#c2171_html_DBLBRACKETS">двойные квадратные
                    скобки</a> ([[ ]]).</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>grep [[:digit:]] test.file</strong></tt>
<tt
 class="COMPUTEROUTPUT">abc=723</tt>
             
</pre>
                    <br>
                    <br>

                    <p>Эти символьные классы могут использоваться, с
                    некоторыми ограничениями, даже в операциях <a
                     href="#x12282_html">подстановки имен файлов
                    (globbing)</a>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ls -l ?[[:digit:]][[:digit:]]?</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">-rw-rw-r--    1 bozo  bozo         0 Aug 21 14:47 a33b</tt>
             
</pre>
                    <br>
                    <br>

                    <p>Примеры использования символьных классов в
                    сценариях вы найдете в <a
                     href="#x7050_html_EX49">Пример 12-14</a> и <a
                     href="#x7050_html_LOWERCASE">Пример 12-15</a>.</p>
                  </td>
                </tr>
              </table>
            </div>
          </li>
        </ul>

        <p><a
         href="#a14586_html_SEDREF">Sed</a>, <a
         href="#x14802_html_AWKREF">awk</a> и <a
         href="#x13541_html_PERLREF">Perl</a>, используемые в сценариях
        в качестве фильтров, могут принимать регулярные выражения в
        качестве входных аргументов. См. <a
         href="#a14477_html_BEHEAD">Пример A-13</a> и <a
         href="#a14477_html_TREE">Пример A-19</a>.</p>

        <p>Книга &quot;Sed &amp; Awk&quot; (авторы Dougherty и Robbins)
        дает полное и ясное представление о регулярных выражениях (см.
        раздел <a
         href="#b14059_html"><em>Литература</em></a>).</p>
      </div>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN11909"
         href="#c11895_html_AEN11909"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>В качестве простейшего регулярного выражения можно
          привести строку, не содержащую никаких метасимволов.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN11937"
         href="#c11895_html_AEN11937"><span
         class="footnote">[2]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Поскольку с помощью <a
           href="#a14586_html_SEDREF">sed</a>, <a
           href="#x14802_html_AWKREF">awk</a> и <a
           href="#x7050_html_GREPREF">grep</a> обрабатывают одиночные
          строки, то обычно символ перевода строки не принимается во
          внимание. В тех же случаях, когда производится разбор
          многострочного текста, метасимвол &quot;точка&quot; будет
          соответствовать символу перевода строки.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

sed -e &#39;N;s/.*/[&amp;]/&#39; &lt;&lt; EOF   # Встроенный документ
line1
line2
EOF
# OUTPUT:
# [line1
# line2]



echo

awk &#39;{ $0=$1 &quot;\n&quot; $2; if (/line.1/) {print}}&#39; &lt;&lt; EOF
line 1
line 2
EOF
# OUTPUT:
# line
# 1


# Спасибо S.C.

exit 0
</pre>
          <br>
          <br>
        </td>
      </tr>
    </table>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#p11889_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x12282_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Материал повышенной сложности</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#p11889_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Globbing -- Подстановка имен файлов</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="c12330_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x12282_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#c12376_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="CHAPTER">
      <h1><a
       name="c12330_html_SUBSHELLS"></a>Глава 19. Подоболочки, или Subshells</h1>

      <p><a
       name="c12330_html_SUBSHELLSREF"></a></p>

      <p>Запуск сценария приводит к запуску дочернего командного
      интерпретатора. Который выполняет интерпретацию и исполнение
      списка команд, содержащихся в файле сценария, точно так же, как
      если бы они были введены из командной строки. Любой сценарий
      запускается как дочерний процесс <a
       href="#c5358_html_FORKREF">родительской</a> командной оболочки,
      той самой, которая выводит перед вами строку приглашения к вводу
      на консоли или в окне xterm.</p>

      <p>Сценарий может, так же, запустить другой дочерний процесс, в
      своей подоболочке. Это позволяет сценариям распараллелить процесс
      обработки данных по нескольким задачам, исполняемым
      одновременно.</p>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="c12330_html_SUBSHELLPARENS1"></a>Список команд в круглых
        скобках</strong></p>

        <dl>
          <dt>( command1; command2; command3; ... )</dt>

          <dd>
            <p>Список команд, в круглых скобках, исполняется в
            подоболочке.</p>
          </dd>
        </dl>
      </div>

      <div
       class="NOTE">
        <table
         class="NOTE"
         width="100%"
         border="0">
          <tr>
            <td
             width="25"
             align="center"
             valign="top"><img
             src="misc/abs-book/images/note.gif"
             hspace="5"
             alt="Note"></td>

            <td
             align="left"
             valign="top">
              <p><a
               name="c12330_html_PARVIS"></a>Значения переменных, определенных в
              дочерней оболочке, <span
               class="emphasis"><em
               class="EMPHASIS">не</em></span> могут быть переданы
              родительской оболочке. Они недоступны <a
               href="#c5358_html_FORKREF">родительскому процессу</a>.
              Фактически, они ведут себя как <a
               href="#x12644_html">локальные переменные</a>.</p>
            </td>
          </tr>
        </table>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="c12330_html_SUBSHELL"></a>

        <p><strong>Пример 19-1. Область видимости
        переменных</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# subshell.sh

echo

outer_variable=Outer

(
inner_variable=Inner
echo &quot;Дочерний процесс, \&quot;inner_variable\&quot; = $inner_variable&quot;
echo &quot;Дочерний процесс, \&quot;outer\&quot; = $outer_variable&quot;
)

echo

if [ -z &quot;$inner_variable&quot; ]
then
  echo &quot;Переменная inner_variable не определена в родительской оболочке&quot;
else
  echo &quot;Переменная inner_variable определена в родительской оболочке&quot;
fi

echo &quot;Родительский процесс, \&quot;inner_variable\&quot; = $inner_variable&quot;
# Переменная $inner_variable не будет определена
# потому, что переменные, определенные в дочернем процессе,
# ведут себя как &quot;локальные переменные&quot;.

echo

exit 0
</pre>
      </div>

      <p>См. также <a
       href="#c13371_html_SUBPIT">Пример 31-1</a>.</p>

      <p>+</p>

      <p>Смена текущего каталога в дочернем процессе (подоболочке) не
      влечет за собой смену текущего каталога в родительской
      оболочке.</p>

      <div
       class="EXAMPLE">
        <a
         name="c12330_html_ALLPROFS"></a>

        <p><strong>Пример 19-2. Личные настройки
        пользователей</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# allprofs.sh: вывод личных настроек (profiles) всех пользователей

# Автор: Heiner Steven
# С некоторыми изменениями, внесенными автором документа.

FILE=.bashrc  #  Файл настроек пользователя,
              #+ в оригинальном сценарии называется &quot;.profile&quot;.

for home in `awk -F: &#39;{print $6}&#39; /etc/passwd`
do
  [ -d &quot;$home&quot; ] || continue    # Перейти к следующей итерации, если нет домашнего каталога.
  [ -r &quot;$home&quot; ] || continue    # Перейти к следующей итерации, если не доступен для чтения.
  (cd $home; [ -e $FILE ] &amp;&amp; less $FILE)
done

#  По завершении сценария -- нет теобходимости выполнять команду &#39;cd&#39;, чтобы вернуться в первоначальный каталог,
#+ поскольку &#39;cd $home&#39; выполняется в подоболочке.

exit 0
</pre>
      </div>

      <p>Подоболочка может использоваться для задания <span
       class="QUOTE">&quot;специфического окружения&quot;</span> для
      группы команд.</p>
<pre
 class="PROGRAMLISTING">
COMMAND1
COMMAND2
COMMAND3
(
  IFS=:
  PATH=/bin
  unset TERMINFO
  set -C
  shift 5
  COMMAND4
  COMMAND5
  exit 3 # Выход только из подоболочки.
)
# Изменение переменных окружения не коснется родительской оболочки.
COMMAND6
COMMAND7
</pre>
      Как вариант использования подоболочки -- проверка переменных. 
<pre
 class="PROGRAMLISTING">
if (set -u; : $variable) 2&gt; /dev/null
then
  echo &quot;Переменная определена.&quot;
fi

# Можно сделать то же самое по другому: [[ ${variable-x} != x || ${variable-y} != y ]]
# или                                   [[ ${variable-x} != x$variable ]]
# или                                   [[ ${variable+x} = x ]])
</pre>
      Еще одно применение -- проверка файлов блокировки: 
<pre
 class="PROGRAMLISTING">
if (set -C; : &gt; lock_file) 2&gt; /dev/null
then
  echo &quot;Этот сценарий уже запущен другим пользователем.&quot;
  exit 65
fi

# Спасибо S.C.
</pre>
      <br>
      <br>

      <p>Процессы в подоболочках могут исполняться параллельно. Это
      позволяет разбить сложную задачу на несколько простых подзадач,
      выполняющих параллельную обработку информации.</p>

      <div
       class="EXAMPLE">
        <a
         name="c12330_html_PARALLEL-PROCESSES"></a>

        <p><strong>Пример 19-3. Запуск нескольких процессов в
        подоболочках</strong></p>
<pre
 class="PROGRAMLISTING">
       (cat list1 list2 list3 | sort | uniq &gt; list123) &amp;
        (cat list4 list5 list6 | sort | uniq &gt; list456) &amp;
        # Слияние и сортировка двух списков производится одновременно.
        # Запуск в фоне гарантирует параллельное исполнение.
        #
        # Тот же эффект дает
        #   cat list1 list2 list3 | sort | uniq &gt; list123 &amp;
        #   cat list4 list5 list6 | sort | uniq &gt; list456 &amp;

        wait   # Ожидание завершения работы подоболочек.

        diff list123 list456
</pre>
      </div>

      <p>Перенаправление ввода/вывода в/из подоболочки производится
      оператором построения конвейера <span
       class="QUOTE">&quot;|&quot;</span>, например, <tt
       class="USERINPUT"><strong>ls -al | (command)</strong></tt>.</p>

      <div
       class="NOTE">
        <table
         class="NOTE"
         width="100%"
         border="0">
          <tr>
            <td
             width="25"
             align="center"
             valign="top"><img
             src="misc/abs-book/images/note.gif"
             hspace="5"
             alt="Note"></td>

            <td
             align="left"
             valign="top">
              <p>Блок команд, заключенный в <tt
               class="REPLACEABLE"><em>фигурные скобки</em></tt> не
              приводит к запуску дочерней подоболочки.</p>

              <p>{ command1; command2; command3; ... }</p>
            </td>
          </tr>
        </table>
      </div>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x12282_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#c12376_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Globbing -- Подстановка имен файлов</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#p11889_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Ограниченный режим командной оболочки</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="c12376_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#c12330_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#c12434_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="CHAPTER">
      <h1><a
       name="c12376_html_RESTRICTED-SH"></a>Глава 20. Ограниченный режим командной
      оболочки</h1>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="c12376_html_DISABLEDCOMMREF"></a>Команды, запрещенные в ограниченном
        режиме командной оболочки</strong></p>

        <dl>
          <dd>
            <div
             class="FORMALPARA">
              <p>Запуск сценария или его части в <span
               class="emphasis"><em
               class="EMPHASIS">ограниченном</em></span> режиме,
              приводит к наложению ограничений на использование
              некоторых команд. Эта мера предназначена для ограничения
              привилегий пользователя, запустившего сценарий, и
              минимизации возможного ущерба системе, который может
              нанести сценарий.</p>
            </div>
          </dd>

          <dd>
            <div
             class="FORMALPARA">
              <p>В ограниченном режиме запрещена команда <tt
               class="REPLACEABLE"><em>cd</em></tt> -- смена текщего
              каталога.</p>
            </div>
          </dd>

          <dd>
            <p>Запрещено изменять <a
             href="#x1716_html_ENVREF">переменные окружения</a> <tt
             class="REPLACEABLE"><em>$PATH</em></tt>, <tt
             class="REPLACEABLE"><em>$SHELL</em></tt>, <tt
             class="REPLACEABLE"><em>$BASH_ENV</em></tt> и <tt
             class="REPLACEABLE"><em>$ENV</em></tt>.</p>
          </dd>

          <dd>
            <p>Заперщен доступ к переменной <tt
             class="REPLACEABLE"><em>$SHELLOPTS</em></tt>.</p>
          </dd>

          <dd>
            <p>Запрещено перенаправление вывода.</p>
          </dd>

          <dd>
            <p>Запрещен вызов утилит, в названии которых присутствует
            хотя бы один символ &quot;слэш&quot; (<span
             class="TOKEN">/</span>).</p>
          </dd>

          <dd>
            <p>Запрещен вызов команды <span
             class="emphasis"><em
             class="EMPHASIS">exec</em></span> для запуска другого
            процесса.</p>
          </dd>

          <dd>
            <p>Запрещен ряд других команд, которые могут использовать
            сценарий для выполнения непредусмотренных действий.</p>
          </dd>

          <dd>
            <p>Запрещен выход из ограниченного режима.</p>
          </dd>
        </dl>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="c12376_html_RESTRICTED"></a>

        <p><strong>Пример 20-1. Запуск сценария в ограниченном
        режиме</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Если sha-bang задать в таком виде: &quot;#!/bin/bash -r&quot;
# то это приведет к включению ограниченного режима с момента запуска скрипта.

echo

echo &quot;Смена каталога.&quot;
cd /usr/local
echo &quot;Текущий каталог: `pwd`&quot;
echo &quot;Переход в домашний каталог.&quot;
cd
echo &quot;Текущий каталог: `pwd`&quot;
echo

# До сих пор сценарий исполнялся в обычном, неограниченном режиме.

set -r
# set --restricted    имеет тот же эффект.
echo &quot;==&gt; Переход в ограниченный режим. &lt;==&quot;

echo
echo

echo &quot;Попытка сменить текущий каталог в ограниченном режиме.&quot;
cd ..
echo &quot;Текущий каталог остался прежним: `pwd`&quot;

echo
echo

echo &quot;\$SHELL = $SHELL&quot;
echo &quot;Попытка смены командного интерпретатора в ограниченном режиме.&quot;
SHELL=&quot;/bin/ash&quot;
echo
echo &quot;\$SHELL= $SHELL&quot;

echo
echo

echo &quot;Попытка перенаправления вывода в ограниченном режиме.&quot;
ls -l /usr/bin &gt; bin.files
ls -l bin.files    # Попробуем найти файл, который пытались создать.

echo

exit 0
</pre>
      </div>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#c12330_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#c12434_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Подоболочки, или Subshells</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#p11889_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Подстановка процессов</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="c12434_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#c12376_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#c12483_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="CHAPTER">
      <h1><a
       name="c12434_html_PROCESS-SUB"></a>Глава 21. Подстановка процессов</h1>

      <p><a
       name="c12434_html_PROCESSSUBREF"></a><tt
       class="REPLACEABLE"><em>Подстановка процессов</em></tt> -- это
      аналог <a
       href="#c11441_html_COMMANDSUBREF">подстановки команд</a>.
      Операция подстановки команд записывает в переменную результат
      выполнения некоторой команды, например, <strong
       class="COMMAND">dir_contents=`ls -al`</strong> или <strong
       class="COMMAND">xref=$(grep word datafile)</strong>. Операция
      подстановки процессов передает вывод одного процесса на ввод
      другого (другими словами, передает результат выполнения одной
      команды -- другой).</p>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="c12434_html_COMMANDSPARENS1"></a>Шаблон подстановки
        команды</strong></p>

        <dl>
          <dt>Внутри круглых скобок</dt>

          <dd>
            <p><strong
             class="COMMAND">&gt;(command)</strong></p>

            <p><strong
             class="COMMAND">&lt;(command)</strong></p>

            <p>Таким образом инициируется подстановка процессов. Здесь,
            для передачи результата работы процесса в круглых скобках,
            используются файлы <tt
             class="FILENAME">/dev/fd/&lt;n&gt;</tt>. <a
             name="AEN12454"
             href="#c12434_html_FTN_AEN12454"><span
             class="footnote">[1]</span></a></p>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Между круглой скобкой и символом <span
                     class="QUOTE">&quot;&lt;&quot;</span> или <span
                     class="QUOTE">&quot;&gt;&quot;</span>, не должно
                    быть пробелов, в противном случае это вызовет
                    сообщение об ошибке.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>
        </dl>
      </div>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo &gt;(true)</strong></tt>
<tt
 class="COMPUTEROUTPUT">/dev/fd/63</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo &lt;(true)</strong></tt>
<tt
 class="COMPUTEROUTPUT">/dev/fd/63</tt>
             
</pre>
      Bash создает канал с двумя <a
       href="#c11620_html_FDREF">файловыми дескрипторами</a>, <tt
       class="FILENAME">--fIn</tt> и <tt
       class="FILENAME">fOut--</tt>. <tt
       class="FILENAME">stdin</tt> команды <a
       href="#c5358_html_TRUEREF">true</a> присоединяется к <tt
       class="FILENAME">fOut</tt> (dup2(fOut, 0)), затем Bash передает
      <tt
       class="FILENAME">/dev/fd/fIn</tt> в качестве аргумента команде
      <strong
       class="COMMAND">echo</strong>. В системах, где отсутствуют файлы
      <tt
       class="FILENAME">/dev/fd/&lt;n&gt;</tt>, Bash может использовать
      временные файлы. (Спасибо S.C.)<br>
      <br>
<pre
 class="PROGRAMLISTING">
cat &lt;(ls -l)
# То же самое, что и     ls -l | cat

sort -k 9 &lt;(ls -l /bin) &lt;(ls -l /usr/bin) &lt;(ls -l /usr/X11R6/bin)
# Список файлов в трех основных каталогах &#39;bin&#39;, отсортированный по именам файлов.
# Обратите внимание: на вход &#39;sort&#39; поданы три самостоятельные команды.


diff &lt;(command1) &lt;(command2)    # Выдаст различия в выводе команд.

tar cf &gt;(bzip2 -c &gt; file.tar.bz2) $directory_name
# Вызовет &quot;tar cf /dev/fd/?? $directory_name&quot; и затем &quot;bzip2 -c &gt; file.tar.bz2&quot;.
#
# Из-за особенностей, присущих некоторым системам, связанным с /dev/fd/&lt;n&gt;,
# канал между командами не обязательно должен быть именованным.
#
# Это можно сделать и так.
#
bzip2 -c &lt; pipe &gt; file.tar.bz2&amp;
tar cf pipe $directory_name
rm pipe
#        или
exec 3&gt;&amp;1
tar cf /dev/fd/4 $directory_name 4&gt;&amp;1 &gt;&amp;3 3&gt;&amp;- | bzip2 -c &gt; file.tar.bz2 3&gt;&amp;-
exec 3&gt;&amp;-


# Спасибо S.C.
</pre>
      <br>
      <br>

      <p>Ниже приводится еще один очень интересный пример использования
      подстановки процессов.</p>
<pre
 class="PROGRAMLISTING">
# Фрагмент сценария из дистрибутива SuSE:

while read  des what mask iface; do
# Некоторые команды ...
done &lt; &lt;(route -n)


# Чтобы проверить это, попробуем вставить команду, выполняющую какие либо действия.
while read  des what mask iface; do
  echo $des $what $mask $iface
done &lt; &lt;(route -n)

# Вывод на экран:
# Kernel IP routing table
# Destination Gateway Genmask Flags Metric Ref Use Iface
# 127.0.0.0 0.0.0.0 255.0.0.0 U 0 0 0 lo


# Как указывает S.C. -- более простой для понимания эквивалент:
route -n |
  while read des what mask iface; do   # Переменные берут значения с устройства вывода конвейера (канала).
    echo $des $what $mask $iface
  done  #  На экран выводится то же самое, что и выше.
        #  Однако, Ulrich Gayer отметил, что ...
        #+ этот вариант запускает цикл while в подоболочке,
        #+ и поэтому переменные не видны за пределами цикла, после закрытия канала.
</pre>
      <br>
      <br>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN12454"
         href="#c12434_html_AEN12454"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Имеет тот же эффект, что и <a
           href="#x9307_html_NAMEDPIPEREF">именованные каналы</a>
          (временный файл), фактически, именованные каналы некогда
          использовались в операциях подстановки процессов.</p>
        </td>
      </tr>
    </table>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#c12376_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#c12483_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Ограниченный режим командной оболочки</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#p11889_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Функции</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="c12483_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#c12434_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x12644_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="CHAPTER">
      <h1><a
       name="c12483_html_FUNCTIONS"></a>Глава 22. Функции</h1>

      <p><a
       name="c12483_html_FUNCTIONREF"></a></p>

      <p>Подобно <span
       class="QUOTE">&quot;настоящим&quot;</span> языкам
      программирования, Bash тоже имеет функции, хотя и в несколько
      ограниченном варианте. Функция -- это подпрограмма, <a
       href="#c301_html_CODEBLOCKREF">блок кода</a> который реализует
      набор операций, своего рода <span
       class="QUOTE">&quot;черный ящик&quot;</span>, предназначенный
      для выполнения конкретной задачи. Функции могут использоваться
      везде, где имеются участки повторяющегося кода.</p>

      <p><strong
       class="COMMAND">function</strong> <tt
       class="REPLACEABLE"><em>function_name</em></tt> {<br>
       <tt
       class="REPLACEABLE"><em>command</em></tt>...<br>
       }<br>
      </p>
      или 

      <p><tt
       class="REPLACEABLE"><em>function_name</em></tt> () {<br>
       <tt
       class="REPLACEABLE"><em>command</em></tt>...<br>
       }<br>
      </p>
      <br>
      <br>

      <p>Вторая форма записи ближе к сердцу C-программистам (она же
      более переносимая).</p>

      <p>Как и в языке C, скобка, открывающая тело функции, может
      помещаться на следующей строке.</p>

      <p><tt
       class="REPLACEABLE"><em>function_name</em></tt> ()<br>
       {<br>
       <tt
       class="REPLACEABLE"><em>command</em></tt>...<br>
       }<br>
      </p>
      <br>
      <br>

      <p>Вызов функции осуществляется простым указанием ее имени в
      тексте сценария.</p>

      <div
       class="EXAMPLE">
        <a
         name="c12483_html_EX59"></a>

        <p><strong>Пример 22-1. Простая функция</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

funky ()
{
  echo &quot;Это обычная функция.&quot;
} # Функция должна быть объявлена раньше, чем ее можно будет использовать.

  # Вызов функции.

funky

exit 0
</pre>
      </div>

      <p>Функция должна быть объявлена раньше, чем ее можно будет
      использовать. К сожалению, в Bash нет возможности <span
       class="QUOTE">&quot;опережающего объявления&quot;</span>
      функции, как например в C.</p>
<pre
 class="PROGRAMLISTING">
f1
# Эта строка вызовет сообщение об ошибке, поскольку функция &quot;f1&quot; еще не определена.

declare -f f1      # Это не поможет.
f1                 # По прежнему -- сообщение об ошибке.

# Однако...


f1 ()
{
  echo &quot;Вызов функции \&quot;f2\&quot; из функции \&quot;f1\&quot;.&quot;
  f2
}

f2 ()
{
  echo &quot;Функция \&quot;f2\&quot;.&quot;
}

f1  #  Функция &quot;f2&quot;, фактически, не вызывается выше этой строки,
    #+ хотя ссылка на нее встречается выше, до ее объявления.
    #  Это допускается.

    # Спасибо S.C.
</pre>
      <br>
      <br>

      <p>Допускается даже создание вложенных функций, хотя пользы от
      этого немного.</p>
<pre
 class="PROGRAMLISTING">
f1 ()
{

  f2 () # вложенная
  {
    echo &quot;Функция \&quot;f2\&quot;, вложенная в \&quot;f1\&quot;.&quot;
  }

}

f2  #  Вызывает сообщение об ошибке.
    #  Даже &quot;declare -f f2&quot; не поможет.

echo

f1  #  Ничего не происходит, простой вызов &quot;f1&quot;, не означает автоматический вызов &quot;f2&quot;.
f2  #  Теперь все нормально, вызов &quot;f2&quot; не приводит к появлению ошибки,
    #+ поскольку функция &quot;f2&quot; была определена в процессе вызова &quot;f1&quot;.

    # Спасибо S.C.
</pre>
      <br>
      <br>

      <p>Объявление функции может размещаться в самых неожиданных
      местах.</p>
<pre
 class="PROGRAMLISTING">
ls -l | foo() { echo &quot;foo&quot;; }  # Допустимо, но бесполезно.



if [ &quot;$USER&quot; = bozo ]
then
  bozo_greet ()   # Объявление функции размещено в условном операторе.
  {
    echo &quot;Привет, Bozo!&quot;
  }
fi

bozo_greet        # Работает только у пользователя bozo, другие получат сообщение об ошибке.



# Нечто подобное можно использовать с определеной пользой для себя.
NO_EXIT=1   # Will enable function definition below.

[[ $NO_EXIT -eq 1 ]] &amp;&amp; exit() { true; }     # Определение функции в последовательности &quot;И-список&quot;.
# Если $NO_EXIT равна 1, то объявляется &quot;exit ()&quot;.
# Тем самым, функция &quot;exit&quot; подменяет встроенную команду &quot;exit&quot;.

exit  # Вызывается функция &quot;exit ()&quot;, а не встроенная команда &quot;exit&quot;.

# Спасибо S.C.
</pre>
      <br>
      <br>

      <div
       class="SECT1">
        <h1
         class="SECT1"><a
         name="c12483_html_COMPLEXFUNCT"></a>22.1. Сложные функции и сложности с
        функциями</h1>

        <p>Функции могут принимать входные аргументы и возвращать <a
         href="#c2105_html_EXITSTATUSREF">код завершения</a>.</p>
<pre
 class="PROGRAMLISTING">
function_name $arg1 $arg2
</pre>

        <p>Доступ к входным аргументам, в функциях, производится
        посредством <a
         href="#c3270_html_POSPARAMREF">позиционных параметров</a>, т.е.
        <tt
         class="VARNAME">$1</tt>, <tt
         class="VARNAME">$2</tt> и так далее.</p>

        <div
         class="EXAMPLE">
          <a
           name="c12483_html_EX60"></a>

          <p><strong>Пример 22-2. Функция с аргументами</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Функции и аргументы

DEFAULT=default                             # Значение аргумента по-умолчанию.

func2 () {
   if [ -z &quot;$1&quot; ]                           # Длина аргумента #1 равна нулю?
   then
     echo &quot;-Аргумент #1 имеет нулевую длину.-&quot;  # Или аргумент не был передан функции.
   else
     echo &quot;-Аргумент #1: \&quot;$1\&quot;.-&quot;
   fi

   variable=${1-$DEFAULT}                   #  Что делает
   echo &quot;variable = $variable&quot;              #+ показанная подстановка параметра?
                                            #  ---------------------------
                                            #  Она различает отсутствующий аргумент
                                            #+ от &quot;пустого&quot; аргумента.

   if [ &quot;$2&quot; ]
   then
     echo &quot;-Аргумент #2: \&quot;$2\&quot;.-&quot;
   fi

   return 0
}

echo

echo &quot;Вызов функции без аргументов.&quot;
func2
echo


echo &quot;Вызов функции с \&quot;пустым\&quot; аргументом.&quot;
func2 &quot;&quot;
echo

echo &quot;Вызов функции с неинициализированным аргументом.&quot;
func2 &quot;$uninitialized_param&quot;
echo

echo &quot;Вызов функции с одним аргументом.&quot;
func2 first
echo

echo &quot;Вызов функции с двумя аргументами.&quot;
func2 first second
echo

echo &quot;Вызов функции с аргументами \&quot;\&quot; \&quot;second\&quot;.&quot;
func2 &quot;&quot; second       # Первый параметр &quot;пустой&quot;
echo                  # и второй параметр -- ASCII-строка.

exit 0
</pre>
        </div>

        <div
         class="IMPORTANT">
          <table
           class="IMPORTANT"
           width="100%"
           border="0">
            <tr>
              <td
               width="25"
               align="center"
               valign="top"><img
               src="misc/abs-book/images/important.gif"
               hspace="5"
               alt="Important"></td>

              <td
               align="left"
               valign="top">
                <p>Команда <a
                 href="#x1716_html_SHIFTREF">shift</a> вполне применима
                и к аргументам функций (см. <a
                 href="#x13753_html_MULTIPLICATION">Пример
                33-10</a>).</p>
              </td>
            </tr>
          </table>
        </div>

        <div
         class="NOTE">
          <table
           class="NOTE"
           width="100%"
           border="0">
            <tr>
              <td
               width="25"
               align="center"
               valign="top"><img
               src="misc/abs-book/images/note.gif"
               hspace="5"
               alt="Note"></td>

              <td
               align="left"
               valign="top">
                <p>В отличие от других языков программирования, в
                сценариях на языке командной оболочке, в функции
                передаются аргументы по значению. <a
                 name="AEN12558"
                 href="#c12483_html_FTN_AEN12558"><span
                 class="footnote">[1]</span></a> Если имена переменных
                (которые фактически являются указателями) передаются
                функции в виде аргументов, то они интерпретируются как
                обычные строки символов и не могут быть разыменованы.
                <span
                 class="emphasis"><em
                 class="EMPHASIS">Функции интерпретируют свои аргументы
                буквально.</em></span></p>
              </td>
            </tr>
          </table>
        </div>

        <div
         class="VARIABLELIST">
          <p><strong><a
           name="c12483_html_EXITRETURN1"></a>Exit и Return</strong></p>

          <dl>
            <dt><strong
             class="COMMAND">код завершения</strong></dt>

            <dd>
              <p>Функции возвращают значение в виде <em
               class="FIRSTTERM">кода завершения</em>. Код завершения
              может быть задан явно, с помощью команды <strong
               class="COMMAND">return</strong>, в противном случае
              будет возвращен код завершения последней команды в
              функции (<span
               class="RETURNVALUE">0</span> -- в случае успеха, иначе
              -- ненулевой код ошибки). Код завершения в сценарии может
              быть получен через переменную <a
               href="#c3270_html_XSTATVARREF">$?</a>.</p>
            </dd>

            <dt><strong
             class="COMMAND">return</strong></dt>

            <dd>
              <p>Завершает исполнение функции. Команда <strong
               class="COMMAND">return</strong> <a
               name="AEN12587"
               href="#c12483_html_FTN_AEN12587"><span
               class="footnote">[2]</span></a> может иметь
              необязательный аргумент типа <span
               class="emphasis"><em
               class="EMPHASIS">integer</em></span>, который
              возвращается в вызывающий сценарий как <span
               class="QUOTE">&quot;код завершения&quot;</span> функции,
              это значение так же записывается в переменную <a
               href="#c3270_html_XSTATVARREF">$?</a>.</p>

              <div
               class="EXAMPLE">
                <a
                 name="c12483_html_MAX"></a>

                <p><strong>Пример 22-3. Наибольшее из двух
                чисел</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# max.sh: Наибольшее из двух целых чисел.

E_PARAM_ERR=-198    # Если функции передано меньше двух параметров.
EQUAL=-199          # Возвращаемое значение, если числа равны.

max2 ()             # Возвращает наибольшее из двух чисел.
{                   # Внимание: сравниваемые числа должны быть меньше 257.
if [ -z &quot;$2&quot; ]
then
  return $E_PARAM_ERR
fi

if [ &quot;$1&quot; -eq &quot;$2&quot; ]
then
  return $EQUAL
else
  if [ &quot;$1&quot; -gt &quot;$2&quot; ]
  then
    return $1
  else
    return $2
  fi
fi
}

max2 33 34
return_val=$?

if [ &quot;$return_val&quot; -eq $E_PARAM_ERR ]
then
  echo &quot;Функции должно быть передано два аргумента.&quot;
elif [ &quot;$return_val&quot; -eq $EQUAL ]
  then
    echo &quot;Числа равны.&quot;
else
    echo &quot;Наибольшее из двух чисел: $return_val.&quot;
fi


exit 0

#  Упражнение:
#  ---------------
#  Сделайте этот сценарий интерактивным,
#+ т.е. заставьте сценарий запрашивать числа для сравнения у пользователя (два числа).
</pre>
              </div>

              <div
               class="TIP">
                <table
                 class="TIP"
                 width="90%"
                 border="0">
                  <tr>
                    <td
                     width="25"
                     align="center"
                     valign="top"><img
                     src="misc/abs-book/images/tip.gif"
                     hspace="5"
                     alt="Tip"></td>

                    <td
                     align="left"
                     valign="top">
                      <p>Для случаев, когда функция должна возвращать
                      строку или массив, используйте специальные
                      переменные.</p>
<pre
 class="PROGRAMLISTING">
count_lines_in_etc_passwd()
{
  [[ -r /etc/passwd ]] &amp;&amp; REPLY=$(echo $(wc -l &lt; /etc/passwd))
  # Если файл /etc/passwd доступен на чтение, то в переменную REPLY заносится число строк.
  # Возвращаются как количество строк, так и код завершения.
}

if count_lines_in_etc_passwd
then
  echo &quot;В файле /etc/passwd найдено $REPLY строк.&quot;
else
  echo &quot;Невозможно подсчитать число строк в файле /etc/passwd.&quot;
fi

# Спасибо S.C.
</pre>
                      <br>
                      <br>
                    </td>
                  </tr>
                </table>
              </div>

              <div
               class="EXAMPLE">
                <a
                 name="c12483_html_EX61"></a>

                <p><strong>Пример 22-4. Преобразование чисел в римскую
                форму записи</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Преобразование чисел из арабской формы записи в римскую
# Диапазон: 0 - 200

# Расширение диапазона представляемых чисел и улучшение сценария
# оставляю вам, в качестве упражнения.

# Порядок использования: roman number-to-convert

LIMIT=200
E_ARG_ERR=65
E_OUT_OF_RANGE=66

if [ -z &quot;$1&quot; ]
then
  echo &quot;Порядок использования: `basename $0` number-to-convert&quot;
  exit $E_ARG_ERR
fi

num=$1
if [ &quot;$num&quot; -gt $LIMIT ]
then
  echo &quot;Выход за границы диапазона!&quot;
  exit $E_OUT_OF_RANGE
fi

to_roman ()   # Функция должна быть объявлена до того как она будет вызвана.
{
number=$1
factor=$2
rchar=$3
let &quot;remainder = number - factor&quot;
while [ &quot;$remainder&quot; -ge 0 ]
do
  echo -n $rchar
  let &quot;number -= factor&quot;
  let &quot;remainder = number - factor&quot;
done

return $number
       # Упражнение:
       # --------
       # Объясните -- как работает функция.
       # Подсказка: деление последовательным вычитанием.
}


to_roman $num 100 C
num=$?
to_roman $num 90 LXXXX
num=$?
to_roman $num 50 L
num=$?
to_roman $num 40 XL
num=$?
to_roman $num 10 X
num=$?
to_roman $num 9 IX
num=$?
to_roman $num 5 V
num=$?
to_roman $num 4 IV
num=$?
to_roman $num 1 I

echo

exit 0
</pre>
              </div>

              <p>См. также <a
               href="#x5210_html_ISALPHA">Пример 10-28</a>.</p>

              <div
               class="IMPORTANT">
                <table
                 class="IMPORTANT"
                 width="90%"
                 border="0">
                  <tr>
                    <td
                     width="25"
                     align="center"
                     valign="top"><img
                     src="misc/abs-book/images/important.gif"
                     hspace="5"
                     alt="Important"></td>

                    <td
                     align="left"
                     valign="top">
                      <p>Наибольшее положительное целое число, которое
                      может вернуть функция -- 255. Команда <strong
                       class="COMMAND">return</strong> очень тесно
                      связана с понятием <a
                       href="#c2105_html_EXITSTATUSREF">код
                      завершения</a>, что объясняет это специфическое
                      ограничение. К счастью существуют <a
                       href="#x13753_html_RVT">различные способы</a>
                      преодоления этого ограничения.</p>

                      <div
                       class="EXAMPLE">
                        <a
                         name="c12483_html_RETURNTEST"></a>

                        <p><strong>Пример 22-5. Проверка возможности
                        возврата функциями больших
                        значений</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# return-test.sh

# Наибольшее целое число, которое может вернуть функция, не может превышать 256.

return_test ()         # Просто возвращает то, что ей передали.
{
  return $1
}

return_test 27         # o.k.
echo $?                # Возвращено число 27.

return_test 255        # o.k.
echo $?                # Возвращено число 255.

return_test 257        # Ошибка!
echo $?                # Возвращено число 1.

return_test -151896    # Как бы то ни было, но для больших отрицательных чисел проходит!
echo $?                # Возвращено число -151896.

exit 0
</pre>
                      </div>

                      <p>Как видно из примера, функции могут возвращать
                      большие отрицательные значения (имеются ввиду --
                      большие по своему абсолютному значению, прим.
                      перев.). Используя эту особенность, можно
                      обыграть возможность получения от функций большие
                      положительные значения.</p>

                      <p>Еще один способ -- использовать глобальные
                      переменные для хранения <span
                       class="QUOTE">&quot;возвращаемого
                      значения&quot;</span>.</p>
<pre
 class="PROGRAMLISTING">
Return_Val=   # Глобальная переменная, которая хранит значение, возвращаемое функцией.

alt_return_test ()
{
  fvar=$1
  Return_Val=$fvar
  return   # Возвратить 0 (успешное завершение).
}

alt_return_test 1
echo $?                                  # 0
echo &quot;Функция вернула число $Return_Val&quot; # 1

alt_return_test 255
echo &quot;Функция вернула число $Return_Val&quot; # 255

alt_return_test 257
echo &quot;Функция вернула число $Return_Val&quot; # 257

alt_return_test 25701
echo &quot;Функция вернула число $Return_Val&quot; #25701
</pre>
                      <br>
                      <br>

                      <div
                       class="EXAMPLE">
                        <a
                         name="c12483_html_MAX2"></a>

                        <p><strong>Пример 22-6. Сравнение двух больших
                        целых чисел</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# max2.sh: Наибольшее из двух БОЛЬШИХ целых чисел.

# Это модификация предыдущего примера &quot;max.sh&quot;,
# которая позволяет выполнять сравнение больших целых чисел.

EQUAL=0             # Если числа равны.
MAXRETVAL=255       # Максимально возможное положительное число, которое может вернуть функция.
E_PARAM_ERR=-99999  # Код ошибки в параметрах.
E_NPARAM_ERR=99999  # &quot;Нормализованный&quot; код ошибки в параметрах.

max2 ()             # Возвращает наибольшее из двух больших целых чисел.
{
if [ -z &quot;$2&quot; ]
then
  return $E_PARAM_ERR
fi

if [ &quot;$1&quot; -eq &quot;$2&quot; ]
then
  return $EQUAL
else
  if [ &quot;$1&quot; -gt &quot;$2&quot; ]
  then
    retval=$1
  else
    retval=$2
  fi
fi

# -------------------------------------------------------------- #
# Следующие строки позволяют &quot;обойти&quot; ограничение
if [ &quot;$retval&quot; -gt &quot;$MAXRETVAL&quot; ]    # Если больше предельного значения,
then                                 # то
  let &quot;retval = (( 0 - $retval ))&quot;   # изменение знака числа.
  # (( 0 - $VALUE )) изменяет знак числа.
fi
# Функции имеют возможность возвращать большие *отрицательные* числа.
# -------------------------------------------------------------- #

return $retval
}

max2 33001 33997
return_val=$?

# -------------------------------------------------------------------------- #
if [ &quot;$return_val&quot; -lt 0 ]                  # Если число отрицательное,
then                                        # то
  let &quot;return_val = (( 0 - $return_val ))&quot;  # опять изменить его знак.
fi                                          # &quot;Абсолютное значение&quot; переменной $return_val.
# -------------------------------------------------------------------------- #


if [ &quot;$return_val&quot; -eq &quot;$E_NPARAM_ERR&quot; ]
then                   # Признак ошибки в параметрах, при выходе из функции так же поменял знак.
  echo &quot;Ошибка: Недостаточно аргументов.&quot;
elif [ &quot;$return_val&quot; -eq &quot;$EQUAL&quot; ]
  then
    echo &quot;Числа равны.&quot;
else
    echo &quot;Наиболшее число: $return_val.&quot;
fi

exit 0
</pre>
                      </div>

                      <p>См. также <a
                       href="#a14477_html_DAYSBETWEEN">Пример
                      A-8</a>.</p>

                      <p><tt
                       class=
                      "USERINPUT"><strong>Упражнение:</strong></tt>
                      Используя только что полученные знания, добавьте
                      в предыдущий пример, <a
                       href="#c12483_html_EX61">преобразования чисел в
                      римскую форму записи</a>, возможность
                      обрабатывать большие числа.</p>
                    </td>
                  </tr>
                </table>
              </div>
            </dd>
          </dl>
        </div>

        <div
         class="VARIABLELIST">
          <p><strong><a
           name="c12483_html_REDSTDINFUNC1"></a>Перенаправление</strong></p>

          <dl>
            <dt><tt
             class="REPLACEABLE"><em>Перенаправление ввода для
            функций</em></tt></dt>

            <dd>
              <p>Функции -- суть есть <a
               href="#c301_html_CODEBLOCKREF">блок кода</a>, а это
              означает, что устройство <tt
               class="FILENAME">stdin</tt> для функций может быть
              переопределено (перенаправление stdin) (как в <a
               href="#c301_html_EX8">Пример 3-1</a>).</p>

              <div
               class="EXAMPLE">
                <a
                 name="c12483_html_REALNAME"></a>

                <p><strong>Пример 22-7. Настоящее имя
                пользователя</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# По имени пользователя получить его &quot;настоящее имя&quot; из /etc/passwd.

ARGCOUNT=1  # Ожидается один аргумент.
E_WRONGARGS=65

file=/etc/passwd
pattern=$1

if [ $# -ne &quot;$ARGCOUNT&quot; ]
then
  echo &quot;Порядок использования: `basename $0` USERNAME&quot;
  exit $E_WRONGARGS
fi

file_excerpt ()  # Производит поиск в файле по заданному шаблону, выводит требуемую часть строки.
{
while read line
do
  echo &quot;$line&quot; | grep $1 | awk -F&quot;:&quot; &#39;{ print $5 }&#39;  # Указывет awk использовать &quot;:&quot; как разделитель полей.
done
} &lt;$file  # Подменить stdin для функции.

file_excerpt $pattern

# Да, этот сценарий можно уменьшить до
#       grep PATTERN /etc/passwd | awk -F&quot;:&quot; &#39;{ print $5 }&#39;
# или
#       awk -F: &#39;/PATTERN/ {print $5}&#39;
# или
#       awk -F: &#39;($1 == &quot;username&quot;) { print $5 }&#39;
# Однако, это было бы не так поучительно.

exit 0
</pre>
              </div>

              <p>Ниже приводится альтернативный, и возможно менее
              запутанный, способ перенаправления ввода для функций. Он
              заключается в использовании перенаправления ввода для
              блока кода, заключенного в фигурные скобки, в пределах
              функции.</p>
<pre
 class="PROGRAMLISTING">
# Вместо:
Function ()
{
 ...
 } &lt; file

# Попробуйте так:
Function ()
{
  {
    ...
   } &lt; file
}

# Похожий вариант,

Function ()  # Тоже работает.
{
  {
   echo $*
  } | tr a b
}

Function ()  # Этот вариант не работает.
{
  echo $*
} | tr a b   # Наличие вложенного блока кода -- обязательное условие.


# Спасибо S.C.
</pre>
              <br>
              <br>
            </dd>
          </dl>
        </div>
      </div>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN12558"
         href="#c12483_html_AEN12558"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Механизм <a
           href="#x4788_html_IVRREF">косвенных ссылок</a> на переменные
          (см. <a
           href="#c13936_html_EX78">Пример 34-2</a>) слишком неудобен
          для передачи аргументов по ссылке.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

ITERATIONS=3  # Количество вводимых значений.
icount=1

my_read () {
  # При вызове my_read varname,
  # выводит предыдущее значение в квадратных скобках,
  # затем просит ввести новое значение.

  local local_var

  echo -n &quot;Введите говое значение переменной &quot;
  eval &#39;echo -n &quot;[$&#39;$1&#39;] &quot;&#39;  # Прежнее значение.
  read local_var
  [ -n &quot;$local_var&quot; ] &amp;&amp; eval $1=\$local_var

  # Последовательность &quot;And-list&quot;: если &quot;local_var&quot; не пуста, то ее значение переписывается в &quot;$1&quot;.
}

echo

while [ &quot;$icount&quot; -le &quot;$ITERATIONS&quot; ]
do
  my_read var
  echo &quot;Значение #$icount = $var&quot;
  let &quot;icount += 1&quot;
  echo
done


# Спасибо Stephane Chazelas за этот поучительный пример.

exit 0
</pre>
          <br>
          <br>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN12587"
         href="#c12483_html_AEN12587"><span
         class="footnote">[2]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Команда <strong
           class="COMMAND">return</strong> -- это <a
           href="#c5358_html_BUILTINREF">встроенная</a> команда
          Bash.</p>
        </td>
      </tr>
    </table>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#c12434_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x12644_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Подстановка процессов</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#p11889_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Локальные переменные</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="c12683_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x12644_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#c12716_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="CHAPTER">
      <h1><a
       name="c12683_html_ALIASES"></a>Глава 23. Псевдонимы</h1>

      <p><a
       name="c12683_html_ALIASREF"></a></p>

      <p><span
       class="emphasis"><em
       class="EMPHASIS">Псевдонимы</em></span> в Bash -- это ни что
      иное, как &quot;горячие клавиши&quot;, средство, позволяющее
      избежать набора длинных строк в командной строке. Если, к
      примеру, в файл <a
       href="#c12891_html_FILESREF1"><tt
       class="FILENAME">~/.bashrc</tt></a> вставить строку <strong
       class="COMMAND">alias lm=&quot;ls -l | more&quot;</strong>, то
      потом вы сможете экономить свои силы и время, набирая команду <tt
       class="USERINPUT"><strong>lm</strong></tt>, вместо более длинной
      <strong
       class="COMMAND">ls -l | more</strong>. Установив <strong
       class="COMMAND">alias rm=&quot;rm -i&quot;</strong>
      (интерактивный режим удаления файлов), вы сможете избежать многих
      неприятностей, потому что сократится вероятность удаления важных
      файлов по неосторожности.</p>

      <p>Псевдонимы в сценариях могут иметь весьма ограниченную область
      применения. Было бы здорово, если бы псевдонимы имели
      функциональность, присущую макроопределениям в языке C, но, к
      сожалению, Bash не может &quot;разворачивать&quot; аргументы в
      теле псевдонима. <a
       name="AEN12698"
       href="#c12683_html_FTN_AEN12698"><span
       class="footnote">[1]</span></a> Кроме того, попытка обратиться к
      псевдониму, созданному внутри <span
       class="QUOTE">&quot;составных конструкций&quot;</span>, таких
      как <a
       href="#c2171_html_IFTHEN">if/then</a>, циклы и функции, будет
      приводить к появлению ошибок. Практически всегда, действия,
      возлагаемые на псевдоним, более эффективно могут быть выполнены с
      помощью <a
       href="#c12483_html_FUNCTIONREF">функций</a>.</p>

      <div
       class="EXAMPLE">
        <a
         name="c12683_html_AL"></a>

        <p><strong>Пример 23-1. Псевдонимы в сценарии</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

shopt -s expand_aliases
# Эта опция должна быть включена, иначе сценарий не сможет &quot;разворачивать&quot; псевдонимы.

alias ll=&quot;ls -l&quot;
# В определении псевдонима можно использовать как одиночные (&#39;), так и двойные (&quot;) кавычки.

echo &quot;Попытка обращения к псевдониму \&quot;ll\&quot;:&quot;
ll /usr/X11R6/bin/mk*   #* Работает.

echo

directory=/usr/X11R6/bin/
prefix=mk*  # Определить -- не будет ли проблем с шаблонами.
echo &quot;Переменные \&quot;directory\&quot; + \&quot;prefix\&quot; = $directory$prefix&quot;
echo

alias lll=&quot;ls -l $directory$prefix&quot;

echo &quot;Попытка обращения к псевдониму \&quot;lll\&quot;:&quot;
lll         # Список всех файлов в /usr/X11R6/bin, чьи имена начинаются с mk.
# Псевдонимы могут работать с шаблонами.




TRUE=1

echo

if [ TRUE ]
then
  alias rr=&quot;ls -l&quot;
  echo &quot;Попытка обращения к псевдониму \&quot;rr\&quot;, созданному внутри if/then:&quot;
  rr /usr/X11R6/bin/mk*   #* В результате -- сообщение об ошибке!
  # К псевдонимам, созданным внутри составных инструкций, нельзя обратиться.
  echo &quot;Однако, ранее созданный псевдоним остается работоспособным:&quot;
  ll /usr/X11R6/bin/mk*
fi

echo

count=0
while [ $count -lt 3 ]
do
  alias rrr=&quot;ls -l&quot;
  echo &quot;Попытка обращения к псевдониму \&quot;rrr\&quot;, созданному внутри цикла \&quot;while\&quot;:&quot;
  rrr /usr/X11R6/bin/mk*   #* Так же возникает ошибка.
                           #  alias.sh: line 57: rrr: command not found
  let count+=1
done

echo; echo

alias xyz=&#39;cat $0&#39;   # Сценарий печатает себя самого.
                     # Обратите внимание на &quot;строгие&quot; кавычки.
xyz
#  Похоже работает,
#+ хотя документация Bash утверждает, что такой псевдоним не должен работать.
#
#  Steve Jacobson отметил, что
#+ параметр &quot;$0&quot; интерпретируется непосредственно, во время объявления псевдонима.

exit 0
</pre>
      </div>

      <p>Команда <strong
       class="COMMAND">unalias</strong> удаляет псевдоним, объявленный
      ранее .</p>

      <div
       class="EXAMPLE">
        <a
         name="c12683_html_UNAL"></a>

        <p><strong>Пример 23-2. unalias: Объявление и удаление
        псевдонимов</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

shopt -s expand_aliases  # Разрешить &quot;разворачивание&quot; псевдонимов.

alias llm=&#39;ls -al | more&#39;
llm

echo

unalias llm              # Удалить псевдоним.
llm
# Сообщение об ошибке, т.к. команда &#39;llm&#39; больше не распознается.

exit 0
</pre>
      </div>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>./unalias.sh</strong></tt>
<tt
 class="COMPUTEROUTPUT">total 6
drwxrwxr-x    2 bozo     bozo         3072 Feb  6 14:04 .
drwxr-xr-x   40 bozo     bozo         2048 Feb  6 14:04 ..
-rwxr-xr-x    1 bozo     bozo          199 Feb  6 14:04 unalias.sh

./unalias.sh: llm: command not found</tt>
</pre>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN12698"
         href="#c12683_html_AEN12698"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Однако, псевдонимы могут &quot;раскручивать&quot;
          позиционные параметры.</p>
        </td>
      </tr>
    </table>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x12644_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#c12716_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Локальные переменные</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#p11889_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Списки команд</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="c12716_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#c12683_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#c12790_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="CHAPTER">
      <h1><a
       name="c12716_html_LIST-CONS"></a>Глава 24. Списки команд</h1>

      <p><a
       name="c12716_html_LISTCONSREF"></a></p>

      <p>Средством обработки последовательности из нескольких команд
      служат списки: <span
       class="QUOTE">&quot;И-списки&quot;</span> и <span
       class="QUOTE">&quot;ИЛИ-списки&quot;</span>. Они эффективно
      могут заменить сложную последовательность вложенных <strong
       class="COMMAND">if</strong>/<strong
       class="COMMAND">then</strong> или даже <strong
       class="COMMAND">case</strong>.</p>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="c12716_html_LCONS1"></a>Объединение команд в цепочки</strong></p>

        <dl>
          <dt>И-список</dt>

          <dd>
<pre
 class="PROGRAMLISTING">
command-1 &amp;&amp; command-2 &amp;&amp; command-3 &amp;&amp; ... command-n
</pre>
            Каждая последующая команда, в таком списке, выполняется
            только тогда, когда предыдущая команда вернула код
            завершения <span
             class="RETURNVALUE">true</span> (ноль). Если какая-либо из
            команд возвращает <span
             class="RETURNVALUE">false</span> (не ноль), то исполнение
            списка команд в этом месте завершается, т.е. следующие
            далее команды не выполняются.<br>
            <br>

            <div
             class="EXAMPLE">
              <a
               name="c12716_html_EX64"></a>

              <p><strong>Пример 24-1. Проверка аргументов командной
              строки с помощью <span
               class="QUOTE">&quot;И-списка&quot;</span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# &quot;И-список&quot;

if [ ! -z &quot;$1&quot; ] &amp;&amp; echo &quot;Аргумент #1 = $1&quot; &amp;&amp; [ ! -z &quot;$2&quot; ] &amp;&amp; echo &quot;Аргумент #2 = $2&quot;
then
  echo &quot;Сценарию передано не менее 2 аргументов.&quot;
  # Все команды в цепочке возвращают true.
else
  echo &quot;Сценарию передано менее 2 аргументов.&quot;
  # Одна из команд в списке вернула false.
fi
# Обратите внимание: &quot;if [ ! -z $1 ]&quot; тоже работает, но, казалось бы эквивалентный вариант
#  if [ -n $1 ] -- нет. Однако, если добавить кавычки
#  if [ -n &quot;$1&quot; ] то все работает.  Будьте внимательны!
# Проверяемые переменные лучше всегда заключать в кавычки.


# То же самое, только без списка команд.
if [ ! -z &quot;$1&quot; ]
then
  echo &quot;Аргумент #1 = $1&quot;
fi
if [ ! -z &quot;$2&quot; ]
then
  echo &quot;Аргумент #2 = $2&quot;
  echo &quot;Сценарию передано не менее 2 аргументов.&quot;
else
  echo &quot;Сценарию передано менее 2 аргументов.&quot;
fi
# Получилось менее элегантно и длиннее, чем с использованием &quot;И-списка&quot;.


exit 0
</pre>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="c12716_html_ANDLIST2"></a>

              <p><strong>Пример 24-2. Еще один пример проверки
              аргументов с помощью <span
               class="QUOTE">&quot;И-списков&quot;</span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

ARGS=1        # Ожидаемое число аргументов.
E_BADARGS=65  # Код завершения, если число аргументов меньше ожидаемого.

test $# -ne $ARGS &amp;&amp; echo &quot;Порядок использования: `basename $0` $ARGS аргумент(а)(ов)&quot; &amp;&amp; exit $E_BADARGS
# Если проверка первого условия возвращает true (неверное число аргументов),
# то исполняется остальная часть строки, и сценарий завершается.

# Строка ниже выполняется только тогда, когда проверка выше не проходит.
# обратите внимание на условие &quot;-ne&quot; -- &quot;не равно&quot; (прим. перев.)
echo &quot;Сценарию передано корректное число аргументов.&quot;

exit 0

# Проверьте код завершения сценария командой &quot;echo $?&quot;.
</pre>
            </div>

            <p><a
             name="c12716_html_ANDDEFAULT"></a></p>

            <p>Конечно же, с помощью <span
             class="emphasis"><em
             class="EMPHASIS">И-списка</em></span> можно присваивать
            переменным значения по-умолчанию.</p>
<pre
 class="PROGRAMLISTING">
arg1=$@       # В $arg1 записать аргументы командной строки.

[ -z &quot;$arg1&quot; ] &amp;&amp; arg1=DEFAULT
              # Записать DEFAULT, если аргументы командной строки отсутствуют.
</pre>
            <br>
            <br>
          </dd>

          <dt>ИЛИ-список</dt>

          <dd>
<pre
 class="PROGRAMLISTING">
command-1 || command-2 || command-3 || ... command-n
</pre>
            Каждая последующая команда, в таком списке, выполняется
            только тогда, когда предыдущая команда вернула код
            завершения <span
             class="RETURNVALUE">false</span> (не ноль). Если
            какая-либо из команд возвращает <span
             class="RETURNVALUE">true</span> (ноль), то исполнение
            списка команд в этом месте завершается, т.е. следующие
            далее команды не выполняются. Очевидно, что <span
             class="QUOTE">&quot;ИЛИ-списки&quot;</span> имеют смысл
            обратный, по отношению к <span
             class="QUOTE">&quot;И-спискам&quot;</span><br>
            <br>

            <div
             class="EXAMPLE">
              <a
               name="c12716_html_EX65"></a>

              <p><strong>Пример 24-3. Комбинирование <span
               class="QUOTE">&quot;ИЛИ-списков&quot;</span> и <span
               class="QUOTE">&quot;И-списков&quot;</span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

#  delete.sh, утилита удаления файлов.
#  Порядок использования: delete имя_файла

E_BADARGS=65

if [ -z &quot;$1&quot; ]
then
  echo &quot;Порядок использования: `basename $0` имя_файла&quot;
  exit $E_BADARGS  # Если не задано имя файла.
else
  file=$1          # Запомнить имя файла.
fi


[ ! -f &quot;$file&quot; ] &amp;&amp; echo &quot;Файл \&quot;$file\&quot; не найден. \
Робкий отказ удаления несуществующего файла.&quot;
# И-СПИСОК, выдать сообщение об ошибке, если файл не существует.
# Обратите внимание: выводимое сообщение продолжается во второй строке,
# благодаря экранированию символа перевода строки.

[ ! -f &quot;$file&quot; ] || (rm -f $file; echo &quot;Файл \&quot;$file\&quot; удален.&quot;)
# ИЛИ-СПИСОК, удаляет существующий файл.

# Обратите внимание на логические условия.
# И-СПИСОК отрабатывает по true, ИЛИ-СПИСОК -- по false.

exit 0
</pre>
            </div>
          </dd>
        </dl>
      </div>

      <div
       class="IMPORTANT">
        <table
         class="IMPORTANT"
         width="100%"
         border="0">
          <tr>
            <td
             width="25"
             align="center"
             valign="top"><img
             src="misc/abs-book/images/important.gif"
             hspace="5"
             alt="Important"></td>

            <td
             align="left"
             valign="top">
              <p>Списки возвращают <a
               href="#c2105_html_EXITSTATUSREF">код завершения</a>
              последней выполненной команды.</p>
            </td>
          </tr>
        </table>
      </div>

      <p>Комбинируя <span
       class="QUOTE">&quot;И&quot;</span> и <span
       class="QUOTE">&quot;ИЛИ&quot;</span> списки, легко
      &quot;перемудрить&quot; с логическими условиями, поэтому, в таких
      случаях может потребоваться детальная отладка.</p>
<pre
 class="PROGRAMLISTING">
false &amp;&amp; true || echo false         # false

# Тот же результат дает
( false &amp;&amp; true ) || echo false     # false
# Но не эта комбинация
false &amp;&amp; ( true || echo false )     # (нет вывода на экран)

#  Обратите внимание на группировку и порядок вычисления условий -- слева-направо,
#+ поскольку логические операции &quot;&amp;&amp;&quot; и &quot;||&quot; имеют равный приоритет.

#  Если вы не уверены в своих действиях, то лучше избегать таких сложных конструкций.

#  Спасибо S.C.
</pre>
      <br>
      <br>

      <p>См. <a
       href="#a14477_html_DAYSBETWEEN">Пример A-8</a> и <a
       href="#x2389_html_BROKENLINK">Пример 7-4</a>, иллюстрирующие
      использование <tt
       class="USERINPUT"><strong>И/ИЛИ-списков</strong></tt> для
      проверки переменных.</p>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#c12683_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#c12790_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Псевдонимы</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#p11889_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Массивы</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="c12790_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#c12716_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#c12891_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="CHAPTER">
      <h1><a
       name="c12790_html_ARRAYS"></a>Глава 25. Массивы</h1>

      <p><a
       name="c12790_html_ARRAYREF"></a></p>

      <p>Новейшие версии Bash поддерживают одномерные массивы.
      Инициализация элементов массива может быть произведена в виде:
      <tt
       class="USERINPUT"><strong>variable[xx]</strong></tt>. Можно явно
      объявить массив в сценарии, с помощью директивы declare: <tt
       class="USERINPUT"><strong>declare -a variable</strong></tt>.
      Обращаться к отдельным элементам массива можно с помощью <em
       class="FIRSTTERM">фигурных скобок</em>, т.е.: <tt
       class="USERINPUT"><strong>${variable[xx]}</strong></tt>.</p>

      <div
       class="EXAMPLE">
        <a
         name="c12790_html_EX66"></a>

        <p><strong>Пример 25-1. Простой массив</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash


area[11]=23
area[13]=37
area[51]=UFOs

# Массивы не требуют, чтобы последовательность элементов в массиве была непрерывной.

# Некоторые элементы массива могут оставаться неинициализированными.
# &quot;Дыркм&quot; в массиве не являются ошибкой.


echo -n &quot;area[11] = &quot;
echo ${area[11]}    #  необходимы {фигурные скобки}

echo -n &quot;area[13] = &quot;
echo ${area[13]}

echo &quot;содержимое area[51] = ${area[51]}.&quot;

# Обращение к неинициализированным элементам дает пустую строку.
echo -n &quot;area[43] = &quot;
echo ${area[43]}
echo &quot;(элемент area[43] -- неинициализирован)&quot;

echo

# Сумма двух элементов массива, записанная в третий элемент
area[5]=`expr ${area[11]} + ${area[13]}`
echo &quot;area[5] = area[11] + area[13]&quot;
echo -n &quot;area[5] = &quot;
echo ${area[5]}

area[6]=`expr ${area[11]} + ${area[51]}`
echo &quot;area[6] = area[11] + area[51]&quot;
echo -n &quot;area[6] = &quot;
echo ${area[6]}
# Эта попытка закончится неудачей, поскольку сложение целого числа со строкой не допускается.

echo; echo; echo

# -----------------------------------------------------------------
# Другой массив, &quot;area2&quot;.
# И другой способ инициализации массива...
# array_name=( XXX YYY ZZZ ... )

area2=( ноль один два три четыре )

echo -n &quot;area2[0] = &quot;
echo ${area2[0]}
# Ага, индексация начинается с нуля (первый элемент массива имеет индекс [0], а не [1]).

echo -n &quot;area2[1] = &quot;
echo ${area2[1]}    # [1] -- второй элемент массива.
# -----------------------------------------------------------------

echo; echo; echo

# -----------------------------------------------
# Еще один массив, &quot;area3&quot;.
# И еще один способ инициализации...
# array_name=([xx]=XXX [yy]=YYY ...)

area3=([17]=семнадцать [21]=двадцать_один)

echo -n &quot;area3[17] = &quot;
echo ${area3[17]}

echo -n &quot;area3[21] = &quot;
echo ${area3[21]}
# -----------------------------------------------

exit 0
</pre>
      </div>

      <div
       class="NOTE">
        <table
         class="NOTE"
         width="100%"
         border="0">
          <tr>
            <td
             width="25"
             align="center"
             valign="top"><img
             src="misc/abs-book/images/note.gif"
             hspace="5"
             alt="Note"></td>

            <td
             align="left"
             valign="top">
              <p>Bash позволяет оперировать переменными, как массивами,
              даже если они не были явно объявлены таковыми.</p>
<pre
 class="PROGRAMLISTING">
string=abcABC123ABCabc
echo ${string[@]}               # abcABC123ABCabc
echo ${string[*]}               # abcABC123ABCabc
echo ${string[0]}               # abcABC123ABCabc
echo ${string[1]}               # Ничего не выводится!
                                # Почему?
echo ${#string[@]}              # 1
                                # Количество элементов в массиве.

# Спасибо Michael Zick за этот пример.
</pre>
              Эти примеры еще раз подтверждают <a
               href="#x1705_html_BVUNTYPED">отсутствие контроля типов в
              Bash</a>. <br>
              <br>
            </td>
          </tr>
        </table>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="c12790_html_POEM"></a>

        <p><strong>Пример 25-2. Форматирование
        стихотворения</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# poem.sh

# Строки из стихотворения (одна строфа).
Line[1]=&quot;Мой дядя самых честных правил,&quot;
Line[2]=&quot;Когда не в шутку занемог;&quot;
Line[3]=&quot;Он уважать себя заставил,&quot;
Line[4]=&quot;И лучше выдумать не мог.&quot;
Line[5]=&quot;Его пример другим наука...&quot;

# Атрибуты.
Attrib[1]=&quot; А.С. Пушкин&quot;
Attrib[2]=&quot;\&quot;Евгений Онегин\&quot;&quot;

for index in 1 2 3 4 5    # Пять строк.
do
  printf &quot;     %s\n&quot; &quot;${Line[index]}&quot;
done

for index in 1 2          # Две строки дополнительных атрибутов.
do
  printf &quot;          %s\n&quot; &quot;${Attrib[index]}&quot;
done

exit 0
</pre>
      </div>

      <p>При работе с отдельными элементами массива можно использовать
      специфический синтаксис, даже стандартные команды и операторы
      Bash адаптированы для работы с массивами.</p>
<pre
 class="PROGRAMLISTING">
array=( ноль один два три четыре пять )

echo ${array[0]}       #  ноль
echo ${array:0}        #  ноль
                       #  Подстановка параметра -- первого элемента.
echo ${array:1}        #  оль
                       #  Подстановка параметра -- первого элемента,
                       #+ начиная с позиции #1 (со 2-го символа).

echo ${#array}         #  4
                       #  Длина первого элемента массива.



array2=( [0]=&quot;первый элемент&quot; [1]=&quot;второй элемент&quot; [3]=&quot;четвертый элемент&quot; )

echo ${array2[0]}      # первый элемент
echo ${array2[1]}      # второй элемент
echo ${array2[2]}      #
                       # Элемент неинициализирован, поэтому на экран ничего не выводится.
echo ${array2[3]}      # четвертый элемент
</pre>
      <br>
      <br>

      <p>При работе с массивами, некоторые <a
       href="#c5358_html_BUILTINREF">встроенные команды</a> Bash имеют
      несколько иной смысл. Например, <a
       href="#c5358_html_UNSETREF">unset</a> -- удаляет отдельные
      элементы массива, или даже массив целиком.</p>

      <div
       class="EXAMPLE">
        <a
         name="c12790_html_EX67"></a>

        <p><strong>Пример 25-3. Некоторые специфичные особенности
        массивов</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

declare -a colors
# Допускается объявление массива без указания его размера.

echo &quot;Введите ваши любимые цвета (разделяя их пробелами).&quot;

read -a colors    # Введите хотя бы 3 цвета для демонстрации некоторых свойств массивов.
#  Специфический ключ команды &#39;read&#39;,
#+ позволяющий вводить несколько элементов массива.

echo

element_count=${#colors[@]}

# Получение количества элементов в массиве.
#     element_count=${#colors[*]} -- дает тот же результат.
#
#  Переменная &quot;@&quot; позволяет &quot;разбивать&quot; строку в кавычках на отдельные слова
#+ (выделяются слова, разделенные пробелами).

index=0

while [ &quot;$index&quot; -lt &quot;$element_count&quot; ]
do    # Список всех элементов в массиве.
  echo ${colors[$index]}
  let &quot;index = $index + 1&quot;
done
# Каждый элемент массива выводится в отдельной строке.
# Если этого не требуется, то используйте  echo -n &quot;${colors[$index]} &quot;
#
# Эквивалентный цикл &quot;for&quot;:
#   for i in &quot;${colors[@]}&quot;
#   do
#     echo &quot;$i&quot;
#   done
# (Спасибо S.C.)

echo

# Еще один, более элегантный, способ вывода списка всех элементов массива.
  echo ${colors[@]}          # ${colors[*]} дает тот же результат.

echo

# Команда &quot;unset&quot; удаляет элементы из массива, или даже массив целиком.
unset colors[1]              # Удаление 2-го элемента массива.
                             # Тот же эффект дает команда   colors[1]=
echo  ${colors[@]}           # Список всех элементов массива -- 2-й элемент отсутствует.

unset colors                 # Удаление всего массива.
                             #  Тот же эффект имеют команды unset colors[*]
                             #+ и unset colors[@].
echo; echo -n &quot;Массив цветов опустошен.&quot;
echo ${colors[@]}            # Список элементов массива пуст.

exit 0
</pre>
      </div>

      <p>Как видно из предыдущего примера, обращение к <strong
       class="COMMAND">${array_name[@]}</strong> или <strong
       class="COMMAND">${array_name[*]}</strong> относится ко <span
       class="emphasis"><em
       class="EMPHASIS">всем</em></span> элементам массива. Чтобы
      получить количество элементов массива, можно обратиться к <strong
       class="COMMAND">${#array_name[@]}</strong> или к <strong
       class="COMMAND">${#array_name[*]}</strong>. <strong
       class="COMMAND">${#array_name}</strong> -- это длина (количество
      символов) первого элемента массива, т.е. <strong
       class="COMMAND">${array_name[0]}</strong>.</p>

      <div
       class="EXAMPLE">
        <a
         name="c12790_html_EMPTYARRAY"></a>

        <p><strong>Пример 25-4. Пустые массивы и пустые
        элементы</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# empty-array.sh

#  Выражаю свою благодарность Stephane Chazelas за этот пример,
#+ и Michael Zick за его доработку.


# Пустой массив -- это не то же самое, что массив с пустыми элементами.

array0=( первый второй третий )
array1=( &#39;&#39; )   # &quot;array1&quot; имеет один пустой элемент.
array2=( )      # Массив &quot;array2&quot; не имеет ни одного элемента, т.е. пуст.

echo
ListArray()
{
echo
echo &quot;Элементы массива array0:  ${array0[@]}&quot;
echo &quot;Элементы массива array1:  ${array1[@]}&quot;
echo &quot;Элементы массива array2:  ${array2[@]}&quot;
echo
echo &quot;Длина первого элемента массива array0 = ${#array0}&quot;
echo &quot;Длина первого элемента массива array1 = ${#array1}&quot;
echo &quot;Длина первого элемента массива array2 = ${#array2}&quot;
echo
echo &quot;Число элементов в массиве array0 = ${#array0[*]}&quot;  # 3
echo &quot;Число элементов в массиве array1 = ${#array1[*]}&quot;  # 1  (сюрприз!)
echo &quot;Число элементов в массиве array2 = ${#array2[*]}&quot;  # 0
}

# ===================================================================

ListArray

# Попробуем добавить новые элементы в массивы

# Добавление новых элементов в массивы.
array0=( &quot;${array0[@]}&quot; &quot;новый1&quot; )
array1=( &quot;${array1[@]}&quot; &quot;новый1&quot; )
array2=( &quot;${array2[@]}&quot; &quot;новый1&quot; )

ListArray

# или
array0[${#array0[*]}]=&quot;новый2&quot;
array1[${#array1[*]}]=&quot;новый2&quot;
array2[${#array2[*]}]=&quot;новый2&quot;

ListArray

# Теперь представим каждый массив как &#39;стек&#39; (&#39;stack&#39;)
# Команды выше, можно считать командами &#39;push&#39; -- добавление нового значения на вершину стека
# &#39;Глубина&#39; стека:
height=${#array2[@]}
echo
echo &quot;Глубина стека array2 = $height&quot;

# Команда &#39;pop&#39; -- выталкивание элемента стека, находящегося на вершине:
unset array2[${#array2[@]}-1]   # Индексация массивов начинается с нуля
height=${#array2[@]}
echo
echo &quot;POP&quot;
echo &quot;Глубина стека array2, после выталкивания = $height&quot;

ListArray

# Вывести только 2-й и 3-й элементы массива array0
from=1          # Индексация массивов начинается с нуля
to=2              #
declare -a array3=( ${array0[@]:1:2} )
echo
echo &quot;Элементы массива array3:  ${array3[@]}&quot;

# Замена элементов по шаблону
declare -a array4=( ${array0[@]/второй/2-й} )
echo
echo &quot;Элементы массива array4:  ${array4[@]}&quot;

# Замена строк по шаблону
declare -a array5=( ${array0[@]//новый?/старый} )
echo
echo &quot;Элементы массива array5:  ${array5[@]}&quot;

# Надо лишь привыкнуть к такой записи...
declare -a array6=( ${array0[@]#*новый} )
echo # Это может вас несколько удивить
echo &quot;Элементы массива array6:  ${array6[@]}&quot;

declare -a array7=( ${array0[@]#новый1} )
echo # Теперь это вас уже не должно удивлять
echo &quot;Элементы массива array7:  ${array7[@]}&quot;

# Выглядить очень похоже на предыдущий вариант...
declare -a array8=( ${array0[@]/новый1/} )
echo
echo &quot;Элементы массива array8:  ${array8[@]}&quot;

#  Итак, что вы можете сказать обо всем этом?

#  Строковые операции выполняются последовательно, над каждым элементом
#+ в массиве var[@].
#  Таким образом, BASH поддерживает векторные операции
#  Если в результате операции получается пустая строка, то
#+ элемент массива &quot;исчезает&quot;.

#  Вопрос: это относится к строкам в &quot;строгих&quot; или &quot;мягких&quot; кавычках?

zap=&#39;новый*&#39;
declare -a array9=( ${array0[@]/$zap/} )
echo
echo &quot;Элементы массива array9:  ${array9[@]}&quot;

# &quot;...А с платформы говорят: &quot;Это город Ленинград!&quot;...&quot;
declare -a array10=( ${array0[@]#$zap} )
echo
echo &quot;Элементы массива array10:  ${array10[@]}&quot;

# Сравните массивы array7 и array10
# Сравните массивы array8 и array9

# Ответ: в &quot;мягких&quot; кавычках.

exit 0
</pre>
      </div>

      <p>Разница между <strong
       class="COMMAND">${array_name[@]}</strong> и <strong
       class="COMMAND">${array_name[*]}</strong> такая же, как между <a
       href="#c3270_html_APPREF">$@ и $*</a>. Эти свойства массивов
      широко применяются на практике.</p>
<pre
 class="PROGRAMLISTING">
# Копирование массивов.
array2=( &quot;${array1[@]}&quot; )
# или
array2=&quot;${array1[@]}&quot;

# Добавить элемент.
array=( &quot;${array[@]}&quot; &quot;новый элемент&quot; )
# или
array[${#array[*]}]=&quot;новый элемент&quot;

# Спасибо S.C.
</pre>
      <br>
      <br>

      <div
       class="TIP">
        <table
         class="TIP"
         width="100%"
         border="0">
          <tr>
            <td
             width="25"
             align="center"
             valign="top"><img
             src="misc/abs-book/images/tip.gif"
             hspace="5"
             alt="Tip"></td>

            <td
             align="left"
             valign="top">
              <p>Операция <a
               href="#c11441_html_COMMANDSUBREF">подстановки команд</a>
              -- <strong
               class="COMMAND">array=( element1 element2 ... elementN
              )</strong>, позволяет загружать содержимое текстовых
              файлов в массивы.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

filename=sample_file

#            cat sample_file
#
#            1 a b c
#            2 d e fg


declare -a array1

array1=( `cat &quot;$filename&quot; | tr &#39;\n&#39; &#39; &#39;`)  # Загрузка содержимого файла
                                           # $filename в массив array1.
#         Вывод на stdout.
#                         с заменой символов перевода строки на пробелы.

echo ${array1[@]}            # список элементов массива.
#                              1 a b c 2 d e fg
#
#  Каждое &quot;слово&quot;, в текстовом файле, отделяемое от других пробелами
#+ заносится в отдельный элемент массива.

element_count=${#array1[*]}
echo $element_count          # 8
</pre>
              <br>
              <br>
            </td>
          </tr>
        </table>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="c12790_html_COPYARRAY"></a>

        <p><strong>Пример 25-5. Копирование и конкатенация
        массивов</strong></p>
<pre
 class="PROGRAMLISTING">
#! /bin/bash
# CopyArray.sh
#
# Автор: Michael Zick.
# Используется с его разрешения.

#  &quot;Принять из массива с заданным именем записать в массив с заданным именем&quot;
#+ или &quot;собственный Оператор Присваивания&quot;.


CpArray_Mac() {

# Оператор Присваивания

    echo -n &#39;eval &#39;
    echo -n &quot;$2&quot;                    # Имя массива-результата
    echo -n &#39;=( ${&#39;
    echo -n &quot;$1&quot;                    # Имя исходного массива
    echo -n &#39;[@]} )&#39;

# Все это могло бы быть объединено в одну команду.
# Это лишь вопрос стиля.
}

declare -f CopyArray                # &quot;Указатель&quot; на функцию
CopyArray=CpArray_Mac               # Оператор Присваивания

Hype()
{

# Исходный массив с именем в $1.
# (Слить с массивом, содержащим &quot;-- Настоящий Рок-н-Ролл&quot;.)
# Вернуть результат в массиве с именем $2.

    local -a TMP
    local -a hype=( -- Настоящий Рок-н-Ролл )

    $($CopyArray $1 TMP)
    TMP=( ${TMP[@]} ${hype[@]} )
    $($CopyArray TMP $2)
}

declare -a before=( Advanced Bash Scripting )
declare -a after

echo &quot;Массив before = ${before[@]}&quot;

Hype before after

echo &quot;Массив after  = ${after[@]}&quot;

# Еще?

echo &quot;Что такое ${after[@]:4:2}?&quot;

declare -a modest=( ${after[@]:2:1} ${after[@]:3:3} )
#                    ---- выделение подстроки ----

echo &quot;Массив Modest = ${modest[@]}&quot;

# А что в массиве &#39;before&#39; ?

echo &quot;Массив Before = ${before[@]}&quot;

exit 0
</pre>
      </div>

      <p>--</p>

      <p>Массивы допускают перенос хорошо известных алгоритмов в
      сценарии на языке командной оболочки. Хорошо ли это -- решать
      вам.</p>

      <div
       class="EXAMPLE">
        <a
         name="c12790_html_BUBBLE"></a>

        <p><strong>Пример 25-6. Старая, добрая: <span
         class="emphasis"><em
         class="EMPHASIS">&quot;Пузырьковая&quot;
        сортировка</em></span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# bubble.sh: &quot;Пузырьковая&quot; сортировка.

#  На каждом проходе по сортируемому массиву,
#+ сравниваются два смежных элемента, и, если необходимо, они меняются местами.
#  В конце первого прохода, самый &quot;тяжелый&quot; элемент &quot;опускается&quot; в конец массива.
#  В конце второго прохода, следующий по &quot;тяжести&quot; элемент занимает второе место снизу.
#  И так далее.
#  Каждый последующий проход требует на одно сравнение меньше предыдущего.
#  Поэтому вы должны заметить ускорение работы сценария на последних проходах.


exchange()
{
  # Поменять местами два элемента массива.
  local temp=${Countries[$1]} #  Временная переменная
  Countries[$1]=${Countries[$2]}
  Countries[$2]=$temp

  return
}

declare -a Countries  #  Объявление массива,
                      #+ необязательно, поскольку он явно инициализируется ниже.

#  Допустимо ли выполнять инициализацию массива в нескольки строках?
#  ДА!

Countries=(Нидерланды Украина Заир Турция Россия Йемен Сирия \
Бразилия Аргентина Никарагуа Япония Мексика Венесуэла Греция Англия \
Израиль Перу Канада Оман Дания Уэльс Франция Кения \
Занаду Катар Лихтенштейн Венгрия)

# &quot;Занаду&quot; -- это мифическое государство, где, согласно Coleridge,
#+ Kubla Khan построил величественный дворец.


clear                      # Очистка экрана.

echo &quot;0: ${Countries[*]}&quot;  # Список элементов несортированного массива.

number_of_elements=${#Countries[@]}
let &quot;comparisons = $number_of_elements - 1&quot;

count=1 # Номер прохода.

while [ &quot;$comparisons&quot; -gt 0 ]          # Начало внешнего цикла
do

  index=0  # Сбросить индекс перед началом каждого прохода.

  while [ &quot;$index&quot; -lt &quot;$comparisons&quot; ] # Начало внутреннего цикла
  do
    if [ ${Countries[$index]} \&gt; ${Countries[`expr $index + 1`]} ]
    #  Если элементы стоят не по порядку...
    #  Оператор \&gt; выполняет сравнение ASCII-строк
    #+ внутри одиночных квадратных скобок.

    #  if [[ ${Countries[$index]} &gt; ${Countries[`expr $index + 1`]} ]]
    #+ дает тот же результат.
    then
      exchange $index `expr $index + 1`  # Поменять местами.
    fi
    let &quot;index += 1&quot;
  done # Конец внутреннего цикла


let &quot;comparisons -= 1&quot; #  Поскольку самый &quot;тяжелый&quot; элемент уже &quot;опустился&quot; на дно,
                       #+ то на каждом последующем проходе нужно выполнять на одно сравнение меньше.

echo
echo &quot;$count: ${Countries[@]}&quot;  # Вывести содержимое массива после каждого прохода.
echo
let &quot;count += 1&quot;                # Увеличить счетчик проходов.

done                            # Конец внешнего цикла

exit 0
</pre>
      </div>

      <p>--</p>

      <p>Можно ли вложить один массив в другой?</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Вложенный массив.

# Автор: Michael Zick.

AnArray=( $(ls --inode --ignore-backups --almost-all \
        --directory --full-time --color=none --time=status \
        --sort=time -l ${PWD} ) )  # Команды и опции.

# Пробелы важны . . .

SubArray=( ${AnArray[@]:11:1}  ${AnArray[@]:6:5} )
# Массив имеет два элемента, каждый из которых, в свою очередь, является массивом.

echo &quot;Текущий каталог и дата последнего изменения:&quot;
echo &quot;${SubArray[@]}&quot;

exit 0
</pre>
      <br>
      <br>

      <p>--</p>

      <p>Вложенные массивы, в комбинации с <a
       href="#c13936_html_VARREFNEW">косвенными ссылками</a>,
      предоставляют в распоряжение программиста ряд замечательных
      возможностей</p>

      <div
       class="EXAMPLE">
        <a
         name="c12790_html_EMBARR"></a>

        <p><strong>Пример 25-7. Вложенные массивы и косвенные
        ссылки</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# embedded-arrays.sh
# Вложенные массивы и косвенные ссылки.

# Автор: Dennis Leeuw.
# Используется с его разрешения.
# Дополнен автором документа.


ARRAY1=(
        VAR1_1=value11
        VAR1_2=value12
        VAR1_3=value13
)

ARRAY2=(
        VARIABLE=&quot;test&quot;
        STRING=&quot;VAR1=value1 VAR2=value2 VAR3=value3&quot;
        ARRAY21=${ARRAY1[*]}
)       # Вложение массива ARRAY1 в массив ARRAY2.

function print () {
        OLD_IFS=&quot;$IFS&quot;
        IFS=$&#39;\n&#39;       #  Вывод каждого элемента массива
                        #+ в отдельной строке.
        TEST1=&quot;ARRAY2[*]&quot;
        local ${!TEST1} # Посмотрите, что произойдет, если убрать эту строку.
        #  Косвенная ссылка.
        #  Позволяет получить доступ к компонентам $TEST1
        #+ в этой функции.


        #  Посмотрим, что получилось.
        echo
        echo &quot;\$TEST1 = $TEST1&quot;       #  Просто имя переменной.
        echo; echo
        echo &quot;{\$TEST1} = ${!TEST1}&quot;  #  Вывод на экран содержимого переменной.
                                      #  Это то, что дает
                                      #+ косвенная ссылка.
        echo
        echo &quot;-------------------------------------------&quot;; echo
        echo


        # Вывод переменной
        echo &quot;Переменная VARIABLE: $VARIABLE&quot;

        # Вывод элементов строки
        IFS=&quot;$OLD_IFS&quot;
        TEST2=&quot;STRING[*]&quot;
        local ${!TEST2}      # Косвенная ссылка (то же, что и выше).
        echo &quot;Элемент VAR2: $VAR2 из строки STRING&quot;

        # Вывод элемента массива
        TEST2=&quot;ARRAY21[*]&quot;
        local ${!TEST2}      # Косвенная ссылка.
        echo &quot;Элемент VAR1_1: $VAR1_1 из массива ARRAY21&quot;
}

print
echo

exit 0
</pre>
      </div>

      <p>--</p>

      <p>С помощью массивов, на языке командной оболочки, вполне
      возможно реализовать алгоритм <span
       class="emphasis"><em
       class="EMPHASIS">Решета Эратосфена</em></span>. Конечно же --
      это очень ресурсоемкая задача. В виде сценария она будет работать
      мучительно долго, так что лучше всего реализовать ее на каком
      либо другом, компилирующем, языке программирования, таком как
      C.</p>

      <div
       class="EXAMPLE">
        <a
         name="c12790_html_EX68"></a>

        <p><strong>Пример 25-8. Пример реализации алгоритма <span
         class="emphasis"><em
         class="EMPHASIS">Решето Эратосфена</em></span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# sieve.sh

# Решето Эратосфена
# Очень старый алгоритм поиска простых чисел.

# Этот сценарий выполняется во много раз медленнее
# чем аналогичная программа на C.

LOWER_LIMIT=1       # Начиная с 1.
UPPER_LIMIT=1000    # До 1000.
# (Вы можете установить верхний предел и выше...  если вам есть чем себя занять.)

PRIME=1
NON_PRIME=0

declare -a Primes
# Primes[] -- массив.


initialize ()
{
# Инициализация массива.

i=$LOWER_LIMIT
until [ &quot;$i&quot; -gt &quot;$UPPER_LIMIT&quot; ]
do
  Primes[i]=$PRIME
  let &quot;i += 1&quot;
done
# Все числа в заданном диапазоне считать простыми,
# пока не доказано обратное.
}

print_primes ()
{
# Вывод индексов элементов массива Primes[], которые признаны простыми.

i=$LOWER_LIMIT

until [ &quot;$i&quot; -gt &quot;$UPPER_LIMIT&quot; ]
do

  if [ &quot;${Primes[i]}&quot; -eq &quot;$PRIME&quot; ]
  then
    printf &quot;%8d&quot; $i
    # 8 пробелов перед числом придают удобочитаемый табличный вывод на экран.
  fi

  let &quot;i += 1&quot;

done

}

sift () # Отсеивание составных чисел.
{

let i=$LOWER_LIMIT+1
# Нам известно, что 1 -- это простое число, поэтому начнем с 2.

until [ &quot;$i&quot; -gt &quot;$UPPER_LIMIT&quot; ]
do

if [ &quot;${Primes[i]}&quot; -eq &quot;$PRIME&quot; ]
# Не следует проверять вторично числа, которые уже признаны составными.
then

  t=$i

  while [ &quot;$t&quot; -le &quot;$UPPER_LIMIT&quot; ]
  do
    let &quot;t += $i &quot;
    Primes[t]=$NON_PRIME
    # Все числа, которые делятся на $t без остатка, пометить как составные.
  done

fi

  let &quot;i += 1&quot;
done


}


# Вызов функций.
initialize
sift
print_primes
# Это называется структурным программированием.

echo

exit 0



# ----------------------------------------------- #
# Код, приведенный ниже, не исполняется из-за команды exit, стоящей выше.

# Улучшенная версия, предложенная Stephane Chazelas,
# работает несколько быстрее.

# Должен вызываться с аргументом командной строки, определяющем верхний предел.

UPPER_LIMIT=$1                  # Из командной строки.
let SPLIT=UPPER_LIMIT/2         # Рассматривать делители только до середины диапазона.

Primes=( &#39;&#39; $(seq $UPPER_LIMIT) )

i=1
until (( ( i += 1 ) &gt; SPLIT ))  # Числа из верхней половины диапазона могут не рассматриваться.
do
  if [[ -n $Primes[i] ]]
  then
    t=$i
    until (( ( t += i ) &gt; UPPER_LIMIT ))
    do
      Primes[t]=
    done
  fi
done
echo ${Primes[*]}

exit 0
</pre>
      </div>

      <p>Сравните этот сценарий с генератором простых чисел, не
      использующим массивов, <a
       href="#a14477_html_PRIMES">Пример A-18</a>.</p>

      <p>--</p>

      <p>Массивы позволяют эмулировать некоторые структуры данных,
      поддержка которых в Bash не предусмотрена.</p>

      <div
       class="EXAMPLE">
        <a
         name="c12790_html_STACKEX"></a>

        <p><strong>Пример 25-9. Эмуляция структуры &quot;СТЕК&quot;
        (&quot;первый вошел -- последний вышел&quot;)</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# stack.sh: Эмуляция структуры &quot;СТЕК&quot; (&quot;первый вошел -- последний вышел&quot;)

#  Подобно стеку процессора, этот &quot;стек&quot; сохраняет и возвращает данные по принципу
#+ &quot;первый вошел -- последний вышел&quot;.

BP=100            # Базовый указатель на массив-стек.
                  # Дно стека -- 100-й элемент.

SP=$BP            # Указатель вершины стека.
                  # Изначально -- стек пуст.

Data=             #  Содержимое вершины стека.
                  #  Следует использовать дополнительную переменную,
                  #+ из-за ограничений на диапазон возвращаемых функциями значений.

declare -a stack


push()            # Поместить элемент на вершину стека.
{
if [ -z &quot;$1&quot; ]    # А вообще, есть что помещать на стек?
then
  return
fi

let &quot;SP -= 1&quot;     # Переместить указатель стека.
stack[$SP]=$1

return
}

pop()                    # Снять элемент с вершины стека.
{
Data=                    # Очистить переменную.

if [ &quot;$SP&quot; -eq &quot;$BP&quot; ]   # Стек пуст?
then
  return
fi                       #  Это предохраняет от выхода SP за границу стека -- 100,

Data=${stack[$SP]}
let &quot;SP += 1&quot;            # Переместить указатель стека.
return
}

status_report()          # Вывод вспомогательной информации.
{
echo &quot;-------------------------------------&quot;
echo &quot;ОТЧЕТ&quot;
echo &quot;Указатель стека SP = $SP&quot;
echo &quot;Со стека был снят элемент \&quot;&quot;$Data&quot;\&quot;&quot;
echo &quot;-------------------------------------&quot;
echo
}


# =======================================================
# А теперь позабавимся.

echo

# Попробуем вытолкнуть что-нибудь из пустого стека.
pop
status_report

echo

push garbage
pop
status_report     # Втолкнуть garbage, вытолкнуть garbage.

value1=23; push $value1
value2=skidoo; push $value2
value3=FINAL; push $value3

pop              # FINAL
status_report
pop              # skidoo
status_report
pop              # 23
status_report    # Первый вошел -- последний вышел!

#  Обратите внимание как изменяется указатель стека на каждом вызове функций push и pop.

echo
# =======================================================


# Упражнения:
# -----------

# 1)  Измените функцию &quot;push()&quot; таким образом,
#   + чтобы она позволяла помещать на стек несколько значений за один вызов.

# 2)  Измените функцию &quot;pop()&quot; таким образом,
#   + чтобы она позволяла снимать со стека несколько значений за один вызов.

# 3)  Попробуйте написать простейший калькулятор, выполняющий 4 арифметических действия?
#   + используя этот пример.

exit 0
</pre>
      </div>

      <p>--</p>

      <p>Иногда, манипуляции с <span
       class="QUOTE">&quot;индексами&quot;</span> массивов могут
      потребовать введения переменных для хранения промежуточных
      результатов. В таких случаях вам предоставляется лишний повод
      подумать о реализации проекта на более мощном языке
      программирования, например Perl или C.</p>

      <div
       class="EXAMPLE">
        <a
         name="c12790_html_QFUNCTION"></a>

        <p><strong>Пример 25-10. <span
         class="emphasis"><em
         class="EMPHASIS">Исследование математических
        последовательностей</em></span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Пресловутая &quot;Q-последовательность&quot; Дугласа Хольфштадтера *Douglas Hofstadter):

# Q(1) = Q(2) = 1
# Q(n) = Q(n - Q(n-1)) + Q(n - Q(n-2)), для n&gt;2

# Это &quot;хаотическая&quot; последовательность целых чисел с непредсказуемым поведением.
# Первые 20 членов последовательности:
# 1 1 2 3 3 4 5 5 6 6 6 8 8 8 10 9 10 11 11 12

# См. книгу Дугласа Хольфштадтера, &quot;Goedel, Escher, Bach: An Eternal Golden Braid&quot;,
# p. 137, ff.


LIMIT=100     # Найти первые 100 членов последовательности
LINEWIDTH=20  # Число членов последовательности, выводимых на экран в одной строке

Q[1]=1        # Первые два члена последовательности равны 1.
Q[2]=1

echo
echo &quot;Q-последовательность [первые $LIMIT членов]:&quot;
echo -n &quot;${Q[1]} &quot;             # Вывести первые два члена последовательности.
echo -n &quot;${Q[2]} &quot;

for ((n=3; n &lt;= $LIMIT; n++))  # C-подобное оформление цикла.
do   # Q[n] = Q[n - Q[n-1]] + Q[n - Q[n-2]]  для n&gt;2
# Это выражение необходимо разбить на отдельные действия,
# поскольку Bash не очень хорошо поддерживает сложные арифметические действия над элементами массивов.

  let &quot;n1 = $n - 1&quot;        # n-1
  let &quot;n2 = $n - 2&quot;        # n-2

  t0=`expr $n - ${Q[n1]}`  # n - Q[n-1]
  t1=`expr $n - ${Q[n2]}`  # n - Q[n-2]

  T0=${Q[t0]}              # Q[n - Q[n-1]]
  T1=${Q[t1]}              # Q[n - Q[n-2]]

Q[n]=`expr $T0 + $T1`      # Q[n - Q[n-1]] + Q[n - Q[n-2]]
echo -n &quot;${Q[n]} &quot;

if [ `expr $n % $LINEWIDTH` -eq 0 ]    # Если выведено очередные 20 членов в строке.
then   # то
  echo # перейти на новую строку.
fi

done

echo

exit 0

# Этот сценарий реализует итеративный алгоритм поиска членов Q-последовательности.
# Рекурсивную реализацию, как более интуитивно понятную, оставляю вам, в качестве упражнения.
# Внимание: рекурсивный поиск членов последовательности будет занимать *очень* продолжительное время.
</pre>
      </div>

      <p>--</p>

      <p>Bash поддерживает только одномерные массивы, но, путем
      небольших ухищрений, можно эмулировать многомерные массивы.</p>

      <div
       class="EXAMPLE">
        <a
         name="c12790_html_TWODIM"></a>

        <p><strong>Пример 25-11. Эмуляция массива с двумя
        измерениями</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Эмуляция двумерного массива.

# Второе измерение представлено как последовательность строк.

Rows=5
Columns=5

declare -a alpha     # char alpha [Rows] [Columns];
                     # Необязательное объявление массива.

load_alpha ()
{
local rc=0
local index


for i in A B C D E F G H I J K L M N O P Q R S T U V W X Y
do
  local row=`expr $rc / $Columns`
  local column=`expr $rc % $Rows`
  let &quot;index = $row * $Rows + $column&quot;
  alpha[$index]=$i   # alpha[$row][$column]
  let &quot;rc += 1&quot;
done

# Более простой вариант
#   declare -a alpha=( A B C D E F G H I J K L M N O P Q R S T U V W X Y )
# но при таком объявлении второе измерение массива завуалировано.
}

print_alpha ()
{
local row=0
local index

echo

while [ &quot;$row&quot; -lt &quot;$Rows&quot; ]   # Вывод содержимого массива построчно
do

  local column=0

  while [ &quot;$column&quot; -lt &quot;$Columns&quot; ]
  do
    let &quot;index = $row * $Rows + $column&quot;
    echo -n &quot;${alpha[index]} &quot;  # alpha[$row][$column]
    let &quot;column += 1&quot;
  done

  let &quot;row += 1&quot;
  echo

done

# Более простой эквивалент:
#   echo ${alpha[*]} | xargs -n $Columns

echo
}

filter ()     # Отфильтровывание отрицательных индексов.
{

echo -n &quot;  &quot;

if [[ &quot;$1&quot; -ge 0 &amp;&amp;  &quot;$1&quot; -lt &quot;$Rows&quot; &amp;&amp; &quot;$2&quot; -ge 0 &amp;&amp; &quot;$2&quot; -lt &quot;$Columns&quot; ]]
then
    let &quot;index = $1 * $Rows + $2&quot;
    echo -n &quot; ${alpha[index]}&quot;  # alpha[$row][$column]
fi

}

rotate ()  # Поворот массива на 45 градусов
{
local row
local column

for (( row = Rows; row &gt; -Rows; row-- ))  # В обратном порядке.
do

  for (( column = 0; column &lt; Columns; column++ ))
  do

    if [ &quot;$row&quot; -ge 0 ]
    then
      let &quot;t1 = $column - $row&quot;
      let &quot;t2 = $column&quot;
    else
      let &quot;t1 = $column&quot;
      let &quot;t2 = $column + $row&quot;
    fi

    filter $t1 $t2   # Отфильтровать отрицательный индекс.
  done

  echo; echo

done

# Поворот массива выполнен на основе примеров (стр. 143-146)
# из книги &quot;Advanced C Programming on the IBM PC&quot;, автор Herbert Mayer
# (см. библиографию).

}


#-----------------------------------------------------#
load_alpha     # Инициализация массива.
print_alpha    # Вывод на экран.
rotate         # Повернуть на 45 градусов против часовой стрелки.
#-----------------------------------------------------#


# Упражнения:
# -----------
# 1)  Сделайте инициализацию и вывод массива на экран
#   + более простым и элегантным способом.
#
# 2)  Объясните принцип работы функции rotate().

exit 0
</pre>
      </div>

      <p>По существу, двумерный массив эквивалентен одномерному, с тем
      лишь различием, что для индексации отдельных элементов
      используются два индекса -- <span
       class="QUOTE">&quot;строка&quot;</span> и <span
       class="QUOTE">&quot;столбец&quot;</span>.</p>

      <p>Более сложный пример эмуляции двумерного массива вы найдете в
      <a
       href="#a14477_html_LIFESLOW">Пример A-11</a>.</p>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#c12716_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#c12891_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Списки команд</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#p11889_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Файлы</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="c12891_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#c12790_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#c12942_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="CHAPTER">
      <h1><a
       name="c12891_html_FILES"></a>Глава 26. Файлы</h1>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="c12891_html_FILESREF1"></a>сценарии начальной загрузки</strong></p>

        <dl>
          <dd>
            <p>Эти файлы содержат объявления псевдонимов и <a
             href="#x1716_html_ENVREF">переменных окружения</a>, которые
            становятся доступны Bash после загрузки и инициализации
            системы.</p>
          </dd>

          <dt><tt
           class="FILENAME">/etc/profile</tt></dt>

          <dd>
            <p>Настройки системы по-умолчанию, главным образом
            настраивается окружение командной оболочки (все
            Bourne-подобные оболочки, не только Bash <a
             name="AEN12906"
             href="#c12891_html_FTN_AEN12906"><span
             class="footnote">[1]</span></a>)</p>
          </dd>

          <dt><tt
           class="FILENAME">/etc/bashrc</tt></dt>

          <dd>
            <p>функции и <a
             href="#c12683_html_ALIASREF">псевдонимы</a> Bash</p>
          </dd>

          <dt><tt
           class="FILENAME"><tt
           class="VARNAME">$HOME</tt>/.bash_profile</tt></dt>

          <dd>
            <p>пользовательские настройки окружения Bash, находится в
            домашнем каталоге у каждого пользователя (локальная копия
            файла <tt
             class="FILENAME">/etc/profile</tt>)</p>
          </dd>

          <dt><tt
           class="FILENAME"><tt
           class="VARNAME">$HOME</tt>/.bashrc</tt></dt>

          <dd>
            <p>пользовательский файл инициализации Bash, находится в
            домашнем каталоге у каждого пользователя (локальная копия
            файла <tt
             class="FILENAME">/etc/bashrc</tt>). См. <a
             href="#a15124_html">Приложение G</a>пример файла <tt
             class="FILENAME">.bashrc</tt>.</p>
          </dd>
        </dl>
      </div>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="c12891_html_LOGOUTFILEREF1"></a>Сценарий выхода из системы
        (logout)</strong></p>

        <dl>
          <dt><tt
           class="FILENAME"><tt
           class="VARNAME">$HOME</tt>/.bash_logout</tt></dt>

          <dd>
            <p>Этот сценарий отрабатывает, когда пользователь выходит
            из системы.</p>
          </dd>
        </dl>
      </div>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN12906"
         href="#c12891_html_AEN12906"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Это не относится к таким оболочкам, как <strong
           class="COMMAND">csh</strong>, <strong
           class="COMMAND">tcsh</strong> и другим, которые не являются
          производными от классической Bourne shell (<strong
           class="COMMAND">sh</strong>).</p>
        </td>
      </tr>
    </table>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#c12790_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#c12942_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Массивы</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#p11889_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">/dev и /proc</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="c12942_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#c12891_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x12987_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="CHAPTER">
      <h1><a
       name="c12942_html_DEVPROC"></a>Глава 27. /dev и /proc</h1>

      <p><a
       name="c12942_html_DEVPROCREF"></a></p>

      <p>Как правило, Linux или UNIX система имеет два каталога
      специального назначения: <tt
       class="FILENAME">/dev</tt> и <tt
       class="FILENAME">/proc</tt>.</p>

      <div
       class="SECT1">
        <h1
         class="SECT1"><a
         name="c12942_html_DEVREF1"></a>27.1. <tt
         class="FILENAME">/dev</tt></h1>

        <p>Каталог <tt
         class="FILENAME">/dev</tt> содержит файлы физических <span
         class="emphasis"><em
         class="EMPHASIS">устройств</em></span>, которые могут входить
        в состав аппаратного обеспечения компьютера. <a
         name="AEN12955"
         href="#c12942_html_FTN_AEN12955"><span
         class="footnote">[1]</span></a> Каждому из разделов не жестком
        диске соответствует свой файл-устройство в каталоге <tt
         class="FILENAME">/dev</tt>, информация о которых может быть
        получена простой командой <a
         href="#c9708_html_DFREF">df</a>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>df</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">Filesystem           1k-blocks      Used Available Use%
 Mounted on
 /dev/hda6               495876    222748    247527  48% /
 /dev/hda1                50755      3887     44248   9% /boot
 /dev/hda8               367013     13262    334803   4% /home
 /dev/hda5              1714416   1123624    503704  70% /usr</tt>
             
</pre>
        <br>
        <br>

        <p><a
         name="c12942_html_LOOPBACKREF"></a>Кроме того, каталог <tt
         class="FILENAME">/dev</tt> содержит <span
         class="emphasis"><em
         class="EMPHASIS">loopback</em></span>-устройства
        (&quot;петлевые&quot; устройства), например <tt
         class="FILENAME">/dev/loop0</tt>. С помощью такого устройства
        можно представить обычный файл как блочное устройство
        ввода/вывода. <a
         name="AEN12973"
         href="#c12942_html_FTN_AEN12973"><span
         class="footnote">[2]</span></a> Это позволяет монтировать
        целые файловые системы, находящиеся в отдельных больших файлах.
        См. <a
         href="#c9708_html_CREATEFS">Пример 13-6</a> и <a
         href="#c9708_html_ISOMOUNTREF">Пример 13-5</a>.</p>

        <p>Отдельные псевдоустройства в <tt
         class="FILENAME">/dev</tt> имеют особое назначение, к таким
        устройствам можно отнести <a
         href="#c13041_html_ZEROSREF"><tt
         class="FILENAME">/dev/null</tt></a>, <a
         href="#c13041_html_ZEROSREF1"><tt
         class="FILENAME">/dev/zero</tt></a> и <a
         href="#x4812_html_URANDOMREF"><tt
         class="FILENAME">/dev/urandom</tt></a>.</p>
      </div>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN12955"
         href="#c12942_html_AEN12955"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Каталог <tt
           class="FILENAME">/dev</tt> содержит специальные файлы --
          точки монтирования физических и виртуальных устройств. Они
          занимают незначительное пространство на диске.</p>

          <p>Некоторые из устройств, такие как <tt
           class="FILENAME">/dev/null</tt>, <tt
           class="FILENAME">/dev/zero</tt> или <tt
           class="FILENAME">/dev/urandom</tt> -- являются виртуальными.
          Они не являются файлами физических устройств, система
          эмулирует эти устройства программным способом.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN12973"
         href="#c12942_html_AEN12973"><span
         class="footnote">[2]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p><span
           class="emphasis"><em
           class="EMPHASIS">Блочное устройство</em></span> читает и/или
          пишет данные целыми блоками, в отличие от <span
           class="emphasis"><em
           class="EMPHASIS">символьных устройств</em></span>, которые
          читают и/или пишут данные по одному символу. Примером
          блочного устройства может служить жесткий диск, CD-ROM.
          Примером символьного устройства -- клавиатура.</p>
        </td>
      </tr>
    </table>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#c12891_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x12987_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Файлы</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#p11889_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><tt
           class="FILENAME">/proc</tt></td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="c13041_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x12987_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#c13099_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="CHAPTER">
      <h1><a
       name="c13041_html_ZEROS"></a>Глава 28. /dev/zero и /dev/null</h1>

      <p><a
       name="c13041_html_ZEROSREF"></a></p>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="c13041_html_ZERONULL1"></a></strong></p>

        <dl>
          <dt><tt
           class="FILENAME">/dev/null</tt></dt>

          <dd>
            <p>Псевдоустройство <tt
             class="FILENAME">/dev/null</tt> -- это, своего рода, <span
             class="QUOTE">&quot;черная дыра&quot;</span> в системе.
            Это, пожалуй, самый близкий смысловой эквивалент. Все, что
            записывается в этот файл, &quot;исчезает&quot; навсегда.
            Попытки записи или чтения из этого файла не дают, ровным
            счетом, никакого результата. Тем не менее, псевдоустройство
            <tt
             class="FILENAME">/dev/null</tt> вполне может
            пригодиться.</p>

            <p>Подавление вывода на <tt
             class="FILENAME">stdout</tt>.</p>
<pre
 class="PROGRAMLISTING">
cat $filename &gt;/dev/null
# Содержимое файла $filename не появится на stdout.
</pre>
            <br>
            <br>

            <p>Подавление вывода на <tt
             class="FILENAME">stderr</tt> (from <a
             href="#x6646_html_EX57">Пример 12-2</a>).</p>
<pre
 class="PROGRAMLISTING">
rm $badname 2&gt;/dev/null
#           Сообщение об ошибке &quot;уйдет в никуда&quot;.
</pre>
            <br>
            <br>

            <p>Подавление вывода, как на <tt
             class="FILENAME">stdout</tt>, так и на <tt
             class="FILENAME">stderr</tt>.</p>
<pre
 class="PROGRAMLISTING">
cat $filename 2&gt;/dev/null &gt;/dev/null
# Если &quot;$filename&quot; не будет найден, то вы не увидите сообщения об ошибке.
# Если &quot;$filename&quot; существует, то вы не увидите его содержимое.
# Таким образом, вышеприведенная команда ничего не выводит на экран.
#
#  Такая методика бывает полезной, когда необходимо лишь проверить код завершения команды
#+ и нежелательно выводить результат работы команды на экран.
#
# cat $filename &amp;&gt;/dev/null
#     дает тот же результат, автор примечания Baris Cicek.
</pre>
            <br>
            <br>

            <p>Удаление содержимого файла, сохраняя, при этом, сам
            файл, со всеми его правами доступа (очистка файла) (из <a
             href="#c178_html_EX1">Пример 2-1</a> и <a
             href="#c178_html_EX2">Пример 2-2</a>):</p>
<pre
 class="PROGRAMLISTING">
cat /dev/null &gt; /var/log/messages
#  : &gt; /var/log/messages   дает тот же эффект, но не порождает дочерний процесс.

cat /dev/null &gt; /var/log/wtmp
</pre>
            <br>
            <br>

            <p>Автоматическая очистка содержимого системного журнала
            (logfile) (особенно хороша для борьбы с надоедливыми
            рекламными идентификационными файлами (<span
             class="QUOTE">&quot;cookies&quot;</span>)):</p>

            <div
             class="EXAMPLE">
              <a
               name="c13041_html_COOKIES"></a>

              <p><strong>Пример 28-1. Удаление
              cookie-файлов</strong></p>
<pre
 class="PROGRAMLISTING">
if [ -f ~/.netscape/cookies ]  # Удалить, если имеются.
then
  rm -f ~/.netscape/cookies
fi

ln -s /dev/null ~/.netscape/cookies
# Теперь, все cookie-файлы, вместо того, чтобы сохраняться на диске, будут &quot;вылетать в трубу&quot;.
</pre>
            </div>
          </dd>

          <dt><a
           name="c13041_html_ZEROSREF1"></a><tt
           class="FILENAME">/dev/zero</tt></dt>

          <dd>
            <p>Подобно псевдоустройству <tt
             class="FILENAME">/dev/null</tt>, <tt
             class="FILENAME">/dev/zero</tt> так же является
            псевдоустройством, с той лишь разницей, что содержит нули.
            Информация, выводимая в этот файл, так же бесследно
            исчезает. Чтение нулей из этого файла может вызвать
            некоторые затруднения, однако это можно сделать, к примеру,
            с помощью команды <a
             href="#x9307_html_ODREF">od</a> или шестнадцатиричного
            редактора. В основном, <tt
             class="FILENAME">/dev/zero</tt> используется для создания
            заготовки файла с заданой длиной.</p>

            <div
             class="EXAMPLE">
              <a
               name="c13041_html_EX73"></a>

              <p><strong>Пример 28-2. Создание файла подкачки
              (swapfile), с помощью <tt
               class="FILENAME">/dev/zero</tt></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Создание файла подкачки.
# Этот сценарий должен запускаться с правами root.

ROOT_UID=0         # Для root -- $UID 0.
E_WRONG_USER=65    # Не root?

FILE=/swap
BLOCKSIZE=1024
MINBLOCKS=40
SUCCESS=0

if [ &quot;$UID&quot; -ne &quot;$ROOT_UID&quot; ]
then
  echo; echo &quot;Этот сценарий должен запускаться с правами root.&quot;; echo
  exit $E_WRONG_USER
fi


blocks=${1:-$MINBLOCKS}          #  По-умолчанию -- 40 блоков,
                                 #+ если размер не задан из командной строки.
# Ниже приводится эквивалентный набор команд.
# --------------------------------------------------
# if [ -n &quot;$1&quot; ]
# then
#   blocks=$1
# else
#   blocks=$MINBLOCKS
# fi
# --------------------------------------------------


if [ &quot;$blocks&quot; -lt $MINBLOCKS ]
then
  blocks=$MINBLOCKS              # Должно быть как минимум 40 блоков.
fi


echo &quot;Создание файла подкачки размером $blocks блоков (KB).&quot;
dd if=/dev/zero of=$FILE bs=$BLOCKSIZE count=$blocks  # &quot;Забить&quot; нулями.

mkswap $FILE $blocks             # Назначить как файл подкачки.
swapon $FILE                     # Активировать.

echo &quot;Файл подкачки создан и активирован.&quot;

exit $SUCCESS
</pre>
            </div>

            <p>Еще одна область применения <tt
             class="FILENAME">/dev/zero</tt> -- <span
             class="QUOTE">&quot;очистка&quot;</span> специального
            файла заданного размера, например файлов, монтируемых как
            <a
             href="#c12942_html_LOOPBACKREF">loopback-устройства</a>
            (см. <a
             href="#c9708_html_CREATEFS">Пример 13-6</a>) или для
            безопасного удаления файла (см. <a
             href="#x9307_html_BLOTOUT">Пример 12-42</a>).</p>

            <div
             class="EXAMPLE">
              <a
               name="c13041_html_RAMDISK"></a>

              <p><strong>Пример 28-3. Создание электронного
              диска</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# ramdisk.sh

#  &quot;электронный диск&quot; -- это область в ОЗУ компьютера
#+ с которой система взаимодействует как с файловой системой.
#  Основное преимущество -- очень высокая скорость чтения/записи.
#  Недостатки -- энергозависимость, уменьшение объема ОЗУ, доступного системе,
#                относительно небольшой размер.
#
#  Чем хорош электронный диск?
#  При хранении наборов данных, таких как таблиц баз данных или словарей, на электронном диске
#+ вы получаете высокую скорость работы с этими наборами, поскольку время доступа к ОЗУ
#  неизмеримо меньше времени доступа к жесткому диску.


E_NON_ROOT_USER=70             # Сценарий должен запускаться с правами root.
ROOTUSER_NAME=root

MOUNTPT=/mnt/ramdisk
SIZE=2000                      # 2K блоков (измените, если это необходимо)
BLOCKSIZE=1024                 # размер блока -- 1K (1024 байт)
DEVICE=/dev/ram0               # Первое устройство ram

username=`id -nu`
if [ &quot;$username&quot; != &quot;$ROOTUSER_NAME&quot; ]
then
  echo &quot;Сценарий должен запускаться с правами root.&quot;
  exit $E_NON_ROOT_USER
fi

if [ ! -d &quot;$MOUNTPT&quot; ]         #  Проверка наличия точки монтирования,
then                           #+ благодаря этой проверке, при повторных запусках сценария
  mkdir $MOUNTPT               #+ ошибки возникать не будет.
fi

dd if=/dev/zero of=$DEVICE count=$SIZE bs=$BLOCKSIZE  # Очистить электронный диск.
mke2fs $DEVICE                 # Создать файловую систему ext2.
mount $DEVICE $MOUNTPT         # Смонтировать.
chmod 777 $MOUNTPT             # Сделать электронный диск доступным для обычных пользователей.
                               # Но при этом, только root сможет его отмонтировать.

echo &quot;Электронный диск \&quot;$MOUNTPT\&quot; готов к работе.&quot;
# Теперь электронный диск доступен для любого пользователя в системе.

#  Внимание! Электронный диск -- это энергозависимое устройство! Все данные, хранящиеся на нем,
#+ будут утеряны при остановке или перезагрузке системы.
#  Если эти данные представляют для вас интерес, то сохраняйте их копии в обычном каталоге.

# После перезагрузки, чтобы вновь создать электронный диск, запустите этот сценарий.
# Простое монтирование /mnt/ramdisk, без выполнения подготовительных действий, не будет работать.

exit 0
</pre>
            </div>
          </dd>
        </dl>
      </div>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x12987_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#c13099_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><tt
           class="FILENAME">/proc</tt></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#p11889_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Отладка сценариев</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="c13099_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#c13041_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#c13228_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="CHAPTER">
      <h1><a
       name="c13099_html_DEBUGGING"></a>Глава 29. Отладка сценариев</h1>

      <p>Командная оболочка Bash не имеет своего отладчика, и не имеет
      даже каких либо отладочных команд или конструкций. <a
       name="AEN13102"
       href="#c13099_html_FTN_AEN13102"><span
       class="footnote">[1]</span></a> Синтаксические ошибки или
      опечатки часто вызывают сообщения об ошибках, которые которые
      практически никак не помогают при отладке.</p>

      <div
       class="EXAMPLE">
        <a
         name="c13099_html_EX74"></a>

        <p><strong>Пример 29-1. Сценарий, содержащий
        ошибку</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# ex74.sh

# Этот сценарий содержит ошибку.

a=37

if [$a -gt 27 ]
then
  echo $a
fi  

exit 0
</pre>
      </div>

      <p>В результате исполнения этого сценария вы получите такое
      сообщение:</p>
<pre
 class="SCREEN">
<tt
 class="COMPUTEROUTPUT">./ex74.sh: [37: command not found</tt>
</pre>
      Что в этом сценарии может быть неправильно (подсказка: после
      ключевого слова <strong
       class="COMMAND">if</strong>)?<br>
      <br>

      <div
       class="EXAMPLE">
        <a
         name="c13099_html_MISSINGKEYWORD"></a>

        <p><strong>Пример 29-2. Пропущено <a
         href="#c5358_html_KEYWORDREF">ключевое слово</a></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# missing-keyword.sh:
# Какое сообщение об ошибке будет выведено, при попытке запустить этот сценарий?

for a in 1 2 3
do
  echo &quot;$a&quot;
# done     # Необходимое ключевое слово &#39;done&#39; закомментировано.

exit 0
</pre>
      </div>

      <p>На экране появится сообщение:</p>
<pre
 class="SCREEN">
<tt
 class=
"COMPUTEROUTPUT">missing-keyword.sh: line 11: syntax error: unexpected end of file</tt>
       
</pre>
      Обратите внимание, сообщение об ошибке будет содержать номер не
      той строки, в которой возникла ошибка, а той, в которой Bash
      точно установил наличие ошибочной ситуации. <br>
      <br>

      <p>Сообщения об ошибках могут вообще не содержать номера строки,
      при исполнении которой эта ошибка появилась.</p>

      <p>А что делать, если сценарий работает, но не так как ожидалось?
      Вот пример весьма распространенной логической ошибки.</p>

      <div
       class="EXAMPLE">
        <a
         name="c13099_html_EX75"></a>

        <p><strong>Пример 29-3. test24</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

#  Ожидается, что этот сценарий будет удалять в текущем каталоге
#+ все файлы, имена которых содержат пробелы.
#  Но он не работает.  Почему?


badname=`ls | grep &#39; &#39;`

# echo &quot;$badname&quot;

rm &quot;$badname&quot;

exit 0
</pre>
      </div>

      <p>Попробуйте найти ошибку, раскомментарив строку <tt
       class="USERINPUT"><strong>echo
      &quot;$badname&quot;</strong></tt>. Инструкция echo очень полезна
      при отладке сценариев, она позволяет узнать -- действительно ли
      вы получаете то, что ожидали получить.</p>

      <p>В данном конкретном случае, команда <tt
       class="USERINPUT"><strong>rm &quot;$badname&quot;</strong></tt>
      не дает желаемого результата потому, что переменная <tt
       class="VARNAME">$badname</tt> взята в кавычки. В результате,
      <strong
       class="COMMAND">rm</strong> получает единственный аргумент (т.е.
      команда будет считать, что получила имя одного файла). Частично
      эта проблема может быть решена за счет удаления кавычек вокруг
      <tt
       class="VARNAME">$badname</tt> и установки переменной <tt
       class="VARNAME">$IFS</tt> так, чтобы она содержала только символ
      перевода строки, <tt
       class="USERINPUT"><strong>IFS=$&#39;\n&#39;</strong></tt>.
      Однако, существует более простой способ выполнить эту задачу.</p>
<pre
 class="PROGRAMLISTING">
# Правильный способ удаления файлов, в чьих именах содержатся пробелы.
rm *\ *
rm *&quot; &quot;*
rm *&#39; &#39;*
# Спасибо S.C.
</pre>
      <br>
      <br>

      <p>В общих чертах, ошибочными можно считать такие сценарии,
      которые</p>

      <ol
       type="1">
        <li>
          <p>&quot;сыплют&quot; сообщениями о <span
           class="QUOTE">&quot;<span
           class="ERRORNAME">синтаксических ошибках</span>&quot;</span>
          или</p>
        </li>

        <li>
          <p>запускаются, но работают не так как ожидалось (<span
           class="ERRORNAME">логические ошибки</span>).</p>
        </li>

        <li>
          <p>запускаются, делают то, что требуется, но имеют побочные
          эффекты (<span
           class="ERRORNAME">логическая бомба</span>).</p>
        </li>
      </ol>
      <br>
      <br>

      <p>Инструменты, которые могут помочь при отладке неработающих
      сценариев</p>

      <ol
       type="1">
        <li>
          <p>команда echo, в критических точках сценария, поможет
          отследить состояние переменных и отобразить ход
          исполнения.</p>
        </li>

        <li>
          <p>команда-фильтр <strong
           class="COMMAND">tee</strong>, которая поможет проверить
          процессы и потоки данных в критических местах.</p>
        </li>

        <li>
          <p>ключи <tt
           class="OPTION">-n -v -x</tt></p>

          <p><tt
           class="USERINPUT"><strong>sh -n scriptname</strong></tt> --
          проверит наличие синтаксических ошибок, не запуская сам
          сценарий. Того же эффекта можно добиться, вставив в сценарий
          команду <tt
           class="USERINPUT"><strong>set -n</strong></tt> или <tt
           class="USERINPUT"><strong>set -o noexec</strong></tt>.
          Обратите внимание, некоторые из синтаксических ошибок не
          могут быть выявлены таким способом.</p>

          <p><tt
           class="USERINPUT"><strong>sh -v scriptname</strong></tt> --
          выводит каждую команду прежде, чем она будет выполнена. Того
          же эффекта можно добиться, вставив в сценарий команду <tt
           class="USERINPUT"><strong>set -v</strong></tt> или <tt
           class="USERINPUT"><strong>set -o verbose</strong></tt>.</p>

          <p>Ключи <tt
           class="OPTION">-n</tt> и <tt
           class="OPTION">-v</tt> могут употребляться совместно: <tt
           class="USERINPUT"><strong>sh -nv
          scriptname</strong></tt>.</p>

          <p><tt
           class="USERINPUT"><strong>sh -x scriptname</strong></tt> --
          выводит, в краткой форме, результат исполнения каждой
          команды. Того же эффекта можно добиться, вставив в сценарий
          команду <tt
           class="USERINPUT"><strong>set -x</strong></tt> или <tt
           class="USERINPUT"><strong>set -o xtrace</strong></tt>.</p>

          <p>Вставив в сценарий <tt
           class="USERINPUT"><strong>set -u</strong></tt> или <tt
           class="USERINPUT"><strong>set -o nounset</strong></tt>, вы
          будете получать сообщение об ошибке <span
           class="ERRORNAME">unbound variable</span> всякий раз, когда
          будет производиться попытка обращения к необъявленной
          переменной.</p>
        </li>

        <li>
          <p>Функция <span
           class="QUOTE">&quot;assert&quot;</span>, предназначенная для
          проверки переменных или условий, в критических точках
          сценария. (Эта идея заимствована из языка программирования
          C.)</p>

          <div
           class="EXAMPLE">
            <a
             name="c13099_html_ASSERT"></a>

            <p><strong>Пример 29-4. Проверка условия с помощью функции
            <span
             class="QUOTE">&quot;assert&quot;</span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# assert.sh

assert ()                 #  Если условие ложно,
{                         #+ выход из сценария с сообщением об ошибке.
  E_PARAM_ERR=98
  E_ASSERT_FAILED=99


  if [ -z &quot;$2&quot; ]          # Недостаточное количество входных параметров.
  then
    return $E_PARAM_ERR
  fi

  lineno=$2

  if [ ! $1 ]
  then
    echo &quot;Утверждение ложно:  \&quot;$1\&quot;&quot;
    echo &quot;Файл: \&quot;$0\&quot;, строка: $lineno&quot;
    exit $E_ASSERT_FAILED
  # else
  #   return
  #   и продолжить исполнение сценария.
  fi
}


a=5
b=4
condition=&quot;$a -lt $b&quot;     # Сообщение об ощибке и завершение сценария.
                          #  Попробуйте поменять условие &quot;condition&quot;
                          #+ на что нибудь другое и
                          #+ посмотреть -- что получится.

assert &quot;$condition&quot; $LINENO
# Сценарий продолжит работу только в том случае, если утверждение истинно.


# Прочие команды.
# ...
echo &quot;Эта строка появится на экране только если утверждение истинно.&quot;
# ...
# Прочие команды.
# ...

exit 0
</pre>
          </div>
        </li>

        <li>
          <p>Ловушка на выхто в этом сценарии может быть неправильно
          (подсказка: после ключевого словоде.</p>

          <p>Команда <strong
           class="COMMAND">exit</strong>, в сценарии, порождает сигнал
          <span
           class="RETURNVALUE">0</span>, по которому процесс завершает
          работу, т.е. -- сам сценарий. <a
           name="AEN13188"
           href="#c13099_html_FTN_AEN13188"><span
           class="footnote">[2]</span></a> Часто бывает полезным по
          выходу из сценария выдать <span
           class="QUOTE">&quot;распечатку&quot;</span> переменных.</p>
        </li>
      </ol>
      <br>
      <br>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="c13099_html_TRAPREF1"></a>Установка ловушек на сигналы</strong></p>

        <dl>
          <dt><strong
           class="COMMAND">trap</strong></dt>

          <dd>
            <p>Определяет действие при получении сигнала; так же
            полезна при отладке.</p>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p><a
                     name="c13099_html_SIGNALD"></a>Сигнал (<span
                     class="emphasis"><em
                     class="EMPHASIS">signal</em></span>) -- это просто
                    сообщение, передается процессу либо ядром, либо
                    другим процессом, чтобы побудить процесс выполнить
                    какие либо действия (обычно -- завершить работу).
                    Например, нажатие на <strong
                     class="KEYCAP">Control</strong>-<strong
                     class="KEYCAP">C</strong>, вызывает передачу
                    сигнала SIGINT, исполняющейся программе.</p>
                  </td>
                </tr>
              </table>
            </div>
<pre
 class="PROGRAMLISTING">
trap &#39;&#39; 2
# Игнорировать прерывание 2 (Control-C), действие по сигналу не указано.

trap &#39;echo &quot;Control-C disabled.&quot;&#39; 2
# Сообщение при нажатии на Control-C.
</pre>
            <br>
            <br>
          </dd>
        </dl>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="c13099_html_EX76"></a>

        <p><strong>Пример 29-5. Ловушка на выходе</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

trap &#39;echo Список переменных --- a = $a  b = $b&#39; EXIT
# EXIT -- это название сигнала, генерируемого при выходе из сценария.

a=39

b=36

exit 0
# Примечательно, что если закомментировать команду &#39;exit&#39;,
# то это никак не скажется на работе сценария,
# поскольку &quot;выход&quot; из сценария происходит в любом случае.
</pre>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="c13099_html_ONLINE"></a>

        <p><strong>Пример 29-6. Удаление временного файла при нажатии
        на Control-C</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# logon.sh: Сценарий, написаный &quot;на скорую руку&quot;, контролирует вход в режим on-line.


TRUE=1
LOGFILE=/var/log/messages
# Обратите внимание: $LOGFILE должен быть доступен на чтение (chmod 644 /var/log/messages).
TEMPFILE=temp.$$
# &quot;Уникальное&quot; имя для временного файла, где расширение в имени -- это pid процесса-сценария.
KEYWORD=address
# При входе, в файл /var/log/messages,
# добавляется  строка &quot;remote IP address xxx.xxx.xxx.xxx&quot;
ONLINE=22
USER_INTERRUPT=13
CHECK_LINES=100
# Количество проверяемых строк.

trap &#39;rm -f $TEMPFILE; exit $USER_INTERRUPT&#39; TERM INT
# Удалить временный файл, когда сценарий завершает работу по control-c.

echo

while [ $TRUE ]  #Бесконечный цикл.
do
  tail -$CHECK_LINES $LOGFILE&gt; $TEMPFILE
  # Последние 100 строк из системного журнала переписать во временный файл.
  # Совершенно необходимо, т.к. новейшие версии ядер генерируют много сообщений при входе.
  search=`grep $KEYWORD $TEMPFILE`
  # Проверить наличие фразы &quot;address&quot;,
  # свидетельствующей об успешном входе.

  if [ ! -z &quot;$search&quot; ] # Кавычки необходимы, т.к. переменная может содержать пробелы.
  then
     echo &quot;On-line&quot;
     rm -f $TEMPFILE    # Удалить временный файл.
     exit $ONLINE
  else
     echo -n &quot;.&quot;        # ключ -n подавляет вывод символа перевода строки,
                        # так вы получите непрерывную строку точек.
  fi

  sleep 1
done


# Обратите внимание: если изменить содержимое переменной KEYWORD
# на &quot;Exit&quot;, то сценарий может использоваться для контроля
# неожиданного выхода (logoff).

exit 0

# Nick Drage предложил альтернативный метод:

while true
  do ifconfig ppp0 | grep UP 1&gt; /dev/null &amp;&amp; echo &quot;соединение установлено&quot; &amp;&amp; exit 0
  echo -n &quot;.&quot;   # Печать последовательности точек (.....), пока соединение не будет установлено.
  sleep 2
done

# Проблема: Нажатия Control-C может оказаться недостаточным, чтобы завершить этот процесс.
#          (Точки продолжают выводиться на экран.)
# Упражнение: Исправьте этот недостаток.



# Stephane Chazelas предложил еще одну альтернативу:

CHECK_INTERVAL=1

while ! tail -1 &quot;$LOGFILE&quot; | grep -q &quot;$KEYWORD&quot;
do echo -n .
   sleep $CHECK_INTERVAL
done
echo &quot;On-line&quot;

# Упражнение: Найдите сильные и слабые стороны
#           каждого из этих подходов.
</pre>
      </div>

      <div
       class="NOTE">
        <table
         class="NOTE"
         width="100%"
         border="0">
          <tr>
            <td
             width="25"
             align="center"
             valign="top"><img
             src="misc/abs-book/images/note.gif"
             hspace="5"
             alt="Note"></td>

            <td
             align="left"
             valign="top">
              <p>Аргумент <tt
               class="OPTION">DEBUG</tt>, команды <strong
               class="COMMAND">trap</strong>, заставляет сценарий
              выполнять указанное действие после выполнения каждой
              команды. Это можно использовать для трассировки
              переменных.</p>

              <div
               class="EXAMPLE">
                <a
                 name="c13099_html_VARTRACE"></a>

                <p><strong>Пример 29-7. Трассировка
                переменной</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

trap &#39;echo &quot;VARIABLE-TRACE&gt; $LINENO: \$variable = \&quot;$variable\&quot;&quot;&#39; DEBUG
# Выводить значение переменной после исполнения каждой команды.

variable=29

echo &quot;Переменная \&quot;\$variable\&quot; инициализирована числом $variable.&quot;

let &quot;variable *= 3&quot;
echo &quot;Значение переменной \&quot;\$variable\&quot; увеличено в 3 раза.&quot;

# Конструкция &quot;trap &#39;commands&#39; DEBUG&quot; может оказаться очень полезной
# при отладке больших и сложных скриптов,
# когда размещение множества инструкций &quot;echo $variable&quot;
# может потребовать достаточно большого времени.

# Спасибо Stephane Chazelas.

exit 0
</pre>
              </div>
              <br>
              <br>
            </td>
          </tr>
        </table>
      </div>

      <div
       class="NOTE">
        <table
         class="NOTE"
         width="100%"
         border="0">
          <tr>
            <td
             width="25"
             align="center"
             valign="top"><img
             src="misc/abs-book/images/note.gif"
             hspace="5"
             alt="Note"></td>

            <td
             align="left"
             valign="top">
              <p>Конструкция <tt
               class="USERINPUT"><strong>trap &#39;&#39;
              SIGNAL</strong></tt> (две одиночных кавычки) -- запрещает
              SIGNAL для оставшейся части сценария. Конструкция <tt
               class="USERINPUT"><strong>trap SIGNAL</strong></tt> --
              восстанавливает действие сигнала SIGNAL. Эти конструкции
              могут использоваться для защиты критических участков
              сценария от нежелательного прерывания.</p>
            </td>
          </tr>
        </table>
      </div>
<pre
 class="PROGRAMLISTING">
       trap &#39;&#39; 2  # Сигнал 2 (Control-C) -- запрещен.
        command
        command
        command
        trap 2     # Разрешение реакции на Control-C
       
</pre>
      <br>
      <br>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN13102"
         href="#c13099_html_AEN13102"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p><a
           href="http://bashdb.sourceforge.net"
           target="_top">Bash debugger</a> (автор: Rocky Bernstein)
          частично возмещает этот недостаток.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN13188"
         href="#c13099_html_AEN13188"><span
         class="footnote">[2]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>В соответствии с соглашениями, сигнал с номером <tt
           class="REPLACEABLE"><em>0</em></tt> соответствует команде <a
           href="#c2105_html_EXITCOMMANDREF">exit</a>.</p>
        </td>
      </tr>
    </table>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#c13041_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#c13228_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">/dev/zero и /dev/null</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#p11889_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Необязательные параметры (ключи)</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="c13228_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#c13099_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#c13371_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="CHAPTER">
      <h1><a
       name="c13228_html_OPTIONS"></a>Глава 30. Необязательные параметры
      (ключи)</h1>

      <p><a
       name="c13228_html_OPTIONSREF"></a></p>

      <p>Необязательные параметры -- это дополнительные ключи (опции),
      которые оказывают влияние на поведение сценария и/или командной
      оболочки.</p>

      <p>Команда <a
       href="#c5358_html_SETREF">set</a> позволяет задавать
      дополнительные опции прямо внутри сценария. В том месте сценария,
      где необходимо, чтобы та или иная опция вступила в силу, вставьте
      такую конструкцию <strong
       class="COMMAND">set -o option-name</strong>, или в более
      короткой форме -- <strong
       class="COMMAND">set -option-abbrev</strong>. Эти две формы
      записи совершенно идентичны по своему действию.</p>
<pre
 class="PROGRAMLISTING">
      #!/bin/bash

      set -o verbose
      # Вывод команд перед их исполнением.
     
</pre>
      <br>
      <br>
<pre
 class="PROGRAMLISTING">
      #!/bin/bash

      set -v
      # Имеет тот же эффект, что и выше.
     
</pre>
      <br>
      <br>

      <div
       class="NOTE">
        <table
         class="NOTE"
         width="100%"
         border="0">
          <tr>
            <td
             width="25"
             align="center"
             valign="top"><img
             src="misc/abs-book/images/note.gif"
             hspace="5"
             alt="Note"></td>

            <td
             align="left"
             valign="top">
              <p>Для того, чтобы отключить действие той или иной опции,
              следует вставить конструкцию <strong
               class="COMMAND">set +o option-name</strong>, или <strong
               class="COMMAND">set +option-abbrev</strong>.</p>
            </td>
          </tr>
        </table>
      </div>
<pre
 class="PROGRAMLISTING">
      #!/bin/bash

      set -o verbose
      # Вывод команд перед их исполнением.
      command
      ...
      command

      set +o verbose
      # Запретить вывод команд перед их исполнением.
      command
      # команда не выводится.


      set -v
      # Вывод команд перед их исполнением.
      command
      ...
      command

      set +v
      # Запретить вывод команд перед их исполнением.
      command

      exit 0
     
</pre>
      <br>
      <br>

      <p>Как вариант установки опций, можно предложить указывать их в
      заголовке сценария (в строке sha-bang) -- <tt
       class="REPLACEABLE"><em>#!</em></tt>.</p>
<pre
 class="PROGRAMLISTING">
      #!/bin/bash -x
      #
      # Далее следует текст сценария.
     
</pre>
      <br>
      <br>

      <p><a
       name="c13228_html_INVOCATIONOPTIONSREF"></a></p>

      <p>Так же можно указывать дополнительные ключи в командной
      строке, при запуске сценария. Некоторые из опций работают только
      если они заданы из командной строки, например <tt
       class="REPLACEABLE"><em>-i</em></tt> -- ключ интерактивного
      режима работы скрипта.</p>

      <p><tt
       class="USERINPUT"><strong>bash -v script-name</strong></tt></p>

      <p><tt
       class="USERINPUT"><strong>bash -o verbose
      script-name</strong></tt></p>

      <p>Ниже приводится список некоторых полезных опций, которые могут
      быть указаны как в полной форме так и в сокращенной.</p>

      <div
       class="TABLE">
        <a
         name="c13228_html_AEN13260"></a>

        <p><strong>Таблица 30-1. Ключи Bash</strong></p>

        <table
         border="1"
         class="CALSTABLE">
          <thead>
            <tr>
              <th
               align="left"
               valign="top">Краткое имя</th>

              <th
               align="left"
               valign="top">Полное имя</th>

              <th
               align="left"
               valign="top">Описание</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td
               align="left"
               valign="top"><a
               name="c13228_html_NOCLOBBERREF"></a><tt
               class="OPTION">-C</tt></td>

              <td
               align="left"
               valign="top">noclobber</td>

              <td
               align="left"
               valign="top">Предотвращает перезапись файла в операциях
              перенаправления вывода (не распространяется на конвейеры
              (каналы) -- <span
               class="TOKEN">&gt;|</span>)</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">-D</tt></td>

              <td
               align="left"
               valign="top">(нет)</td>

              <td
               align="left"
               valign="top">Выводит список строк в двойных кавычках,
              которым предшествует символ <span
               class="TOKEN">$</span>, сам сценарий не исполняется</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">-a</tt></td>

              <td
               align="left"
               valign="top">allexport</td>

              <td
               align="left"
               valign="top">Экспорт всех, определенных в сценарии,
              переменных</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">-b</tt></td>

              <td
               align="left"
               valign="top">notify</td>

              <td
               align="left"
               valign="top">Выводит уведомление по завершении фоновой
              задачи (job) (довольно редко используется в
              сценариях)</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">-c ...</tt></td>

              <td
               align="left"
               valign="top">(нет)</td>

              <td
               align="left"
               valign="top">Читает команды из <strong
               class="COMMAND">...</strong></td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">-f</tt></td>

              <td
               align="left"
               valign="top">noglob</td>

              <td
               align="left"
               valign="top">Подстановка имен файлов (globbing)
              запрещена</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">-i</tt></td>

              <td
               align="left"
               valign="top">interactive</td>

              <td
               align="left"
               valign="top">Сценарий запускается в <span
               class="emphasis"><em
               class="EMPHASIS">интерактивном</em></span> режиме</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">-p</tt></td>

              <td
               align="left"
               valign="top">privileged</td>

              <td
               align="left"
               valign="top">Сценарий запускается как <span
               class="QUOTE">&quot;suid&quot;</span> (осторожно!)</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">-r</tt></td>

              <td
               align="left"
               valign="top">restricted</td>

              <td
               align="left"
               valign="top">Сценарий запускается в <span
               class="emphasis"><em
               class="EMPHASIS">ограниченном</em></span> режиме (см. <a
               href="#c12376_html">Глава 20</a>).</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">-u</tt></td>

              <td
               align="left"
               valign="top">nounset</td>

              <td
               align="left"
               valign="top">При попытке обращения к неопределенным
              переменным, выдает сообщение об ошибке и прерывает работу
              сценария</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">-v</tt></td>

              <td
               align="left"
               valign="top">verbose</td>

              <td
               align="left"
               valign="top">Выводит на <tt
               class="FILENAME">stdout</tt> каждую команду прежде, чем
              она будет исполнена</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">-x</tt></td>

              <td
               align="left"
               valign="top">xtrace</td>

              <td
               align="left"
               valign="top">Подобна <tt
               class="OPTION">-v</tt>, но выполняет подстановку
              команд</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">-e</tt></td>

              <td
               align="left"
               valign="top">errexit</td>

              <td
               align="left"
               valign="top">Прерывает работу сценария при появлении
              первой же ошибки (когда команда возвращает ненулевой код
              завершения)</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">-n</tt></td>

              <td
               align="left"
               valign="top">noexec</td>

              <td
               align="left"
               valign="top">Читает команды из сценария, но не исполняет
              их (проверка синтаксиса)</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">-s</tt></td>

              <td
               align="left"
               valign="top">stdin</td>

              <td
               align="left"
               valign="top">Читает команды с устройства <tt
               class="FILENAME">stdin</tt></td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">-t</tt></td>

              <td
               align="left"
               valign="top">(нет)</td>

              <td
               align="left"
               valign="top">Выход после исполнения первой команды</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">-</tt></td>

              <td
               align="left"
               valign="top">(нет)</td>

              <td
               align="left"
               valign="top">Конец списка ключей (опций), последующие
              аргументы будут восприниматься как <a
               href="#c3270_html_POSPARAMREF">позиционные
              параметры</a>.</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">--</tt></td>

              <td
               align="left"
               valign="top">(нет)</td>

              <td
               align="left"
               valign="top">Эквивалент предыдущей опции (-).</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#c13099_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#c13371_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Отладка сценариев</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#p11889_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Широко распространенные ошибки</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="c13371_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#c13228_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#c13468_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="CHAPTER">
      <h1><a
       name="c13371_html_GOTCHAS"></a>Глава 31. Широко распространенные ошибки</h1>

      <table
       border="0"
       width="100%"
       cellspacing="0"
       cellpadding="0"
       class="EPIGRAPH">
        <tr>
          <td
           width="45%"> </td>

          <td
           width="45%"
           align="left"
           valign="top">
            <p><em>Turandot: Gli enigmi sono tre, la morte
            una!</em></p>

            <p><em>Caleph: No, no! Gli enigmi sono tre, una la
            vita!</em></p>
          </td>
        </tr>

        <tr>
          <td
           width="45%"> </td>

          <td
           width="45%"
           align="right"
           valign="top"><em><span
           class="ATTRIBUTION">Puccini</span></em></td>
        </tr>
      </table>

      <p>Использование зарезервированных слов и служебных символов в
      качестве имен переменных.</p>
<pre
 class="PROGRAMLISTING">
case=value0       # Может вызвать проблемы.
23skidoo=value1   # Тоже самое.
# Имена переменных, начинающиеся с цифр, зарезервированы командной оболочкой.
# Если имя переменной начинается с символа подчеркивания: _23skidoo=value1, то это не считается ошибкой.

# Однако... если имя переменной состоит из единственного символа подчеркивания, то это ошибка.
_=25
echo $_           # $_  -- это внутренняя переменная.

xyz((!*=value2    # Вызывает серьезные проблемы.
</pre>
      <br>
      <br>

      <p>Использование дефиса, и других зарезервированных символов, в
      именах переменных.</p>
<pre
 class="PROGRAMLISTING">
var-1=23
# Вместо такой записи используйте &#39;var_1&#39;.
</pre>
      <br>
      <br>

      <p>Использование одинаковых имен для переменных и функций. Это
      делает сценарий трудным для понимания.</p>
<pre
 class="PROGRAMLISTING">
do_something ()
{
  echo &quot;Эта функция должна что-нибудь сделать с \&quot;$1\&quot;.&quot;
}

do_something=do_something

do_something do_something

# Все это будет работать правильно, но слишком уж запутанно.
</pre>
      <br>
      <br>

      <p><a
       name="c13371_html_WSBAD"></a>Использование лишних <a
       href="#c301_html_WHITESPACEREF">пробелов</a>. В отличие от других
      языков программирования, Bash весьма привередлив по отношению к
      пробелам.</p>
<pre
 class="PROGRAMLISTING">
var1 = 23   # Правильный вариант: &#39;var1=23&#39;.
# В вышеприведенной строке Bash будет трактовать &quot;var1&quot; как имя команды
# с аргументами &quot;=&quot; и &quot;23&quot;.

let c = $a - $b   # Правильный вариант: &#39;let c=$a-$b&#39; или &#39;let &quot;c = $a - $b&quot;&#39;

if [ $a -le 5]    # Правильный вариант: if [ $a -le 5 ]
# if [ &quot;$a&quot; -le 5 ]   еще лучше.
# [[ $a -le 5 ]] тоже верно.
</pre>
      <br>
      <br>

      <p>Ошибочным является предположение о том, что
      неинициализированные переменные содержат <span
       class="QUOTE">&quot;ноль&quot;</span>. Неинициализированные
      переменные содержат <span
       class="QUOTE">&quot;пустое&quot;</span> (null) значение, а <span
       class="emphasis"><em
       class="EMPHASIS">не</em></span> ноль.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

echo &quot;uninitialized_var = $uninitialized_var&quot;
# uninitialized_var =
</pre>
      <br>
      <br>

      <p>Часто программисты путают операторы сравнения <span
       class="emphasis"><em
       class="EMPHASIS">=</em></span> и <span
       class="emphasis"><em
       class="EMPHASIS">-eq</em></span>. Запомните, оператор <span
       class="emphasis"><em
       class="EMPHASIS">=</em></span> используется для сравнения
      строковых переменных, а <span
       class="emphasis"><em
       class="EMPHASIS">-eq</em></span> -- для сравнения целых
      чисел.</p>
<pre
 class="PROGRAMLISTING">
if [ &quot;$a&quot; = 273 ]      # Как вы полагаете? $a -- это целое число или строка?
if [ &quot;$a&quot; -eq 273 ]    # Если $a -- целое число.

# Иногда, такого рода ошибка никак себя не проявляет.
# Однако...


a=273.0   # Не целое число.

if [ &quot;$a&quot; = 273 ]
then
  echo &quot;Равны.&quot;
else
  echo &quot;Не равны.&quot;
fi    # Не равны.

# тоже самое и для  a=&quot; 273&quot;  и  a=&quot;0273&quot;.


# Подобные проблемы возникают при использовании &quot;-eq&quot; со строковыми значениями.

if [ &quot;$a&quot; -eq 273.0 ]
then
  echo &quot;a = $a&#39;
fi  # Исполнение сценария прерывается по ошибке.
# test.sh: [: 273.0: integer expression expected
</pre>
      <br>
      <br>

      <p>Ошибки при сравнении <a
       href="#x2565_html_ICOMPARISON1">целых чисел</a> и <a
       href="#x2565_html_SCOMPARISON1">строковых значений</a>.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# bad-op.sh

number=1

while [ &quot;$number&quot; &lt; 5 ]    # Неверно! должно быть   while [ &quot;number&quot; -lt 5 ]
do
  echo -n &quot;$number &quot;
  let &quot;number += 1&quot;
done

# Этот сценарий генерирует сообщение об ошибке:
# bad-op.sh: 5: No such file or directory
</pre>
      <br>
      <br>

      <p>Иногда, в операциях проверки, с использованием квадратных
      скобок ([ ]), переменные необходимо брать в двойные кавычки. См.
      <a
       href="#x2565_html_STRTEST">Пример 7-6</a>, <a
       href="#x11731_html_REDIR2">Пример 16-4</a> и <a
       href="#c3270_html_ARGLIST">Пример 9-6</a>.</p>

      <p>Иногда сценарий не в состоянии выполнить команду из-за
      нехватки прав доступа. Если пользователь не сможет запустить
      команду из командной строки, то эта команда не сможет быть
      запущена и из сценария. Попробуйте изменить атрибуты команды,
      возможно вам придется установить бит suid.</p>

      <p>Использование символа <strong
       class="COMMAND">-</strong> в качестве оператора перенаправления
      (каковым он не является) может приводить к неожиданным
      результатам.</p>
<pre
 class="PROGRAMLISTING">
command1 2&gt; - | command2  # Попытка передать сообщения об ошибках команде command1 через конвейер...
#    ...не будет работать.

command1 2&gt;&amp; - | command2  # Так же бессмысленно.

Спасибо S.C.
</pre>
      <br>
      <br>

      <p>Использование функциональных особенностей Bash <a
       href="#c13936_html_BASH2REF">версии 2</a> или выше, может
      привести к аварийному завершению сценария, работающему под
      управлением Bash версии 1.XX.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

minimum_version=2
# Поскольку Chet Ramey постоянно развивает Bash,
# вам может потребоваться указать другую минимально допустимую версию $minimum_version=2.XX.
E_BAD_VERSION=80

if [ &quot;$BASH_VERSION&quot; \&lt; &quot;$minimum_version&quot; ]
then
  echo &quot;Этот сценарий должен исполняться под управлением Bash, версии $minimum или выше.&quot;
  echo &quot;Настоятельно рекомендуется обновиться.&quot;
  exit $E_BAD_VERSION
fi

...
</pre>
      <br>
      <br>

      <p>Использование специфических особенностей Bash может приводить
      к аварийному завершению сценария в Bourne shell (<tt
       class="USERINPUT"><strong>#!/bin/sh</strong></tt>). Как правило,
      в Linux дистрибутивах, <strong
       class="COMMAND">sh</strong> является псевдонимом <strong
       class="COMMAND">bash</strong>, но это не всегда верно для
      UNIX-систем вообще.</p>

      <p>Сценарий, в котором строки отделяются друг от друга в стиле
      MS-DOS (<tt
       class="REPLACEABLE"><em>\r\n</em></tt>), будет завершаться
      аварийно, поскольку комбинация <tt
       class="USERINPUT"><strong>#!/bin/bash\r\n</strong></tt>
      считается недопустимой. Исправить эту ошибку можно простым
      удалением символа \r из сценария.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

echo &quot;Начало&quot;

unix2dos $0    # Сценарий переводит символы перевода строки в формат DOS.
chmod 755 $0   # Восстановление прав на запуск.
               # Команда &#39;unix2dos&#39; удалит право на запуск из атрибутов файла.

./$0           # Попытка запустить себя самого.
               # Но это не сработает из-за того, что теперь строки отделяются
               # друг от друга в стиле DOS.

echo &quot;Конец&quot;

exit 0
</pre>
      <br>
      <br>

      <p>Сценарий, начинающийся с <tt
       class="USERINPUT"><strong>#!/bin/sh</strong></tt>, не может
      работать в режиме полной совместимости с Bash. Некоторые из
      специфических функций, присущих Bash, могут оказаться
      запрещенными к использованию. Сценарий, который требует полного
      доступа ко всем расширениям, имеющимся в Bash, должен начинаться
      строкой <tt
       class="USERINPUT"><strong>#!/bin/bash</strong></tt>.</p>

      <p>Сценарий не может <strong
       class="COMMAND">экспортировать</strong> переменные <a
       href="#c5358_html_FORKREF">родительскому процессу</a> - оболочке.
      Здесь как в природе, потомок может унаследовать черты родителя,
      но не наооборот.</p>
<pre
 class="PROGRAMLISTING">
WHATEVER=/home/bozo
export WHATEVER
exit 0
</pre>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <strong
 class="COMMAND">echo $WHATEVER</strong>

<tt
 class="PROMPT">bash$</tt>
</pre>
      Будьте уверены -- при выходе в командную строку переменная
      $WHATEVER останется неинициализированной. <br>
      <br>

      <p>Использование в подоболочке переменных с теми же именами, что
      и в родительской оболочке может не давать ожидаемого
      результата.</p>

      <div
       class="EXAMPLE">
        <a
         name="c13371_html_SUBPIT"></a>

        <p><strong>Пример 31-1. Западня в подоболочке</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Западня в подоболочке.

outer_variable=внешняя_переменная
echo
echo &quot;outer_variable = $outer_variable&quot;
echo

(
# Запуск в подоболочке

echo &quot;внутри подоболочки outer_variable = $outer_variable&quot;
inner_variable=внутренняя_переменная  # Инициализировать
echo &quot;внутри подоболочки inner_variable = $inner_variable&quot;
outer_variable=внутренняя_переменная  # Как думаете? Изменит внешнюю переменную?
echo &quot;внутри подоболочки outer_variable = $outer_variable&quot;

# Выход из подоболочки
)

echo
echo &quot;за пределами подоболочки inner_variable = $inner_variable&quot;  # Ничего не выводится.
echo &quot;за пределами подоболочки outer_variable = $outer_variable&quot;  # внешняя_переменная.
echo

exit 0
</pre>
      </div>

      <p><a
       name="c13371_html_BADREAD0"></a></p>

      <p>Передача вывода от <strong
       class="COMMAND">echo</strong> по <a
       href="#c301_html_PIPEREF">конвейеру</a> команде <a
       href="#c5358_html_READREF">read</a> может давать неожиданные
      результаты. В этом сценарии, команда <strong
       class="COMMAND">read</strong> действует так, как будто бы она
      была запущена в подоболочке. Вместо нее лучше использовать
      команду <a
       href="#c5358_html_SETREF">set</a> (см. <a
       href="#c5358_html_SETPOS">Пример 11-14</a>).</p>

      <div
       class="EXAMPLE">
        <a
         name="c13371_html_BADREAD"></a>

        <p><strong>Пример 31-2. Передача вывода от команды echo команде
        read, по конвейеру</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
#  badread.sh:
#  Попытка использования &#39;echo&#39; и &#39;read&#39;
#+ для записи значений в переменные.

a=aaa
b=bbb
c=ccc

echo &quot;один два три&quot; | read a b c
# Попытка записать значения в переменные a, b и c.

echo
echo &quot;a = $a&quot;  # a = aaa
echo &quot;b = $b&quot;  # b = bbb
echo &quot;c = $c&quot;  # c = ccc
# Присваивания не произошло.

# ------------------------------

# Альтернативный вариант.

var=`echo &quot;один два три&quot;`
set -- $var
a=$1; b=$2; c=$3

echo &quot;-------&quot;
echo &quot;a = $a&quot;  # a = один
echo &quot;b = $b&quot;  # b = два
echo &quot;c = $c&quot;  # c = три
# На этот раз все в порядке.

# ------------------------------

#  Обратите внимание: в подоболочке &#39;read&#39;, для первого варианта, переменные присваиваются нормально.
#  Но только в подоболочке.

a=aaa          # Все сначала.
b=bbb
c=ccc

echo; echo
echo &quot;один два три&quot; | ( read a b c;
echo &quot;Внутри подоболочки: &quot;; echo &quot;a = $a&quot;; echo &quot;b = $b&quot;; echo &quot;c = $c&quot; )
# a = один
# b = два
# c = три
echo &quot;-------&quot;
echo &quot;Снаружи: &quot;
echo &quot;a = $a&quot;  # a = aaa
echo &quot;b = $b&quot;  # b = bbb
echo &quot;c = $c&quot;  # c = ccc
echo

exit 0
</pre>
      </div>

      <p>Огромный риск, для безопасности системы, представляет
      использование в скриптах команд, с установленным битом <span
       class="QUOTE">&quot;suid&quot;</span>. <a
       name="AEN13453"
       href="#c13371_html_FTN_AEN13453"><span
       class="footnote">[1]</span></a></p>

      <p>Использование сценариев в качестве CGI-приложений может
      приводить к серьезным проблемам из-за отсутствия контроля типов
      переменных. Более того, они легко могут быть заменены взломщиком
      на его собственные сценарии.</p>

      <p>Bash не совсем корректно обрабатывает строки, содержащие <a
       href="#c5358_html_DOUBLESLASHREF">двойной слэш (<span
       class="TOKEN">//</span>)</a>.</p>

      <p>Сценарии на языке Bash, созданные для Linux или BSD систем,
      могут потребовать доработки, перед тем как они смогут быть
      запущены в коммерческой версии UNIX. Такие сценарии, как правило,
      используют GNU-версии команд и утилит, которые имеют лучшую
      функциональность, нежели их аналоги в UNIX. Это особенно
      справедливо для таких утилит обработки текста, как <a
       href="#x7050_html_TRREF">tr</a>.</p>

      <table
       border="0"
       width="100%"
       cellspacing="0"
       cellpadding="0"
       class="EPIGRAPH">
        <tr>
          <td
           width="45%"> </td>

          <td
           width="45%"
           align="left"
           valign="top">
            <p><em>Danger is near thee --</em></p>

            <p><em>Beware, beware, beware, beware.</em></p>

            <p><em>Many brave hearts are asleep in the deep.</em></p>

            <p><em>So beware --</em></p>

            <p><em>Beware.</em></p>
          </td>
        </tr>

        <tr>
          <td
           width="45%"> </td>

          <td
           width="45%"
           align="right"
           valign="top"><em><span
           class="ATTRIBUTION">A.J. Lamb and H.W.
          Petrie</span></em></td>
        </tr>
      </table>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN13453"
         href="#c13371_html_AEN13453"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Установка этого бита на файлы сценариев не имеет никакого
          эффекта.</p>
        </td>
      </tr>
    </table>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#c13228_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#c13468_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Необязательные параметры (ключи)</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#p11889_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Стиль программирования</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="c13468_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#c13371_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#c13505_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="CHAPTER">
      <h1><a
       name="c13468_html_SCRSTYLE"></a>Глава 32. Стиль программирования</h1>

      <p>Возьмите в привычку структурный и систематический подход к
      программированию на языке командной оболочки. Даже для сценариев
      <span
       class="QUOTE">&quot;выходного дня&quot;</span> и <span
       class="QUOTE">&quot;писаных на коленке&quot;</span>, не
      поленитесь, найдите время для того, чтобы разложить свои мысли по
      полочкам и продумать структуру будущего скрипта прежде чем
      приниматься за кодирование.</p>

      <p>Ниже приводится несколько рекомендаций по оформлению
      сценариев, однако их не следует рассматривать как <span
       class="emphasis"><em
       class="EMPHASIS">Официальное Руководство</em></span>.</p>

      <div
       class="SECT1">
        <h1
         class="SECT1"><a
         name="c13468_html_UNOFFICIALST"></a>32.1. Неофициальные рекомендации по
        оформлению сценариев</h1>

        <ul>
          <li>
            <p>Комментируйте свой код. Это сделает ваши сценарии
            понятнее для других, и более простыми, в обслуживании, для
            вас.</p>
<pre
 class="PROGRAMLISTING">
PASS=&quot;$PASS${MATRIX:$(($RANDOM%${#MATRIX})):1}&quot;
# Эта строка имела некоторый смысл в момент написания,
# но через год-другой будет очень тяжело вспомнить -- что она делает.
# (Из сценария &quot;pw.sh&quot;, автор: Antek Sawicki)
</pre>
            <br>
            <br>

            <p>Добавляйте заголовочные комментарии в начале сценария и
            перед функциями.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

#************************************************#
#                   xyz.sh                       #
#             автор: Bozo Bozeman                #
#                Июль 05, 2001                   #
#                                                #
#          Удаление файлов проекта.              #
#************************************************#

BADDIR=65                       # Нет такого каталога.
projectdir=/home/bozo/projects  # Каталог проекта.

# ------------------------------------------------------- #
# cleanup_pfiles ()                                       #
# Удаляет все файлы в заданном каталоге.                  #
# Параметры: $target_directory                            #
# Возвращаемое значение: 0 -- в случае успеха,            #
#                        $BADDIR -- в случае ошибки.      #
# ------------------------------------------------------- #
cleanup_pfiles ()
{
  if [ ! -d &quot;$1&quot; ]  # Проверка существования заданного каталога.
  then
    echo &quot;$1 -- не является каталогом.&quot;
    return $BADDIR
  fi

  rm -f &quot;$1&quot;/*
  return 0   # Успешное завершение функции.
}

cleanup_pfiles $projectdir

exit 0
</pre>
            Не забывайте начинать ваш сценарий с sha-bang -- <span
             class="emphasis"><em
             class="EMPHASIS">#!/bin/bash</em></span>.<br>
            <br>
          </li>

          <li>
            <p>Заменяйте повторяющиеся значения константами. Это
            сделает ваш сценарий более простым для понимания и позволит
            вносить изменения, не опасаясь за его
            работоспособность.</p>
<pre
 class="PROGRAMLISTING">
if [ -f /var/log/messages ]
then
  ...
fi
# Представьте себе, что через пару лет
# вы захотите изменить /var/log/messages на /var/log/syslog.
# Тогда вам придется отыскать все строки,
# содержащие /var/log/messages, и заменить их на /var/log/syslog.
# И проверить несколько раз -- не пропустили ли что-нибудь.

# Использование &quot;констант&quot; дает лучший способ:
LOGFILE=/var/log/messages  # Если и придется изменить, то только в этой строке.
if [ -f &quot;$LOGFILE&quot; ]
then
  ...
fi
</pre>
            <br>
            <br>
          </li>

          <li>
            <p>В качестве имен переменных и функций выбирайте
            осмысленные названия.</p>
<pre
 class="PROGRAMLISTING">
fl=`ls -al $dirname`                 # Не очень удачное имя переменной.
file_listing=`ls -al $dirname`       # Уже лучше.


MAXVAL=10   # Пишите имена констант в верхнем регистре.
while [ &quot;$index&quot; -le &quot;$MAXVAL&quot; ]
...


E_NOTFOUND=75                        # Имена кодов ошибок -- в верхнем регистре,
                                     # к тому же, их желательно дополнять префиксом &quot;E_&quot;.
if [ ! -e &quot;$filename&quot; ]
then
  echo &quot;Файл $filename не найден.&quot;
  exit $E_NOTFOUND
fi


MAIL_DIRECTORY=/var/spool/mail/bozo  # Имена переменных окружения
                                     # так же желательно записывать символами
                                     # в верхнем регистре.
export MAIL_DIRECTORY


GetAnswer ()                         # Смешивание символов верхнего и нижнего решистров
                                     # удобно использовать для имен функций.
{
  prompt=$1
  echo -n $prompt
  read answer
  return $answer
}

GetAnswer &quot;Ваше любимое число? &quot;
favorite_number=$?
echo $favorite_number


_uservariable=23                     # Допустимо, но не рекомендуется.
# Желательно, чтобы пользовательские переменные не начинались с символа подчеркивания.
# Так обычно начинаются системные переменные.
</pre>
            <br>
            <br>
          </li>

          <li>
            <p>Используйте смысловые имена для <a
             href="#c2105_html_EXITCOMMANDREF">кодов завершения</a>.</p>
<pre
 class="PROGRAMLISTING">
E_WRONG_ARGS=65
...
...
exit $E_WRONG_ARGS
</pre>
            См. так же <a
             href="#a14876_html">Приложение C</a>.<br>
            <br>
          </li>

          <li>
            <p>Разделяйте большие сложные сценарии на серию более
            коротких и простых модулей. Пользуйтесь функциями. См. <a
             href="#c13936_html_EX79">Пример 34-4</a>.</p>
          </li>

          <li>
            <p>Не пользуйтесь сложными конструкциями, если их можно
            заменить простыми.</p>
<pre
 class="PROGRAMLISTING">
COMMAND
if [ $? -eq 0 ]
...
# Избыточно и неинтуитивно.

if COMMAND
...
# Более понятно и коротко.
</pre>
            <br>
            <br>
          </li>
        </ul>

        <table
         border="0"
         width="100%"
         cellspacing="0"
         cellpadding="0"
         class="EPIGRAPH">
          <tr>
            <td
             width="45%"> </td>

            <td
             width="45%"
             align="left"
             valign="top">
              <p><em>... читая исходные тексты сценариев на Bourne
              shell (/bin/sh). Я был потрясен тем, насколько непонятно
              и загадочно могут выглядеть очень простые алгоритмы из-за
              неправильного оформления кода. Я не раз спрашивал себя:
              <span
               class="QUOTE">&quot;Неужели кто-то может гордиться таким
              кодом?&quot;</span></em></p>
            </td>
          </tr>

          <tr>
            <td
             width="45%"> </td>

            <td
             width="45%"
             align="right"
             valign="top"><em><span
             class="ATTRIBUTION">Landon Noll</span></em></td>
          </tr>
        </table>
      </div>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#c13371_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#c13505_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Широко распространенные ошибки</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#p11889_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Разное</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="c13505_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#c13468_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x13541_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="CHAPTER">
      <h1><a
       name="c13505_html_MISCELLANY"></a>Глава 33. Разное</h1>

      <table
       border="0"
       width="100%"
       cellspacing="0"
       cellpadding="0"
       class="EPIGRAPH">
        <tr>
          <td
           width="45%"> </td>

          <td
           width="45%"
           align="left"
           valign="top">
            <p><em>Практически никто не знает грамматики Bourne
            shell-а. Даже изучение исходных текстов не дает ее полного
            понимания.</em></p>
          </td>
        </tr>

        <tr>
          <td
           width="45%"> </td>

          <td
           width="45%"
           align="right"
           valign="top"><em><span
           class="ATTRIBUTION">Tom Duff</span></em></td>
        </tr>
      </table>

      <div
       class="SECT1">
        <h1
         class="SECT1"><a
         name="c13505_html_INTANDNONINT"></a>33.1. Интерактивный и неинтерактивный
        режим работы</h1>

        <p>В <span
         class="emphasis"><em
         class="EMPHASIS">интеракивном</em></span> режиме, оболочка
        читает команды, вводимые пользователем, с устройства <tt
         class="FILENAME">tty</tt>. Кроме того, такая оболочка
        считывает конфигурационные файлы на запуске, выводит строку
        приглашения к вводу (prompt), и, по-умолчанию, разрешает
        управление заданиями. Пользователь имеет возможность <span
         class="emphasis"><em
         class="EMPHASIS">взаимодействия</em></span> с оболочкой.</p>

        <p>Сценарий всегда запускается в неинтерактивном режиме. Но, не
        смотря на это, он сохраняет доступ к своему <tt
         class="FILENAME">tty</tt>. И даже может эмулировать
        интерактивный режим работы.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
MY_PROMPT=&#39;$ &#39;
while :
do
  echo -n &quot;$MY_PROMPT&quot;
  read line
  eval &quot;$line&quot;
  done

exit 0

# Этот сценарий, как иллюстрация к вышесказанному, предоставлен
# Stephane Chazelas (спасибо).
</pre>
        <br>
        <br>

        <p>Будем считать <span
         class="emphasis"><em
         class="EMPHASIS">интерактивным</em></span> такой сценарий,
        который может принимать ввод от пользователя, обычно с помощью
        команды <a
         href="#c5358_html_READREF">read</a> (см. <a
         href="#c5358_html_EX36">Пример 11-2</a>). В <span
         class="QUOTE">&quot;реальной жизни&quot;</span> все намного
        сложнее. Пока же, будем придерживаться предположения о том, что
        интерактивный сценарий ограничен рамками tty, с которого
        сценарий был запущен пользователемa, т.е консоль или окно
        xterm.</p>

        <p>Сценарии начальной инициализации системы не являются
        интерактивными, поскольку они не предполагают вмешательство
        человека в процессе своей работы. Большая часть сценариев,
        выполняющих администрирование и обслуживание системы -- так же
        работают в неинтерактивном режиме. Многие задачи автоматизации
        труда администратора очень трудно представить себе без
        неинтерактивных сценариев.</p>

        <p>Неинтерактивные сценарии прекрасно могут работать в фоне, в
        то время, как интерактивные -- подвисают, останавливаясь на
        операциях, ожидающих ввода пользователя. Сложности, возникающие
        с запуском интерактивных сценариев в фоновом режиме, могут быть
        преодолены с помощью <strong
         class="COMMAND">expect</strong>-сценария или <a
         href="#c11785_html_HEREDOCREF">встроенного документа</a>. В
        простейших случаях, можно организовать перенаправление ввода из
        файла в команду <strong
         class="COMMAND">read</strong> (<strong
         class="COMMAND">read variable &lt;file</strong>). Эти приемы
        позволят создавать сценарии, которые смогут работать как в
        интерактивном, так и в неинтерактивном режимах.</p>

        <p>Если внутри сценария необходимо проверить режим работы --
        интерактивный или неинтерактивный, это можно сделать проверкой
        переменной окружения <a
         href="#c3270_html_PS1REF">$PS1</a>.</p>
<pre
 class="PROGRAMLISTING">
if [ -z $PS1 ] # интерактивный режим?
then
  # неинтерактивный
  ...
else
  # интерактивный
  ...
fi
</pre>
        <a
         name="c13505_html_IITEST"></a>Еще один способ -- проверка установки флага
        <span
         class="QUOTE">&quot;i&quot;</span> в переменной <a
         href="#c3270_html_FLPREF">$-</a>. 
<pre
 class="PROGRAMLISTING">
case $- in
*i*)    # интерактивный режим
;;
*)      # неинтерактивный режим
;;
# (Из &quot;UNIX F.A.Q.,&quot; 1993)
</pre>
        <br>
        <br>

        <div
         class="NOTE">
          <table
           class="NOTE"
           width="100%"
           border="0">
            <tr>
              <td
               width="25"
               align="center"
               valign="top"><img
               src="misc/abs-book/images/note.gif"
               hspace="5"
               alt="Note"></td>

              <td
               align="left"
               valign="top">
                <p>Сценарий может принудительно запускаться в
                интерактивном режиме, для этого необходимо указать ключ
                <span
                 class="TOKEN">-i</span> в строке-заголовке <tt
                 class="USERINPUT"><strong>#!/bin/bash
                -i</strong></tt>. Однако вы должны помнить о том, что в
                таких случаях сценарий может выдавать сообщения об
                ошибках даже тогда, когда ошибок, по сути, нет.</p>
              </td>
            </tr>
          </table>
        </div>
      </div>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#c13468_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x13541_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Стиль программирования</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#p11889_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Сценарии-обертки</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="c13936_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x13930_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#c13962_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="CHAPTER">
      <h1><a
       name="c13936_html_BASH2"></a>Глава 34. Bash, версия 2</h1>

      <p><a
       name="c13936_html_BASH2REF"></a></p>

      <p>Текущая версия <span
       class="emphasis"><em
       class="EMPHASIS">Bash</em></span>, та, которая скорее всего
      установлена в вашей системе, фактически -- 2.XX.Y.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo $BASH_VERSION</strong></tt>
<tt
 class="COMPUTEROUTPUT">2.05.8(1)-release</tt>
             
</pre>
      В этой версии классического языка сценариев Bash были добавлены
      переменные-массивы, <a
       name="AEN13946"
       href="#c13936_html_FTN_AEN13946"><span
       class="footnote">[1]</span></a> расширение строк и подстановка
      параметров, улучшен метод косвенных ссылок на переменные.<br>
      <br>

      <div
       class="EXAMPLE">
        <a
         name="c13936_html_EX77"></a>

        <p><strong>Пример 34-1. Расширение строк</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# &quot;Расширение&quot; строк (String expansion).
# Введено в Bash, начиная с версии 2.

# Строки вида  $&#39;xxx&#39;
# могут содержать дополнительные экранированные символы.

echo $&#39;Звонок звенит 3 раза \a \a \a&#39;
echo $&#39;Три перевода формата \f \f \f&#39;
echo $&#39;10 новых строк \n\n\n\n\n\n\n\n\n\n&#39;

exit 0
</pre>
      </div>

      <p><a
       name="c13936_html_VARREFNEW"></a></p>

      <div
       class="EXAMPLE">
        <a
         name="c13936_html_EX78"></a>

        <p><strong>Пример 34-2. Косвенные ссылки на переменные -- новый
        метод</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Косвенные ссылки на переменные.


a=letter_of_alphabet
letter_of_alphabet=z

echo &quot;a = $a&quot;           # Прямая ссылка.

echo &quot;Now a = ${!a}&quot;    # Косвенная ссылка.
# Форма записи ${!variable} намного удобнее старой &quot;eval var1=\$$var2&quot;

echo

t=table_cell_3
table_cell_3=24
echo &quot;t = ${!t}&quot;        # t = 24
table_cell_3=387
echo &quot;Значение переменной t изменилось на ${!t}&quot;    # 387

# Теперь их можно использовать для ссылок на элементы массива,
# или для эмуляции многомерных массивов.
# Было бы здорово, если бы косвенные ссылки допускали индексацию.

exit 0
</pre>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="c13936_html_RESISTOR"></a>

        <p><strong>Пример 34-3. Простая база данных, с применением
        косвенных ссылок</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# resistor-inventory.sh
# Простая база данных, с применением косвенных ссылок.

# ============================================================== #
# Данные

B1723_value=470                                   # сопротивление (Ом)
B1723_powerdissip=.25                             # рассеиваемая мощность (Вт)
B1723_colorcode=&quot;желтый-фиолетовый-коричневый&quot;    # цветовая маркировка
B1723_loc=173                                     # где
B1723_inventory=78                                # количество (шт)

B1724_value=1000
B1724_powerdissip=.25
B1724_colorcode=&quot;коричневый-черный-красный&quot;
B1724_loc=24N
B1724_inventory=243

B1725_value=10000
B1725_powerdissip=.25
B1725_colorcode=&quot;коричневый-черный-оранжевый&quot;
B1725_loc=24N
B1725_inventory=89

# ============================================================== #


echo

PS3=&#39;Введите ноиер: &#39;

echo

select catalog_number in &quot;B1723&quot; &quot;B1724&quot; &quot;B1725&quot;
do
  Inv=${catalog_number}_inventory
  Val=${catalog_number}_value
  Pdissip=${catalog_number}_powerdissip
  Loc=${catalog_number}_loc
  Ccode=${catalog_number}_colorcode

  echo
  echo &quot;Номер по каталогу $catalog_number:&quot;
  echo &quot;Имеется в наличии ${!Inv} шт. [${!Val} Ом / ${!Pdissip} Вт].&quot;
  echo &quot;Находятся в лотке # ${!Loc}.&quot;
  echo &quot;Цветовая маркировка: \&quot;${!Ccode}\&quot;.&quot;

  break
done

echo; echo

# Упражнение:
# ----------
# Переделайте этот сценарий так, чтобы он использовал массивы вместо косвенных ссылок.
# Какой из вариантов более простой и интуитивный?


# Примечание:
# ----------
#  Язык командной оболочки не очень удобен для написания приложений,
#+ работающих с базами данных.
#  Для этой цели лучше использовать языки программирования, имеющие
#+ развитые средства для работы со структурами данных,
#+ такие как C++ или Java (может быть Perl).

exit 0
</pre>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="c13936_html_EX79"></a>

        <p><strong>Пример 34-4. Массивы и другие хитрости для раздачи
        колоды карт в четыре руки</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# На старых системах может потребоваться вставить #!/bin/bash2.

# Карты:
# раздача в четыре руки.

UNPICKED=0
PICKED=1

DUPE_CARD=99

LOWER_LIMIT=0
UPPER_LIMIT=51
CARDS_IN_SUIT=13
CARDS=52

declare -a Deck
declare -a Suits
declare -a Cards
# Проще и понятнее было бы, имей мы дело
# с одним 3-мерным массивом.
# Будем надеяться, что в будущем, поддержка многомерных массивов будет введена в Bash.


initialize_Deck ()
{
i=$LOWER_LIMIT
until [ &quot;$i&quot; -gt $UPPER_LIMIT ]
do
  Deck[i]=$UNPICKED   # Пометить все карты в колоде &quot;Deck&quot;, как &quot;невыданная&quot;.
  let &quot;i += 1&quot;
done
echo
}

initialize_Suits ()
{
Suits[0]=Т # Трефы
Suits[1]=Б # Бубны
Suits[2]=Ч # Червы
Suits[3]=П # Пики
}

initialize_Cards ()
{
Cards=(2 3 4 5 6 7 8 9 10 В Д K Т)
# Альтернативный способ инициализации массива.
}

pick_a_card ()
{
card_number=$RANDOM
let &quot;card_number %= $CARDS&quot;
if [ &quot;${Deck[card_number]}&quot; -eq $UNPICKED ]
then
  Deck[card_number]=$PICKED
  return $card_number
else
  return $DUPE_CARD
fi
}

parse_card ()
{
number=$1
let &quot;suit_number = number / CARDS_IN_SUIT&quot;
suit=${Suits[suit_number]}
echo -n &quot;$suit-&quot;
let &quot;card_no = number % CARDS_IN_SUIT&quot;
Card=${Cards[card_no]}
printf %-4s $Card
# Вывод по столбцам.
}

seed_random ()  # Переустановка генератора случайных чисел.
{
seed=`eval date +%s`
let &quot;seed %= 32766&quot;
RANDOM=$seed
}

deal_cards ()
{
echo

cards_picked=0
while [ &quot;$cards_picked&quot; -le $UPPER_LIMIT ]
do
  pick_a_card
  t=$?

  if [ &quot;$t&quot; -ne $DUPE_CARD ]
  then
    parse_card $t

    u=$cards_picked+1
    # Возврат к индексации с 1 (временно).
    let &quot;u %= $CARDS_IN_SUIT&quot;
    if [ &quot;$u&quot; -eq 0 ]   # вложенный if/then.
    then
     echo
     echo
    fi
    # Смена руки.

    let &quot;cards_picked += 1&quot;
  fi
done

echo

return 0
}


# Структурное программирование:
# вся логика приложения построена на вызове функций.

#================
seed_random
initialize_Deck
initialize_Suits
initialize_Cards
deal_cards

exit 0
#================



# Упражнение 1:
# Добавьте комментарии, чтобы до конца задокументировать этот сценарий.

# Упражнение 2:
# Исправьте сценарий так, чтобы карты в каждой руке выводились отсортированными по масти.
# Вы можете добавить и другие улучшения.

# Упражнение 3:
# Упростите логику сценария.
</pre>
      </div>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN13946"
         href="#c13936_html_AEN13946"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Chet Ramey обещал ввести в Bash ассоциативные массивы (они
          хорошо знакомы программистам, работающим с языком Perl) в
          одном из следующих релизов Bash.</p>
        </td>
      </tr>
    </table>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x13930_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#c13962_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Сценарии командной оболочки под Windows</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#p11889_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Замечания и дополнения</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="c13962_html"></a>
<div
     class="NAVHEADER">
      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#c13936_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x13968_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="CHAPTER">
      <h1><a
       name="c13962_html_ENDNOTES"></a>Глава 35. Замечания и дополнения</h1>

      <div
       class="SECT1">
        <h1
         class="SECT1"><a
         name="c13962_html_AUTHORSNOTE"></a>35.1. От автора</h1>

        <p>Как я пришел к мысли о написании этой книги? Это необычная
        история. Случилось это лет несколько тому назад. Мне
        потребовалось изучить язык командной оболочки -- а что может
        быть лучше, как не чтение хорошей книги!? Я надеялся купить
        учебник и справочник, которые охватывали бы в полной мере
        данную тематику. Я искал книгу, которая возьмет трудные
        понятия, вывернет их наизнанку и подробно разжует на хорошо
        откомментированных примерах. В общем, я искал очень хорошую
        книгу. К сожалению, в природе таковой не существовало, поэтому
        я счел необходимым написать ее.</p>

        <p>Это напоминает мне сказку о сумасшедшем профессоре.
        Помешанный, до безумия, при виде книги, любой книги -- в
        библиотеке, в книжном магазине -- не важно где, им овладевала
        уверенность в том, что и он мог бы написать эту книгу, причем
        сделать это гораздо лучше. Он стремительно мчался домой и
        садился за создание своей собственной книги с тем же названием.
        Когда он умер, в его доме нашли несколько тысяч, написанных им
        книг, этого количества хватило бы, чтобы посрамить самого
        Айзека Азимова. Книги, может быть и не были так хороши -- кто
        знает, но разве это имеет какое-то значение? Вот -- человек,
        жил своими грезами, пусть одержимый и движимый ими, но я не
        могу удержаться от восхищения старым чудаком...</p>
      </div>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#c13936_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x13968_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Bash, версия 2</td>

          <td
           width="34%"
           align="center"
           valign="top"> </td>

          <td
           width="33%"
           align="right"
           valign="top">Об авторе</td>
        </tr>
      </table>
    </div>
<hr>

<a name="c1613_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#c301_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x1673_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="CHAPTER">
      <h1><a
       name="c1613_html_VARIABLES"></a>Глава 4. Переменные и параметры.
      Введение.</h1>

      <p>Переменные -- это одна из основ любого языка программирования.
      Они учавствуют в арифметических операциях, в синтаксическом
      анализе строк и совершенно необходимы для абстрагирования каких
      либо величин с помощью символических имен. Физически переменные
      представляют собой ни что иное как участки памяти, в которые
      записана некоторая информация.</p>

      <div
       class="SECT1">
        <h1
         class="SECT1"><a
         name="c1613_html_VARSUBN"></a>4.1. Подстановка переменных</h1>

        <p>Когда интерпретатор встречает в тексте сценария <span
         class="emphasis"><em
         class="EMPHASIS">имя</em></span> переменной, то он вместо него
        подставляет <span
         class="emphasis"><em
         class="EMPHASIS">значение</em></span> этой переменной. Поэтому
        ссылки на переменные называются <span
         class="emphasis"><em
         class="EMPHASIS">подстановкой переменных</em></span>.</p>

        <div
         class="VARIABLELIST">
          <dl>
            <dt><span
             class="TOKEN">$</span></dt>

            <dd>
              <p>Необходимо всегда помнить о различиях между <span
               class="emphasis"><em
               class="EMPHASIS">именем</em></span> переменной и ее
              <span
               class="emphasis"><em
               class="EMPHASIS">значением</em></span>. Если <tt
               class="USERINPUT"><strong>variable1</strong></tt> -- это
              имя переменной, то <tt
               class="USERINPUT"><strong>$variable1</strong></tt> --
              это ссылка на ее <span
               class="emphasis"><em
               class="EMPHASIS">значение</em></span>. <span
               class="QUOTE">&quot;Чистые&quot;</span> имена
              переменных, без префикса <span
               class="TOKEN">$</span>, могут использоваться только при
              объявлении переменный, при присваивании переменной
              некоторого значения, при <span
               class="emphasis"><em
               class="EMPHASIS">удалении (сбросе)</em></span>, при <a
               href="#c5358_html_EXPORTREF">экспорте</a> и в особых
              случаях -- когда переменная представляет собой название
              <a
               href="#c13099_html_SIGNALD">сигнала</a> (см. <a
               href="#c13099_html_EX76">Пример 29-5</a>). Присваивание
              может производится с помощью символа <span
               class="TOKEN">=</span> (например: <span
               class="emphasis"><em
               class="EMPHASIS">var1=27</em></span>), инструкцией <a
               href="#c5358_html_READREF">read</a> и в заголовке цикла
              (<span
               class="emphasis"><em
               class="EMPHASIS">for var2 in 1 2 3</em></span>).</p>

              <p><a
               name="c1613_html_DBLQUO"></a>Заключение ссылки на переменную в
              двойные кавычки (<span
               class="TOKEN">&quot; &quot;</span>) никак не сказывается
              на работе механизма подстановки. Этот случай называется
              &quot;частичные кавычки&quot;, иногда можно встретить
              название <span
               class="QUOTE">&quot;нестрогие кавычки&quot;</span>. <a
               name="c1613_html_SNGLQUO"></a>Одиночные кавычки (<span
               class="TOKEN">&#39; &#39;</span>) заставляют
              интерпретатор воспринимать ссылку на переменную как
              простой набор символов, потому в одинарных кавычках
              операции подстановки не производятся. Этот случай
              называется &quot;полные&quot;, или <span
               class="QUOTE">&quot;строгие&quot;</span> кавычки.
              Дополнительную информацию вы найдете в <a
               href="#c1833_html">Глава 5</a>.</p>

              <p>Примечательно, что написание <tt
               class="USERINPUT"><strong>$variable</strong></tt>
              фактически является упрощенной формой написания <tt
               class="USERINPUT"><strong>${variable}</strong></tt>.
              Более строгая форма записи <tt
               class="USERINPUT"><strong>${variable}</strong></tt>
              может с успехом использоваться в тех случаях, когда
              применение упрощенной формы записи порождает сообщения о
              синтаксических ошибках (см. <a
               href="#x4462_html">Section 9.3</a>, ниже).</p>

              <div
               class="EXAMPLE">
                <a
                 name="c1613_html_EX9"></a>

                <p><strong>Пример 4-1. Присваивание значений переменным
                и подстановка значений переменных</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Присваивание значений переменным и подстановка значений переменных

a=375
hello=$a

#-------------------------------------------------------------------------
# Использование пробельных символов
# с обеих сторон символа &quot;=&quot; присваивания недопустимо.

#  Если записать &quot;VARIABLE =value&quot;,
#+ то интерпретатор попытается выполнить команду &quot;VARIABLE&quot; с параметром &quot;=value&quot;.

#  Если записать &quot;VARIABLE= value&quot;,
#+ то интерпретатор попытается установить переменную окружения &quot;VARIABLE&quot; в &quot;&quot;
#+ и выполнить команду &quot;value&quot;.
#-------------------------------------------------------------------------


echo hello    # Это не ссылка на переменную, выведет строку &quot;hello&quot;.

echo $hello
echo ${hello} # Идентично предыдущей строке.

echo &quot;$hello&quot;
echo &quot;${hello}&quot;

echo

hello=&quot;A B  C   D&quot;
echo $hello   # A B C D
echo &quot;$hello&quot; # A B  C   D
# Здесь вы сможете наблюдать различия в выводе echo $hello и echo &quot;$hello&quot;.
# Заключение ссылки на переменную в кавычки сохраняет пробельные символы.

echo

echo &#39;$hello&#39;  # $hello
# Внутри одинарных кавычек не производится подстановка значений переменных,
#+ т.е. &quot;$&quot; интерпретируется как простой символ.

# Обратите внимание на различия, существующие между этими типами кавычек.


hello=    # Запись пустого значения в переменную.
echo &quot;\$hello (пустое значение) = $hello&quot;
#  Обратите внимание: запись пустого значения -- это не то же самое,
#+ что сброс переменной, хотя конечный результат -- тот же (см. ниже).

# --------------------------------------------------------------

#  Допускается присваивание нескольких переменных в одной строке,
#+ если они отделены пробельными символами.
#  Внимание! Это может снизить читабельность сценария и оказаться непереносимым.

var1=variable1  var2=variable2  var3=variable3
echo
echo &quot;var1=$var1   var2=$var2  var3=$var3&quot;

# Могут возникнуть проблемы с устаревшими версиями &quot;sh&quot;.

# --------------------------------------------------------------

echo; echo

numbers=&quot;один два три&quot;
other_numbers=&quot;1 2 3&quot;
# Если в значениях переменных встречаются пробелы,
# то использование кавычек обязательно.
echo &quot;numbers = $numbers&quot;
echo &quot;other_numbers = $other_numbers&quot;   # other_numbers = 1 2 3
echo

echo &quot;uninitialized_variable = $uninitialized_variable&quot;
# Неинициализированная переменная содержит &quot;пустое&quot; значение.
uninitialized_variable=   #  Объявление неинициализированной переменной
                          #+ (то же, что и присваивание пустого значения, см. выше).
echo &quot;uninitialized_variable = $uninitialized_variable&quot;
                          # Переменная содержит &quot;пустое&quot; значение.

uninitialized_variable=23       # Присваивание.
unset uninitialized_variable    # Сброс.
echo &quot;uninitialized_variable = $uninitialized_variable&quot;
                                # Переменная содержит &quot;пустое&quot; значение.

echo

exit 0
</pre>
              </div>

              <div
               class="CAUTION">
                <table
                 class="CAUTION"
                 width="90%"
                 border="0">
                  <tr>
                    <td
                     width="25"
                     align="center"
                     valign="top"><img
                     src="misc/abs-book/images/caution.gif"
                     hspace="5"
                     alt="Caution"></td>

                    <td
                     align="left"
                     valign="top">
                      <p>Неинициализированная переменная хранит <span
                       class="QUOTE">&quot;пустое&quot;</span> значение
                      - не ноль!. Использование неинициализированных
                      переменных может приводить к ошибкам разного рода
                      в процессе исполнения.</p>

                      <p>Не смотря на это в арифметических операциях
                      допускается использовать неинициализированные
                      переменные.</p>
<pre
 class="PROGRAMLISTING">
echo &quot;$uninitialized&quot;                                # (пустая строка)
let &quot;uninitialized += 5&quot;                             # Прибавить 5.
echo &quot;$uninitialized&quot;                                # 5

#  Заключение:
#  Неинициализированные переменные не имеют значения, однако
#+ в арифметических операциях за значение таких переменных принимается число 0.
#  Это недокументированная (и возможно непереносимая) возможность.
</pre>
                      См. так же <a
                       href="#c5358_html_SELFSOURCE">Пример
                      11-19</a>.<br>
                      <br>
                    </td>
                  </tr>
                </table>
              </div>
            </dd>
          </dl>
        </div>
      </div>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#c301_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x1673_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Служебные символы</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#p299_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Присваивание значений переменным</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="c178_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#c118_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x288_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="CHAPTER">
      <h1><a
       name="c178_html_SHA-BANG"></a>Глава 2. Для начала о Sha-Bang</h1>

      <p>В простейшем случае, скрипт -- это ни что иное, как простой
      список команд системы, записанный в файл. Создание скриптов
      поможет сохранить ваше время и силы, которые тратятся на ввод
      последовательности команд всякий раз, когда необходимо их
      выполнить.</p>

      <div
       class="EXAMPLE">
        <a
         name="c178_html_EX1"></a>

        <p><strong>Пример 2-1. cleanup: Сценарий очистки лог-файлов в
        /var/log</strong></p>
<pre
 class="PROGRAMLISTING">
# cleanup
# Для работы сценария требуются права root.

cd /var/log
cat /dev/null &gt; messages
cat /dev/null &gt; wtmp
echo &quot;Лог-файлы очищены.&quot;
</pre>
      </div>

      <p>Здесь нет ничего необычного, это простая последовательность
      команд, которая может быть набрана в командной строке с консоли
      или в xterm. Преимущество размещения последовательности команд в
      скрипте состоит в том, что вам не придется всякий раз набирать
      эту последовательность вручную. Кроме того, скрипты легко могут
      быть модифицированы или обобщены для разных применений.</p>

      <div
       class="EXAMPLE">
        <a
         name="c178_html_EX2"></a>

        <p><strong>Пример 2-2. cleanup: Расширенная версия предыдущего
        сценария.</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# cleanup, version 2
# Для работы сценария требуются права root.

LOG_DIR=/var/log
ROOT_UID=0     # Только пользователь с $UID 0 имеет привилегии root.
LINES=50       # Количество сохраняемых строк по-умолчанию.
E_XCD=66       # Невозможно сменить каталог?
E_NOTROOT=67   # Признак отсутствия root-привилегий.


if [ &quot;$UID&quot; -ne &quot;$ROOT_UID&quot; ]
then
  echo &quot;Для работы сценария требуются права root.&quot;
  exit $E_NOTROOT
fi

if [ -n &quot;$1&quot; ]
# Проверка наличия аргумента командной строки.
then
  lines=$1
else
  lines=$LINES # Значение по-умолчанию, если число не задано в командной строке
fi


#  Stephane Chazelas предложил следующее,
#+ для проверки корректности аргумента, переданного из командной строки,
#+ правда это достаточно сложно для данного руководства.
#
#    E_WRONGARGS=65  # Не числовой аргумент
#
#    case &quot;$1&quot; in
#    &quot;&quot;      ) lines=50;;
#    *[!0-9]*) echo &quot;Usage: `basename $0` file-to-cleanup&quot;; exit $E_WRONGARGS;;
#    *       ) lines=$1;;
#    esac
#
#* Конец проверки корректности аргумента


cd $LOG_DIR

if [ `pwd` != &quot;$LOG_DIR&quot; ]  # или   if [ &quot;$PWD&quot; != &quot;$LOG_DIR&quot; ]
                            # Не в /var/log?
then
  echo &quot;Невозможно перейти в каталог $LOG_DIR.&quot;
  exit $E_XCD
fi  # Проверка каталога перед очисткой лог-файлов.

# более эффективный вариант:
#
# cd /var/log || {
#   echo &quot;Невозможно перейти в требуемый каталог.&quot; &gt;&amp;2
#   exit $E_XCD;
# }




tail -$lines messages &gt; mesg.temp # Сохранить последние строки в лог-файле.
mv mesg.temp messages


# cat /dev/null &gt; messages
#* Необходимость этой команды отпала, поскольку очистка выполняется выше.

cat /dev/null &gt; wtmp  #  команды &#39;: &gt; wtmp&#39; и &#39;&gt; wtmp&#39;  имеют тот же эффект.
echo &quot;Лог-файлы очищены.&quot;

exit 0
#  Возвращаемое значение 0
#+ указывает на успешное завершение работы сценария.
</pre>
      </div>

      <p>Если вы не желаете полностью вычищать системные логи, то выше
      представлена улучшенная версия предыдущего сценария. Здесь
      сохраняются последние несколько строк (по-умолчанию -- 50).</p>

      <p>Если файл сценария начинается с последовательности <span
       class="TOKEN">#!</span>, которая в мире UNIX называется <em
       class="FIRSTTERM">sha-bang</em>, то это указывает системе какой
      интерпретатор следует использовать для исполнения сценария. <a
       name="c178_html_MAGNUMREF"></a>Это двухбайтовая последовательность, или <a
       name="AEN199"
       href="#c178_html_FTN_AEN199"><span
       class="footnote">[1]</span></a> -- специальный маркер,
      определяющий тип сценария, в данном случае -- сценарий командной
      оболочки (см. <tt
       class="USERINPUT"><strong>man magic</strong></tt>). Более точно,
      <span
       class="emphasis"><em
       class="EMPHASIS">sha-bang</em></span> определяет интерпретатор,
      который вызывается для исполнения сценария, это может быть
      командная оболочка (shell), иной интерпретатор или утилита. <a
       name="AEN207"
       href="#c178_html_FTN_AEN207"><span
       class="footnote">[2]</span></a></p>
<pre
 class="PROGRAMLISTING">
#!/bin/sh
#!/bin/bash
#!/usr/bin/perl
#!/usr/bin/tcl
#!/bin/sed -f
#!/usr/awk -f
</pre>
      <br>
      <br>

      <p>Каждая, из приведенных выше сигнатур, приводит к вызову
      различных интерпретаторов, будь то <tt
       class="FILENAME">/bin/sh</tt> -- командный интерпретатор
      по-умолчанию (<strong
       class="COMMAND">bash</strong> для Linux-систем), либо иной. <a
       name="AEN220"
       href="#c178_html_FTN_AEN220"><span
       class="footnote">[3]</span></a> При <a
       href="#x13898_html">переносе</a> сценариев с сигнатурой <tt
       class="USERINPUT"><strong>#!/bin/sh</strong></tt> на другие UNIX
      системы, где в качестве командного интерпретатора задан другой
      shell, вы можете лишиться некоторых особенностей, присущих bash.
      Поэтому такие сценарии должны быть <span
       class="ACRONYM">POSIX</span> совместимыми. <a
       name="AEN230"
       href="#c178_html_FTN_AEN230"><span
       class="footnote">[4]</span></a>.</p>

      <p>Обратите внимание на то, что сигнатура должна указывать
      правильный путь к интерпретатору, в противном случае вы получите
      сообщение об ошибке -- как правило это <span
       class="QUOTE">&quot;Command not found&quot;</span>.</p>

      <p>Сигнатура <span
       class="TOKEN">#!</span> может быть опущена, если вы не
      используете специфичных команд. Во втором примере (см. выше)
      использование сигнатуры <span
       class="TOKEN">#!</span> обязательно, поскольку сценарий
      использует специфичную конструкцию присваивания значения
      переменной <tt
       class="USERINPUT"><strong>lines=50</strong></tt>. Еще раз
      замечу, что сигнатура <tt
       class="USERINPUT"><strong>#!/bin/sh</strong></tt> вызывает
      командный интерпретатор по-умолчанию -- <tt
       class="FILENAME">/bin/bash</tt> в Linux-системах.</p>

      <div
       class="IMPORTANT">
        <table
         class="IMPORTANT"
         width="100%"
         border="0">
          <tr>
            <td
             width="25"
             align="center"
             valign="top"><img
             src="misc/abs-book/images/important.gif"
             hspace="5"
             alt="Important"></td>

            <td
             align="left"
             valign="top">
              <p>В данном руководстве приветствуется модульный подход к
              построению сценариев. Записывайте, собирайте свою
              коллекцию участков кода, который может вам встретиться. В
              конечном итоге вы соберете свою &quot;библиотеку&quot;
              подпрограмм, которые затем сможете использовать при
              написании своих сценариев. Например, следующий отрывок
              сценария проверяет количество аргументов в командной
              строке:</p>
<pre
 class="PROGRAMLISTING">
if [ $# -ne Number_of_expected_args ]
then
  echo &quot;Usage: `basename $0` whatever&quot;
  exit $WRONG_ARGS
fi
</pre>
              <br>
              <br>
            </td>
          </tr>
        </table>
      </div>

      <div
       class="SECT1">
        <h1
         class="SECT1"><a
         name="c178_html_INVOKING"></a>2.1. Запуск сценария</h1>

        <p>Запустить сценарий можно командой <tt
         class="USERINPUT"><strong>sh scriptname</strong></tt> <a
         name="AEN253"
         href="#c178_html_FTN_AEN253"><span
         class="footnote">[5]</span></a> или <tt
         class="USERINPUT"><strong>bash scriptname</strong></tt>. (Не
        рекомендуется запуск сценария командой <tt
         class="USERINPUT"><strong>sh &lt;scriptname&gt;</strong></tt>,
        поскольку это запрещает использование устройства стандартного
        ввода <tt
         class="FILENAME">stdin</tt> в скрипте). Более удобный вариант
        -- сделать файл скрипта исполняемым, командой <a
         href="#c6407_html_CHMODREF">chmod</a>.</p>

        <div
         class="VARIABLELIST">
          <dl>
            <dt>Это:</dt>

            <dd>
              <p><tt
               class="USERINPUT"><strong>chmod 555
              scriptname</strong></tt> (выдача прав на
              чтение/исполнение любому пользователю в системе) <a
               name="AEN266"
               href="#c178_html_FTN_AEN266"><span
               class="footnote">[6]</span></a></p>
            </dd>

            <dt>или</dt>

            <dd>
              <p><tt
               class="USERINPUT"><strong>chmod +rx
              scriptname</strong></tt> (выдача прав на
              чтение/исполнение любому пользователю в системе)</p>

              <p><tt
               class="USERINPUT"><strong>chmod u+rx
              scriptname</strong></tt> (выдача прав на
              чтение/исполнение только &quot;владельцу&quot;
              скрипта)</p>
            </dd>
          </dl>
        </div>
        <br>
        <br>

        <p>После того, как вы сделаете файл сценария исполняемым, вы
        можете запустить его примерно такой командой <tt
         class="USERINPUT"><strong>./scriptname</strong></tt>. <a
         name="AEN278"
         href="#c178_html_FTN_AEN278"><span
         class="footnote">[7]</span></a> Если, при этом, текст сценария
        начинается с корректной сигнатуры (<span
         class="QUOTE">&quot;sha-bang&quot;</span>), то для его
        исполнения будет вызван соответствующий интерпретатор.</p>

        <p>И наконец, завершив отладку сценария, вы можете поместить
        его в каталог <tt
         class="FILENAME">/usr/local/bin</tt> (естественно, что для
        этого вы должны обладать правами root), чтобы сделать его
        доступным для себя и других пользователей системы. После этого
        сценарий можно вызвать, просто напечатав название файла в
        командной строке и нажав клавишу <strong
         class="KEYCAP">[ENTER]</strong>.</p>
      </div>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN199"
         href="#c178_html_AEN199"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Некоторые разновидности UNIX (основанные на 4.2BSD)
          требуют, чтобы эта последовательность состояла из 4-х байт,
          за счет добавления пробела после <span
           class="TOKEN">!</span>, <tt
           class="USERINPUT"><strong>#! /bin/sh</strong></tt>.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN207"
         href="#c178_html_AEN207"><span
         class="footnote">[2]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>В shell-скриптах последовательность <span
           class="TOKEN">#!</span> должна стоять самой первой и задает
          интерпретатор (<strong
           class="COMMAND">sh</strong> или <strong
           class="COMMAND">bash</strong>). Интерпретатор, в свою
          очередь, воспринимает эту строку как комментарий, поскольку
          она начинается с символа <span
           class="TOKEN">#</span>.</p>

          <p>Если в сценарии имеются еще такие же строки, то они
          воспринимаются как обычный комментарий.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

echo &quot;Первая часть сценария.&quot;
a=1

#!/bin/bash
# Это *НЕ* означает запуск нового сценария.

echo &quot;Вторая часть сценария.&quot;
echo $a  # Значение переменной $a осталось равно 1.
</pre>
          <br>
          <br>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN220"
         href="#c178_html_AEN220"><span
         class="footnote">[3]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Эта особенность позволяет использовать различные
          хитрости.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/rm
# Самоуничтожающийся сценарий.

# Этот скрипт ничего не делает -- только уничтожает себя.

WHATEVER=65

echo &quot;Эта строка никогда не будет напечатана.&quot;

exit $WHATEVER  # Не имеет смысла, поскольку работа сценария завершается не здесь.
</pre>
          <br>
          <br>

          <p>Попробуйте запустить файл <tt
           class="FILENAME">README</tt> с сигнатурой <tt
           class="USERINPUT"><strong>#!/bin/more</strong></tt>
          (предварительно не забудьте сделать его исполняемым).</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN230"
         href="#c178_html_AEN230"><span
         class="footnote">[4]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p><span
           class="strong"><strong
           class="EMPHASIS">P</strong></span>ortable <span
           class="strong"><strong
           class="EMPHASIS">O</strong></span>perating <span
           class="strong"><strong
           class="EMPHASIS">S</strong></span>ystem <span
           class="bold"><strong
           class="EMPHASIS">I</strong></span>nterface, попытка
          стандартизации UNI<span
           class="strong"><strong
           class="EMPHASIS">X</strong></span>-подобных операционных
          систем.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN253"
         href="#c178_html_AEN253"><span
         class="footnote">[5]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Внимание: вызов Bash-скрипта с помощью команды <tt
           class="USERINPUT"><strong>sh scriptname</strong></tt>
          отключает специфичные для Bash расширения, что может привести
          к появлению ошибки и аварийному завершению работы
          сценария.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN266"
         href="#c178_html_AEN266"><span
         class="footnote">[6]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Сценарий должен иметь как право на исполнение, так и право
          на <span
           class="emphasis"><em
           class="EMPHASIS">чтение</em></span>, поскольку shell должен
          иметь возможность прочитать скрипт.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN278"
         href="#c178_html_AEN278"><span
         class="footnote">[7]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Почему бы не запустить сценарий просто набрав название
          файла <tt
           class="USERINPUT"><strong>scriptname</strong></tt>, если
          сценарий находится в текущем каталоге? Дело в том, что из
          соображений безопасности, путь к текущему каталогу <span
           class="QUOTE">&quot;.&quot;</span> не включен в переменную
          окружения <a
           href="#c3270_html_PATHREF">$PATH</a>. Поэтому необходимо явно
          указывать путь к текущему каталогу, в котором находится
          сценарий, т.е. <tt
           class="USERINPUT"><strong>./scriptname</strong></tt>.</p>
        </td>
      </tr>
    </table>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#c118_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x288_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Зачем необходимо знание языка Shell?</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#p112_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Упражнения</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="c1833_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x1716_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#c2105_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="CHAPTER">
      <h1><a
       name="c1833_html_QUOTING"></a>Глава 5. Кавычки</h1>

      <p><a
       name="c1833_html_QUOTINGREF"></a></p>

      <p>Кавычки, ограничивающие строки с обеих сторон, служат для
      предотвращения интерпретации специальных символов, которые могут
      находиться в строке. (Символ называется &quot;специальным&quot;,
      если он несет дополнительную смысловую нагрузку, например символ
      <span
       class="TOKEN">шаблона</span> -- <span
       class="TOKEN">*</span>.)</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ls -l [Vv]*</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">-rw-rw-r--    1 bozo  bozo       324 Apr  2 15:05 VIEWDATA.BAT
 -rw-rw-r--    1 bozo  bozo       507 May  4 14:25 vartrace.sh
 -rw-rw-r--    1 bozo  bozo       539 Apr 14 17:11 viewdata.sh</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ls -l &#39;[Vv]*&#39;</strong></tt>
<tt
 class="COMPUTEROUTPUT">ls: [Vv]*: No such file or directory</tt>
</pre>
      <br>
      <br>

      <div
       class="NOTE">
        <table
         class="NOTE"
         width="100%"
         border="0">
          <tr>
            <td
             width="25"
             align="center"
             valign="top"><img
             src="misc/abs-book/images/note.gif"
             hspace="5"
             alt="Note"></td>

            <td
             align="left"
             valign="top">
              <p>Некоторые программы и утилиты могут вызываться с
              дополнительными параметрами, содержащими специальными
              символы, поэтому очень важно предотвратить интерпретацию
              передаваемых параметров командной оболочкой, позволяя
              сделать это вызываемой программой.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>grep &#39;[Пп]ервая&#39; *.txt</strong></tt>
<tt
 class="COMPUTEROUTPUT">file1.txt:Это первая строка в file1.txt.
 file2.txt:Это Первая строка в file2.txt.</tt>
</pre>
              <br>
              <br>

              <p>Примечательно, что &quot;не окавыченный&quot; вариант
              команды <tt
               class="USERINPUT"><strong>grep [Пп]ервая
              *.txt</strong></tt> будет правильно исполняться в Bash,
              но не в <strong
               class="COMMAND">tcsh</strong>.</p>
            </td>
          </tr>
        </table>
      </div>

      <p>Вообще, желательно использовать двойные кавычки (<span
       class="TOKEN">&quot; &quot;</span>) при обращении к переменным.
      Это предотвратит интерпретацию специальных символов, которые
      могут содержаться в именах переменных, за исключением <span
       class="TOKEN">$</span>, <span
       class="TOKEN">`</span> (обратная кавычка) и <span
       class="TOKEN">\</span> (escape -- обратный слэш). <a
       name="AEN1882"
       href="#c1833_html_FTN_AEN1882"><span
       class="footnote">[1]</span></a> То, что символ <span
       class="TOKEN">$</span> попал в разряд исключений, позволяет
      выполнять обращение к переменным внутри строк, ограниченных
      двойными кавычками (<tt
       class="REPLACEABLE"><em>&quot;$variable&quot;</em></tt>), т.е.
      выполнять подстановку значений переменных (см. <a
       href="#c1613_html_EX9">Пример 4-1</a>, выше).</p>

      <p>Двойные кавычки могут быть использованы для предотвращения
      разбиения строки на слова. <a
       name="AEN1906"
       href="#c1833_html_FTN_AEN1906"><span
       class="footnote">[2]</span></a> Заключение строки в кавычки
      приводит к тому, что она передается как один аргумент, даже если
      она содержит <a
       href="#c301_html_WHITESPACEREF">пробельные символы</a> -
      разделители.</p>
<pre
 class="PROGRAMLISTING">
variable1=&quot;a variable containing five words&quot;
COMMAND This is $variable1    # Исполнение COMMAND с 7 входными аргументами:
# &quot;This&quot; &quot;is&quot; &quot;a&quot; &quot;variable&quot; &quot;containing&quot; &quot;five&quot; &quot;words&quot;

COMMAND &quot;This is $variable1&quot;  # Исполнение COMMAND с одним входным аргументом:
# &quot;This is a variable containing five words&quot;


variable2=&quot;&quot;    # Пустая переменная.

COMMAND $variable2 $variable2 $variable2        # Исполнение COMMAND без аргументов.
COMMAND &quot;$variable2&quot; &quot;$variable2&quot; &quot;$variable2&quot;  # Исполнение COMMAND с 3 &quot;пустыми&quot; аргументами.
COMMAND &quot;$variable2 $variable2 $variable2&quot;      # Исполнение COMMAND с 1 аргументом (и 2 пробелами).

# Спасибо S.C.
</pre>
      <br>
      <br>

      <div
       class="TIP">
        <table
         class="TIP"
         width="100%"
         border="0">
          <tr>
            <td
             width="25"
             align="center"
             valign="top"><img
             src="misc/abs-book/images/tip.gif"
             hspace="5"
             alt="Tip"></td>

            <td
             align="left"
             valign="top">
              <p>Заключение в кавычки аргументов команды <strong
               class="COMMAND">echo</strong> необходимо только в том
              случае, когда разбиение на отдельные слова сопряжено с
              определенными трудностями.</p>
            </td>
          </tr>
        </table>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="c1833_html_WEIRDVARS"></a>

        <p><strong>Пример 5-1. Вывод &quot;причудливых&quot;
        переменных</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# weirdvars.sh: Вывод &quot;причудливых&quot; переменных

var=&quot;&#39;(]\\{}\$\&quot;&quot;
echo $var        # &#39;(]\{}$&quot;
echo &quot;$var&quot;      # &#39;(]\{}$&quot;     Никаких различий.

echo

IFS=&#39;\&#39;
echo $var        # &#39;(] {}$&quot;     \ символ-разделитель преобразован в пробел.
echo &quot;$var&quot;      # &#39;(]\{}$&quot;

# Примеры выше предоставлены S.C.

exit 0
</pre>
      </div>

      <p>Одиночные кавычки (<span
       class="TOKEN">&#39; &#39;</span>) схожи по своему действию с
      двойными кавычками, только не допускают обращение к переменным,
      поскольку специальный символ &quot;$&quot; внутри одинарных
      кавычек воспринимается как обычный символ. Внутри одиночных
      кавычек, <span
       class="emphasis"><em
       class="EMPHASIS">любой</em></span> специальный символ, за
      исключением <span
       class="TOKEN">&#39;</span>, интерпретируется как простой символ.
      Одиночные кавычки (<span
       class="QUOTE">&quot;строгие, или полные кавычки&quot;</span>)
      следует рассматривать как более строгий вариант чем двойные
      кавычки (<span
       class="QUOTE">&quot;нестрогие, или неполные
      кавычки&quot;</span>).</p>

      <div
       class="NOTE">
        <table
         class="NOTE"
         width="100%"
         border="0">
          <tr>
            <td
             width="25"
             align="center"
             valign="top"><img
             src="misc/abs-book/images/note.gif"
             hspace="5"
             alt="Note"></td>

            <td
             align="left"
             valign="top">
              <p>Поскольку внутри одиночных кавычек даже экранирующий
              (<span
               class="TOKEN">\</span>) символ воспринимается как
              обычный символ, попытка вывести одиночную кавычку внутри
              строки, ограниченной одинарными кавычками, не даст
              желаемого результата.</p>
<pre
 class="PROGRAMLISTING">
echo &quot;Why can&#39;t I write &#39;s between single quotes&quot;

echo

# Обходной метод.
echo &#39;Why can&#39;\&#39;&#39;t I write &#39;&quot;&#39;&quot;&#39;s between single quotes&#39;
#    |-------|  |----------|   |-----------------------|
# Три строки, ограниченных одинарными кавычками,
# и экранированные одиночные кавычки между ними.

# Пример любезно предоставлен Stephane Chazelas.
</pre>
              <br>
              <br>
            </td>
          </tr>
        </table>
      </div>

      <p><a
       name="c1833_html_ESCP"></a><em
       class="FIRSTTERM">Экранирование</em> -- это способ заключения в
      кавычки одиночного символа. Экранирующий (<span
       class="TOKEN">escape</span>) символ (<span
       class="TOKEN">\</span>) сообщает интерпретатору, что следующий
      за ним символ должен восприниматься как обычный символ.</p>

      <div
       class="CAUTION">
        <table
         class="CAUTION"
         width="100%"
         border="0">
          <tr>
            <td
             width="25"
             align="center"
             valign="top"><img
             src="misc/abs-book/images/caution.gif"
             hspace="5"
             alt="Caution"></td>

            <td
             align="left"
             valign="top">
              <p>С отдельными командами и утилитами, такими как <a
               href="#c5358_html_ECHOREF">echo</a> и <a
               href="#a14586_html_SEDREF">sed</a>, экранирующий символ
              может применяться для получения обратного эффекта - когда
              обычные символы при экранировании приобретают специальное
              значение.</p>
            </td>
          </tr>
        </table>
      </div>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="c1833_html_SPM"></a>Специальное назначение некоторых экранированных
        символов</strong></p>

        <dl>
          <dt>используемых совместно с <strong
           class="COMMAND">echo</strong> и <strong
           class="COMMAND">sed</strong></dt>

          <dt><span
           class="TOKEN">\n</span></dt>

          <dd>
            <p>перевод строки (новая строка)</p>
          </dd>

          <dt><span
           class="TOKEN">\r</span></dt>

          <dd>
            <p>перевод каретки</p>
          </dd>

          <dt><span
           class="TOKEN">\t</span></dt>

          <dd>
            <p>табуляция</p>
          </dd>

          <dt><span
           class="TOKEN">\v</span></dt>

          <dd>
            <p>вертикальная табуляция</p>
          </dd>

          <dt><span
           class="TOKEN">\b</span></dt>

          <dd>
            <p>забой (backspace)</p>
          </dd>

          <dt><span
           class="TOKEN">\a</span></dt>

          <dd>
            <p><span
             class="QUOTE">&quot;звонок&quot;</span> (сигнал)</p>
          </dd>

          <dt><span
           class="TOKEN">\0xx</span></dt>

          <dd>
            <p>ASCII-символ с кодом <tt
             class="REPLACEABLE"><em>0xx</em></tt> в восьмеричном
            виде)</p>

            <div
             class="EXAMPLE">
              <a
               name="c1833_html_ESCAPED"></a>

              <p><strong>Пример 5-2. Экранированные
              символы</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# escaped.sh: экранированные символы

echo; echo

echo &quot;\v\v\v\v&quot;      # Вывод последовательности символов \v\v\v\v.
# Для вывода экранированных символов следует использовать ключ -e.
echo &quot;=============&quot;
echo &quot;ВЕРТИКАЛЬНАЯ ТАБУЛЯЦИЯ&quot;
echo -e &quot;\v\v\v\v&quot;   # Вывод 4-х вертикальных табуляций.
echo &quot;==============&quot;

echo &quot;КАВЫЧКИ&quot;
echo -e &quot;\042&quot;       # Выводит символ &quot; (кавычки с восьмеричным кодом ASCII 42).
echo &quot;==============&quot;

# Конструкция $&#39;\X&#39; делает использование ключа -e необязательным.
echo; echo &quot;НОВАЯ СТРОКА И ЗВОНОК&quot;
echo $&#39;\n&#39;           # Перевод строки.
echo $&#39;\a&#39;           # Звонок (сигнал).

echo &quot;===============&quot;
echo &quot;КАВЫЧКИ&quot;
# Bash версии 2 и выше допускает использование конструкции $&#39;\nnn&#39;.
# Обратите внимание: здесь под &#39;\nnn&#39; подразумевается восьмеричное значение.
echo $&#39;\t \042 \t&#39;   # Кавычки (&quot;) окруженные табуляцией.

# В конструкции $&#39;\xhhh&#39; допускается использовать и шестнадцатеричные значения.
echo $&#39;\t \x22 \t&#39;  # Кавычки (&quot;) окруженные табуляцией.
# Спасибо Greg Keraunen, за это примечание.
# Ранние версии Bash допускали употребление конструкции в виде &#39;\x022&#39;.
echo &quot;===============&quot;
echo


# Запись ASCII-символов в переменную.
# ----------------------------------------
quote=$&#39;\042&#39;        # запись символа &quot; в переменную.
echo &quot;$quote Эта часть строки ограничена кавычками, $quote а эта -- нет.&quot;

echo

# Конкатенация ASCII-символов в переменную.
triple_underline=$&#39;\137\137\137&#39;  # 137 -- это восьмеричный код символа &#39;_&#39;.
echo &quot;$triple_underline ПОДЧЕРКИВАНИЕ $triple_underline&quot;

echo

ABC=$&#39;\101\102\103\010&#39;           # 101, 102, 103 это  A, B и C соответственно.
echo $ABC

echo; echo

escape=$&#39;\033&#39;                    # 033 -- восьмеричный код экранирующего символа.
echo &quot;\&quot;escape\&quot; выводится как $escape&quot;
#                                   вывод отсутствует.

echo; echo

exit 0
</pre>
            </div>

            <p>Еще один пример использования конструкции <tt
             class="USERINPUT"><strong>$&#39; &#39;</strong></tt> вы
            найдете в <a
             href="#c13936_html_EX77">Пример 34-1</a>.</p>
          </dd>

          <dt><span
           class="TOKEN">\&quot;</span></dt>

          <dd>
            <p>кавычки</p>
<pre
 class="PROGRAMLISTING">
echo &quot;Привет&quot;                    # Привет
echo &quot;Он сказал: \&quot;Привет\&quot;.&quot;    # Он сказал: &quot;Привет&quot;.
</pre>
            <br>
            <br>
          </dd>

          <dt><span
           class="TOKEN">\$</span></dt>

          <dd>
            <p>символ доллара (если за комбинацией символов \$ следует
            имя переменной, то она не будет разыменована)</p>
<pre
 class="PROGRAMLISTING">
echo &quot;\$variable01&quot;  # выведет $variable01
</pre>
            <br>
            <br>
          </dd>

          <dt><span
           class="TOKEN">\\</span></dt>

          <dd>
            <p>обратный слэш</p>
<pre
 class="PROGRAMLISTING">
echo &quot;\\&quot;  # выведет \
</pre>
            <br>
            <br>
          </dd>
        </dl>
      </div>

      <div
       class="NOTE">
        <table
         class="NOTE"
         width="100%"
         border="0">
          <tr>
            <td
             width="25"
             align="center"
             valign="top"><img
             src="misc/abs-book/images/note.gif"
             hspace="5"
             alt="Note"></td>

            <td
             align="left"
             valign="top">
              <p>Поведение символа <span
               class="TOKEN">\</span> сильно зависит от того
              экранирован ли он, ограничен ли кавычками или находится
              внутри конструкции <a
               href="#c11441_html_COMMANDSUBREF">подстановки команды</a>
              или во <a
               href="#c11785_html_HEREDOCREF">вложенном
              документе</a>.</p>
<pre
 class="PROGRAMLISTING">
                      #  Простое экранирование и кавычки
echo \z               #  z
echo \\z              # \z
echo &#39;\z&#39;             # \z
echo &#39;\\z&#39;            # \\z
echo &quot;\z&quot;             # \z
echo &quot;\\z&quot;            # \z

                      #  Подстановка команды
echo `echo \z`        #  z
echo `echo \\z`       #  z
echo `echo \\\z`      # \z
echo `echo \\\\z`     # \z
echo `echo \\\\\\z`   # \z
echo `echo \\\\\\\z`  # \\z
echo `echo &quot;\z&quot;`      # \z
echo `echo &quot;\\z&quot;`     # \z

                      # Встроенный документ
cat &lt;&lt;EOF
\z
EOF                   # \z

cat &lt;&lt;EOF
\\z
EOF                   # \z

# Эти примеры предоставил Stephane Chazelas.
</pre>
              <br>
              <br>

              <p>Отдельные символы в строке, которая записывается в
              переменную, могут быть экранированы, исключение
              составляет сам экранирующий символ.</p>
<pre
 class="PROGRAMLISTING">
variable=\
echo &quot;$variable&quot;
# Не работает - дает сообщение об ошибке:
# test.sh: : command not found
# В &quot;чистом&quot; виде экранирующий (escape) символ не может быть записан в переменную.
#
#  Фактически, в данном примере, происходит экранирование символа перевода строки
#+ в результате получается такая команда:   variable=echo &quot;$variable&quot;
#+                                          ошибочное присваивание

variable=\
23skidoo
echo &quot;$variable&quot;    #  23skidoo
                    #  Здесь все в порядке, поскольку вторая строка
                    #+ является нормальным, с точки зрения присваивания, выражением.

variable=\
#        \^    За escape-символом следует пробел
echo &quot;$variable&quot;        # пробел

variable=\\
echo &quot;$variable&quot;        # \

variable=\\\
echo &quot;$variable&quot;
# Не работает - сообщение об ошибке:
# test.sh: \: command not found
#
#  Первый escape-символ экранирует второй, а третий оказывается неэкранированным,
#+ результат тот же, что и в первом примере.

variable=\\\\
echo &quot;$variable&quot;        # \\
                        # Второй и четвертый escape-символы экранированы.
                        # Это нормально.
</pre>
              <br>
              <br>
            </td>
          </tr>
        </table>
      </div>

      <p>Экранирование пробелов предотвращает разбиение списка
      аргументов командной строки на отдельные аргументы.</p>
<pre
 class="PROGRAMLISTING">
file_list=&quot;/bin/cat /bin/gzip /bin/more /usr/bin/less /usr/bin/emacs-20.7&quot;
# Список файлов как аргумент(ы) командной строки.

# Добавить два файла в список и вывести список.
ls -l /usr/X11R6/bin/xsetroot /sbin/dump $file_list

echo &quot;-------------------------------------------------------------------------&quot;

# Что произойдет, если экранировать пробелы в списке?
ls -l /usr/X11R6/bin/xsetroot\ /sbin/dump\ $file_list
# Ошибка: первые три файла будут &quot;слиты&quot; воедино
# и переданы команде &#39;ls -l&#39; как один аргумент
# потому что два пробела, разделяющие аргументы (слова) -- экранированы.
</pre>
      <br>
      <br>

      <p>Кроме того, <span
       class="TOKEN">escape</span>-символ позволяет писать
      многострочные команды. Обычно, каждая команда занимает одну
      строку, но <span
       class="TOKEN">escape</span>-символ позволяет <span
       class="emphasis"><em
       class="EMPHASIS">экранировать символ перевода
      строки</em></span>, в результате чего одна команда может занимать
      несколько строк.</p>
<pre
 class="PROGRAMLISTING">
(cd /source/directory &amp;&amp; tar cf - . ) | \
(cd /dest/directory &amp;&amp; tar xpvf -)
# Команда копирования дерева каталогов.
# Разбита на две строки для большей удобочитаемости.

# Альтернативный вариант:
tar cf - -C /source/directory . |
tar xpvf - -C /dest/directory
# См. примечание ниже.
# (Спасибо Stephane Chazelas.)
</pre>

      <div
       class="NOTE">
        <table
         class="NOTE"
         width="100%"
         border="0">
          <tr>
            <td
             width="25"
             align="center"
             valign="top"><img
             src="misc/abs-book/images/note.gif"
             hspace="5"
             alt="Note"></td>

            <td
             align="left"
             valign="top">
              <p>Если строка сценария заканчивается символом создания
              конвейера <span
               class="TOKEN">|</span>, то необходимость в применении
              символа <span
               class="TOKEN">\</span>, для экранирования перевода
              строки, отпадает. Тем не менее, считается хорошим тоном,
              всегда использовать символ &quot;\&quot; в конце
              промежуточных строк многострочных команд.</p>
            </td>
          </tr>
        </table>
      </div>
      <br>
      <br>
<pre
 class="PROGRAMLISTING">
echo &quot;foo
bar&quot;
#foo
#bar

echo

echo &#39;foo
bar&#39;    # Никаких различий.
#foo
#bar

echo

echo foo\
bar     # Перевод строки экранирован.
#foobar

echo

echo &quot;foo\
bar&quot;     # Внутри &quot;нестрогих&quot; кавычек символ &quot;\&quot; интерпретируется как экранирующий.
#foobar

echo

echo &#39;foo\
bar&#39;     # В &quot;строгих&quot; кавычках обратный слэш воспринимается как обычный символ.
#foo\
#bar

# Примеры предложены Stephane Chazelas.
</pre>
      <br>
      <br>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN1882"
         href="#c1833_html_AEN1882"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Символ <span
           class="QUOTE">&quot;!&quot;</span>, помещенный в двойные
          кавычки, порождает сообщение об ошибке, если команда вводится
          <span
           class="emphasis"><em
           class="EMPHASIS">с командной строки</em></span>. Вероятно
          это связано с тем, что этот символ интерпретируется как
          попытка обращения к <a
           href="#a15070_html">истории команд</a>. Однако внутри
          сценариев такой прием проблем не вызывает.</p>

          <p>Не менее любопытно поведение символа <span
           class="QUOTE">&quot;\&quot;</span>, употребляемого внутри
          двойных кавычек.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo hello\!</strong></tt>
<tt
 class="COMPUTEROUTPUT">hello!</tt>



<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo &quot;hello\!&quot;</strong></tt>
<tt
 class="COMPUTEROUTPUT">hello\!</tt>



<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo -e x\ty</strong></tt>
<tt
 class="COMPUTEROUTPUT">xty</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo -e &quot;x\ty&quot;</strong></tt>
<tt
 class="COMPUTEROUTPUT">x       y</tt>
             
</pre>
          (Спасибо Wayne Pollock за пояснения.) <br>
          <br>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN1906"
         href="#c1833_html_AEN1906"><span
         class="footnote">[2]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p><span
           class="QUOTE">&quot;Разбиение на слова&quot;</span>, в
          данном случае это означает разделение строки символов на
          некоторое число аргументов.</p>
        </td>
      </tr>
    </table>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x1716_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#c2105_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Специальные типы переменных</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#p299_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Завершение и код завершения</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="c2105_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#c1833_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#c2171_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="CHAPTER">
      <h1><a
       name="c2105_html_EXIT-STATUS"></a>Глава 6. Завершение и код завершения</h1>

      <table
       border="0"
       width="100%"
       cellspacing="0"
       cellpadding="0"
       class="EPIGRAPH">
        <tr>
          <td
           width="45%"> </td>

          <td
           width="45%"
           align="left"
           valign="top">
            <p><em>...эта часть Bourne shell покрыта мраком, тем не
            менее все пользуются ею.</em></p>
          </td>
        </tr>

        <tr>
          <td
           width="45%"> </td>

          <td
           width="45%"
           align="right"
           valign="top"><em><span
           class="ATTRIBUTION">Chet Ramey</span></em></td>
        </tr>
      </table>

      <p><a
       name="c2105_html_EXITCOMMANDREF"></a>Команда <strong
       class="COMMAND">exit</strong> может использоваться для
      завершения работы сценария, точно так же как и в программах на
      языке C. Кроме того, она может возвращать некоторое значение,
      которое может быть проанализировано вызывающим процессом.</p>

      <p><a
       name="c2105_html_EXITSTATUSREF"></a>Каждая команда возвращает <em
       class="FIRSTTERM">код завершения</em> (иногда код завершения
      называют <em
       class="FIRSTTERM">возвращаемым значением</em> ). В случае успеха
      команда должна возвращать <span
       class="RETURNVALUE">0</span>, а в случае ошибки -- <span
       class="RETURNVALUE">ненулевое</span> значение, которое, как
      правило, интерпретируется как код ошибки. Практически все команды
      и утилиты UNIX возвращают <span
       class="RETURNVALUE">0</span> в случае успешного завершения, но
      имеются и исключения из правил.</p>

      <p>Аналогичным образом ведут себя функции, расположенные внутри
      сценария, и сам сценарий, возвращая код завершения. Код,
      возвращаемый функцией или сценарием, определяется кодом возврата
      последней команды. Команде <tt
       class="USERINPUT"><strong>exit</strong></tt> можно явно указать
      код возврата, в виде: <tt
       class="USERINPUT"><strong>exit</strong></tt> <span
       class="RETURNVALUE"><tt
       class="REPLACEABLE"><em>nnn</em></tt></span>, где <span
       class="RETURNVALUE"><tt
       class="REPLACEABLE"><em>nnn</em></tt></span> -- это код возврата
      (число в диапазоне <span
       class="RETURNVALUE">0</span> - <span
       class="RETURNVALUE">255</span>).</p>

      <div
       class="NOTE">
        <table
         class="NOTE"
         width="100%"
         border="0">
          <tr>
            <td
             width="25"
             align="center"
             valign="top"><img
             src="misc/abs-book/images/note.gif"
             hspace="5"
             alt="Note"></td>

            <td
             align="left"
             valign="top">
              <p>Когда работа сценария завершается командой <strong
               class="COMMAND">exit</strong> без параметров, то код
              возврата сценария определяется кодом возврата последней
              исполненной командой.</p>
            </td>
          </tr>
        </table>
      </div>

      <p><a
       name="c2105_html_EXSREF"></a></p>

      <p>Код возврата последней команды хранится в специальной
      переменной <tt
       class="VARNAME">$?</tt>. После исполнения кода функции,
      переменная <tt
       class="VARNAME">$?</tt> хранит код завершения последней команды,
      исполненной в функции. Таким способом в Bash передается <span
       class="QUOTE">&quot;значение, возвращаемое&quot;</span>
      функцией. После завершения работы сценария, код возврата можно
      получить, обратившись из командной строки к переменной <tt
       class="VARNAME">$?</tt>, т.е. это будет код возврата последней
      команды, исполненной в сценарии.</p>

      <div
       class="EXAMPLE">
        <a
         name="c2105_html_EX5"></a>

        <p><strong>Пример 6-1. завершение / код завершения</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

echo hello
echo $?    # код возврата = 0, поскольку команда выполнилась успешно.

lskdf      # Несуществующая команда.
echo $?    # Ненулевой код возврата, поскольку команду выполнить не удалось.

echo

exit 113   # Явное указание кода возврата 113.
           # Проверить можно, если набрать в командной строке &quot;echo $?&quot;
           # после выполнения этого примера.

#  В соответствии с соглашениями, &#39;exit 0&#39; указывает на успешное завершение,
#+ в то время как ненулевое значение означает ошибку.
</pre>
      </div>

      <p>Переменная <a
       href="#c3270_html_XSTATVARREF">$?</a> особенно полезна, когда
      необходимо проверить результат исполнения команды (см. <a
       href="#x7794_html_FILECOMP">Пример 12-27</a> и <a
       href="#x7050_html_LOOKUP">Пример 12-13</a>).</p>

      <div
       class="NOTE">
        <table
         class="NOTE"
         width="100%"
         border="0">
          <tr>
            <td
             width="25"
             align="center"
             valign="top"><img
             src="misc/abs-book/images/note.gif"
             hspace="5"
             alt="Note"></td>

            <td
             align="left"
             valign="top">
              <p>Символ <a
               href="#c301_html_NOTREF">!</a>, может выступать как
              логическое &quot;НЕ&quot; для инверсии <a
               href="#c2105_html_EXITSTATUSREF">кода возврата</a>.</p>

              <div
               class="EXAMPLE">
                <a
                 name="c2105_html_NEGCOND"></a>

                <p><strong>Пример 6-2. Использование символа <span
                 class="TOKEN">!</span> для логической инверсии кода
                возврата</strong></p>
<pre
 class="PROGRAMLISTING">
true  # встроенная команда &quot;true&quot;.
echo &quot;код возврата команды \&quot;true\&quot; = $?&quot;     # 0

! true
echo &quot;код возврата команды \&quot;! true\&quot; = $?&quot;   # 1
# Обратите внимание: символ &quot;!&quot; от команды необходимо отделять пробелом.
#    !true   вызовет сообщение об ошибке &quot;command not found&quot;

# Спасибо S.C.
</pre>
              </div>
              <br>
              <br>
            </td>
          </tr>
        </table>
      </div>

      <div
       class="CAUTION">
        <table
         class="CAUTION"
         width="100%"
         border="0">
          <tr>
            <td
             width="25"
             align="center"
             valign="top"><img
             src="misc/abs-book/images/caution.gif"
             hspace="5"
             alt="Caution"></td>

            <td
             align="left"
             valign="top">
              <p>В отдельных случаях коды возврата должны иметь <a
               href="#a14876_html_EXITCODESREF">предопределенные
              значения</a> и не должны задаваться пользователем.</p>
            </td>
          </tr>
        </table>
      </div>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#c1833_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#c2171_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Кавычки</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#p299_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Проверка условий</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="c2171_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#c2105_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x2389_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="CHAPTER">
      <h1><a
       name="c2171_html_TESTS"></a>Глава 7. Проверка условий</h1>

      <p><a
       name="c2171_html_IFTHEN"></a></p>

      <p>практически любой язык программирования включает в себя
      условные операторы, предназначенные для проверки условий, чтобы
      выбрать тот или иной путь развития событий в зависимости от этих
      условий. В Bash, для проверки условий, имеется команда <strong
       class="COMMAND">test</strong>, различного вида скобочные
      операторы и условный оператор <strong
       class="COMMAND">if/then</strong>.</p>

      <div
       class="SECT1">
        <h1
         class="SECT1"><a
         name="c2171_html_TESTCONSTRUCTS"></a>7.1. Конструкции проверки
        условий</h1>

        <p><a
         name="c2171_html_TESTCONSTRUCTS1"></a></p>

        <ul>
          <li>
            <p>Оператор <strong
             class="COMMAND">if/then</strong> проверяет -- является ли
            <a
             href="#c2105_html_EXITSTATUSREF">код завершения</a> списка
            команд <span
             class="RETURNVALUE">0</span> (поскольку 0 означает <span
             class="QUOTE">&quot;успех&quot;</span>), и если это так,
            то выполняет одну, или более, команд, следующие за словом
            then.</p>
          </li>

          <li>
            <p>Существует специальная команда -- <strong
             class="COMMAND">[</strong> (<a
             href="#c301_html_LEFTBRACKET">левая квадратная скобка</a>).
            Она является синонимом команды <strong
             class="COMMAND">test</strong>, и является <a
             href="#c5358_html_BUILTINREF">встроенной</a> командой (т.е.
            более эффективной, в смысле производительности). Эта
            команда воспринимает свои аргументы как выражение сравнения
            или как файловую проверку и возвращает код завершения в
            соответствии с результатами проверки (0 -- истина, 1 --
            ложь).</p>
          </li>

          <li>
            <p>Начиная с версии 2.02, Bash предоставляет в распоряжение
            программиста конструкцию <a
             href="#c2171_html_DBLBRACKETS">[[ ... ]]</a> <span
             class="emphasis"><em
             class="EMPHASIS">расширенный вариант команды
            test</em></span>, которая выполняет сравнение способом
            более знакомым программистам, пишущим на других языках
            программирования. Обратите внимание: <strong
             class="COMMAND">[[</strong> -- это <a
             href="#c5358_html_KEYWORDREF">зарезервированное слово</a>,
            а не команда.</p>

            <p>Bash исполняет <tt
             class="USERINPUT"><strong>[[ $a -lt $b ]]</strong></tt>
            как один элемент, который имеет код возврата.</p>

            <p>Круглые скобки <a
             href="#x4862_html">(( ... ))</a> и предложение <a
             href="#c5358_html_LETREF">let ...</a> так же возвращают код
            <span
             class="RETURNVALUE">0</span>, если результатом
            арифметического выражения является ненулевое значение.
            Таким образом, <a
             href="#c11565_html_ARITHEXPREF">арифметические
            выражения</a> могут учавствовать в операциях сравнения.</p>
<pre
 class="PROGRAMLISTING">
Предложение let &quot;1&lt;2&quot; возвращает 0 (так как результат сравнения &quot;1&lt;2&quot; -- &quot;1&quot;, или &quot;истина&quot;)
(( 0 &amp;&amp; 1 )) возвращает 1 (так как результат операции &quot;0 &amp;&amp; 1&quot; -- &quot;0&quot;, или &quot;ложь&quot;)
</pre>
            <br>
            <br>
          </li>

          <li>
            <p>Условный оператор <strong
             class="COMMAND">if</strong> проверяет код завершения любой
            команды, а не только результат выражения, заключенного в
            квадратные скобки.</p>
<pre
 class="PROGRAMLISTING">
if cmp a b &amp;&gt; /dev/null  # Подавление вывода.
then echo &quot;Файлы a и b идентичны.&quot;
else echo &quot;Файлы a и b имеют различия.&quot;
fi

if grep -q Bash file
then echo &quot;Файл содержит, как минимум, одно слово Bash.&quot;
fi

if COMMAND_WHOSE_EXIT_STATUS_IS_0_UNLESS_ERROR_OCCURRED
then echo &quot;Команда выполнена успешно.&quot;
else echo &quot;Обнаружена ошибка при выполнении команды.&quot;
fi
</pre>
            <br>
            <br>
          </li>

          <li>
            <p>Оператор <strong
             class="COMMAND">if/then</strong> допускает наличие
            вложенных проверок.</p>
<pre
 class="PROGRAMLISTING">
if echo &quot;Следующий *if* находится внутри первого *if*.&quot;

  if [[ $comparison = &quot;integer&quot; ]]
    then (( a &lt; b ))
  else
    [[ $a &lt; $b ]]
  fi

then
  echo &#39;$a меньше $b&#39;
fi
</pre>
            <br>
            <br>

            <p><span
             class="emphasis"><em
             class="EMPHASIS">Это детальное описание конструкции <span
             class="QUOTE">&quot;if-test&quot;</span> любезно
            предоставлено Stephane Chazelas.</em></span></p>
          </li>
        </ul>

        <div
         class="EXAMPLE">
          <a
           name="c2171_html_EX10"></a>

          <p><strong>Пример 7-1. Что есть
          &quot;истина&quot;?</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

echo

echo &quot;Проверяется \&quot;0\&quot;&quot;
if [ 0 ]      # ноль
then
  echo &quot;0 -- это истина.&quot;
else
  echo &quot;0 -- это ложь.&quot;
fi            # 0 -- это истина.

echo

echo &quot;Проверяется \&quot;1\&quot;&quot;
if [ 1 ]      # единица
then
  echo &quot;1 -- это истина.&quot;
else
  echo &quot;1 -- это ложь.&quot;
fi            # 1 -- это ложь.

echo

echo &quot;Testing \&quot;-1\&quot;&quot;
if [ -1 ]     # минус один
then
  echo &quot;-1 -- это истина.&quot;
else
  echo &quot;-1 -- это ложь.&quot;
fi            # -1 -- это истина.

echo

echo &quot;Проверяется \&quot;NULL\&quot;&quot;
if [ ]        # NULL (пустое условие)
then
  echo &quot;NULL -- это истина.&quot;
else
  echo &quot;NULL -- это ложь.&quot;
fi            # NULL -- это ложь.

echo

echo &quot;Проверяется \&quot;xyz\&quot;&quot;
if [ xyz ]    # строка
then
  echo &quot;Случайная строка -- это истина.&quot;
else
  echo &quot;Случайная строка -- это ложь.&quot;
fi            # Случайная строка -- это истина.

echo

echo &quot;Проверяется \&quot;\$xyz\&quot;&quot;
if [ $xyz ]   # Проверка, если $xyz это null, но...
              # только для неинициализированных переменных.
then
  echo &quot;Неинициализированная переменная -- это истина.&quot;
else
  echo &quot;Неинициализированная переменная -- это ложь.&quot;
fi            # Неинициализированная переменная -- это ложь.

echo

echo &quot;Проверяется \&quot;-n \$xyz\&quot;&quot;
if [ -n &quot;$xyz&quot; ]            # Более корректный вариант.
then
  echo &quot;Неинициализированная переменная -- это истина.&quot;
else
  echo &quot;Неинициализированная переменная -- это ложь.&quot;
fi            # Неинициализированная переменная -- это ложь.

echo


xyz=          # Инициализирована пустым значением.

echo &quot;Проверяется \&quot;-n \$xyz\&quot;&quot;
if [ -n &quot;$xyz&quot; ]
then
  echo &quot;Пустая переменная -- это истина.&quot;
else
  echo &quot;Пустая переменная -- это ложь.&quot;
fi            # Пустая переменная -- это ложь.


echo


# Кргда &quot;ложь&quot; истинна?

echo &quot;Проверяется \&quot;false\&quot;&quot;
if [ &quot;false&quot; ]              #  это обычная строка &quot;false&quot;.
then
  echo &quot;\&quot;false\&quot; -- это истина.&quot; #+ и она истинна.
else
  echo &quot;\&quot;false\&quot; -- это ложь.&quot;
fi            # &quot;false&quot; -- это истина.

echo

echo &quot;Проверяется \&quot;\$false\&quot;&quot;  # Опять неинициализированная переменная.
if [ &quot;$false&quot; ]
then
  echo &quot;\&quot;\$false\&quot; -- это истина.&quot;
else
  echo &quot;\&quot;\$false\&quot; -- это ложь.&quot;
fi            # &quot;$false&quot; -- это ложь.
              # Теперь мв получили ожидаемый результат.


echo

exit 0
</pre>
        </div>

        <div
         class="FORMALPARA">
          <p><strong>Упражнение.</strong> Объясните результаты,
          полученные в <a
           href="#c2171_html_EX10">Пример 7-1</a>.</p>
        </div>
<pre
 class="PROGRAMLISTING">
if [ condition-true ]
then
   command 1
   command 2
   ...
else
   # Необязательная ветка (можно опустить, если в ней нет необходимости).
   # Дополнительный блок кода,
   # исполняемый в случае, когда результат проверки -- &quot;ложь&quot;.
   command 3
   command 4
   ...
fi
</pre>
        <br>
        <br>

        <div
         class="NOTE">
          <table
           class="NOTE"
           width="100%"
           border="0">
            <tr>
              <td
               width="25"
               align="center"
               valign="top"><img
               src="misc/abs-book/images/note.gif"
               hspace="5"
               alt="Note"></td>

              <td
               align="left"
               valign="top">
                <p>Когда <span
                 class="emphasis"><em
                 class="EMPHASIS">if</em></span> и <span
                 class="emphasis"><em
                 class="EMPHASIS">then</em></span> располагаются в
                одной строке, то конструкция <span
                 class="emphasis"><em
                 class="EMPHASIS">if</em></span> должна завершаться
                точкой с запятой. И <span
                 class="emphasis"><em
                 class="EMPHASIS">if</em></span>, и <span
                 class="emphasis"><em
                 class="EMPHASIS">then</em></span> -- это <a
                 href="#c5358_html_KEYWORDREF">зарезервированные
                слова</a>. Зарезервированные слова начинают инструкцию,
                которая должна быть завершена прежде, чем в той же
                строке появится новая инструкция.</p>
<pre
 class="PROGRAMLISTING">
if [ -x &quot;$filename&quot; ]; then
</pre>
                <br>
                <br>
              </td>
            </tr>
          </table>
        </div>

        <div
         class="VARIABLELIST">
          <p><strong><a
           name="c2171_html_ELIFREF1"></a>Else if и elif</strong></p>

          <dl>
            <dt><span
             class="TOKEN">elif</span></dt>

            <dd>
              <p><tt
               class="USERINPUT"><strong>elif</strong></tt> -- это
              краткая форма записи конструкции <span
               class="TOKEN">else if</span>. Применяется для построения
              многоярусных инструкций <span
               class="TOKEN">if/then</span>.</p>
<pre
 class="PROGRAMLISTING">
if [ condition1 ]
then
   command1
   command2
   command3
elif [ condition2 ]
# То же самое, что и else if
then
   command4
   command5
else
   default-command
fi
</pre>
              <br>
              <br>
            </dd>
          </dl>
        </div>

        <p>Конструкция <tt
         class="USERINPUT"><strong>if test condition-true</strong></tt>
        является точным эквивалентом конструкции <tt
         class="USERINPUT"><strong>if [ condition-true ]</strong></tt>,
        где левая квадратная скобка <strong
         class="COMMAND">[</strong> выполняет те же действия, что и
        команда <strong
         class="COMMAND">test</strong>. Закрывающая правая квадратная
        скобка <strong
         class="COMMAND">]</strong> не является абсолютно необходимой,
        однако, более новые версии Bash требуют ее наличие.</p>

        <div
         class="NOTE">
          <table
           class="NOTE"
           width="100%"
           border="0">
            <tr>
              <td
               width="25"
               align="center"
               valign="top"><img
               src="misc/abs-book/images/note.gif"
               hspace="5"
               alt="Note"></td>

              <td
               align="left"
               valign="top">
                <p>Команда <strong
                 class="COMMAND">test</strong> -- это <a
                 href="#c5358_html_BUILTINREF">встроенная</a> команда
                Bash, которая выполняет проверки файлов и производит
                сравнение строк. Таким образом, в Bash-скриптах,
                команда <strong
                 class="COMMAND">test</strong> <span
                 class="emphasis"><em
                 class="EMPHASIS">не</em></span> вызывает внешнюю (<tt
                 class="FILENAME">/usr/bin/test</tt>) утилиту, которая
                является частью пакета <span
                 class="emphasis"><em
                 class="EMPHASIS">sh-utils</em></span>. Аналогично,
                <span
                 class="TOKEN">[</span> не производит вызов утилиты <tt
                 class="FILENAME">/usr/bin/[</tt>, которая является
                символической ссылкой на <tt
                 class="FILENAME">/usr/bin/test</tt>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>type test</strong></tt>
<tt
 class="COMPUTEROUTPUT">test is a shell builtin</tt>
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>type &#39;[&#39;</strong></tt>
<tt
 class="COMPUTEROUTPUT">[ is a shell builtin</tt>
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>type &#39;[[&#39;</strong></tt>
<tt
 class="COMPUTEROUTPUT">[[ is a shell keyword</tt>
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>type &#39;]]&#39;</strong></tt>
<tt
 class="COMPUTEROUTPUT">]] is a shell keyword</tt>
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>type &#39;]&#39;</strong></tt>
<tt
 class="COMPUTEROUTPUT">bash: type: ]: not found</tt>
             
</pre>
                <br>
                <br>
              </td>
            </tr>
          </table>
        </div>

        <div
         class="EXAMPLE">
          <a
           name="c2171_html_EX11"></a>

          <p><strong>Пример 7-2. Эквиваленты команды <span
           class="TOKEN">test</span> -- <tt
           class="FILENAME">/usr/bin/test</tt>, <span
           class="TOKEN">[ ]</span>, и <tt
           class="FILENAME">/usr/bin/[</tt></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

echo

if test -z &quot;$1&quot;
then
  echo &quot;Аргументы командной строки отсутствуют.&quot;
else
  echo &quot;Первый аргумент командной строки: $1.&quot;
fi

echo

if /usr/bin/test -z &quot;$1&quot;      # Дает тот же рузультат, что и встроенная команда &quot;test&quot;.
then
  echo &quot;Аргументы командной строки отсутствуют.&quot;
else
  echo &quot;Первый аргумент командной строки: $1.&quot;
fi

echo

if [ -z &quot;$1&quot; ]                # Функционально идентично вышеприведенному блоку кода.
#   if [ -z &quot;$1&quot;                эта конструкция должна работать, но...
#+  Bash выдает сообщение об отсутствующей закрывающей скобке.
then
  echo &quot;Аргументы командной строки отсутствуют.&quot;
else
  echo &quot;Первый аргумент командной строки: $1.&quot;
fi

echo

if /usr/bin/[ -z &quot;$1&quot;         # Функционально идентично вышеприведенному блоку кода.
# if /usr/bin/[ -z &quot;$1&quot; ]     # Работает, но выдает сообщение об ошибке.
then
  echo &quot;Аргументы командной строки отсутствуют.&quot;
else
  echo &quot;Первый аргумент командной строки: $1.&quot;
fi

echo

exit 0
</pre>
        </div>

        <p><a
         name="c2171_html_DBLBRACKETS"></a>Конструкция <span
         class="TOKEN">[[ ]]</span> более универсальна, по сравнению с
        <span
         class="TOKEN">[ ]</span>. Этот <span
         class="emphasis"><em
         class="EMPHASIS">расширенный вариант команды test</em></span>
        перекочевал в Bash из <span
         class="emphasis"><em
         class="EMPHASIS">ksh88</em></span>.</p>

        <div
         class="NOTE">
          <table
           class="NOTE"
           width="100%"
           border="0">
            <tr>
              <td
               width="25"
               align="center"
               valign="top"><img
               src="misc/abs-book/images/note.gif"
               hspace="5"
               alt="Note"></td>

              <td
               align="left"
               valign="top">
                <p>Внутри этой конструкции не производится никакой
                дополнительной интерпретации имен файлов и не
                производится разбиение аргументов на отдельные слова,
                но допускается подстановка параметров и команд.</p>
              </td>
            </tr>
          </table>
        </div>
<pre
 class="PROGRAMLISTING">
file=/etc/passwd

if [[ -e $file ]]
then
  echo &quot;Файл паролей найден.&quot;
fi
</pre>
        <br>
        <br>

        <div
         class="TIP">
          <table
           class="TIP"
           width="100%"
           border="0">
            <tr>
              <td
               width="25"
               align="center"
               valign="top"><img
               src="misc/abs-book/images/tip.gif"
               hspace="5"
               alt="Tip"></td>

              <td
               align="left"
               valign="top">
                <p>Конструкция <strong
                 class="COMMAND">[[ ... ]]</strong> более
                предпочтительна, нежели <strong
                 class="COMMAND">[ ... ]</strong>, поскольку поможет
                избежать некоторых логических ошибок. Например,
                операторы <span
                 class="TOKEN">&amp;&amp;</span>, <span
                 class="TOKEN">||</span>, <span
                 class="TOKEN">&lt;</span> и <span
                 class="TOKEN">&gt;</span> внутри <span
                 class="TOKEN">[[ ]]</span> вполне допустимы, в то
                время как внутри <span
                 class="TOKEN">[ ]</span> порождают сообщения об
                ошибках.</p>
              </td>
            </tr>
          </table>
        </div>

        <div
         class="NOTE">
          <table
           class="NOTE"
           width="100%"
           border="0">
            <tr>
              <td
               width="25"
               align="center"
               valign="top"><img
               src="misc/abs-book/images/note.gif"
               hspace="5"
               alt="Note"></td>

              <td
               align="left"
               valign="top">
                <p>Строго говоря, после оператора <strong
                 class="COMMAND">if</strong>, ни команда <strong
                 class="COMMAND">test</strong>, ни квадратные скобки (
                [ ] или [[ ]] ) не являются обязательными.</p>
<pre
 class="PROGRAMLISTING">
dir=/home/bozo

if cd &quot;$dir&quot; 2&gt;/dev/null; then   # &quot;2&gt;/dev/null&quot; подавление вывода сообщений об ошибках.
  echo &quot;Переход в каталог $dir выполнен.&quot;
else
  echo &quot;Невозможно перейти в каталог $dir.&quot;
fi
</pre>
                Инструкция &quot;if COMMAND&quot; возвращает код
                возврата команды COMMAND.<br>
                <br>

                <p>Точно так же, условие, находящееся внутри квадратных
                скобок может быть проверено без использования оператора
                <strong
                 class="COMMAND">if</strong>.</p>
<pre
 class="PROGRAMLISTING">
var1=20
var2=22
[ &quot;$var1&quot; -ne &quot;$var2&quot; ] &amp;&amp; echo &quot;$var1 не равно $var2&quot;

home=/home/bozo
[ -d &quot;$home&quot; ] || echo &quot;каталог $home не найден.&quot;
</pre>
                <br>
                <br>
              </td>
            </tr>
          </table>
        </div>

        <p>Внутри <a
         href="#x4862_html">(( ))</a> производится вычисление
        арифметического выражения. Если результатом вычислений является
        ноль, то возвращается <span
         class="RETURNVALUE">1</span>, или <span
         class="QUOTE">&quot;ложь&quot;</span>. Ненулевой результат
        дает код возврата <span
         class="RETURNVALUE">0</span>, или <span
         class="QUOTE">&quot;истина&quot;</span>. То есть полная
        противоположность инструкциям <strong
         class="COMMAND">test</strong> и <span
         class="TOKEN">[ ]</span>, обсуждавшимся выше.</p>

        <div
         class="EXAMPLE">
          <a
           name="c2171_html_ARITHTESTS"></a>

          <p><strong>Пример 7-3. Арифметические выражения внутри <span
           class="TOKEN">(( ))</span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Проверка арифметических выражений.

# Инструкция (( ... )) вычисляет арифметические выражения.
# Код возврата противоположен коду возврата инструкции [ ... ] !

(( 0 ))
echo &quot;Код возврата \&quot;(( 0 ))\&quot;:  $?.&quot;         # 1

(( 1 ))
echo &quot;Код возврата \&quot;(( 1 ))\&quot;:  $?.&quot;         # 0

(( 5 &gt; 4 ))                                   # true
echo &quot;Код возврата \&quot;(( 5 &gt; 4 ))\&quot;:  $?.&quot;     # 0

(( 5 &gt; 9 ))                                   # false
echo &quot;Код возврата \&quot;(( 5 &gt; 9 ))\&quot;:  $?.&quot;     # 1

(( 5 - 5 ))                                   # 0
echo &quot;Код возврата \&quot;(( 5 - 5 ))\&quot;:  $?.&quot;     # 1

(( 5 / 4 ))                                   # Деление, все в порядке
echo &quot;Код возврата \&quot;(( 5 / 4 ))\&quot;:  $?.&quot;     # 0

(( 1 / 2 ))                                   # Результат деления &lt; 1.
echo &quot;Код возврата \&quot;(( 1 / 2 ))\&quot;:  $?.&quot;     # Округляется до 0.
                                              # 1

(( 1 / 0 )) 2&gt;/dev/null                       # Деление на 0.
echo &quot;Код возврата \&quot;(( 1 / 0 ))\&quot;:  $?.&quot;     # 1

# Для чего нужна инструкция &quot;2&gt;/dev/null&quot; ?
# Что произойдет, если ее убрать?
# Попробуйте убрать ее и выполнить сценарий.

exit 0
</pre>
        </div>
      </div>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#c2105_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x2389_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Завершение и код завершения</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#p299_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Операции проверки файлов</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="c2792_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x2780_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x3255_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="CHAPTER">
      <h1><a
       name="c2792_html_OPERATIONS"></a>Глава 8. Операции и смежные темы</h1>

      <div
       class="SECT1">
        <h1
         class="SECT1"><a
         name="c2792_html_OPS"></a>8.1. Операторы</h1>

        <div
         class="VARIABLELIST">
          <p><strong><a
           name="c2792_html_ASNOP1"></a>присваивание</strong></p>

          <dl>
            <dt><tt
             class="REPLACEABLE"><em>variable assignment</em></tt></dt>

            <dd>
              <p>Инициализация переменной или изменение ее значения</p>
            </dd>

            <dt>=</dt>

            <dd>
              <p>Универсальный оператор присваивания, пригоден как для
              сравнения целых чисел, так и для сравнения строк.</p>
<pre
 class="PROGRAMLISTING">
var=27
category=minerals  # Пробелы до и после оператора &quot;=&quot; -- недопустимы.
</pre>
              <br>
              <br>

              <div
               class="CAUTION">
                <table
                 class="CAUTION"
                 width="90%"
                 border="0">
                  <tr>
                    <td
                     width="25"
                     align="center"
                     valign="top"><img
                     src="misc/abs-book/images/caution.gif"
                     hspace="5"
                     alt="Caution"></td>

                    <td
                     align="left"
                     valign="top">
                      <p>Пусть вас не смущает, что оператор
                      присваивания (<span
                       class="QUOTE">&quot;=&quot;</span>), по своему
                      внешнему виду, совпадает с оператором сравнения
                      (<a
                       href="#x2565_html_EQUALSIGNREF">=</a>).</p>
<pre
 class="PROGRAMLISTING">
#    Здесь знак &quot;=&quot;  выступает в качестве оператора сравнения

if [ &quot;$string1&quot; = &quot;$string2&quot; ]
# if [ &quot;X$string1&quot; = &quot;X$string2&quot; ] более отказоустойчивый вариант,
# предохраняет от &quot;сваливания&quot; по ошибке в случае, когда одна из переменных пуста.
# (добавленные символы &quot;X&quot; компенсируют друг друга.)
then
   command
fi
</pre>
                      <br>
                      <br>
                    </td>
                  </tr>
                </table>
              </div>
            </dd>
          </dl>
        </div>

        <div
         class="VARIABLELIST">
          <p><strong><a
           name="c2792_html_AROPS1"></a>арифметические операторы</strong></p>

          <dl>
            <dt><span
             class="TOKEN">+</span></dt>

            <dd>
              <p>сложение</p>
            </dd>

            <dt><span
             class="TOKEN">-</span></dt>

            <dd>
              <p>вычитание</p>
            </dd>

            <dt><span
             class="TOKEN">*</span></dt>

            <dd>
              <p>умножение</p>
            </dd>

            <dt><span
             class="TOKEN">/</span></dt>

            <dd>
              <p>деление</p>
            </dd>

            <dt><a
             name="c2792_html_EXPONENTIATIONREF"></a><span
             class="TOKEN">**</span></dt>

            <dd>
              <p>возведение в степень</p>
<pre
 class="PROGRAMLISTING">
# В Bash, начиная с версии 2.02, был введен оператор возведения в степень -- &quot;**&quot;.

let &quot;z=5**3&quot;
echo &quot;z = $z&quot;   # z = 125
</pre>
              <br>
              <br>
            </dd>

            <dt><a
             name="c2792_html_MODULOREF"></a><span
             class="TOKEN">%</span></dt>

            <dd>
              <p>модуль (деление по модулю), возвращает остаток от
              деления</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo `expr 5 % 3`</strong></tt>
<tt
 class="COMPUTEROUTPUT">2</tt>
             
</pre>
              <br>
              <br>

              <p>Этот оператор может применяться в алгоритмах генерации
              псевдослучайных чисел в заданном диапазоне (см. <a
               href="#x4812_html_EX21">Пример 9-23</a> и <a
               href="#x4812_html_RANDOMTEST">Пример 9-25</a>), для
              форматирования вывода на экран (см. <a
               href="#c12790_html_QFUNCTION">Пример 25-10</a> и <a
               href="#a14477_html_COLLATZ">Пример A-7</a>), и даже для
              генерации простых чисел (см. <a
               href="#a14477_html_PRIMES">Пример A-18</a>). На удивление
              часто операцию деления по модулю можно встретить в
              различных численных алгоритмах.</p>

              <div
               class="EXAMPLE">
                <a
                 name="c2792_html_GCD"></a>

                <p><strong>Пример 8-1. Наибольший общий
                делитель</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# gcd.sh: поиск наибольшего общего делителя
#         по алгоритму Эвклида

#  Под &quot;наибольшим общим делителем&quot; (нод) двух целых чисел
#+ понимается наибольшее целое число, которое делит оба делимых без остатка.

#  Алгоритм Эвклида выполняет последовательное деление.
#  В каждом цикле,
#+ делимое  &lt;---  делитель
#+ делитель &lt;---  остаток
#+ до тех пор, пока остаток не станет равным нулю (остаток = 0).
#+ The gcd = dividend, on the final pass.
#
#  Замечательное описание алгоритма Эвклида можно найти
#  на сайте Jim Loy, http://www.jimloy.com/number/euclids.htm.


# ------------------------------------------------------
# Проверка входных параметров
ARGS=2
E_BADARGS=65

if [ $# -ne &quot;$ARGS&quot; ]
then
  echo &quot;Порядок использования: `basename $0` первое-число второе-число&quot;
  exit $E_BADARGS
fi
# ------------------------------------------------------


gcd ()
{

                                 #  Начальное присваивание.
  dividend=$1                    #  В сущности, не имеет значения
  divisor=$2                     #+ какой из них больше.
                                 #  Почему?

  remainder=1                    #  Если переменные неинициализировать,
                                 #+ то работа сценария будет прервана по ошибке
                                 #+ в первом же цикле.

  until [ &quot;$remainder&quot; -eq 0 ]
  do
    let &quot;remainder = $dividend % $divisor&quot;
    dividend=$divisor            # Повторить цикл с новыми исходными данными
    divisor=$remainder
  done                           # алгоритм Эвклида

}                                # последнее $dividend и есть нод.


gcd $1 $2

echo; echo &quot;НОД чисел $1 и $2 = $dividend&quot;; echo


# Упражнение :
# --------
#  Вставьте дополнительную проверку входных аргументов,
#+ и предусмотрите завершение работы сценария с сообщением об ошибке, если
#+ входные аргументы не являются целыми числами.

exit 0
</pre>
              </div>
            </dd>

            <dt><span
             class="TOKEN">+=</span></dt>

            <dd>
              <p><span
               class="QUOTE">&quot;плюс-равно&quot;</span> (увеличивает
              значение переменной на заданное число)</p>

              <p><tt
               class="USERINPUT"><strong>let &quot;var +=
              5&quot;</strong></tt> значение переменной <tt
               class="VARNAME">var</tt> будет увеличено на <tt
               class="LITERAL">5</tt>.</p>
            </dd>

            <dt><span
             class="TOKEN">-=</span></dt>

            <dd>
              <p><span
               class="QUOTE">&quot;минус-равно&quot;</span> (уменьшение
              значения переменной на заданное число)</p>
            </dd>

            <dt><span
             class="TOKEN">*=</span></dt>

            <dd>
              <p><span
               class="QUOTE">&quot;умножить-равно&quot;</span>
              (умножить значение переменной на заданное число,
              результат записать в переменную)</p>

              <p><tt
               class="USERINPUT"><strong>let &quot;var *=
              4&quot;</strong></tt> значение переменной <tt
               class="VARNAME">var</tt> будет увеличено в <tt
               class="LITERAL">4</tt> раза.</p>
            </dd>

            <dt><span
             class="TOKEN">/=</span></dt>

            <dd>
              <p><span
               class="QUOTE">&quot;слэш-равно&quot;</span> (уменьшение
              значения переменной в заданное число раз)</p>
            </dd>

            <dt><span
             class="TOKEN">%=</span></dt>

            <dd>
              <p><span
               class="QUOTE">&quot;процент-равно&quot;</span> (найти
              остаток от деления значения переменной на заданное число,
              результат записать в переменную)</p>

              <p><span
               class="emphasis"><em
               class="EMPHASIS">Арифметические операторы очень часто
              используются совместно с командами <a
               href="#x6646_html_EXPRREF">expr</a> и <a
               href="#c5358_html_LETREF">let</a>.</em></span></p>

              <div
               class="EXAMPLE">
                <a
                 name="c2792_html_ARITHOPS"></a>

                <p><strong>Пример 8-2. Арифметические
                операции</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# От 1 до 6 пятью различными способами.

n=1; echo -n &quot;$n &quot;

let &quot;n = $n + 1&quot;   # let &quot;n = n + 1&quot;   тоже допустимо
echo -n &quot;$n &quot;

: $((n = $n + 1))
# оператор &quot;:&quot; обязателен, поскольку в противном случае, Bash будет
#+ интерпретировать выражение &quot;$((n = $n + 1))&quot; как команду.
echo -n &quot;$n &quot;

n=$(($n + 1))
echo -n &quot;$n &quot;

: $[ n = $n + 1 ]
# оператор &quot;:&quot; обязателен, поскольку в противном случае, Bash будет
#+ интерпретировать выражение &quot;$[ n = $n + 1 ]&quot; как команду.
# Не вызывает ошибки даже если &quot;n&quot; содержит строку.
echo -n &quot;$n &quot;

n=$[ $n + 1 ]
#  Не вызывает ошибки даже если &quot;n&quot; содержит строку.
#* Старайтесь избегать употребления такой конструкции,
#+ поскольку она уже давно устарела и не переносима.
echo -n &quot;$n &quot;; echo

# Спасибо Stephane Chazelas.

exit 0
</pre>
              </div>
            </dd>
          </dl>
        </div>

        <div
         class="NOTE">
          <table
           class="NOTE"
           width="100%"
           border="0">
            <tr>
              <td
               width="25"
               align="center"
               valign="top"><img
               src="misc/abs-book/images/note.gif"
               hspace="5"
               alt="Note"></td>

              <td
               align="left"
               valign="top">
                <p>Целые числа в Bash фактически являются знаковыми
                <span
                 class="emphasis"><em
                 class="EMPHASIS">длинными</em></span> целыми (32-бит),
                с диапазоном изменений от -2147483648 до 2147483647.
                Если в результате какой либо операции эти пределы будут
                превышены, то результат получится ошибочным.</p>
<pre
 class="PROGRAMLISTING">
a=2147483646
echo &quot;a = $a&quot;      # a = 2147483646
let &quot;a+=1&quot;         # Увеличить &quot;a&quot; на 1.
echo &quot;a = $a&quot;      # a = 2147483647
let &quot;a+=1&quot;         # увеличить &quot;a&quot; еще раз, с выходом за границы диапазона.
echo &quot;a = $a&quot;      # a = -2147483648
                   #      ОШИБКА! (выход за границы диапазона)
</pre>
                <br>
                <br>
              </td>
            </tr>
          </table>
        </div>

        <div
         class="CAUTION">
          <table
           class="CAUTION"
           width="100%"
           border="0">
            <tr>
              <td
               width="25"
               align="center"
               valign="top"><img
               src="misc/abs-book/images/caution.gif"
               hspace="5"
               alt="Caution"></td>

              <td
               align="left"
               valign="top">
                <p>Bash ничего не знает о существовании чисел с
                плавающей запятой. Такие числа, из-за наличия символа
                десятичной точки, он воспринимает как строки.</p>
<pre
 class="PROGRAMLISTING">
a=1.5

let &quot;b = $a + 1.3&quot;  # Ошибка.
# t2.sh: let: b = 1.5 + 1.3: syntax error in expression (error token is &quot;.5 + 1.3&quot;)

echo &quot;b = $b&quot;       # b=1
</pre>
                Для работы с числами с плавающей запятой в сценариях
                можно использовать утилиту-калькулятор <a
                 href="#x9199_html_BCREF">bc</a>.<br>
                <br>
              </td>
            </tr>
          </table>
        </div>

        <div
         class="FORMALPARA">
          <p><strong>битовые операции.</strong> Битовые операции очень
          редко используются в сценариях командного интерпретатора. Их
          главное назначение, на мой взгляд, установка и проверка
          некоторых значений, читаемых из портов ввода-вывода и
          сокетов. <span
           class="QUOTE">&quot;Битовые операции&quot;</span> гораздо
          более уместны в компилирующих языках программирования, таких
          как C и C++.</p>
        </div>

        <div
         class="VARIABLELIST">
          <p><strong><a
           name="c2792_html_BITWSOPS1"></a>битовые операции</strong></p>

          <dl>
            <dt><span
             class="TOKEN">&lt;&lt;</span></dt>

            <dd>
              <p>сдвигает на 1 бит влево (умножение на <tt
               class="LITERAL">2</tt>)</p>
            </dd>

            <dt><span
             class="TOKEN">&lt;&lt;=</span></dt>

            <dd>
              <p><span
               class="QUOTE">&quot;сдвиг-влево-равно&quot;</span></p>

              <p><tt
               class="USERINPUT"><strong>let &quot;var &lt;&lt;=
              2&quot;</strong></tt> значение переменной <tt
               class="VARNAME">var</tt> сдвигается влево на 2 бита
              (умножается на <tt
               class="LITERAL">4</tt>)</p>
            </dd>

            <dt><span
             class="TOKEN">&gt;&gt;</span></dt>

            <dd>
              <p>сдвиг вправо на 1 бит (деление на <tt
               class="LITERAL">2</tt>)</p>
            </dd>

            <dt><span
             class="TOKEN">&gt;&gt;=</span></dt>

            <dd>
              <p><span
               class="QUOTE">&quot;сдвиг-вправо-равно&quot;</span>
              (имеет смысл обратный <span
               class="TOKEN">&lt;&lt;=</span>)</p>
            </dd>

            <dt><span
             class="TOKEN">&amp;</span></dt>

            <dd>
              <p>по-битовое И (AND)</p>
            </dd>

            <dt><span
             class="TOKEN">&amp;=</span></dt>

            <dd>
              <p><span
               class="QUOTE">&quot;по-битовое И-равно&quot;</span></p>
            </dd>

            <dt><span
             class="TOKEN">|</span></dt>

            <dd>
              <p>по-битовое ИЛИ (OR)</p>
            </dd>

            <dt><span
             class="TOKEN">|=</span></dt>

            <dd>
              <p><span
               class="QUOTE">&quot;по-битовое
              ИЛИ-равно&quot;</span></p>
            </dd>

            <dt><span
             class="TOKEN">~</span></dt>

            <dd>
              <p>по-битовая инверсия</p>
            </dd>

            <dt><span
             class="TOKEN">!</span></dt>

            <dd>
              <p>По-битовое отрицание</p>
            </dd>

            <dt><span
             class="TOKEN">^</span></dt>

            <dd>
              <p>по-битовое ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR)</p>
            </dd>

            <dt><span
             class="TOKEN">^=</span></dt>

            <dd>
              <p><span
               class="QUOTE">&quot;по-битовое
              ИСКЛЮЧАЮЩЕЕ-ИЛИ-равно&quot;</span></p>
            </dd>
          </dl>
        </div>

        <div
         class="VARIABLELIST">
          <p><strong><a
           name="c2792_html_LOGOPS1"></a>логические операции</strong></p>

          <dl>
            <dt><span
             class="TOKEN">&amp;&amp;</span></dt>

            <dd>
              <p>логическое И (and)</p>
<pre
 class="PROGRAMLISTING">
if [ $condition1 ] &amp;&amp; [ $condition2 ]
# То же самое, что:  if [ $condition1 -a $condition2 ]
# Возвращает true если оба операнда condition1 и condition2 истинны...

if [[ $condition1 &amp;&amp; $condition2 ]]    # То же верно
# Обратите внимание: оператор &amp;&amp; не должен использоваться внутри [ ... ].
</pre>
              <br>
              <br>

              <div
               class="NOTE">
                <table
                 class="NOTE"
                 width="90%"
                 border="0">
                  <tr>
                    <td
                     width="25"
                     align="center"
                     valign="top"><img
                     src="misc/abs-book/images/note.gif"
                     hspace="5"
                     alt="Note"></td>

                    <td
                     align="left"
                     valign="top">
                      <p>оператор <span
                       class="TOKEN">&amp;&amp;</span>, в зависимости
                      от контекста, может так же использоваться в <a
                       href="#c12716_html_LISTCONSREF">И-списках</a> для
                      построения составных команд.</p>
                    </td>
                  </tr>
                </table>
              </div>
            </dd>

            <dt><a
             name="c2792_html_ORREF"></a><span
             class="TOKEN">||</span></dt>

            <dd>
              <p>логическое ИЛИ (or)</p>
<pre
 class="PROGRAMLISTING">
if [ $condition1 ] || [ $condition2 ]
# То же самое, что:  if [ $condition1 -o $condition2 ]
# Возвращает true если хотя бы один из операндов истинен...

if [[ $condition1 || $condition2 ]]    # Also works.
# Обратите внимание: оператор || не должен использоваться внутри [ ... ].
</pre>
              <br>
              <br>

              <div
               class="NOTE">
                <table
                 class="NOTE"
                 width="90%"
                 border="0">
                  <tr>
                    <td
                     width="25"
                     align="center"
                     valign="top"><img
                     src="misc/abs-book/images/note.gif"
                     hspace="5"
                     alt="Note"></td>

                    <td
                     align="left"
                     valign="top">
                      <p>Bash производит проверку <a
                       href="#c2105_html_EXITSTATUSREF">кода
                      возврата</a> КАЖДОГО из операндов в логических
                      выражениях.</p>
                    </td>
                  </tr>
                </table>
              </div>

              <div
               class="EXAMPLE">
                <a
                 name="c2792_html_ANDOR"></a>

                <p><strong>Пример 8-3. Построение сложных условий,
                использующих &amp;&amp; и ||</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

a=24
b=47

if [ &quot;$a&quot; -eq 24 ] &amp;&amp; [ &quot;$b&quot; -eq 47 ]
then
  echo &quot;Первая проверка прошла успешно.&quot;
else
  echo &quot;Первая проверка не прошла.&quot;
fi

# ОКА:  if [ &quot;$a&quot; -eq 24 &amp;&amp; &quot;$b&quot; -eq 47 ]
#          пытается выполнить  &#39; [ &quot;$a&quot; -eq 24 &#39;
#          и терпит неудачу наткнувшись на &#39;]&#39;.
#
#    if [[ $a -eq 24 &amp;&amp; $b -eq 24 ]]   это правильный вариант
#    (в строке 17 оператор &quot;&amp;&amp;&quot; имеет иной смысл, нежели в строке 6.)
#    Спасибо Stephane Chazelas.


if [ &quot;$a&quot; -eq 98 ] || [ &quot;$b&quot; -eq 47 ]
then
  echo &quot;Вторая проверка прошла успешно.&quot;
else
  echo &quot;Вторая проверка не прошла.&quot;
fi


#  Опции -a и -o предоставляют
#+ альтернативный механизм проверки условий.
#  Спасибо Patrick Callahan.


if [ &quot;$a&quot; -eq 24 -a &quot;$b&quot; -eq 47 ]
then
  echo &quot;Третья проверка прошла успешно.&quot;
else
  echo &quot;Третья проверка не прошла.&quot;
fi


if [ &quot;$a&quot; -eq 98 -o &quot;$b&quot; -eq 47 ]
then
  echo &quot;Четвертая проверка прошла успешно.&quot;
else
  echo &quot;Четвертая проверка не прошла.&quot;
fi


a=rhino
b=crocodile
if [ &quot;$a&quot; = rhino ] &amp;&amp; [ &quot;$b&quot; = crocodile ]
then
  echo &quot;Пятая проверка прошла успешно.&quot;
else
  echo &quot;Пятая проверка не прошла.&quot;
fi

exit 0
</pre>
              </div>

              <p>Операторы <span
               class="TOKEN">&amp;&amp;</span> и <span
               class="TOKEN">||</span> могут использоваться и в
              арифметических вычислениях.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>echo $(( 1 &amp;&amp; 2 )) $((3 &amp;&amp; 0)) $((4 || 0)) $((0 || 0))</strong></tt>
<tt
 class="COMPUTEROUTPUT">1 0 1 0</tt>
             
</pre>
              <br>
              <br>
            </dd>
          </dl>
        </div>

        <div
         class="VARIABLELIST">
          <p><strong><a
           name="c2792_html_MISCOP1"></a>прочие операции</strong></p>

          <dl>
            <dt><a
             name="c2792_html_COMMAOP"></a><span
             class="TOKEN">,</span></dt>

            <dd>
              <p>запятая</p>

              <p>С помощью оператора <strong
               class="COMMAND">запятая</strong> можно связать несколько
              арифметических в одну последовательность. При разборе
              таких последовательностей, командный интерпретатор
              вычисляет все выражения (которые могут иметь побочные
              эффекты) в последовательности и возвращает результат
              последнего.</p>
<pre
 class="PROGRAMLISTING">
let &quot;t1 = ((5 + 3, 7 - 1, 15 - 4))&quot;
echo &quot;t1 = $t1&quot;               # t1 = 11

let &quot;t2 = ((a = 9, 15 / 3))&quot;  #  Выполняется присваивание &quot;a&quot; = 9,
                              #+ а затем вычисляется &quot;t2&quot;.
echo &quot;t2 = $t2    a = $a&quot;     # t2 = 5    a = 9
</pre>
              <br>
              <br>

              <p>Оператор запятая чаще всего находит применение в <a
               href="#c4875_html_FORLOOPREF1">циклах for</a>. См. <a
               href="#c4875_html_FORLOOPC">Пример 10-12</a>.</p>
            </dd>
          </dl>
        </div>
      </div>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x2780_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x3255_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Проверка степени усвоения материала</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#p299_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Числовые константы</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="c301_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#p299_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#c1613_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="CHAPTER">
      <h1><a
       name="c301_html_SPECIAL-CHARS"></a>Глава 3. Служебные символы</h1>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="c301_html_SCHARLIST1"></a>Служебные символы, используемые в
        текстах сценариев.</strong></p>

        <dl>
          <dt><span
           class="TOKEN">#</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong>Комментарии.</strong> Строки, начинающиеся с
              символа <span
               class="TOKEN">#</span> (<a
               href="#c178_html_MAGNUMREF">за исключением комбинации
              <span
               class="TOKEN">#!</span></a>) -- являются
              комментариями.</p>
            </div>
<pre
 class="PROGRAMLISTING">
# Эта строка -- комментарий.
</pre>
            <br>
            <br>

            <p>Комментарии могут располагаться и в конце строки с
            исполняемым кодом.</p>
<pre
 class="PROGRAMLISTING">
echo &quot;Далее следует комментарий.&quot; # Это комментарий.
</pre>
            <br>
            <br>

            <p>Комментариям могут предшествовать <a
             href="#c301_html_WHITESPACEREF">пробелы</a> (пробел,
            табуляция).</p>
<pre
 class="PROGRAMLISTING">
       # Перед комментарием стоит символ табуляции.
</pre>
            <br>
            <br>

            <div
             class="CAUTION">
              <table
               class="CAUTION"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/caution.gif"
                   hspace="5"
                   alt="Caution"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Исполняемые команды не могут следовать за
                    комментарием в той же самой строке. Пока что еще не
                    существует способа отделения комментария от <span
                     class="QUOTE">&quot;исполняемого
                    кода&quot;</span>, следующего за комментарием в той
                    же строке.</p>
                  </td>
                </tr>
              </table>
            </div>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Само собой разумеется, экранированный символ
                    <span
                     class="TOKEN">#</span> в операторе <strong
                     class="COMMAND">echo</strong> не воспринимается
                    как начало комментария. Более того, он может
                    использоваться в <a
                     href="#x4462_html_PSUB2">операциях подстановки
                    параметров</a> и в <a
                     href="#x3255_html_NUMCONSTANTS">константных
                    числовых выражениях</a>.</p>
<pre
 class="PROGRAMLISTING">
echo &quot;Символ # не означает начало комментария.&quot;
echo &#39;Символ # не означает начало комментария.&#39;
echo Символ \# не означает начало комментария.
echo А здесь символ # означает начало комментария.

echo ${PATH#*:}       # Подстановка -- не комментарий.
echo $(( 2#101011 ))  # База системы счисления -- не комментарий.

# Спасибо, S.C.
</pre>
                    <a
                     href="#c1833_html_QUOTINGREF">Кавычки &quot; &#39;
                    и \</a> экранируют действие символа #. <br>
                    <br>
                  </td>
                </tr>
              </table>
            </div>

            <p>В операциях <a
             href="#x4462_html_PSOREX1">поиска по шаблону</a> символ
            <span
             class="TOKEN">#</span> так же не воспринимается как начало
            комментария.</p>
          </dd>

          <dt><span
           class="TOKEN">;</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong>Разделитель команд.</strong> [Точка-с-запятой]
              Позволяет записывать две и более команд в одной
              строке.</p>
            </div>
<pre
 class="PROGRAMLISTING">
echo hello; echo there
</pre>
            <br>
            <br>

            <p>Следует отметить, что символ <span
             class="QUOTE">&quot;<span
             class="TOKEN">;</span>&quot;</span> иногда так же как и #
            необходимо <a
             href="#c1833_html_ESCP">экранировать</a>.</p>
          </dd>

          <dt><span
           class="TOKEN">;;</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong>Ограничитель в операторе выбора <a
               href="#x5210_html_CASEESAC1">case</a> .</strong>
              [Двойная-точка-с-запятой]</p>
            </div>
<pre
 class="PROGRAMLISTING">
case &quot;$variable&quot; in
abc)  echo &quot;$variable = abc&quot; ;;
xyz)  echo &quot;$variable = xyz&quot; ;;
esac
</pre>
            <br>
            <br>
          </dd>

          <dt><span
           class="TOKEN">.</span></dt>

          <dd>
            <p><a
             name="c301_html_DOTREF"></a></p>

            <div
             class="FORMALPARA">
              <p><strong>команда <span
               class="QUOTE">&quot;точка&quot;</span>.</strong>
              Эквивалент команды <a
               href="#c5358_html_SOURCEREF">source</a> (см. <a
               href="#c5358_html_EX38">Пример 11-18</a>). Это <a
               href="#c5358_html_BUILTINREF">встроенная</a> команда
              bash.</p>
            </div>
          </dd>

          <dt><span
           class="TOKEN">.</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong><span
               class="QUOTE">&quot;точка&quot;</span> может являться
              частью имени файла .</strong> Если имя файла начинается с
              точки, то это <span
               class="QUOTE">&quot;скрытый&quot;</span> файл, т.е.
              команда <a
               href="#c6407_html_LSREF">ls</a> при обычных условиях его
              не отображает.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>touch .hidden-file</strong></tt>
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ls -l</strong></tt>
<tt
 class="COMPUTEROUTPUT">total 10
 -rw-r--r--    1 bozo      4034 Jul 18 22:04 data1.addressbook
 -rw-r--r--    1 bozo      4602 May 25 13:58 data1.addressbook.bak
 -rw-r--r--    1 bozo       877 Dec 17  2000 employment.addressbook</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ls -al</strong></tt>
<tt
 class="COMPUTEROUTPUT">total 14
 drwxrwxr-x    2 bozo  bozo      1024 Aug 29 20:54 ./
 drwx------   52 bozo  bozo      3072 Aug 29 20:51 ../
 -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.addressbook
 -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.addressbook.bak
 -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.addressbook
 -rw-rw-r--    1 bozo  bozo         0 Aug 29 20:54 .hidden-file</tt>
               
</pre>
              <br>
              <br>
            </div>

            <p>Если подразумевается имя каталога, то <span
             class="emphasis"><em
             class="EMPHASIS">одна точка</em></span> означает текущий
            каталог и <span
             class="emphasis"><em
             class="EMPHASIS">две точки</em></span> -- каталог уровнем
            выше, или родительский каталог.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>pwd</strong></tt>
<tt
 class="COMPUTEROUTPUT">/home/bozo/projects</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>cd .</strong></tt>
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>pwd</strong></tt>
<tt
 class="COMPUTEROUTPUT">/home/bozo/projects</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>cd ..</strong></tt>
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>pwd</strong></tt>
<tt
 class="COMPUTEROUTPUT">/home/bozo/</tt>
               
</pre>
            <br>
            <br>

            <p>Символ <span
             class="emphasis"><em
             class="EMPHASIS">точка</em></span> довольно часто
            используется для обозначения каталога назначения в
            операциях копирования/перемещения файлов.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>cp /home/bozo/current_work/junk/* .</strong></tt>
               
</pre>
            <br>
            <br>
          </dd>

          <dt><span
           class="TOKEN">.</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong>Символ <span
               class="QUOTE">&quot;точка&quot;</span> в операциях
              поиска.</strong> При выполнении <a
               href="#c11895_html_REGEXDOT">поиска по шаблону</a> , в <a
               href="#c11895_html_REGEXREF">регулярных выражениях</a>,
              символ <span
               class="QUOTE">&quot;точка&quot;</span> обозначает
              одиночный символ.</p>
            </div>
          </dd>

          <dt><span
           class="TOKEN">&quot;</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong><a
               href="#c1613_html_DBLQUO">Двойные кавычки</a> .</strong>
              В строке <span
               class="emphasis"><em
               class="EMPHASIS">&quot;STRING&quot;</em></span>,
              ограниченной двойными кавычками не выполняется
              интерпретация большинства служебных символов, которые
              могут находиться в строке. см. <a
               href="#c1833_html">Глава 5</a>.</p>
            </div>
          </dd>

          <dt><span
           class="TOKEN">&#39;</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong><a
               href="#c1613_html_SNGLQUO">Одинарные кавычки</a>
              .</strong> [Одинарные кавычки] <span
               class="emphasis"><em
               class="EMPHASIS">&#39;STRING&#39;</em></span> экранирует
              все служебные символы в строке <span
               class="emphasis"><em
               class="EMPHASIS">STRING</em></span>. Это более строгая
              форма экранирования. Смотрите так же <a
               href="#c1833_html">Глава 5</a>.</p>
            </div>
          </dd>

          <dt><span
           class="TOKEN">,</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong><a
               href="#c2792_html_COMMAOP">Запятая</a> .</strong>
              Оператор <strong
               class="COMMAND">запятая</strong> используется для
              вычисления серии арифметических выражений. Вычисляются
              все выражения, но возвращается результат последнего
              выражения.</p>
<pre
 class="PROGRAMLISTING">
let &quot;t2 = ((a = 9, 15 / 3))&quot;  # Присваивает значение переменной &quot;a&quot; и вычисляет &quot;t2&quot;.
</pre>
              <br>
              <br>
            </div>
          </dd>

          <dt><span
           class="TOKEN">\</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong><a
               href="#c1833_html_ESCP">escape</a>.</strong> [обратный
              слэш] Комбинация <tt
               class="USERINPUT"><strong>\X</strong></tt> <span
               class="QUOTE">&quot;экранирует&quot;</span> символ <span
               class="emphasis"><em
               class="EMPHASIS">X</em></span>. Аналогичный эффект имеет
              комбинация с <span
               class="QUOTE">&quot;одинарными кавычками&quot;</span>,
              т.е. <span
               class="emphasis"><em
               class="EMPHASIS">&#39;X&#39;</em></span>. Символ <span
               class="TOKEN">\</span> может использоваться для
              экранирования кавычек <span
               class="TOKEN">&quot;</span> и <span
               class="TOKEN">&#39;</span>.</p>
            </div>

            <p>Более детальному рассмотрению темы экранирования
            посвящена <a
             href="#c1833_html">Глава 5</a>.</p>
          </dd>

          <dt><span
           class="TOKEN">/</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong>Разделитель, используемый в указании пути к
              каталогам и файлам.</strong> [слэш] Отделяет элементы
              пути к каталогам и файлам (например <tt
               class="FILENAME">/home/bozo/projects/Makefile</tt>).</p>
            </div>

            <p>В <a
             href="#c2792_html_AROPS1">арифметических операциях</a> --
            это оператор деления.</p>
          </dd>

          <dt><span
           class="TOKEN">`</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong><a
               href="#c11441_html_COMMANDSUBREF">Подстановка
              команд</a>.</strong> [обратные кавычки] <a
               href="#c11441_html_BACKQUOTESREF">Обратные кавычки</a>
              могут использоваться для записи в переменную команды
              <span
               class="emphasis"><em
               class="EMPHASIS">`command`</em></span>.</p>
            </div>
          </dd>

          <dt><span
           class="TOKEN">:</span></dt>

          <dd>
            <p><a
             name="c301_html_NULLREF"></a></p>

            <div
             class="FORMALPARA">
              <p><strong>пустая команда.</strong> [двоеточие] Это
              эквивалент операции <span
               class="QUOTE">&quot;NOP&quot;</span> (<tt
               class="REPLACEABLE"><em>no op</em></tt>, нет операции).
              Может рассматриваться как синоним встроенной команды <a
               href="#c5358_html_TRUEREF">true</a>. Команда <span
               class="QUOTE">&quot;<span
               class="TOKEN">:</span>&quot;</span> так же является
              встроенной командой Bash, которая всегда <a
               href="#c2105_html_EXITSTATUSREF">возвращает</a> <span
               class="QUOTE">&quot;true&quot;</span> (<span
               class="RETURNVALUE">0</span>).</p>
            </div>
<pre
 class="PROGRAMLISTING">
:
echo $?   # 0
</pre>
            <br>
            <br>

            <p>Бесконечный цикл:</p>
<pre
 class="PROGRAMLISTING">
while :
do
   operation-1
   operation-2
   ...
   operation-n
done

# То же самое:
#    while true
#    do
#      ...
#    done
</pre>
            <br>
            <br>

            <p>Символ-заполнитель в условном операторе if/then:</p>
<pre
 class="PROGRAMLISTING">
if condition
then :   # Никаких действий не производится и управление передается дальше
else
   take-some-action
fi
</pre>
            <br>
            <br>

            <p>Как символ-заполнитель в операциях, которые предполагают
            наличие двух операндов, см. <a
             href="#c2792_html_ARITHOPS">Пример 8-2</a> и <a
             href="#x4462_html_DEFPARAM">параметры по-умолчанию</a>.</p>
<pre
 class="PROGRAMLISTING">
: ${username=`whoami`}
# ${username=`whoami`}   без символа : выдает сообщение об ошибке,
#                        если &quot;username&quot; не является командой...
</pre>
            <br>
            <br>

            <p>Как символ-заполнитель для оператора <a
             href="#c11785_html_HEREDOCREF">вложенного документа</a>.
            См. <a
             href="#c11785_html_ANONHEREDOC">Пример 17-9</a>.</p>

            <p>В операциях с <a
             href="#x4462_html_PARAMSUBREF">подстановкой параметров</a>
            (см. <a
             href="#x4462_html_EX6">Пример 9-13</a>).</p>
<pre
 class="PROGRAMLISTING">
: ${HOSTNAME?} ${USER?} ${MAIL?}
#Вывод сообщения об ошибке, если одна или более переменных не определены.
</pre>
            <br>
            <br>

            <p>В операциях <strong
             class="COMMAND"><a
             href="#x4462_html_EXPREPL1">замены подстроки с подстановкой
            значений переменных</a></strong>.</p>

            <p>В комбинации с оператором <span
             class="TOKEN">&gt;</span> (<a
             href="#c11620_html_IOREDIRREF">оператор перенаправления
            вывода</a>), усекает длину файла до нуля. Если указан
            несуществующий файл -- то он создается.</p>
<pre
 class="PROGRAMLISTING">
: &gt; data.xxx   # Файл &quot;data.xxx&quot; -- пуст

# Тот же эффект имеет команда cat /dev/null &gt;data.xxx
# Однако в данном случае не производится создание нового процесса, поскольку &quot;:&quot; является встроенной командой.
</pre>
            См. так же <a
             href="#x7050_html_EX12">Пример 12-11</a>.<br>
            <br>

            <p>В комбинации с оператором <span
             class="TOKEN">&gt;&gt;</span> -- оператор перенаправления
            с добавлением в конец файла и обновлением времени
            последнего доступа (<tt
             class="USERINPUT"><strong>: &gt;&gt;
            new_file</strong></tt>). Если задано имя несуществующего
            файла, то он создается. Эквивалентно команде <a
             href="#x6837_html_TOUCHREF">touch</a>.</p>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Вышеизложенное применимо только к обычным файлам
                    и неприменимо к конвейерам, символическим ссылкам и
                    другим специальным файлам.</p>
                  </td>
                </tr>
              </table>
            </div>

            <p>Символ <span
             class="TOKEN">:</span> может использоваться для создания
            комментариев, хотя и не рекомендуется. Если строка
            комментария начинается с символа <span
             class="TOKEN">#</span>, то такая строка не проверяется
            интерпретатором на наличие ошибок. Однако в случае
            оператора <span
             class="TOKEN">:</span> это не так.</p>
<pre
 class="PROGRAMLISTING">
: Это комментарий, который генерирует сообщение об ошибке, ( if [ $x -eq 3] ).
</pre>
            <br>
            <br>

            <p>Символ <span
             class="QUOTE">&quot;<span
             class="TOKEN">:</span>&quot;</span> может использоваться
            как разделитель полей в <tt
             class="FILENAME">/etc/passwd</tt> и переменной <a
             href="#c3270_html_PATHREF">$PATH</a>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo $PATH</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin:/sbin:/usr/sbin:/usr/games</tt>
</pre>
            <br>
            <br>
          </dd>

          <dt><span
           class="TOKEN">!</span></dt>

          <dd>
            <p><a
             name="c301_html_NOTREF"></a></p>

            <div
             class="FORMALPARA">
              <p><strong>инверсия (или логическое отрицание)
              используемое в условных операторах.</strong> Оператор
              <span
               class="TOKEN">!</span> инвертирует <a
               href="#c2105_html_EXITSTATUSREF">код завершения</a>
              команды, к которой он применен. (см. <a
               href="#c2105_html_NEGCOND">Пример 6-2</a>). Так же
              используется для логического отрицания в операциях
              сравнения, например, операция сравнения <span
               class="QUOTE">&quot;равно&quot;</span> ( <a
               href="#x2565_html_EQUALSIGNREF">=</a> ), при
              использовании оператора отрицания, преобразуется в
              операцию сравнения -- <span
               class="QUOTE">&quot;не равно&quot;</span> ( != ). Символ
              <span
               class="TOKEN">!</span> является зарезервированным
              ключевым словом BASH.</p>
            </div>

            <p>В некоторых случаях символ <span
             class="TOKEN">!</span> используется для <a
             href="#x4788_html_IVR2">косвенного обращения к
            переменным</a>.</p>

            <p>Кроме того, из <span
             class="emphasis"><em
             class="EMPHASIS">командной строки</em></span> оператор
            <span
             class="TOKEN">!</span> запускает <span
             class="emphasis"><em
             class="EMPHASIS">механизм историй</em></span> Bash (см. <a
             href="#a15070_html">Приложение F</a>). Примечательно, что
            этот механизм недоступен из сценариев (т.е. исключительно
            из командной строки).</p>
          </dd>

          <dt><span
           class="TOKEN">*</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong>символ-шаблон.</strong> [звездочка] Символ
              <span
               class="TOKEN">*</span> служит <span
               class="QUOTE">&quot;шаблоном&quot;</span> для <a
               href="#x12282_html">подстановки</a> в имена файлов.
              Одиночный символ <span
               class="TOKEN">*</span> означает любое имя файла в
              заданном каталоге.</p>
            </div>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo *</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">abs-book.sgml add-drive.sh agram.sh alias.sh</tt>
             
</pre>
            <br>
            <br>

            <p>В <a
             href="#c11895_html_REGEXREF">регулярных выражениях</a>
            токен <span
             class="TOKEN">*</span> представляет любое количество (в
            том числе и 0) символов.</p>
          </dd>

          <dt><span
           class="TOKEN">*</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong><a
               href="#c2792_html_AROPS1">арифметический
              оператор</a>.</strong> В арифметических выражениях символ
              <span
               class="TOKEN">*</span> обозначает операцию
              умножения.</p>
            </div>

            <p>Двойная звездочка (два символа звездочки, следующих
            подряд друг за другом -- <span
             class="TOKEN">**</span>), обозначает операцию <a
             href="#c2792_html_EXPONENTIATIONREF">возведения в
            степень</a>.</p>
          </dd>

          <dt><span
           class="TOKEN">?</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong>Оператор проверки условия.</strong> В
              некоторых выражениях символ <span
               class="TOKEN">?</span> служит для проверки выполнения
              условия.</p>
            </div>

            <p>В <a
             href="#x4862_html">конструкциях с двойными скобками</a>,
            символ <span
             class="TOKEN">?</span> подобен трехместному оператору
            языка C. См. <a
             href="#x4862_html_CVARS">Пример 9-28</a>.</p>

            <p>В выражениях с <a
             href="#x4462_html_PARAMSUBREF">подстановкой параметра</a>,
            символ <span
             class="TOKEN">?</span> <a
             href="#x4462_html_QERRMSG">проверяет -- установлена ли
            переменная</a>.</p>
          </dd>

          <dt><span
           class="TOKEN">?</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong>сивол-шаблон.</strong> Символ <span
               class="TOKEN">?</span> обозначает одиночный символ при
              <a
               href="#x12282_html">подстановке</a> в имена файлов. В <a
               href="#c11895_html_EXTREGEX">регулярных выражениях</a>
              служит для обозначения <a
               href="#c11895_html_QUEXREGEX">одиночного символа</a>.</p>
            </div>
          </dd>

          <dt><span
           class="TOKEN">$</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong><a
               href="#c1613_html_VARSUBN">Подстановка
              переменной</a>.</strong></p>
<pre
 class="PROGRAMLISTING">
var1=5
var2=23skidoo

echo $var1     # 5
echo $var2     # 23skidoo
</pre>
              <br>
              <br>
            </div>

            <p>Символ <span
             class="TOKEN">$</span>, предшествующий имени переменной,
            указывает на то, что будет получено <span
             class="emphasis"><em
             class="EMPHASIS">значение</em></span> переменной.</p>
          </dd>

          <dt><span
           class="TOKEN">$</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong>end-of-line (конец строки).</strong> В <a
               href="#c11895_html_REGEXREF">регулярных выражениях</a>,
              символ <span
               class="QUOTE">&quot;$&quot;</span> обозначает конец
              строки.</p>
            </div>
          </dd>

          <dt><span
           class="TOKEN">${}</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong><a
               href="#x4462_html_PARAMSUBREF">Подстановка
              параметра</a>.</strong></p>
            </div>
          </dd>

          <dt><span
           class="TOKEN">$*</span>, <span
           class="TOKEN">$@</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong><a
               href="#c3270_html_APPREF">параметры командной
              строки</a>.</strong></p>
            </div>
          </dd>

          <dt><span
           class="TOKEN">$?</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong>код завершения.</strong> <a
               href="#c2105_html_EXSREF">Переменная $?</a> хранит <a
               href="#c2105_html_EXITSTATUSREF">код завершения</a>
              последней выполненной команды, <a
               href="#c12483_html_FUNCTIONREF">функции</a> или
              сценария.</p>
            </div>
          </dd>

          <dt><span
           class="TOKEN">$$</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong>id процесса.</strong> <a
               href="#c3270_html_PROCCID">Переменная $$</a> хранит <span
               class="emphasis"><em
               class="EMPHASIS">id процесса</em></span> сценария.</p>
            </div>
          </dd>

          <dt><span
           class="TOKEN">()</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong>группа команд.</strong></p>
<pre
 class="PROGRAMLISTING">
(a=hello; echo $a)
</pre>
              <br>
              <br>
            </div>

            <div
             class="IMPORTANT">
              <table
               class="IMPORTANT"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/important.gif"
                   hspace="5"
                   alt="Important"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Команды, заключенные в <tt
                     class="REPLACEABLE"><em>круглые скобки</em></tt>
                    исполняются в дочернем процессе -- <a
                     href=
                    "#c12330_html_SUBSHELLSREF">subshell-е</a>.</p>

                    <p>Переменные, создаваемые в дочернем процессе не
                    видны в &quot;родительском&quot; сценарии.
                    Родительский процесс-сценарий, <a
                     href="#c12330_html_PARVIS">не может обращаться к
                    переменным, создаваемым в дочернем
                    процессе</a>.</p>
<pre
 class="PROGRAMLISTING">
a=123
( a=321; )

echo &quot;a = $a&quot;   # a = 123
# переменная &quot;a&quot; в скобках подобна локальной переменной.
</pre>
                    <br>
                    <br>
                  </td>
                </tr>
              </table>
            </div>

            <div
             class="FORMALPARA">
              <p><strong>инициализация массивов.</strong></p>
<pre
 class="PROGRAMLISTING">
Array=(element1 element2 element3)
</pre>
              <br>
              <br>
            </div>
          </dd>

          <dt><span
           class="TOKEN">{xxx,yyy,zzz,...}</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong>Фигурные скобки.</strong></p>
<pre
 class="PROGRAMLISTING">
grep Linux file*.{txt,htm*}
# Поиск всех вхождений слова &quot;Linux&quot;
# в файлах &quot;fileA.txt&quot;, &quot;file2.txt&quot;, &quot;fileR.html&quot;, &quot;file-87.htm&quot;, и пр.
</pre>
              <br>
              <br>
            </div>

            <p>Команда интерпретируется как список команд, разделенных
            точкой с запятой, с вариациями, представленными в <tt
             class="REPLACEABLE"><em>фигурных скобках</em></tt>. <a
             name="AEN901"
             href="#c301_html_FTN_AEN901"><span
             class="footnote">[1]</span></a> При интерпретации имен
            файлов (<a
             href="#x12282_html">подстановка</a>) используются
            параметры, заключенные в фигурные скобки.</p>

            <div
             class="CAUTION">
              <table
               class="CAUTION"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/caution.gif"
                   hspace="5"
                   alt="Caution"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Использование <span
                     class="emphasis"><em
                     class="EMPHASIS">неэкранированных или
                    неокавыченных</em></span> пробелов внутри фигурных
                    скобок недопустимо.</p>

                    <p><tt
                     class="USERINPUT"><strong>echo {file1,file2}\ :{\
                    A,&quot; B&quot;,&#39; C&#39;}</strong></tt></p>

                    <p><tt
                     class="COMPUTEROUTPUT">file1 : A file1 : B file1 :
                    C file2 : A file2 : B file2 : C</tt></p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><span
           class="TOKEN">{}</span></dt>

          <dd>
            <p><a
             name="c301_html_CODEBLOCKREF"></a></p>

            <div
             class="FORMALPARA">
              <p><strong>Блок кода.</strong> [фигурные скобки] Известен
              так же как <span
               class="QUOTE">&quot;вложенный блок&quot;</span>, эта
              конструкция, фактически, создает анонимную функцию.
              Однако, в отличии от обычных <a
               href="#c12483_html_FUNCTIONREF">функций</a>, переменные,
              создаваемые во вложенных блоках кода, доступны
              объемлющему сценарию.</p>
            </div>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>{ local a; a=123; }</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">bash: local: can only be used in a function</tt>
             
</pre>
            <br>
            <br>
<pre
 class="PROGRAMLISTING">
a=123
{ a=321; }
echo &quot;a = $a&quot;   # a = 321   (значение, присвоенное во вложенном блоке кода)

# Спасибо, S.C.
</pre>
            <br>
            <br>

            <p>Код, заключенный в фигурные скобки, может выполнять <a
             href="#c11620_html_IOREDIRREF">перенаправление
            ввода-вывода</a>.</p>

            <div
             class="EXAMPLE">
              <a
               name="c301_html_EX8"></a>

              <p><strong>Пример 3-1. Вложенные блоки и перенаправление
              ввода-вывода</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Чтение строк из файла /etc/fstab.

File=/etc/fstab

{
read line1
read line2
} &lt; $File

echo &quot;Первая строка в $File :&quot;
echo &quot;$line1&quot;
echo
echo &quot;Вторая строка в $File :&quot;
echo &quot;$line2&quot;

exit 0
</pre>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="c301_html_RPMCHECK"></a>

              <p><strong>Пример 3-2. Сохранение результата исполнения
              вложенного блока в файл</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# rpm-check.sh

# Запрашивает описание rpm-архива, список файлов, и проверяется возможность установки.
# Результат сохраняется в файле.
#
# Этот сценарий иллюстрирует порядок работы со вложенными блоками кода.

SUCCESS=0
E_NOARGS=65

if [ -z &quot;$1&quot; ]
then
  echo &quot;Порядок использования: `basename $0` rpm-file&quot;
  exit $E_NOARGS
fi

{
  echo
  echo &quot;Описание архива:&quot;
  rpm -qpi $1       # Запрос описания.
  echo
  echo &quot;Список файлов:&quot;
  rpm -qpl $1       # Запрос списка.
  echo
  rpm -i --test $1  # Проверка возможности установки.
  if [ &quot;$?&quot; -eq $SUCCESS ]
  then
    echo &quot;$1 может быть установлен.&quot;
  else
    echo &quot;$1 -- установка невозможна!&quot;
  fi
  echo
} &gt; &quot;$1.test&quot;       # Перенаправление вывода в файл.

echo &quot;Результаты проверки rpm-архива находятся в файле $1.test&quot;

# За дополнительной информацией по ключам команды rpm см. man rpm.

exit 0
</pre>
            </div>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>В отличие от групп команд в (круглых скобках),
                    описаных выше, вложенные блоки кода, заключенные в
                    {фигурные скобки} исполняются в пределах того же
                    процесса, что и сам скрипт (т.е. не вызывают запуск
                    дочернего процесса -- <a
                     href="#c12330_html_SUBSHELLSREF">subshell</a>). <a
                     name="AEN947"
                     href="#c301_html_FTN_AEN947"><span
                     class="footnote">[2]</span></a></p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><span
           class="TOKEN">{} \;</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong>pathname -- полное имя файла (т.е. путь к
              файлу и его имя).</strong> Чаще всего используется
              совместно с командой <a
               href="#x6646_html_FINDREF">find</a>.</p>
            </div>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Обратите внимание на то, что символ <span
                     class="QUOTE">&quot;<span
                     class="TOKEN">;</span>&quot;</span>, которым
                    завершается ключ <tt
                     class="OPTION">-exec</tt> команды <strong
                     class="COMMAND">find</strong>, экранируется
                    обратным слэшем. Это необходимо, чтобы
                    предотвратить его интерпретацию.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><span
           class="TOKEN">[ ]</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong>test.</strong></p>
            </div>

            <p><a
             name="c301_html_LEFTBRACKET"></a><a
             href="#c2171_html_IFTHEN">Проверка истинности</a>
            выражения, заключенного в квадратные скобки <strong
             class="COMMAND">[ ]</strong>. Примечательно, что <strong
             class="COMMAND">[</strong> является частью встроенной
            команды <strong
             class="COMMAND">test</strong> (и ее синонимом), И <span
             class="emphasis"><em
             class="EMPHASIS">не</em></span> имеет никакого отношения к
            &quot;внешней&quot; утилите <tt
             class="FILENAME">/usr/bin/test</tt>.</p>
          </dd>

          <dt><span
           class="TOKEN">[[ ]]</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong>test.</strong></p>
            </div>

            <p>Проверка истинности выражения, заключенного между <span
             class="TOKEN">[[ ]]</span> (<a
             href="#c5358_html_KEYWORDREF">зарезервированное слово</a>
            интерпретатора).</p>

            <p>См. описание конструкции <a
             href="#c2171_html_DBLBRACKETS">[[ ... ]]</a> ниже.</p>
          </dd>

          <dt><span
           class="TOKEN">[ ]</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong>элемент массива.</strong></p>
            </div>

            <p>При работе с <a
             href="#c12790_html_ARRAYREF">массивами</a> в квадратных
            скобках указывается порядковый номер того элемента массива,
            к которому производится обращение.</p>
<pre
 class="PROGRAMLISTING">
Array[1]=slot_1
echo ${Array[1]}
</pre>
            <br>
            <br>
          </dd>

          <dt><span
           class="TOKEN">[ ]</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong>диапазон символов.</strong></p>
            </div>

            <p>В <a
             href="#c11895_html_REGEXREF">регулярных выражениях</a>, в
            квадратных скобках задается <a
             href="#c11895_html_BRACKETSREF">диапазон искомых
            символов</a>.</p>
          </dd>

          <dt><span
           class="TOKEN">(( ))</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong>двойные круглые скобки.</strong></p>
            </div>

            <p>Вычисляется целочисленное выражение, заключенное между
            двойными круглыми скобками <span
             class="TOKEN">(( ))</span>.</p>

            <p>См. обсуждение, посвященное <a
             href="#x4862_html">конструкции (( ... ))</a> .</p>
          </dd>

          <dt><span
           class="TOKEN">&gt;</span> <span
           class="TOKEN">&amp;&gt;</span> <span
           class="TOKEN">&gt;&amp;</span> <span
           class="TOKEN">&gt;&gt;</span> <span
           class="TOKEN">&lt;</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong><a
               href=
              "#c11620_html_IOREDIRREF">перенаправление</a>.</strong></p>
            </div>

            <p>Конструкция <tt
             class="USERINPUT"><strong>scriptname
            &gt;filename</strong></tt> перенаправляет вывод <tt
             class="FILENAME">scriptname</tt> в файл <tt
             class="FILENAME">filename</tt>. Если файл <tt
             class="FILENAME">filename</tt> уже существовал, то его
            прежнее содержимое будет утеряно.</p>

            <p>Конструкция <tt
             class="USERINPUT"><strong>command
            &amp;&gt;filename</strong></tt> перенаправляет вывод
            команды <tt
             class="FILENAME">command</tt>, как со <tt
             class="FILENAME">stdout</tt>, так и с <tt
             class="FILENAME">stderr</tt>, в файл <tt
             class="FILENAME">filename</tt>.</p>

            <p>Конструкция <tt
             class="USERINPUT"><strong>command &gt;&amp;2</strong></tt>
            перенаправляет вывод со <tt
             class="FILENAME">stdout</tt> на <tt
             class="FILENAME">stderr</tt>.</p>

            <p>Конструкция <tt
             class="USERINPUT"><strong>scriptname
            &gt;&gt;filename</strong></tt> добавляет вывод <tt
             class="FILENAME">scriptname</tt> к файлу <tt
             class="FILENAME">filename</tt>. Если задано имя
            несуществующего файла, то он создается.</p>

            <div
             class="FORMALPARA">
              <p><strong><a
               href="#c12434_html_PROCESSSUBREF">подстановка
              процесса</a>.</strong></p>
            </div>

            <p><tt
             class="USERINPUT"><strong>(command)&gt;</strong></tt></p>

            <p><tt
             class="USERINPUT"><strong>&lt;(command)</strong></tt></p>

            <p>В <a
             href="#x2565_html_LTREF">операциях сравнения</a>, символы
            <span
             class="QUOTE">&quot;<span
             class="TOKEN">&lt;</span>&quot;</span> и <span
             class="QUOTE">&quot;<span
             class="TOKEN">&gt;</span>&quot;</span> обозначают операции
            <a
             href="#x2565_html_SCOMPARISON1">сравнения строк</a> .</p>

            <p><a
             href="#x2565_html_INTLT">А так же</a> -- операции <a
             href="#x2565_html_ICOMPARISON1">сравнения целых чисел</a>.
            См. так же <a
             href="#x6646_html_EX45">Пример 12-6</a>.</p>
          </dd>

          <dt><span
           class="TOKEN">&lt;&lt;</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong>перенаправление ввода на <a
               href="#c11785_html_HEREDOCREF">встроенный
              документ</a>.</strong></p>
            </div>
          </dd>

          <dt><span
           class="TOKEN">&lt;</span>, <span
           class="TOKEN">&gt;</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong><a
               href="#x2565_html_LTREF">Посимвольное
              ASCII-сравнение</a>.</strong></p>
<pre
 class="PROGRAMLISTING">
veg1=carrots
veg2=tomatoes

if [[ &quot;$veg1&quot; &lt; &quot;$veg2&quot; ]]
then
  echo &quot;Не смотря на то, что в словаре слово $veg1 предшествует слову $veg2,&quot;
  echo &quot;это никак не отражает мои кулинарные предпочтения.&quot;
else
  echo &quot;Интересно. Каким словарем вы пользуетесь?&quot;
fi
</pre>
              <br>
              <br>
            </div>
          </dd>

          <dt><span
           class="TOKEN">\&lt;</span>, <span
           class="TOKEN">\&gt;</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong><a
               href="#c11895_html_ANGLEBRAC">границы отдельных слов</a>
              в <a
               href="#c11895_html_REGEXREF">регулярных
              выражениях</a>.</strong></p>
            </div>

            <p><tt
             class="PROMPT">bash$</tt> <tt
             class="USERINPUT"><strong>grep &#39;\&lt;the\&gt;&#39;
            textfile</strong></tt></p>
          </dd>

          <dt><span
           class="TOKEN">|</span></dt>

          <dd>
            <p><a
             name="c301_html_PIPEREF"></a></p>

            <div
             class="FORMALPARA">
              <p><strong>конвейер.</strong> Передает вывод предыдущей
              команды на ввод следующей или на вход командного
              интерпретатора shell. Этот метод часто используется для
              связывания последовательности команд в единую
              цепочку.</p>
            </div>
<pre
 class="PROGRAMLISTING">
echo ls -l | sh
#  Передает вывод &quot;echo ls -l&quot; команлному интерпретатору shell,
#+ тот же результат дает простая команда &quot;ls -l&quot;.


cat *.lst | sort | uniq
# Объединяет все файлы &quot;.lst&quot;, сортирует содержимое и удаляет повторяющиеся строки.
</pre>
            <br>
            <br>

            <table
             class="SIDEBAR"
             border="1"
             cellpadding="5">
              <tr>
                <td>
                  <div
                   class="SIDEBAR">
                    <a
                     name="c301_html_AEN1202"></a>

                    <p>Конвейеры (еще их называют каналами) -- это
                    классический способ взаимодействия процессов, с
                    помощью которого <tt
                     class="FILENAME">stdout</tt> одного процесса
                    перенаправляется на <tt
                     class="FILENAME">stdin</tt> другого. Обычно
                    используется совместно с командами вывода, такими
                    как <a
                     href="#c6407_html_CATREF">cat</a> или <a
                     href="#c5358_html_ECHOREF">echo</a>, от которых
                    поток данных поступает в <span
                     class="QUOTE">&quot;фильтр&quot;</span> (команда,
                    которая на входе получает данные, преобразует их и
                    обрабатывает).</p>

                    <p><tt
                     class="USERINPUT"><strong>cat $filename | grep
                    $search_word</strong></tt></p>
                  </div>
                </td>
              </tr>
            </table>

            <p><a
             name="c301_html_UCREF"></a>В конвейер могут объединяться и сценарии
            на языке командной оболочки.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# uppercase.sh : Преобразование вводимых символов в верхний регистр.

tr &#39;a-z&#39; &#39;A-Z&#39;
#  Диапазоны символов должны быть заключены в кавычки
#+ чтобы предотвратить порождение имен файлов от однобуквенных имен файлов.

exit 0
</pre>
            А теперь попробуем объединить в конвейер команду <strong
             class="COMMAND">ls -l</strong> с этим сценарием. 
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ls -l | ./uppercase.sh</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">-RW-RW-R--    1 BOZO  BOZO       109 APR  7 19:49 1.TXT
 -RW-RW-R--    1 BOZO  BOZO       109 APR 14 16:48 2.TXT
 -RW-R--R--    1 BOZO  BOZO       725 APR 20 20:56 DATA-FILE</tt>
             
</pre>
            <br>
            <br>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Выход <tt
                     class="FILENAME">stdout</tt> каждого процесса в
                    конвейере должен читаться на входе <tt
                     class="FILENAME">stdin</tt> последующим, в
                    конвейере, процессом. Если этого не делается, то
                    поток данных <span
                     class="emphasis"><em
                     class="EMPHASIS">блокируется</em></span>, в
                    результате конвейер будет работать не так как
                    ожидается.</p>
<pre
 class="PROGRAMLISTING">
cat file1 file2 | ls -l | sort
# Вывод команды &quot;cat file1 file2&quot; будет утерян.
</pre>
                    <br>
                    <br>

                    <p>Конвейер исполняется в <a
                     href="#x1716_html_CHILDREF">дочернем процессе</a>,
                    а посему -- не имеет доступа к переменным
                    сценария.</p>
<pre
 class="PROGRAMLISTING">
variable=&quot;initial_value&quot;
echo &quot;new_value&quot; | read variable
echo &quot;variable = $variable&quot;     # variable = initial_value
</pre>
                    <br>
                    <br>

                    <p>Если одна из команд в конвейере завершается
                    аварийно, то это приводит к аварийному завершению
                    работы всего конвейера.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><span
           class="TOKEN">&gt;|</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong>принудительное перенаправление, даже если
              установлен ключ <a
               href="#c13228_html_NOCLOBBERREF">noclobber
              option</a>.</strong></p>
            </div>
          </dd>

          <dt><span
           class="TOKEN">||</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong><a
               href="#c2792_html_ORREF">логическая операция OR
              (логическое ИЛИ)</a>.</strong> В <a
               href="#c2171_html_TESTCONSTRUCTS1">опрециях проверки
              условий</a>, оператор <span
               class="TOKEN">||</span> возвращает <span
               class="RETURNVALUE">0</span> (success), если один из
              операндов имеет значение true (ИСТИНА).</p>
            </div>
          </dd>

          <dt><span
           class="TOKEN">&amp;</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong>Выполнение задачи в фоне.</strong> Команда, за
              которой стоит <span
               class="TOKEN">&amp;</span>, будет исполняться в фоновом
              режиме.</p>
            </div>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>sleep 10 &amp;</strong></tt>
<tt
 class="COMPUTEROUTPUT">[1] 850</tt>
<tt
 class="COMPUTEROUTPUT">[1]+  Done                    sleep 10</tt>
             
</pre>
            <br>
            <br>

            <p>В сценариях команды, и даже <a
             href="#c4875_html_FORLOOPREF1">циклы</a> могут запускаться
            в фоновом режиме.</p>

            <div
             class="EXAMPLE">
              <a
               name="c301_html_BGLOOP"></a>

              <p><strong>Пример 3-3. Запуск цикла в фоновом
              режиме</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# background-loop.sh

for i in 1 2 3 4 5 6 7 8 9 10            # Первый цикл.
do
  echo -n &quot;$i &quot;
done &amp; # Запуск цикла в фоне.
       # Иногда возможны случаи выполнения этого цикла после второго цикла.

echo   # Этот &#39;echo&#39; иногда не отображается на экране.

for i in 11 12 13 14 15 16 17 18 19 20   # Второй цикл.
do
  echo -n &quot;$i &quot;
done

echo   # Этот &#39;echo&#39; иногда не отображается на экране.

# ======================================================

# Ожидается, что данный сценарий выведет следующую последовательность:
# 1 2 3 4 5 6 7 8 9 10
# 11 12 13 14 15 16 17 18 19 20

# Иногда возможен такой вариант:
# 11 12 13 14 15 16 17 18 19 20
# 1 2 3 4 5 6 7 8 9 10 bozo $
# (Второй &#39;echo&#39; не был выполнен. Почему?)

# Изредка возможен такой вариант:
# 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
# (Первый &#39;echo&#39; не был выполнен. Почему?)

# Крайне редко встречается и такое:
# 11 12 13 1 2 3 4 5 6 7 8 9 10 14 15 16 17 18 19 20
# Второй цикл начал исполняться раньше первого.

exit 0
</pre>
            </div>

            <div
             class="CAUTION">
              <table
               class="CAUTION"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/caution.gif"
                   hspace="5"
                   alt="Caution"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Команда, исполняемая в пределах сценария в фоне,
                    может подвесить сценарий, ожидая нажатия клавиши. К
                    счастью, это легко <a
                     href=
                    "#c5358_html_WAITHANG">&quot;лечится&quot;</a>.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><span
           class="TOKEN">&amp;&amp;</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong><a
               href="#c2792_html_LOGOPS1">Логическая операция AND
              (логическое И)</a>.</strong> В <a
               href="#c2171_html_TESTCONSTRUCTS1">операциях проверки
              условий</a>, оператор <span
               class="TOKEN">&amp;&amp;</span> возвращает <span
               class="RETURNVALUE">0</span> (success) тогда, и только
              тогда, когда <span
               class="emphasis"><em
               class="EMPHASIS">оба</em></span> операнда имеют значение
              true (ИСТИНА).</p>
            </div>
          </dd>

          <dt><a
           name="c301_html_DASHREF"></a><span
           class="TOKEN">-</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong>префикс ключа.</strong> С этого символа
              начинаются опциональные ключи команд.</p>
            </div>

            <p><tt
             class="USERINPUT"><strong>COMMAND
            -[Option1][Option2][...]</strong></tt></p>

            <p><tt
             class="USERINPUT"><strong>ls -al</strong></tt></p>

            <p><tt
             class="USERINPUT"><strong>sort -dfu
            $filename</strong></tt></p>

            <p><tt
             class="USERINPUT"><strong>set --
            $variable</strong></tt></p>
<pre
 class="PROGRAMLISTING">
if [ $file1 -ot $file2 ]
then
  echo &quot;Файл $file1 был создан раньше чем $file2.&quot;
fi

if [ &quot;$a&quot; -eq &quot;$b&quot; ]
then
  echo &quot;$a равно $b.&quot;
fi

if [ &quot;$c&quot; -eq 24 -a &quot;$d&quot; -eq 47 ]
then
  echo &quot;$c равно 24, а $d равно 47.&quot;
fi
</pre>
            <br>
            <br>
          </dd>

          <dt><span
           class="TOKEN">-</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong>перенаправление из/в <tt
               class="FILENAME">stdin</tt> или <tt
               class="FILENAME">stdout</tt>.</strong> <a
               name="c301_html_COXEX"></a>[дефис]</p>
            </div>
<pre
 class="PROGRAMLISTING">
(cd /source/directory &amp;&amp; tar cf - . ) | (cd /dest/directory &amp;&amp; tar xpvf -)
# Перемещение полного дерева файлов и подкаталогов из одной директории в другую
# [спасибо Алану Коксу (Alan Cox) &lt;a.cox@swansea.ac.uk&gt;, за небольшие поправки]

# 1) cd /source/directory    Переход в исходный каталог, содержимое которого будет перемещено
# 2) &amp;&amp;                     &quot;И-список&quot;: благодаря этому все последующие команды будут выполнены
#                            только тогда, когда &#39;cd&#39; завершится успешно
# 3) tar cf - .              ключом &#39;c&#39; архиватор &#39;tar&#39; создает новый архив,
#                            ключом &#39;f&#39; (file) и последующим &#39;-&#39; задается файл архива -- stdout,
#                            в архив помещается текущий каталог (&#39;.&#39;) с вложенными подкаталогами.
# 4) |                       конвейер с ...
# 5) ( ... )                 subshell-ом (дочерним экземпляром командной оболочки)
# 6) cd /dest/directory      Переход в каталог назначения.
# 7) &amp;&amp;                     &quot;И-список&quot;, см. выше
# 8) tar xpvf -              Разархивирование (&#39;x&#39;), с сохранением атрибутов &quot;владельца&quot; и прав доступа (&#39;p&#39;) к файлам,
#                            с выдачей более подробных сообщений на stdout (&#39;v&#39;),
#                            файл архива -- stdin (&#39;f&#39; с последующим &#39;-&#39;).
#
#                            Примечательно, что &#39;x&#39; -- это команда, а &#39;p&#39;, &#39;v&#39; и &#39;f&#39; -- ключи
# Во как!



# Более элегантный вариант:
#   cd source-directory
#   tar cf - . | (cd ../target-directory; tar xzf -)
#
# cp -a /source/directory /dest     имеет тот же эффект.
</pre>
            <br>
            <br>
<pre
 class="PROGRAMLISTING">
bunzip2 linux-2.4.3.tar.bz2 | tar xvf -
# --разархивирование tar-файла--    | --затем файл передается утилите &quot;tar&quot;--
# Если у вас утилита &quot;tar&quot; не поддерживает работу с &quot;bunzip2&quot;,
# тогда придется выполнять работу в два этапа, с использованием конвейера.
# Целью данного примера является разархивирование тарбола (tar.bz2) с исходными текстами ядра.
</pre>
            <br>
            <br>

            <p>Обратите внимание, что в этом контексте <span
             class="QUOTE">&quot;-&quot;</span> - не самостоятельный
            оператор Bash, а скорее опция, распознаваемая некоторыми
            утилитами UNIX (такими как <strong
             class="COMMAND">tar</strong>, <strong
             class="COMMAND">cat</strong> и т.п.), которые выводят
            результаты своей работы в <tt
             class="FILENAME">stdout</tt>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>echo &quot;whatever&quot; | cat -</strong></tt>
<tt
 class="COMPUTEROUTPUT">whatever</tt>
</pre>
            <br>
            <br>

            <p>В случае, когда ожидается имя файла, тогда <span
             class="QUOTE">&quot;-&quot;</span> перенаправляет вывод на
            <tt
             class="FILENAME">stdout</tt> (вспомните пример с <tt
             class="USERINPUT"><strong>tar cf</strong></tt>) или
            принимает ввод с <tt
             class="FILENAME">stdin</tt>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>file</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">Usage: file [-bciknvzL] [-f namefile] [-m magicfiles] file...</tt>
             
</pre>
            Сама по себе команда <a
             href="#x7794_html_FILEREF">file</a> без параметров
            завершается с сообщением об ошибке. <br>
            <br>

            <p>Добавим символ <span
             class="QUOTE">&quot;-&quot;</span> и получим более
            полезный результат. Это заставит командный интерпретатор
            ожидать ввода от пользователя.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>file -</strong></tt>
<tt
 class="USERINPUT"><strong>abc</strong></tt>
<tt
 class="COMPUTEROUTPUT">standard input:              ASCII text</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>file -</strong></tt>
<tt
 class="USERINPUT"><strong>#!/bin/bash</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">standard input:              Bourne-Again shell script text executable</tt>
             
</pre>
            Теперь команда принимает ввод пользователя со <tt
             class="FILENAME">stdin</tt> и анализирует его. <br>
            <br>

            <p>Используя передачу <tt
             class="FILENAME">stdout</tt> по конвейеру другим командам,
            можно выполнять довольно эффектные трюки, например <a
             href="#x13753_html_PREPENDREF">вставка строк в начало
            файла</a>.</p>

            <p>С помощью команды <a
             href="#x7794_html_DIFFREF">diff</a> -- находить различия
            между одним файлом и <span
             class="emphasis"><em
             class="EMPHASIS">частью</em></span> другого:</p>

            <p><tt
             class="USERINPUT"><strong>grep Linux file1 | diff file2
            -</strong></tt></p>

            <p>И наконец пример использования служебного символа <tt
             class="REPLACEABLE"><em>&quot;-&quot;</em></tt> с командой
            <a
             href="#x7794_html_TARREF">tar</a>.</p>

            <div
             class="EXAMPLE">
              <a
               name="c301_html_EX58"></a>

              <p><strong>Пример 3-4. Резервное архивирование всех
              файлов, которые были изменены в течение последних
              суток</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Резервное архивирование (backup) всех файлов в текущем каталоге,
# которые были изменены в течение последних 24 часов
#+ в тарболл (tarball) (.tar.gz - файл).

BACKUPFILE=backup
archive=${1:-$BACKUPFILE}
#  На случай, если имя архива в командной строке не задано,
#+ т.е. по-умолчанию имя архива -- &quot;backup.tar.gz&quot;

tar cvf - `find . -mtime -1 -type f -print` &gt; $archive.tar
gzip $archive.tar
echo &quot;Каталог $PWD заархивирован в файл \&quot;$archive.tar.gz\&quot;.&quot;


#  Stephane Chazelas заметил, что вышеприведенный код будет &quot;падать&quot;
#+ если будет найдено слишком много файлов
#+ или если имена файлов будут содержать символы пробела.

# Им предложен альтернативный код:
# -------------------------------------------------------------------
#   find . -mtime -1 -type f -print0 | xargs -0 tar rvf &quot;$archive.tar&quot;
#      используется версия GNU утилиты &quot;find&quot;.


#   find . -mtime -1 -type f -exec tar rvf &quot;$archive.tar&quot; &#39;{}&#39; \;
#         более универсальный вариант, хотя и более медленный,
#         зато может использоваться в других версиях UNIX.
# -------------------------------------------------------------------


exit 0
</pre>
            </div>

            <div
             class="CAUTION">
              <table
               class="CAUTION"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/caution.gif"
                   hspace="5"
                   alt="Caution"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Могут возникнуть конфликтные ситуации между
                    опреатором перенаправления <span
                     class="QUOTE">&quot;-&quot;</span> и именами
                    файлов, начинающимися с символа <span
                     class="QUOTE">&quot;-&quot;</span>. Поэтому
                    сценарий должен проверять имена файлов и
                    предаварять их префиксом пути, например, <tt
                     class="FILENAME">./-FILENAME</tt>, <tt
                     class="FILENAME">$PWD/-FILENAME</tt> или <tt
                     class="FILENAME">$PATHNAME/-FILENAME</tt>.</p>

                    <p>Если значение переменной начинается с символа
                    <span
                     class="QUOTE">&quot;-&quot;</span>, то это тоже
                    может быть причиной появления ошибок.</p>
<pre
 class="PROGRAMLISTING">
var=&quot;-n&quot;
echo $var
# В данном случае команда приобретет вид &quot;echo -n&quot; и ничего не выведет.
</pre>
                    <br>
                    <br>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><span
           class="TOKEN">-</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong>предыдущий рабочий каталог.</strong> [дефис]
              Команда <strong
               class="COMMAND">cd -</strong> выполнит переход в
              предыдущий рабочий каталог, путь к которому хранится в <a
               href="#x1716_html_ENVREF">переменной окружения</a> <a
               href="#c3270_html_OLDPWD">$OLDPWD</a> .</p>
            </div>

            <div
             class="CAUTION">
              <table
               class="CAUTION"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/caution.gif"
                   hspace="5"
                   alt="Caution"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Не путайте оператор <span
                     class="QUOTE">&quot;-&quot;</span> (предыдущего
                    рабочего каталога) с оператором <span
                     class="QUOTE">&quot;-&quot;</span>
                    (переназначения). Еще раз напомню, что
                    интерпретация символа <span
                     class="QUOTE">&quot;-&quot;</span> зависит от
                    контекста, в котором он употребляется.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><span
           class="TOKEN">-</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong>Минус.</strong> Знак минус в <a
               href="#c2792_html_AROPS1">арифметических
              операциях</a>.</p>
            </div>
          </dd>

          <dt><span
           class="TOKEN">=</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong>Символ &quot;равно&quot;.</strong> <a
               href="#x1673_html_EQREF">Оператор присваивания</a></p>
<pre
 class="PROGRAMLISTING">
a=28
echo $a   # 28
</pre>
              <br>
              <br>
            </div>

            <p>В зависимости от <a
             href="#x2565_html_EQUALSIGNREF">контекста применения</a>,
            символ <span
             class="QUOTE">&quot;<span
             class="TOKEN">=</span>&quot;</span> может выступать в
            качестве оператора <a
             href="#x2565_html_SCOMPARISON1">сравнения</a>.</p>
          </dd>

          <dt><span
           class="TOKEN">+</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong>Плюс.</strong> Оператор сложения в <a
               href="#c2792_html_AROPS1">арифметических
              операциях</a>.</p>
            </div>

            <p>В зависимости от <a
             href="#c11895_html_PLUSREF">контекста применения</a>,
            символ <span
             class="TOKEN">+</span> может выступать как оператор <a
             href="#c11895_html">регулярного выражения</a>.</p>
          </dd>

          <dt><span
           class="TOKEN">+</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong>Ключ (опция).</strong> Дополнительный флаг для
              ключей (опций) команд.</p>
            </div>

            <p>Отдельные внешние и <a
             href="#c5358_html_BUILTINREF">встроенные</a> команды
            используют символ <span
             class="QUOTE">&quot;<span
             class="TOKEN">+</span>&quot;</span> для разрешения
            некоторой опции, а символ <span
             class="QUOTE">&quot;<span
             class="TOKEN">-</span>&quot;</span> -- для запрещения.</p>
          </dd>

          <dt><span
           class="TOKEN">%</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong><a
               href="#c2792_html_MODULOREF">модуль</a>.</strong> Модуль
              (остаток от деления) -- <a
               href="#c2792_html_AROPS1">арифметическая
              операция</a>.</p>
            </div>

            <p>В зависимости от <a
             href="#x4462_html_PCTPATREF">контекста применения</a>,
            символ <span
             class="TOKEN">%</span> может выступать в качестве <a
             href="#x4462_html_PSUB2">шаблона</a>.</p>
          </dd>

          <dt><span
           class="TOKEN">~</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong>домашний каталог.</strong> [тильда]
              Соответствует содержимому внутренней переменной <a
               href="#c3270_html_HOMEDIRREF">$HOME</a>. <span
               class="emphasis"><em
               class="EMPHASIS">~bozo</em></span> -- домашний каталог
              пользователя bozo, а команда <strong
               class="COMMAND">ls ~bozo</strong> выведет содержимое его
              домашнего каталога. <span
               class="TOKEN">~/</span> -- это домашний каталог текущего
              пользователя, а команда <strong
               class="COMMAND">ls ~/</strong> выведет содержимое
              домашнего каталога текущего пользователя.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo ~bozo</strong></tt>
<tt
 class="COMPUTEROUTPUT">/home/bozo</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo ~</strong></tt>
<tt
 class="COMPUTEROUTPUT">/home/bozo</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo ~/</strong></tt>
<tt
 class="COMPUTEROUTPUT">/home/bozo/</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo ~:</strong></tt>
<tt
 class="COMPUTEROUTPUT">/home/bozo:</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo ~nonexistent-user</strong></tt>
<tt
 class="COMPUTEROUTPUT">~nonexistent-user</tt>
             
</pre>
              <br>
              <br>
            </div>
          </dd>

          <dt><span
           class="TOKEN">~+</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong>текущий рабочий каталог.</strong>
              Соответствует содержимому внутренней переменной <a
               href="#c3270_html_PWDREF">$PWD</a>.</p>
            </div>
          </dd>

          <dt><span
           class="TOKEN">~-</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong>предыдущий рабочий каталог.</strong>
              Соответствует содержимому внутренней переменной <a
               href="#c3270_html_OLDPWD">$OLDPWD</a>.</p>
            </div>
          </dd>

          <dt><span
           class="TOKEN">^</span></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong>начало-строки.</strong> В <a
               href="#c11895_html_REGEXREF">регулярных выражениях</a>
              символ <span
               class="QUOTE">&quot;^&quot;</span> задает начало строки
              текста.</p>
            </div>
          </dd>

          <dt>Управляющий символ</dt>

          <dd>
            <p><a
             name="c301_html_CONTROLCHARREF"></a></p>

            <div
             class="FORMALPARA">
              <p><strong>изменяет поведение терминала или управляет
              выводом текста.</strong> Управляющий символ набирается с
              клавиатуры как комбинация <strong
               class="KEYCAP">CONTROL</strong> + <strong
               class="KEYCAP">&lt;клавиша&gt;</strong>.</p>
            </div>

            <ul>
              <li>
                <p><tt
                 class="USERINPUT"><strong>Ctl-C</strong></tt></p>

                <p>Завершение выполнения процесса.</p>
              </li>

              <li>
                <p><a
                 name="c301_html_CTLDREF"></a></p>

                <p><tt
                 class="USERINPUT"><strong>Ctl-D</strong></tt></p>

                <p>Выход из командного интерпретатора (log out) (аналог
                команды <a
                 href="#c2105_html_EXITCOMMANDREF">exit</a>).</p>

                <p><span
                 class="QUOTE">&quot;EOF&quot;</span> (признак конца
                файла). Этот символ может выступать в качестве
                завершающего при вводе с <tt
                 class="FILENAME">stdin</tt>.</p>
              </li>

              <li>
                <p><tt
                 class="USERINPUT"><strong>Ctl-G</strong></tt></p>

                <p><span
                 class="QUOTE">&quot;BEL&quot;</span> (звуковой сигнал
                -- &quot;звонок&quot;).</p>
              </li>

              <li>
                <p><tt
                 class="USERINPUT"><strong>Ctl-H</strong></tt></p>

                <p>Backspace -- удаление предыдущего символа.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Вставка символа Ctl-H в строку.

a=&quot;^H^H&quot;                  # Два символа Ctl-H (backspace).
echo &quot;abcdef&quot;             # abcdef
echo -n &quot;abcdef$a &quot;       # abcd f
# Пробел в конце ^              ^ двойной шаг назад.
echo -n &quot;abcdef$a&quot;        # abcdef
# Пробела в конце нет             backspace не работает (почему?).
# Результаты могут получиться совсем не те, что вы ожидаете.
echo; echo
</pre>
                <br>
                <br>
              </li>

              <li>
                <p><tt
                 class="USERINPUT"><strong>Ctl-J</strong></tt></p>

                <p>Возврат каретки.</p>
              </li>

              <li>
                <p><tt
                 class="USERINPUT"><strong>Ctl-L</strong></tt></p>

                <p>Перевод формата (очистка экрана (окна) терминала).
                Аналогична команде <a
                 href="#x9117_html_CLEARREF">clear</a>.</p>
              </li>

              <li>
                <p><tt
                 class="USERINPUT"><strong>Ctl-M</strong></tt></p>

                <p>Перевод строки.</p>
              </li>

              <li>
                <p><tt
                 class="USERINPUT"><strong>Ctl-U</strong></tt></p>

                <p>Стирание строки ввода.</p>
              </li>

              <li>
                <p><tt
                 class="USERINPUT"><strong>Ctl-Z</strong></tt></p>

                <p>Приостановка процесса.</p>
              </li>
            </ul>
          </dd>

          <dt>Пробельный символ</dt>

          <dd>
            <p><a
             name="c301_html_WHITESPACEREF"></a></p>

            <div
             class="FORMALPARA">
              <p><strong>используется как разделитель команд или
              переменных.</strong> В качестве пробельного символа могут
              выступать -- собственно пробел (space), символ табуляции,
              символ перевода строки, символ возврата каретки или
              комбинация из вышеперечисленных символов. В некоторых
              случаях, таких как <a
               href="#c13371_html_WSBAD">присваивание значений
              переменным</a>, использование пробельных символов
              недопустимо.</p>
            </div>

            <p>Пустые строки никак не обрабатываются командным
            интерпретатором и могут свободно использоваться для
            визуального выделения отдельных блоков сценария.</p>

            <p><a
             href="#c3270_html_IFSREF">$IFS</a> -- переменная
            специального назначения. Содержит символы-разделители
            полей, используемые некоторыми командами. По-умолчанию --
            пробельные символы.</p>
          </dd>
        </dl>
      </div>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN901"
         href="#c301_html_AEN901"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Интерпретатор, встретив фигурные скобки, раскрывает их и
          возвращает полученный список команд, которые затем и
          исполняет.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN947"
         href="#c301_html_AEN947"><span
         class="footnote">[2]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Исключение: блок кода, являющийся частью конвейера, <span
           class="emphasis"><em
           class="EMPHASIS">может</em></span> быть запущен в дочернем
          процессе (<a
           href="#c12330_html_SUBSHELLSREF">subshell-е</a>).</p>
<pre
 class="PROGRAMLISTING">
ls | { read firstline; read secondline; }
# Ошибка! Вложенный блок будет запущен в дочернем процессе,
# таким образом, вывод команды &quot;ls&quot; не может быть записан в переменные
# находящиеся внутри блока.
echo &quot;Первая строка: $firstline; вторая строка: $secondline&quot;  # Не работает!

# Спасибо S.C.
</pre>
          <br>
          <br>
        </td>
      </tr>
    </table>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#p299_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#c1613_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Основы</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#p299_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Переменные и параметры. Введение.</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="c3270_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#p3268_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x4171_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="CHAPTER">
      <h1><a
       name="c3270_html_VARIABLES2"></a>Глава 9. К вопросу о переменных</h1>

      <p>Правильное использование переменных может придать сценариям
      дополнительную мощь и гибкость, а для этого необходимо изучить
      все тонкости и нюансы.</p>

      <div
       class="SECT1">
        <h1
         class="SECT1"><a
         name="c3270_html_INTERNALVARIABLES"></a>9.1. Внутренние переменные</h1>

        <div
         class="VARIABLELIST">
          <dl>
            <dt><tt
             class="REPLACEABLE"><em><a
             href="#c5358_html_BUILTINREF">Встроенные</a>
            переменные</em></tt></dt>

            <dt><tt
             class="VARNAME">$BASH</tt></dt>

            <dd>
              <p>путь к исполняемому файлу <span
               class="emphasis"><em
               class="EMPHASIS">Bash</em></span></p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo $BASH</strong></tt>
<tt
 class="COMPUTEROUTPUT">/bin/bash</tt>
</pre>
              <br>
              <br>
            </dd>

            <dt><tt
             class="VARNAME">$BASH_VERSINFO[n]</tt></dt>

            <dd>
              <p>это <a
               href="#c12790_html_ARRAYREF">массив</a>, состоящий из 6
              элементов, и содержащий информацию о версии Bash. Очень
              похожа на переменную <tt
               class="VARNAME">$BASH_VERSION</tt>, описываемую
              ниже.</p>
<pre
 class="PROGRAMLISTING">
# Информация о версии Bash:

for n in 0 1 2 3 4 5
do
  echo &quot;BASH_VERSINFO[$n] = ${BASH_VERSINFO[$n]}&quot;
done

# BASH_VERSINFO[0] = 2                      # Major version no.
# BASH_VERSINFO[1] = 05                     # Minor version no.
# BASH_VERSINFO[2] = 8                      # Patch level.
# BASH_VERSINFO[3] = 1                      # Build version.
# BASH_VERSINFO[4] = release                # Release status.
# BASH_VERSINFO[5] = i386-redhat-linux-gnu  # Architecture
                                            # (same as $MACHTYPE).
</pre>
              <br>
              <br>
            </dd>

            <dt><tt
             class="VARNAME">$BASH_VERSION</tt></dt>

            <dd>
              <p>версия Bash, установленного в системе</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo $BASH_VERSION</strong></tt>
<tt
 class="COMPUTEROUTPUT">2.04.12(1)-release</tt>
             
</pre>
              <br>
              <br>
<pre
 class="SCREEN">
<tt
 class="PROMPT">tcsh%</tt> <tt
 class="USERINPUT"><strong>echo $BASH_VERSION</strong></tt>
<tt
 class="COMPUTEROUTPUT">BASH_VERSION: Undefined variable.</tt>
             
</pre>
              <br>
              <br>

              <p>Проверка переменной $BASH_VERSION -- неплохой метод
              проверки типа командной оболочки, под которой исполняется
              скрипт. Переменная <a
               href="#c3270_html_SHELLVARREF">$SHELL</a> не всегда дает
              правильный ответ.</p>
            </dd>

            <dt><a
             name="c3270_html_DIRSTACKREF"></a><tt
             class="VARNAME">$DIRSTACK</tt></dt>

            <dd>
              <p>содержимое вершины стека каталогов (который
              управляется командами <a
               href="#c5358_html_PUSHDREF">pushd</a> и <a
               href="#c5358_html_POPDREF">popd</a>)</p>

              <p>Эта переменная соответствует команде <a
               href="#c5358_html_DIRSD">dirs</a>, за исключением того,
              что <strong
               class="COMMAND">dirs</strong> показывает полное
              содержимое всего стека каталогов.</p>
            </dd>

            <dt><tt
             class="VARNAME">$EDITOR</tt></dt>

            <dd>
              <p>заданный по-умолчанию редактор, вызываемый скриптом,
              обычно <strong
               class="COMMAND">vi</strong> или <strong
               class="COMMAND">emacs</strong>.</p>
            </dd>

            <dt><a
             name="c3270_html_EUIDREF"></a><tt
             class="VARNAME">$EUID</tt></dt>

            <dd>
              <p><span
               class="QUOTE">&quot;эффективный&quot;</span>
              идентификационный номер пользователя (Effective User
              ID)</p>

              <p>Идентификационный номер пользователя, права которого
              были получены, возможно с помощью команды <a
               href="#c9708_html_SUREF">su</a>.</p>

              <div
               class="CAUTION">
                <table
                 class="CAUTION"
                 width="90%"
                 border="0">
                  <tr>
                    <td
                     width="25"
                     align="center"
                     valign="top"><img
                     src="misc/abs-book/images/caution.gif"
                     hspace="5"
                     alt="Caution"></td>

                    <td
                     align="left"
                     valign="top">
                      <p>Значение переменной <tt
                       class="VARNAME">$EUID</tt> необязательно должно
                      совпадать с содержимым переменной <a
                       href="#c3270_html_UIDREF">$UID</a>.</p>
                    </td>
                  </tr>
                </table>
              </div>
            </dd>

            <dt><tt
             class="VARNAME">$FUNCNAME</tt></dt>

            <dd>
              <p>имя текущей функции</p>
<pre
 class="PROGRAMLISTING">
xyz23 ()
{
  echo &quot;Исполняется функция $FUNCNAME.&quot;  # Исполняется функция xyz23.
}

xyz23

echo &quot;FUNCNAME = $FUNCNAME&quot;        # FUNCNAME =
                                   # Пустое (Null) значение за пределеми функций.
</pre>
              <br>
              <br>
            </dd>

            <dt><tt
             class="VARNAME">$GLOBIGNORE</tt></dt>

            <dd>
              <p>Перечень шаблонных символов, которые будут
              проигнорированы при выполнении <a
               href="#x12282_html">подстановки имен файлов
              (globbing)</a> .</p>
            </dd>

            <dt><a
             name="c3270_html_GROUPSREF"></a><tt
             class="VARNAME">$GROUPS</tt></dt>

            <dd>
              <p>группы, к которым принадлежит текущий пользователь</p>

              <p>Это список групп (массив) идентификационных номеров
              групп для текущего пользователя, как эо записано в <tt
               class="FILENAME">/etc/passwd</tt>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">root#</tt> <tt
 class="USERINPUT"><strong>echo $GROUPS</strong></tt>
<tt
 class="COMPUTEROUTPUT">0</tt>


<tt
 class="PROMPT">root#</tt> <tt
 class="USERINPUT"><strong>echo ${GROUPS[1]}</strong></tt>
<tt
 class="COMPUTEROUTPUT">1</tt>


<tt
 class="PROMPT">root#</tt> <tt
 class="USERINPUT"><strong>echo ${GROUPS[5]}</strong></tt>
<tt
 class="COMPUTEROUTPUT">6</tt>
             
</pre>
              <br>
              <br>
            </dd>

            <dt><a
             name="c3270_html_HOMEDIRREF"></a><tt
             class="VARNAME">$HOME</tt></dt>

            <dd>
              <p>домашний каталог пользователя, как правило это <tt
               class="FILENAME">/home/username</tt> (см. <a
               href="#x4462_html_EX6">Пример 9-13</a>)</p>
            </dd>

            <dt><a
             name="c3270_html_HOSTNAMEREF"></a><tt
             class="VARNAME">$HOSTNAME</tt></dt>

            <dd>
              <p>Сетевое имя хоста устанавливается командой <a
               href="#c9708_html_HNAMEREF">hostname</a> во время
              исполнения инициализирующих сценариев на загрузке
              системы. Внутренняя переменная <tt
               class="VARNAME">$HOSTNAME</tt> Bash получает свое
              значение посредством вызова функции <tt
               class="FUNCTION">gethostname()</tt>. См. так же <a
               href="#x4462_html_EX6">Пример 9-13</a>.</p>
            </dd>

            <dt><tt
             class="VARNAME">$HOSTTYPE</tt></dt>

            <dd>
              <p>тип машины</p>

              <p>Подобно <a
               href="#c3270_html_MACHTYPEREF">$MACHTYPE</a>,
              идентифицирует аппаратную архитектуру.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo $HOSTTYPE</strong></tt>
<tt
 class="COMPUTEROUTPUT">i686</tt>
</pre>
            </dd>

            <dt><a
             name="c3270_html_IFSREF"></a><tt
             class="VARNAME">$IFS</tt></dt>

            <dd>
              <p>разделитель полей во вводимой строке (IFS -- Input
              Field Separator)</p>

              <p>По-умолчанию -- <a
               href="#c301_html_WHITESPACEREF">пробельный символ</a>
              (пробел, табуляция и перевод строки), но может быть
              изменен, например, для разбора строк, в которых отдельные
              поля разделены запятыми. Обратите внимание: при
              составлении содержимого переменной <a
               href="#c3270_html_APPREF">$*</a>, Bash использует первый
              символ из <tt
               class="VARNAME">$IFS</tt> для разделения аргументов. См.
              <a
               href="#c1833_html_WEIRDVARS">Пример 5-1</a>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo $IFS | cat -vte</strong></tt>
<tt
 class="COMPUTEROUTPUT">$</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>bash -c &#39;set w x y z; IFS=&quot;:-;&quot;; echo &quot;$*&quot;&#39;</strong></tt>
<tt
 class="COMPUTEROUTPUT">w:x:y:z</tt>
             
</pre>
              <br>
              <br>

              <div
               class="CAUTION">
                <table
                 class="CAUTION"
                 width="90%"
                 border="0">
                  <tr>
                    <td
                     width="25"
                     align="center"
                     valign="top"><img
                     src="misc/abs-book/images/caution.gif"
                     hspace="5"
                     alt="Caution"></td>

                    <td
                     align="left"
                     valign="top">
                      <p>При всем при том следует помнить, что при
                      использовании <tt
                       class="VARNAME">$IFS</tt> пробельные символы
                      обрабатываются несколько иначе, чем все
                      остальные.</p>

                      <div
                       class="EXAMPLE">
                        <a
                         name="c3270_html_IFSH"></a>

                        <p><strong>Пример 9-1. $IFS и пробельные
                        символы</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# При использовании $IFS, пробельные символы обрабатываются иначе, чем все остальные.

output_args_one_per_line()
{
  for arg
  do echo &quot;[$arg]&quot;
  done
}

echo; echo &quot;IFS=\&quot; \&quot;&quot;
echo &quot;-------&quot;

IFS=&quot; &quot;
var=&quot; a  b c   &quot;
output_args_one_per_line $var  # output_args_one_per_line `echo &quot; a  b c   &quot;`
#
# [a]
# [b]
# [c]


echo; echo &quot;IFS=:&quot;
echo &quot;-----&quot;

IFS=:
var=&quot;:a::b:c:::&quot;               # То же самое, только пробелы зменены символом &quot;:&quot;.
output_args_one_per_line $var
#
# []
# [a]
# []
# [b]
# [c]
# []
# []
# []

# То же самое происходит и с разделителем полей &quot;FS&quot; в awk.

# Спасибо Stephane Chazelas.

echo

exit 0
</pre>
                      </div>
                      <br>
                      <br>
                    </td>
                  </tr>
                </table>
              </div>

              <p>(Спасибо S. C., за разъяснения и примеры.)</p>
            </dd>

            <dt><tt
             class="VARNAME">$LC_COLLATE</tt></dt>

            <dd>
              <p>Чаще всего устанавливается в <tt
               class="FILENAME">.bashrc</tt> или <tt
               class="FILENAME">/etc/profile</tt>, эта переменная
              задает порядок сортировки символов, в операциях
              подстановки имен файлов и в поиске по шаблону. При
              неверной настройке переменной <tt
               class="VARNAME">LC_COLLATE</tt> можно получить весьма
              неожиданные результаты.</p>

              <div
               class="NOTE">
                <table
                 class="NOTE"
                 width="90%"
                 border="0">
                  <tr>
                    <td
                     width="25"
                     align="center"
                     valign="top"><img
                     src="misc/abs-book/images/note.gif"
                     hspace="5"
                     alt="Note"></td>

                    <td
                     align="left"
                     valign="top">
                      <p>Начиная с версии 2.05, Bash, в операциях
                      подстановки имен файлов, не делает различий между
                      символами верхнего и нижнего регистров, в
                      диапазонах символов в квадратных скобках.
                      Например,, <strong
                       class="COMMAND">ls [A-M]*</strong> выведет как
                      <tt
                       class="FILENAME">File1.txt</tt>, так и <tt
                       class="FILENAME">file1.txt</tt>. Возврат к
                      общепринятому стандарту поведения шаблонов в
                      квадратных скобках выполняется установкой
                      переменной <tt
                       class="VARNAME">LC_COLLATE</tt> в значение <tt
                       class="OPTION">C</tt> командой <tt
                       class="USERINPUT"><strong>export
                      LC_COLLATE=C</strong></tt> в файле <tt
                       class="FILENAME">/etc/profile</tt> и/или <tt
                       class="FILENAME">~/.bashrc</tt>.</p>
                    </td>
                  </tr>
                </table>
              </div>
            </dd>

            <dt><tt
             class="VARNAME">$LC_CTYPE</tt></dt>

            <dd>
              <p>Эта внутренняя переменная определяет кодировку
              символов. Используется в операциях <a
               href="#x12282_html">подстановки</a> и поиске по
              шаблону.</p>
            </dd>

            <dt><tt
             class="VARNAME">$LINENO</tt></dt>

            <dd>
              <p>Номер строки исполняемого сценария. Эта переменная
              имеет смысл только внутри исполняемого сценария и чаще
              всего применяется в отладочных целях.</p>
<pre
 class="PROGRAMLISTING">
# *** BEGIN DEBUG BLOCK ***
last_cmd_arg=$_  # Запомнить.

echo &quot;Строка $LINENO: переменная \&quot;v1\&quot; = $v1&quot;
echo &quot;Последний аргумент командной строки = $last_cmd_arg&quot;
# *** END DEBUG BLOCK ***
</pre>
              <br>
              <br>
            </dd>

            <dt><a
             name="c3270_html_MACHTYPEREF"></a><tt
             class="VARNAME">$MACHTYPE</tt></dt>

            <dd>
              <p>аппаратная архитектура</p>

              <p>Идентификатор аппаратной архитектуры.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo $MACHTYPE</strong></tt>
<tt
 class="COMPUTEROUTPUT">i686</tt>
</pre>
            </dd>

            <dt><a
             name="c3270_html_OLDPWD"></a><tt
             class="VARNAME">$OLDPWD</tt></dt>

            <dd>
              <p>прежний рабочий каталог (<span
               class=
              "QUOTE">&quot;OLD-Print-Working-Directory&quot;</span>)</p>
            </dd>

            <dt><tt
             class="VARNAME">$OSTYPE</tt></dt>

            <dd>
              <p>тип операционной системы</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo $OSTYPE</strong></tt>
<tt
 class="COMPUTEROUTPUT">linux</tt>
</pre>
            </dd>

            <dt><a
             name="c3270_html_PATHREF"></a><tt
             class="VARNAME">$PATH</tt></dt>

            <dd>
              <p>путь поиска, как правило включает в себя каталоги <tt
               class="FILENAME">/usr/bin/</tt>, <tt
               class="FILENAME">/usr/X11R6/bin/</tt>, <tt
               class="FILENAME">/usr/local/bin</tt>, и т.д.</p>

              <p>Когда командный интерпретатор получает команду, то он
              автоматически пытается отыскать соответствующий
              исполняемый файл в указанном списке каталогов (в
              переменной $PATH). Каталоги, в указанном списке, должны
              отделяться друг от друга двоеточиями. Обычно, переменная
              <tt
               class="VARNAME">$PATH</tt> инициализируется в <tt
               class="FILENAME">/etc/profile</tt> и/или в <tt
               class="FILENAME">~/.bashrc</tt> (см. <a
               href="#c12891_html">Глава 26</a>).</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <strong
 class="COMMAND">echo $PATH</strong>
<tt
 class=
"COMPUTEROUTPUT">/bin:/usr/bin:/usr/local/bin:/usr/X11R6/bin:/sbin:/usr/sbin</tt>
</pre>
              <br>
              <br>

              <p>Инструкция <tt
               class=
              "USERINPUT"><strong>PATH=${PATH}:/opt/bin</strong></tt>
              добавляет каталог <tt
               class="FILENAME">/opt/bin</tt> в конец текущего пути
              поиска. Иногда может оказаться целесообразным, внутри
              сценария, временно добавить какой-либо каталог к пути
              поиска. По завершении работы скрипта, эти изменения будут
              утеряны (вспомните о том, что невозможно изменить
              переменные окружения вызывающего процесса).</p>

              <div
               class="NOTE">
                <table
                 class="NOTE"
                 width="90%"
                 border="0">
                  <tr>
                    <td
                     width="25"
                     align="center"
                     valign="top"><img
                     src="misc/abs-book/images/note.gif"
                     hspace="5"
                     alt="Note"></td>

                    <td
                     align="left"
                     valign="top">
                      <p>Текущий <span
                       class="QUOTE">&quot;рабочий
                      каталог&quot;</span>, <tt
                       class="FILENAME">./</tt>, обычно не включается в
                      <tt
                       class="VARNAME">$PATH</tt> из соображений
                      безопасности.</p>
                    </td>
                  </tr>
                </table>
              </div>
            </dd>

            <dt><tt
             class="VARNAME">$PIPESTATUS</tt></dt>

            <dd>
              <p>Код возврата <a
               href="#c301_html_PIPEREF">канала (конвейера)</a>.
              Интересно, что это не то же самое, что <a
               href="#c2105_html_EXITSTATUSREF">код возврата</a>
              последней исполненной команды.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo $PIPESTATUS</strong></tt>
<tt
 class="COMPUTEROUTPUT">0</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ls -al | bogus_command</strong></tt>
<tt
 class="COMPUTEROUTPUT">bash: bogus_command: command not found</tt>
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo $PIPESTATUS</strong></tt>
<tt
 class="COMPUTEROUTPUT">141</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ls -al | bogus_command</strong></tt>
<tt
 class="COMPUTEROUTPUT">bash: bogus_command: command not found</tt>
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo $?</strong></tt>
<tt
 class="COMPUTEROUTPUT">127</tt>
             
</pre>
              <br>
              <br>

              <div
               class="CAUTION">
                <table
                 class="CAUTION"
                 width="90%"
                 border="0">
                  <tr>
                    <td
                     width="25"
                     align="center"
                     valign="top"><img
                     src="misc/abs-book/images/caution.gif"
                     hspace="5"
                     alt="Caution"></td>

                    <td
                     align="left"
                     valign="top">
                      <p>Переменная <tt
                       class="VARNAME">$PIPESTATUS</tt> может давать
                      неверные значения при вызове из командной
                      строки.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">tcsh%</tt> <tt
 class="USERINPUT"><strong>bash</strong></tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>who | grep nobody | sort</strong></tt>
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo ${PIPESTATUS[*]}</strong></tt>
<tt
 class="COMPUTEROUTPUT">0</tt>
             
</pre>
                      <br>
                      <br>

                      <p>Если поместить эти строки в сценарий и
                      исполнить его, то будут выведены верные значения
                      <tt
                       class="COMPUTEROUTPUT">0 1 0</tt>.</p>

                      <p>Спасибо Wayne Pollock за замечания и
                      предоставленный пример.</p>
                    </td>
                  </tr>
                </table>
              </div>
            </dd>

            <dt><a
             name="c3270_html_PPIDREF"></a><tt
             class="VARNAME">$PPID</tt></dt>

            <dd>
              <p>Переменная <tt
               class="VARNAME">$PPID</tt> хранит PID (идентификатор)
              родительского процесса. <a
               name="AEN3728"
               href="#c3270_html_FTN_AEN3728"><span
               class="footnote">[1]</span></a></p>

              <p>Сравните с командой <a
               href="#c9708_html_PIDOFREF">pidof</a>.</p>
            </dd>

            <dt><a
             name="c3270_html_PS1REF"></a><tt
             class="VARNAME">$PS1</tt></dt>

            <dd>
              <p>prompt, приглашение командной строки.</p>
            </dd>

            <dt><tt
             class="VARNAME">$PS2</tt></dt>

            <dd>
              <p>Вторичное приглашение командной строки, выводится
              тогда, когда от пользователя ожидается дополнительный
              ввод. Отображается как <span
               class="QUOTE">&quot;&gt;&quot;</span>.</p>
            </dd>

            <dt><tt
             class="VARNAME">$PS3</tt></dt>

            <dd>
              <p>Третичное приглашение (prompt), выводится тогда, когда
              пользователь должен сделать выбор в операторе <a
               href="#x5210_html_SELECTREF">select</a> (см. <a
               href="#x5210_html_EX31">Пример 10-29</a>).</p>
            </dd>

            <dt><tt
             class="VARNAME">$PS4</tt></dt>

            <dd>
              <p>Приглашение (prompt) четвертого уровня, выводится в
              начале каждой строки вывода тогда, когда сценарий
              вызывается с <a
               href="#c13228_html_OPTIONSREF">ключом</a> <span
               class="TOKEN">-x</span>. Отображается как <span
               class="QUOTE">&quot;+&quot;</span>.</p>
            </dd>

            <dt><a
             name="c3270_html_PWDREF"></a><tt
             class="VARNAME">$PWD</tt></dt>

            <dd>
              <p>рабочий (текущий) каталог</p>

              <p>Аналог встроенной команды <a
               href="#c5358_html_PWD2REF">pwd</a>.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

E_WRONG_DIRECTORY=73

clear # Очистка экрана.

TargetDirectory=/home/bozo/projects/GreatAmericanNovel

cd $TargetDirectory
echo &quot;Удаление файлов в каталоге $TargetDirectory.&quot;

if [ &quot;$PWD&quot; != &quot;$TargetDirectory&quot; ]
then    # Защита от случайного удаления файлов не в том каталоге.
  echo &quot;Неверный каталог!&quot;
  echo &quot;Переменная $PWD указывает на другой каталог!&quot;
  exit $E_WRONG_DIRECTORY
fi

rm -rf *
rm .[A-Za-z0-9]*    # удалить &quot;скрытые&quot; файлы (начинающиеся с &quot;.&quot;)
# rm -f .[^.]* ..?*   удалить файлы, чьи имена начинаются с нескольких точек.
# (shopt -s dotglob; rm -f *)   тоже работает верно.
# Спасибо S.C. за замечание.

# Имена файлов могут содержать любые символы из диапазона 0-255, за исключением &quot;/&quot;.
# Оставляю вопрос удаления файлов с &quot;необычными&quot; символами для самостоятельного изучения.

# Здесь можно вставить дополнительные действия, по мере необходимости.

echo
echo &quot;Конец.&quot;
echo &quot;Файлы, из каталога $TargetDirectory, удалены.&quot;
echo


exit 0
</pre>
              <br>
              <br>
            </dd>

            <dt><a
             name="c3270_html_REPLYREF"></a><tt
             class="VARNAME">$REPLY</tt></dt>

            <dd>
              <p>переменная по-умолчанию, куда записывается ввод
              пользователя, выполненный с помощью команды <a
               href="#c5358_html_READREF">read</a> если явно не задана
              другая переменная. Так же может использоваться в
              операторе <a
               href="#x5210_html_SELECTREF">select</a>, для построения
              меню выбора.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

echo
echo -n &quot;Ваше любимое растение? &quot;
read

echo &quot;Ваше любимое растение: $REPLY.&quot;
# REPLY хранит последнее значение, прочитанное командой &quot;read&quot; тогда, и только тогда
#+ когда команде &quot;read&quot; не передается имя переменной.

echo
echo -n &quot;Ваш любимый фрукт? &quot;
read fruit
echo &quot;Ваш любимый фрукт $fruit.&quot;
echo &quot;но...&quot;
echo &quot;Значение переменной \$REPLY осталось равным $REPLY.&quot;
# Переменная $REPLY не была перезаписана потому, что
# следующей команде &quot;read&quot;, в качестве аргумента была передана переменная $fruit

echo

exit 0
</pre>
              <br>
              <br>
            </dd>

            <dt><tt
             class="VARNAME">$SECONDS</tt></dt>

            <dd>
              <p>Время паботы сценария в секундах.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Автор: Mendel Cooper
# Дополнен переводчиком.
#

TIME_LIMIT=10
INTERVAL=1

echo
echo &quot;Для прерывания работы сценария, ранее чем через $TIME_LIMIT секунд, нажмите Control-C.&quot;
echo

while [ &quot;$SECONDS&quot; -le &quot;$TIME_LIMIT&quot; ]
do
# Оригинальный вариант сценария содержал следующие строки
#  if [ &quot;$SECONDS&quot; -eq 1 ]
#  then
#    units=second
#  else
#    units=seconds
#  fi
#
# Однако, из-за того, что в русском языке для описания множественного числа
# существует большее число вариантов, чем в английском,
# переводчик позволил себе смелость несколько подправить сценарий
# (прошу ногами не бить! ;-) )
# === НАЧАЛО БЛОКА ИЗМЕНЕНИЙ, ВНЕСЕННЫХ ПЕРЕВОДЧИКОМ ===

  let &quot;last_two_sym = $SECONDS - $SECONDS / 100 * 100&quot; # десятки и единицы
  if [ &quot;$last_two_sym&quot; -ge 11 -a &quot;$last_two_sym&quot; -le 19 ]
  then
    units=&quot;секунд&quot;               # для чисел, которые заканчиваются на &quot;...надцать&quot;
  else
    let &quot;last_sym = $last_two_sym - $last_two_sym / 10 * 10&quot;  # единицы
    case &quot;$last_sym&quot; in
      &quot;1&quot; )
        units=&quot;секунду&quot;         # для чисел, заканчивающихся на 1
      ;;
      &quot;2&quot; | &quot;3&quot; | &quot;4&quot; )
        units=&quot;секунды&quot;         # для чисел, заканчивающихся на 2, 3 и 4
      ;;
      * )
        units=&quot;секунд&quot;          # для всех остальных (0, 5, 6, 7, 8, 9)
      ;;
    esac
  fi
# === КОНЕЦ БЛОКА ИЗМЕНЕНИЙ, ВНЕСЕННЫХ ПЕРЕВОДЧИКОМ ===

  echo &quot;Сценарий отработал $SECONDS $units.&quot;
  #  В случае перегруженности системы, скрипт может перескакивать через отдельные
  #+  значения счетчика
  sleep $INTERVAL
done

echo -e &quot;\a&quot;  # Сигнал!

exit 0
</pre>
              <br>
              <br>
            </dd>

            <dt><tt
             class="VARNAME">$SHELLOPTS</tt></dt>

            <dd>
              <p>список допустимых <a
               href="#c13228_html_OPTIONSREF">опций</a> интерпретатора
              shell. Переменная доступна только для чтения.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo $SHELLOPTS</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">braceexpand:hashall:histexpand:monitor:history:interactive-comments:emacs</tt>
             
</pre>
              <br>
              <br>
            </dd>

            <dt><tt
             class="VARNAME">$SHLVL</tt></dt>

            <dd>
              <p>Уровень вложенности shell. Если в командной строке</p>
<pre
 class="SCREEN">
echo $SHLVL
</pre>
              дает 1, то в сценарии значение этой переменной будет
              больше на 1, т.е. 2.<br>
              <br>
            </dd>

            <dt><tt
             class="VARNAME">$TMOUT</tt></dt>

            <dd>
              <p>Если переменная окружения <tt
               class="REPLACEABLE"><em>$TMOUT</em></tt> содержит
              ненулевое значение, то интерпретатор будет ожидать ввод
              не более чем заданное число секунд, что, в первичном
              приглашении (см. описание PS1 выше), может привести к
              автоматическому завершению сеанса работы.</p>

              <div
               class="NOTE">
                <table
                 class="NOTE"
                 width="90%"
                 border="0">
                  <tr>
                    <td
                     width="25"
                     align="center"
                     valign="top"><img
                     src="misc/abs-book/images/note.gif"
                     hspace="5"
                     alt="Note"></td>

                    <td
                     align="left"
                     valign="top">
                      <p>К сожалению это возможно только во время
                      ожидания ввода с консоли или в окне терминала. А
                      как было бы здорово, если бы можно было
                      использовать эту внутреннюю переменную, скажем в
                      комбинации с командой <a
                       href="#c5358_html_READREF">read</a>! Но в данном
                      контексте эта переменная абсолютно не применима и
                      потому фактически бесполезна в сценариях. (Есть
                      сведения о том, что в <span
                       class="emphasis"><em
                       class="EMPHASIS">ksh</em></span> время ожидания
                      ввода командой <strong
                       class="COMMAND">read</strong> можно
                      ограничить.)</p>
                    </td>
                  </tr>
                </table>
              </div>

              <p>Организация ограничения времени ожидания ввода от
              пользователя в сценариях возможна, но это требут довольно
              сложных махинаций. Как один из вариантов, можно
              предложить организовать прерывание цикла ожидания по
              сигналу. Но это потребует написание функции обработки
              сигналов командой trap (см. <a
               href="#c13099_html_EX76">Пример 29-5</a>).</p>

              <div
               class="EXAMPLE">
                <a
                 name="c3270_html_TMDIN"></a>

                <p><strong>Пример 9-2. Ограничения времени ожидания
                ввода</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# timed-input.sh

# TMOUT=3            бесполезно в сценариях

TIMELIMIT=3  # Три секунды в данном случае, но может быть установлено и другое значение

PrintAnswer()
{
  if [ &quot;$answer&quot; = TIMEOUT ]
  then
    echo $answer
  else       # Чтобы не спутать разные варианты вывода.
    echo &quot;Ваше любимое растение $answer&quot;
    kill $!  # &quot;Прибить&quot; ненужную больше функцию TimerOn, запущенную в фоновом процессе.
             # $! -- PID последнего процесса, запущенного в фоне.
  fi

}



TimerOn()
{
  sleep $TIMELIMIT &amp;&amp; kill -s 14 $$ &amp;
  # Ждать 3 секунды, после чего выдать sigalarm сценарию.
}

Int14Vector()
{
  answer=&quot;TIMEOUT&quot;
  PrintAnswer
  exit 14
}

trap Int14Vector 14   # переназначить процедуру обработки прерывания от таймера (14)

echo &quot;Ваше любимое растение? &quot;
TimerOn
read answer
PrintAnswer


#  По общему признанию, это не очень хороший способ ограничения времени ожидания,
#+ однако опция &quot;-t&quot;команды &quot;read&quot; упрощает задачу.
#  См. &quot;t-out.sh&quot;, ниже.

#  Если вам нужно что-то более элегантное...
#+ подумайте о написании программы на C или C++,
#+ с использованием соответствующих библиотечных функций, таких как &#39;alarm&#39; и &#39;setitimer&#39;.

exit 0
</pre>
              </div>

              <p>В качестве альтернативы можно использовать <a
               href="#c9708_html_STTYREF">stty</a>.</p>

              <div
               class="EXAMPLE">
                <a
                 name="c3270_html_TIMEOUT"></a>

                <p><strong>Пример 9-3. Еще один пример ограничения
                времени ожидания ввода от пользователя</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# timeout.sh

# Автор: Stephane Chazelas,
# дополнен автором документа.

INTERVAL=5                # предел времени ожидания

timedout_read() {
  timeout=$1
  varname=$2
  old_tty_settings=`stty -g`
  stty -icanon min 0 time ${timeout}0
  eval read $varname      # или просто    read $varname
  stty &quot;$old_tty_settings&quot;
  # См. man stty.
}

echo; echo -n &quot;Как Вас зовут? Отвечайте быстрее! &quot;
timedout_read $INTERVAL your_name

# Такой прием может не работать на некоторых типах терминалов.
# Максимальное время ожидания зависит от терминала.
# (чаще всего это 25.5 секунд).

echo

if [ ! -z &quot;$your_name&quot; ]  # Если имя было введено...
then
  echo &quot;Вас зовут $your_name.&quot;
else
  echo &quot;Вы не успели ответить.&quot;
fi

echo

# Алгоритм работы этого сценария отличается от &quot;timed-input.sh&quot;.
# Каждое нажатие на клавишу вызывает сброс счетчика в начальное состояние.

exit 0
</pre>
              </div>

              <p>Возможно самый простой способ -- использовать опцию
              <tt
               class="OPTION">-t</tt> команды <a
               href="#c5358_html_READREF">read</a>.</p>

              <div
               class="EXAMPLE">
                <a
                 name="c3270_html_TOUT"></a>

                <p><strong>Пример 9-4. Ограничение времени ожидания
                команды read</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# t-out.sh 

TIMELIMIT=4        # 4 секунды

read -t $TIMELIMIT variable &lt;&amp;1

echo

if [ -z &quot;$variable&quot; ]
then
  echo &quot;Время ожидания истекло.&quot;
else
  echo &quot;variable = $variable&quot;
fi  

exit 0
</pre>
              </div>
            </dd>

            <dt><a
             name="c3270_html_UIDREF"></a><tt
             class="VARNAME">$UID</tt></dt>

            <dd>
              <p>user id number</p>

              <p>UID (идентификатор) текущего пользователя, в
              соответствии с <tt
               class="FILENAME">/etc/passwd</tt></p>

              <p>Это реальный UID текущего пользователя, даже если он
              временно приобрел права другого пользователя с помощью <a
               href="#c9708_html_SUREF">su</a>. Переменная <tt
               class="VARNAME">$UID</tt> доступна только для
              чтения.</p>

              <div
               class="EXAMPLE">
                <a
                 name="c3270_html_AMIROOT"></a>

                <p><strong>Пример 9-5. Я -- root?</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# am-i-root.sh:   Root я, или не root?

ROOT_UID=0   # $UID root-а всегда равен 0.

if [ &quot;$UID&quot; -eq &quot;$ROOT_UID&quot; ]  # Настоящий &quot;root&quot;?
then
  echo &quot;- root!&quot;
else
  echo &quot;простой пользователь (но мамочка вас тоже любит)!&quot;
fi

exit 0


# ============================================================= #
#  Код, приведенный ниже, никогда не отработает,
#+ поскольку работа сценария уже завершилась выше

# Еще один способ отличить root-а от не root-а:

ROOTUSER_NAME=root

username=`id -nu`              # Или...   username=`whoami`
if [ &quot;$username&quot; = &quot;$ROOTUSER_NAME&quot; ]
then
  echo &quot;Рутти-тутти. - root!&quot;
else
  echo &quot;Вы - лишь обычный юзер.&quot;
fi
</pre>
              </div>

              <p>См. также <a
               href="#c178_html_EX2">Пример 2-2</a>.</p>

              <div
               class="NOTE">
                <table
                 class="NOTE"
                 width="90%"
                 border="0">
                  <tr>
                    <td
                     width="25"
                     align="center"
                     valign="top"><img
                     src="misc/abs-book/images/note.gif"
                     hspace="5"
                     alt="Note"></td>

                    <td
                     align="left"
                     valign="top">
                      <p>Переменные <tt
                       class="VARNAME">$ENV</tt>, <tt
                       class="VARNAME">$LOGNAME</tt>, <tt
                       class="VARNAME">$MAIL</tt>, <tt
                       class="VARNAME">$TERM</tt>, <tt
                       class="VARNAME">$USER</tt> и <tt
                       class="VARNAME">$USERNAME</tt>, не являются <a
                       href="#c5358_html_BUILTINREF">встроенными</a>
                      переменными Bash. Тем не менее, они часто
                      инициализируются как <a
                       href="#x1716_html_ENVREF">переменные
                      окружения</a> в одном из <a
                       href="#c12891_html_FILESREF1">стартовых
                      файлов</a> Bash. <a
                       name="c3270_html_SHELLVARREF"></a>Переменная <tt
                       class="VARNAME">$SHELL</tt>, командная оболочка
                      пользователя, может задаваться в <tt
                       class="FILENAME">/etc/passwd</tt> или в сценарии
                      <span
                       class="QUOTE">&quot;init&quot;</span> и она тоже
                      не является встроенной переменной Bash.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">tcsh%</tt> <tt
 class="USERINPUT"><strong>echo $LOGNAME</strong></tt>
<tt
 class="COMPUTEROUTPUT">bozo</tt>
<tt
 class="PROMPT">tcsh%</tt> <tt
 class="USERINPUT"><strong>echo $SHELL</strong></tt>
<tt
 class="COMPUTEROUTPUT">/bin/tcsh</tt>
<tt
 class="PROMPT">tcsh%</tt> <tt
 class="USERINPUT"><strong>echo $TERM</strong></tt>
<tt
 class="COMPUTEROUTPUT">rxvt</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo $LOGNAME</strong></tt>
<tt
 class="COMPUTEROUTPUT">bozo</tt>
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo $SHELL</strong></tt>
<tt
 class="COMPUTEROUTPUT">/bin/tcsh</tt>
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo $TERM</strong></tt>
<tt
 class="COMPUTEROUTPUT">rxvt</tt>
             
</pre>
                      <br>
                      <br>
                    </td>
                  </tr>
                </table>
              </div>
            </dd>
          </dl>
        </div>

        <div
         class="VARIABLELIST">
          <p><strong>Позиционные параметры (аргументы)</strong></p>

          <dl>
            <dt><a
             name="c3270_html_POSPARAMREF"></a><tt
             class="VARNAME">$0</tt>, <tt
             class="VARNAME">$1</tt>, <tt
             class="VARNAME">$2</tt> и т.д.</dt>

            <dd>
              <p>аргументы передаются... из командной строки в
              сценарий, функциям или команде <a
               href="#c5358_html_SETREF">set</a> (см. <a
               href="#x1716_html_EX17">Пример 4-5</a> и <a
               href="#c5358_html_EX34">Пример 11-13</a>)</p>
            </dd>

            <dt><tt
             class="VARNAME">$#</tt></dt>

            <dd>
              <p>количество аргументов командной строки <a
               name="AEN4011"
               href="#c3270_html_FTN_AEN4011"><span
               class="footnote">[2]</span></a>, или позиционных
              параметров (см. <a
               href="#x13541_html_EX4">Пример 33-2</a>)</p>
            </dd>

            <dt><a
             name="c3270_html_APPREF"></a><tt
             class="VARNAME">$*</tt></dt>

            <dd>
              <p>Все аргументы в виде одной строки (слова)</p>
            </dd>

            <dt><tt
             class="VARNAME">$@</tt></dt>

            <dd>
              <p>То же самое, что и <span
               class="TOKEN">$*</span>, но при этом каждый параметр
              представлен как отдельная строка (слово), т.е. параметры
              не подвергаются какой либо интерпретации.</p>

              <div
               class="EXAMPLE">
                <a
                 name="c3270_html_ARGLIST"></a>

                <p><strong>Пример 9-6. arglist: Вывод списка аргументов
                с помощью переменных $* и $@</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Вызовите сценарий с несколькими аргументами, например: &quot;один два три&quot;.

E_BADARGS=65

if [ ! -n &quot;$1&quot; ]
then
  echo &quot;Порядок использования: `basename $0` argument1 argument2 и т.д.&quot;
  exit $E_BADARGS
fi

echo

index=1

echo &quot;Список аргументов в переменной \&quot;\$*\&quot;:&quot;
for arg in &quot;$*&quot;  # Работает некорректно, если &quot;$*&quot; не ограничена кавычками.
do
  echo &quot;Аргумент #$index = $arg&quot;
  let &quot;index+=1&quot;
done             # $* воспринимает все аргументы как одну строку.
echo &quot;Полный список аргументов выглядит как одна строка.&quot;

echo

index=1

echo &quot;Список аргументов в переменной \&quot;\$@\&quot;:&quot;
for arg in &quot;$@&quot;
do
  echo &quot;Аргумент #$index = $arg&quot;
  let &quot;index+=1&quot;
done             # $@ воспринимает аргументы как отдельные строки (слова).
echo &quot;Список аргументов выглядит как набор различных строк (слов).&quot;

echo

exit 0
</pre>
              </div>

              <p>После команды <strong
               class="COMMAND">shift</strong> (сдвиг), первый аргумент,
              в переменной <tt
               class="VARNAME">$@</tt>, теряется, а остальные
              сдвигаются на одну позицию &quot;вниз&quot; (или
              &quot;влево&quot;, если хотите).</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Вызовите сценарий в таком виде: ./scriptname 1 2 3 4 5

echo &quot;$@&quot;    # 1 2 3 4 5
shift
echo &quot;$@&quot;    # 2 3 4 5
shift
echo &quot;$@&quot;    # 3 4 5

# Каждая из команд &quot;shift&quot; приводит к потере аргумента $1,
# но остальные аргументы остаются в &quot;$@&quot;.
</pre>
              <br>
              <br>

              <p>Специальная переменная <tt
               class="VARNAME">$@</tt> может быть использована для
              выбора типа ввода в сценария. Команда <strong
               class="COMMAND">cat &quot;$@&quot;</strong> позволяет
              выполнять ввод как со стандартного устройства ввода <tt
               class="FILENAME">stdin</tt>, так и из файла, имя
              которого передается сценарию из командной строки. См. <a
               href="#x7050_html_ROT13">Пример 12-17</a> и <a
               href="#x7050_html_CRYPTOQUOTE">Пример 12-18</a>.</p>

              <div
               class="CAUTION">
                <table
                 class="CAUTION"
                 width="90%"
                 border="0">
                  <tr>
                    <td
                     width="25"
                     align="center"
                     valign="top"><img
                     src="misc/abs-book/images/caution.gif"
                     hspace="5"
                     alt="Caution"></td>

                    <td
                     align="left"
                     valign="top">
                      <p>Переменные <tt
                       class="VARNAME">$*</tt> и <tt
                       class="VARNAME">$@</tt>, в отдельных случаях,
                      могут содержать противоречивую информацию! Это
                      зависит от содержимого переменной <a
                       href="#c3270_html_IFSREF">$IFS</a>.</p>
                    </td>
                  </tr>
                </table>
              </div>

              <div
               class="EXAMPLE">
                <a
                 name="c3270_html_INCOMPAT"></a>

                <p><strong>Пример 9-7. Противоречия в переменных <tt
                 class="VARNAME">$*</tt> и <tt
                 class="VARNAME">$@</tt></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

#  Демонстрация противоречивости содержимого внутренних переменных &quot;$*&quot; и &quot;$@&quot;,
#+ которая проявляется при изменении порядка заключения параметров в кавычки.
#  Демонстрация противоречивости, проявляющейся при изменении
#+ содержимого переменной IFS.


set -- &quot;Первый один&quot; &quot;второй&quot; &quot;третий:один&quot; &quot;&quot; &quot;Пятый: :один&quot;
# Установка аргументов $1, $2, и т.д.

echo

echo &#39;IFS по-умолчанию, переменная &quot;$*&quot;&#39;
c=0
for i in &quot;$*&quot;               # в кавычках
do echo &quot;$((c+=1)): [$i]&quot;   # Эта строка остается без изменений во всех циклах.
                            # Вывод аргументов.
done
echo ---

echo &#39;IFS по-умолчанию, переменная $*&#39;
c=0
for i in $*                 # без кавычек
do echo &quot;$((c+=1)): [$i]&quot;
done
echo ---

echo &#39;IFS по-умолчанию, переменная &quot;$@&quot;&#39;
c=0
for i in &quot;$@&quot;
do echo &quot;$((c+=1)): [$i]&quot;
done
echo ---

echo &#39;IFS по-умолчанию, переменная $@&#39;
c=0
for i in $@
do echo &quot;$((c+=1)): [$i]&quot;
done
echo ---

IFS=:
echo &#39;IFS=&quot;:&quot;, переменная &quot;$*&quot;&#39;
c=0
for i in &quot;$*&quot;
do echo &quot;$((c+=1)): [$i]&quot;
done
echo ---

echo &#39;IFS=&quot;:&quot;, переменная $*&#39;
c=0
for i in $*
do echo &quot;$((c+=1)): [$i]&quot;
done
echo ---

var=$*
echo &#39;IFS=&quot;:&quot;, переменная &quot;$var&quot; (var=$*)&#39;
c=0
for i in &quot;$var&quot;
do echo &quot;$((c+=1)): [$i]&quot;
done
echo ---

echo &#39;IFS=&quot;:&quot;, переменная $var (var=$*)&#39;
c=0
for i in $var
do echo &quot;$((c+=1)): [$i]&quot;
done
echo ---

var=&quot;$*&quot;
echo &#39;IFS=&quot;:&quot;, переменная $var (var=&quot;$*&quot;)&#39;
c=0
for i in $var
do echo &quot;$((c+=1)): [$i]&quot;
done
echo ---

echo &#39;IFS=&quot;:&quot;, переменная &quot;$var&quot; (var=&quot;$*&quot;)&#39;
c=0
for i in &quot;$var&quot;
do echo &quot;$((c+=1)): [$i]&quot;
done
echo ---

echo &#39;IFS=&quot;:&quot;, переменная &quot;$@&quot;&#39;
c=0
for i in &quot;$@&quot;
do echo &quot;$((c+=1)): [$i]&quot;
done
echo ---

echo &#39;IFS=&quot;:&quot;, переменная $@&#39;
c=0
for i in $@
do echo &quot;$((c+=1)): [$i]&quot;
done
echo ---

var=$@
echo &#39;IFS=&quot;:&quot;, переменная $var (var=$@)&#39;
c=0
for i in $var
do echo &quot;$((c+=1)): [$i]&quot;
done
echo ---

echo &#39;IFS=&quot;:&quot;, переменная &quot;$var&quot; (var=$@)&#39;
c=0
for i in &quot;$var&quot;
do echo &quot;$((c+=1)): [$i]&quot;
done
echo ---

var=&quot;$@&quot;
echo &#39;IFS=&quot;:&quot;, переменная &quot;$var&quot; (var=&quot;$@&quot;)&#39;
c=0
for i in &quot;$var&quot;
do echo &quot;$((c+=1)): [$i]&quot;
done
echo ---

echo &#39;IFS=&quot;:&quot;, переменная $var (var=&quot;$@&quot;)&#39;
c=0
for i in $var
do echo &quot;$((c+=1)): [$i]&quot;
done

echo

# Попробуйте запустить этот сценарий под ksh или zsh -y.

exit 0

# Это сценарий написан Stephane Chazelas,
# Незначительные изменения внесены автором документа.
</pre>
              </div>

              <div
               class="NOTE">
                <table
                 class="NOTE"
                 width="90%"
                 border="0">
                  <tr>
                    <td
                     width="25"
                     align="center"
                     valign="top"><img
                     src="misc/abs-book/images/note.gif"
                     hspace="5"
                     alt="Note"></td>

                    <td
                     align="left"
                     valign="top">
                      <p>Различия между <strong
                       class="COMMAND">$@</strong> и <strong
                       class="COMMAND">$*</strong> наблюдаются только
                      тогда, когда они помещаются в двойные
                      кавычки.</p>
                    </td>
                  </tr>
                </table>
              </div>

              <div
               class="EXAMPLE">
                <a
                 name="c3270_html_IFSEMPTY"></a>

                <p><strong>Пример 9-8. Содержимое <tt
                 class="VARNAME">$*</tt> и <tt
                 class="VARNAME">$@</tt>, когда переменная <tt
                 class="VARNAME">$IFS</tt> -- пуста</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Если переменная $IFS инициализирована &quot;пустым&quot; значением,
# то &quot;$*&quot; и &quot;$@&quot; содержат аргументы не в том виде, в каком ожидается.

mecho ()       # Вывод аргументов.
{
echo &quot;$1,$2,$3&quot;;
}


IFS=&quot;&quot;         # Инициализация &quot;пустым&quot; значением.
set a b c      # Установка аргументов.

mecho &quot;$*&quot;     # abc,,
mecho $*       # a,b,c

mecho $@       # a,b,c
mecho &quot;$@&quot;     # a,b,c

# Поведение переменных $* и $@, при &quot;пустой&quot; $IFS, зависит
# от версии командной оболочки, Bash или sh.
# Поэтому, было бы неразумным пользоваться этой &quot;фичей&quot; в своих сценариях.


# Спасибо S.C.

exit 0
</pre>
              </div>
            </dd>
          </dl>
        </div>

        <div
         class="VARIABLELIST">
          <p><strong>Прочие специальные переменные</strong></p>

          <dl>
            <dt><a
             name="c3270_html_FLPREF"></a><tt
             class="VARNAME">$-</tt></dt>

            <dd>
              <p>Список флагов, переданных сценарию (командой <a
               href="#c5358_html_SETREF">set</a>). См. <a
               href="#c5358_html_EX34">Пример 11-13</a>.</p>

              <div
               class="CAUTION">
                <table
                 class="CAUTION"
                 width="90%"
                 border="0">
                  <tr>
                    <td
                     width="25"
                     align="center"
                     valign="top"><img
                     src="misc/abs-book/images/caution.gif"
                     hspace="5"
                     alt="Caution"></td>

                    <td
                     align="left"
                     valign="top">
                      <p>Эта конструкция изначально была введена в
                      <span
                       class="emphasis"><em
                       class="EMPHASIS">ksh</em></span>, откуда
                      перекочевала в Bash и, похоже, работает в Bash не
                      совсем надежно. Единственное возможное применение
                      -- <a
                       href="#c13505_html_IITEST">проверка - запущен ли
                      сценарий в интерактивном режиме</a>.</p>
                    </td>
                  </tr>
                </table>
              </div>
            </dd>

            <dt><tt
             class="VARNAME">$!</tt></dt>

            <dd>
              <p>PID последнего, запущенного в фоне, процесса</p>
<pre
 class="PROGRAMLISTING">
LOG=$0.log

COMMAND1=&quot;sleep 100&quot;

echo &quot;Запись в лог всех PID фоновых процессов, запущенных из сценария: $0&quot; &gt;&gt; &quot;$LOG&quot;
# Таким образом возможен мониторинг и удаление процессов по мере необходимости.
echo &gt;&gt; &quot;$LOG&quot;

# Команды записи в лог.

echo -n &quot;PID of \&quot;$COMMAND1\&quot;:  &quot; &gt;&gt; &quot;$LOG&quot;
${COMMAND1} &amp;
echo $! &gt;&gt; &quot;$LOG&quot;
# PID процесса &quot;sleep 100&quot;:  1506

# Спасибо Jacques Lederer за предложенный пример.
</pre>
              <br>
              <br>
            </dd>

            <dt><a
             name="c3270_html_UNDERSCOREREF"></a><tt
             class="VARNAME">$_</tt></dt>

            <dd>
              <p>Специальная переменная, содержит последний аргумент
              предыдущей команды.</p>

              <div
               class="EXAMPLE">
                <a
                 name="c3270_html_USCREF"></a>

                <p><strong>Пример 9-9. Переменная
                &quot;подчеркивание&quot;</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

echo $_              # /bin/bash
                     # Для запуска сценария был вызван /bin/bash.

du &gt;/dev/null        # Подавление вывода.
echo $_              # du

ls -al &gt;/dev/null    # Подавление вывода.
echo $_              # -al  (последний аргумент)

:
echo $_              # :
</pre>
              </div>
            </dd>

            <dt><a
             name="c3270_html_XSTATVARREF"></a><tt
             class="VARNAME">$?</tt></dt>

            <dd>
              <p><a
               href="#c2105_html_EXITSTATUSREF">Код возврата</a>
              команды, <a
               href="#c12483_html_FUNCTIONREF">функции</a> или скрипта
              (см. <a
               href="#c12483_html_MAX">Пример 22-3</a>)</p>
            </dd>

            <dt><a
             name="c3270_html_PROCCID"></a><tt
             class="VARNAME">$$</tt></dt>

            <dd>
              <p>PID самого процесса-сценария. Переменная <tt
               class="VARNAME">$$</tt> часто используется при генерации
              &quot;уникальных&quot; имен для временных файлов (см. <a
               href="#a14477_html_FTPGET">Пример A-14</a>, <a
               href="#c13099_html_ONLINE">Пример 29-6</a>, <a
               href="#x7794_html_DERPM">Пример 12-23</a> и <a
               href="#c5358_html_SELFDESTRUCT">Пример 11-23</a>). Обычно
              это проще чем вызов <a
               href="#x7794_html_MKTEMPREF">mktemp</a>.</p>
            </dd>
          </dl>
        </div>
      </div>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN3728"
         href="#c3270_html_AEN3728"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>PID текущего процесса хранится в переменной <tt
           class="VARNAME">$$</tt>.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN4011"
         href="#c3270_html_AEN4011"><span
         class="footnote">[2]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Слова <span
           class="QUOTE">&quot;аргумент&quot;</span> и <span
           class="QUOTE">&quot;параметр&quot;</span> очень часто
          используются как синонимы. В тексте данного документа, они
          применяются для обозначения одного и того же понятия, будь то
          аргумент, передаваемый скрипту из командной строки или
          входной параметр функции.</p>
        </td>
      </tr>
    </table>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#p3268_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x4171_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Углубленный материал</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#p3268_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Работа со строками</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="c4875_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x4862_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x5140_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="CHAPTER">
      <h1><a
       name="c4875_html_LOOPS"></a>Глава 10. Циклы и ветвления</h1>

      <p>Управление ходом исполнения -- один из ключевых моментов
      структурной организации сценариев на языке командной оболочки.
      Циклы и преходы являются теми инструментальными средствами,
      которые обеспечивают управление порядком исполнения команд.</p>

      <div
       class="SECT1">
        <h1
         class="SECT1"><a
         name="c4875_html_LOOPS1"></a>10.1. Циклы</h1>

        <p><span
         class="emphasis"><em
         class="EMPHASIS">Цикл</em></span> -- это блок команд, который
        исполняется многократно до тех пор, пока не будет выполнено
        условие выхода из цикла.</p>

        <div
         class="VARIABLELIST">
          <p><strong><a
           name="c4875_html_FORLOOPREF1"></a>циклы for</strong></p>

          <dl>
            <dt><strong
             class="COMMAND">for (in)</strong></dt>

            <dd>
              <p>Это одна из основных разновидностей циклов. И она
              значительно отличается от аналога в языке C.</p>

              <p><strong
               class="COMMAND">for</strong> <tt
               class="REPLACEABLE"><em>arg</em></tt> in [<tt
               class="REPLACEABLE"><em>list</em></tt>]<br>
               do<br>
               <tt
               class="REPLACEABLE"><em> команда(ы)</em></tt>...<br>
               done</p>
              <br>
              <br>

              <div
               class="NOTE">
                <table
                 class="NOTE"
                 width="90%"
                 border="0">
                  <tr>
                    <td
                     width="25"
                     align="center"
                     valign="top"><img
                     src="misc/abs-book/images/note.gif"
                     hspace="5"
                     alt="Note"></td>

                    <td
                     align="left"
                     valign="top">
                      <p>На каждом проходе цикла, переменная-аргумент
                      цикла <tt
                       class="REPLACEABLE"><em>arg</em></tt>
                      последовательно, одно за другим, принимает
                      значения из списка <tt
                       class="REPLACEABLE"><em>list</em></tt>.</p>
                    </td>
                  </tr>
                </table>
              </div>
<pre
 class="PROGRAMLISTING">
for arg in &quot;$var1&quot; &quot;$var2&quot; &quot;$var3&quot; ... &quot;$varN&quot;
# На первом проходе, $arg = $var1
# На втором проходе, $arg = $var2
# На третьем проходе, $arg = $var3
# ...
# На N-ном проходе, $arg = $varN

# Элементы списка заключены в кавычки для того, чтобы предотвратить возможное разбиение их на отдельные аргументы (слова).
</pre>
              <br>
              <br>

              <p>Элементы списка могут включать в себя шаблонные
              символы.</p>

              <p>Есл ключевое слово <strong
               class="COMMAND">do</strong> находится в одной строке со
              словом <strong
               class="COMMAND">for</strong>, то после списка аргументов
              (перед do) необходимо ставить точку с запятой.</p>

              <p><strong
               class="COMMAND">for</strong> <tt
               class="REPLACEABLE"><em>arg</em></tt> in [<tt
               class="REPLACEABLE"><em>list</em></tt>] ; do<br>
              </p>
              <br>
              <br>

              <div
               class="EXAMPLE">
                <a
                 name="c4875_html_EX22"></a>

                <p><strong>Пример 10-1. Простой цикл for</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Список планет.

for planet in Меркурий Венера Земля Марс Юпитер Сатурн Уран Нептун Плутон
do
  echo $planet
done

echo

# Если &#39;список аргументов&#39; заключить в кавычки, то он будет восприниматься как единственный аргумент .
for planet in &quot;Меркурий Венера Земля Марс Юпитер Сатурн Уран Нептун Плутон&quot;
do
  echo $planet
done

exit 0
</pre>
              </div>

              <div
               class="NOTE">
                <table
                 class="NOTE"
                 width="90%"
                 border="0">
                  <tr>
                    <td
                     width="25"
                     align="center"
                     valign="top"><img
                     src="misc/abs-book/images/note.gif"
                     hspace="5"
                     alt="Note"></td>

                    <td
                     align="left"
                     valign="top">
                      <p>Каждый из элементов <tt
                       class="USERINPUT"><strong>[списка]</strong></tt>
                      может содержать несколько аргументов. Это бывает
                      полезным при обработке групп параметров. В этом
                      случае, для принудительного разбора каждого из
                      аргументов в списке, необходимо использовать
                      инструкцию <strong
                       class="COMMAND">set</strong> (см. <a
                       href="#c5358_html_EX34">Пример 11-13</a>).</p>
                    </td>
                  </tr>
                </table>
              </div>

              <div
               class="EXAMPLE">
                <a
                 name="c4875_html_EX22A"></a>

                <p><strong>Пример 10-2. Цикл for с двумя параметрами в
                каждом из элементов списка</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Список планет.

# Имя кажой планеты ассоциировано с расстоянием от планеты до Солнца (млн. миль).

for planet in &quot;Меркурий 36&quot; &quot;Венера 67&quot; &quot;Земля 93&quot;  &quot;Марс 142&quot; &quot;Юпитер 483&quot;
do
  set -- $planet  # Разбиение переменной &quot;planet&quot; на множество аргументов (позиционных параметров).
  # Конструкция &quot;--&quot; предохраняет от неожиданностей, если $planet &quot;пуста&quot; или начинается с символа &quot;-&quot;.

  # Если каждый из аргументов потребуется сохранить, поскольку на следующем проходе они будут &quot;забиты&quot; новыми значениями,
  # То можно поместить их в массив,
  #        original_params=(&quot;$@&quot;)

  echo &quot;$1      в $2,000,000 миль от Солнца&quot;
  #----две табуляции---к параметру $2 добавлены нули
done

# (Спасибо S.C., за разъяснения.)

exit 0
</pre>
              </div>

              <p>В качестве списка, в цикле <strong
               class="COMMAND">for</strong>, можно использовать
              переменную.</p>

              <div
               class="EXAMPLE">
                <a
                 name="c4875_html_FILEINFO"></a>

                <p><strong>Пример 10-3. <span
                 class="emphasis"><em
                 class="EMPHASIS">Fileinfo:</em></span> обработка
                списка файлов, находящегося в переменной</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# fileinfo.sh

FILES=&quot;/usr/sbin/privatepw
/usr/sbin/pwck
/usr/sbin/go500gw
/usr/bin/fakefile
/sbin/mkreiserfs
/sbin/ypbind&quot;     # Список интересующих нас файлов.
                  # В список добавлен фиктивный файл /usr/bin/fakefile.

echo

for file in $FILES
do

  if [ ! -e &quot;$file&quot; ]       # Проверка наличия файла.
  then
    echo &quot;Файл $file не найден.&quot;; echo
    continue                # Переход к следующей итерации.
  fi

  ls -l $file | awk &#39;{ print $8 &quot;         размер: &quot; $5 }&#39;  # Печать 2 полей.
  whatis `basename $file`   # Информация о файле.
  echo
done  

exit 0
</pre>
              </div>

              <p>В <tt
               class="USERINPUT"><strong>[списке]</strong></tt> цикла
              <strong
               class="COMMAND">for</strong> могут быть использованы
              имена файлов, которые в свою очередь могут содержать
              символы-шаблоны.</p>

              <div
               class="EXAMPLE">
                <a
                 name="c4875_html_LISTGLOB"></a>

                <p><strong>Пример 10-4. Обработка списка файлов в цикле
                for</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# list-glob.sh: Создание список файлов в цикле for с использованием
# операции подстановки имен файлов (&quot;globbing&quot;).

echo

for file in *
do
  ls -l &quot;$file&quot;  # Список всех файлов в $PWD (текущем каталоге).
  # Напоминаю, что символу &quot;*&quot; соответствует любое имя файла,
  # однако, в операциях подстановки имен файлов (&quot;globbing&quot;),
  # имеются исключения -- имена файлов, начинающиеся с точки.

  # Если в каталоге нет ни одного файла, соответствующего шаблону,
  # то за имя файла принимается сам шаблон.
  # Чтобы избежать этого, используйте ключ nullglob
  # (shopt -s nullglob).
  # Спасибо S.C.
done

echo; echo

for file in [jx]*
do
  rm -f $file    # Удаление файлов, начинающихся с &quot;j&quot; или &quot;x&quot; в $PWD.
  echo &quot;Удален файл \&quot;$file\&quot;&quot;.
done

echo

exit 0
</pre>
              </div>

              <p>Если <tt
               class="USERINPUT"><strong>[список]</strong></tt> в цикле
              <strong
               class="COMMAND">for</strong> не задан, то в качестве
              оного используется переменная <span
               class="TOKEN">$@</span> -- список аргументов командной
              строки. Оень остроумно эта особенность проиллюстрирована
              в <a
               href="#a14477_html_PRIMES">Пример A-18</a>.</p>

              <div
               class="EXAMPLE">
                <a
                 name="c4875_html_EX23"></a>

                <p><strong>Пример 10-5. Цикл for без списка
                аргументов</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Попробуйте вызвать этот сценарий с аргументами и без них и посмотреть на результаты.

for a
do
 echo -n &quot;$a &quot;
done

#  Список аргументов не задан, поэтому цикл работает с переменной &#39;$@&#39;
#+ (список аргументов командной строки, включая пробельные символы).

echo

exit 0
</pre>
              </div>

              <p>При создании списка аргументов, в цикле for
              допускается пользоваться <a
               href="#c11441_html_COMMANDSUBREF">подстановкой
              команд</a>. См. <a
               href="#x9307_html_EX53">Пример 12-39</a>, <a
               href="#c4875_html_SYMLINKS">Пример 10-10</a> и <a
               href="#x9199_html_BASE">Пример 12-33</a>.</p>

              <div
               class="EXAMPLE">
                <a
                 name="c4875_html_FORLOOPCMD"></a>

                <p><strong>Пример 10-6. Создание списка аргументов в
                цикле for с помощью операции подстановки
                команд</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# уЩЫЬ for гЯ [гаЩгЫЯЭ], гЯкФСЮЮйЭ г аЯЭЯниР аЯФгдСЮЯзЫЩ ЫЯЭСЮФ.

NUMBERS=&quot;9 7 3 8 37.53&quot;

for number in `echo $NUMBERS`  # for number in 9 7 3 8 37.53
do
  echo -n &quot;$number &quot;
done

echo 
exit 0
</pre>
              </div>

              <p>Более сложный пример использования подстановки команд
              при создании списка аргументов цикла.</p>

              <div
               class="EXAMPLE">
                <a
                 name="c4875_html_BINGREP"></a>

                <p><strong>Пример 10-7. <a
                 href="#x7050_html_GREPREF">grep</a> для бинарных
                файлов</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# bin-grep.sh: Поиск строк в двоичных файлах.

# замена &quot;grep&quot; для бинарных файлов.
# Аналогично команде &quot;grep -a&quot;

E_BADARGS=65
E_NOFILE=66

if [ $# -ne 2 ]
then
  echo &quot;Порядок использования: `basename $0` string filename&quot;
  exit $E_BADARGS
fi

if [ ! -f &quot;$2&quot; ]
then
  echo &quot;Файл \&quot;$2\&quot; не найден.&quot;
  exit $E_NOFILE
fi


for word in $( strings &quot;$2&quot; | grep &quot;$1&quot; )
# Инструкция &quot;strings&quot; возвращает список строк в двоичных файлах.
# Который затем передается по конвейеру команде &quot;grep&quot;, для выполнения поиска.
do
  echo $word
done

# Как указывает S.C., вышепрведенное объявление цикла for может быть упрощено
#    strings &quot;$2&quot; | grep &quot;$1&quot; | tr -s &quot;$IFS&quot; &#39;[\n*]&#39;


# Попробуйте что нибудь подобное:  &quot;./bin-grep.sh mem /bin/ls&quot;

exit 0
</pre>
              </div>

              <p>Еще один пример.</p>

              <div
               class="EXAMPLE">
                <a
                 name="c4875_html_USERLIST"></a>

                <p><strong>Пример 10-8. Список всех пользователей
                системы</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# userlist.sh

PASSWORD_FILE=/etc/passwd
n=1           # Число пользователей

for name in $(awk &#39;BEGIN{FS=&quot;:&quot;}{print $1}&#39; &lt; &quot;$PASSWORD_FILE&quot; )
# Разделитель полей = :  ^^^^^^
# Вывод первого поля              ^^^^^^^^
# Данные берутся из файла паролей            ^^^^^^^^^^^^^^^^^
do
  echo &quot;Пользователь #$n = $name&quot;
  let &quot;n += 1&quot;
done


# Пользователь #1 = root
# Пользователь #2 = bin
# Пользователь #3 = daemon
# ...
# Пользователь #30 = bozo

exit 0
</pre>
              </div>

              <p>И заключительный пример использования подстановки
              команд при создании [списка].</p>

              <div
               class="EXAMPLE">
                <a
                 name="c4875_html_FINDSTRING"></a>

                <p><strong>Пример 10-9. Проверка авторства всех
                бинарных файлов в текущем каталоге</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# findstring.sh:
# Поиск заданной строки в двоичном файле.

directory=/usr/local/bin/
fstring=&quot;Free Software Foundation&quot;  # Поиск файлов от FSF.

for file in $( find $directory -type f -name &#39;*&#39; | sort )
do
  strings -f $file | grep &quot;$fstring&quot; | sed -e &quot;s%$directory%%&quot;
  #  Команде &quot;sed&quot; передается выражение (ключ -e),
  #+ для того, чтобы изменить обычный разделитель &quot;/&quot; строки поиска и строки замены
  #+ поскольку &quot;/&quot; - один из отфильтровываемых символов.
  #  Использование такого символа порождает сообщение об ошибке (попробуйте).
done

exit 0

#  Упражнение:
#  ---------------
#  Измените сценарий таким образом, чтобы он брал
#+ $directory и $fstring из командной строки.
</pre>
              </div>

              <p>Результат работы цикла <strong
               class="COMMAND">for</strong> может передаваться другим
              командам по конвейеру.</p>

              <div
               class="EXAMPLE">
                <a
                 name="c4875_html_SYMLINKS"></a>

                <p><strong>Пример 10-10. Список символических ссылок в
                каталоге</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# symlinks.sh: Список символических ссылок в каталоге.


directory=${1-`pwd`}
#  По-умолчанию в текущем каталоге,
#  Блок кода, который выполняет аналогичные действия.
# ----------------------------------------------------------
# ARGS=1                 # Ожидается один аргумент командной строки.
#
# if [ $# -ne &quot;$ARGS&quot; ]  # Если каталог поиска не задан...
# then
#   directory=`pwd`      # текущий каталог
# else
#   directory=$1
# fi
# ----------------------------------------------------------

echo &quot;символические ссылки в каталоге \&quot;$directory\&quot;&quot;

for file in &quot;$( find $directory -type l )&quot;   # -type l = символические ссылки
do
  echo &quot;$file&quot;
done | sort             # В противном случае получится неотсортированный список.

#  Как отмечает Dominik &#39;Aeneas&#39; Schnitzer,
#+ в случае отсутствия кавычек для $( find $directory -type l )
#+ сценарий &quot;подавится&quot; именами файлов, содержащими пробелы.

exit 0
</pre>
              </div>

              <p>Вывод цикла может быть <a
               href="#c11620_html_IOREDIRREF">перенаправлен</a> со <tt
               class="FILENAME">stdout</tt> в файл, ниже приводится
              немного модифицированный вариант предыдущего примера,
              демонстрирующий эту возможность.</p>

              <div
               class="EXAMPLE">
                <a
                 name="c4875_html_SYMLINKS2"></a>

                <p><strong>Пример 10-11. Список символических ссылок в
                каталоге, сохраняемый в файле</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# symlinks.sh: Список символических ссылок в каталоге.

OUTFILE=symlinks.list                         # файл со списком

directory=${1-`pwd`}
#  По-умолчанию -- текущий каталог,

echo &quot;символические ссылки в каталоге \&quot;$directory\&quot;&quot; &gt; &quot;$OUTFILE&quot;
echo &quot;---------------------------&quot; &gt;&gt; &quot;$OUTFILE&quot;

for file in &quot;$( find $directory -type l )&quot;    # -type l = символические ссылки
do
  echo &quot;$file&quot;
done | sort &gt;&gt; &quot;$OUTFILE&quot;                     # перенаправление вывода
#           ^^^^^^^^^^^^^                       в файл.

exit 0
</pre>
              </div>

              <p>Оператор цикла <strong
               class="COMMAND">for</strong> имеет и альтернативный
              синтаксис записи -- очень похожий на синтаксис оператора
              for в языке C. Для этого используются двойные круглые
              скобки.</p>

              <div
               class="EXAMPLE">
                <a
                 name="c4875_html_FORLOOPC"></a>

                <p><strong>Пример 10-12. C-подобный синтаксис оператора
                цикла for</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Два вапианта оформления цикла.

echo

# Стандартный синтаксис.
for a in 1 2 3 4 5 6 7 8 9 10
do
  echo -n &quot;$a &quot;
done

echo; echo

# +==========================================+

# А теперь C-подобный синтаксис.

LIMIT=10

for ((a=1; a &lt;= LIMIT ; a++))  # Двойные круглые скобки и &quot;LIMIT&quot; без &quot;$&quot;.
do
  echo -n &quot;$a &quot;
done                           # Конструкция заимствована из &#39;ksh93&#39;.

echo; echo

# +=========================================================================+

# Попробуем и C-шный оператор &quot;запятая&quot;.

for ((a=1, b=1; a &lt;= LIMIT ; a++, b++))  # Запятая разделяет две операции, которые выполняются совместно.
do
  echo -n &quot;$a-$b &quot;
done

echo; echo

exit 0
</pre>
              </div>

              <p>См. так же <a
               href="#c12790_html_QFUNCTION">Пример 25-10</a>, <a
               href="#c12790_html_TWODIM">Пример 25-11</a> и <a
               href="#a14477_html_COLLATZ">Пример A-7</a>.</p>

              <p>---</p>

              <p>А сейчас пример сценария, который может найти
              &quot;реальное&quot; применение.</p>

              <div
               class="EXAMPLE">
                <a
                 name="c4875_html_EX24"></a>

                <p><strong>Пример 10-13. Работа с командой efax в
                пакетном режиме</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

EXPECTED_ARGS=2
E_BADARGS=65

if [ $# -ne $EXPECTED_ARGS ]
# Проверка наличия аргументов командной строки.
then
   echo &quot;Порядок использования: `basename $0` phone# text-file&quot;
   exit $E_BADARGS
fi


if [ ! -f &quot;$2&quot; ]
then
  echo &quot;Файл $2 не является текстовым файлом&quot;
  exit $E_BADARGS
fi


fax make $2              # Создать fax-файлы из текстовых файлов.

for file in $(ls $2.0*)  # Все файлы, получившиеся в результате преобразования.
                         # Используется шаблонный символ в списке.
do
  fil=&quot;$fil $file&quot;
done

efax -d /dev/ttyS3 -o1 -t &quot;T$1&quot; $fil   # отправить.


# Как указывает S.C., в цикл for может быть вставлена сама команда отправки в виде:
#    efax -d /dev/ttyS3 -o1 -t &quot;T$1&quot; $2.0*
# но это не так поучительно [;-)].

exit 0
</pre>
              </div>
            </dd>

            <dt><a
             name="c4875_html_WHILELOOPREF"></a><strong
             class="COMMAND">while</strong></dt>

            <dd>
              <p>Оператор while проверяет условие перед началом каждой
              итерации и если условие истинно (если <a
               href="#c2105_html_EXITSTATUSREF">код возврата</a> равен
              <span
               class="RETURNVALUE">0</span>), то управление передается
              в тело цикла. В отличие от циклов <a
               href="#c4875_html_FORLOOPREF1">for</a>, циклы <span
               class="emphasis"><em
               class="EMPHASIS">while</em></span> используются в тех
              случаях, когда количество итераций заранее не
              известно.</p>

              <p><strong
               class="COMMAND">while</strong> [<tt
               class="REPLACEABLE"><em>condition</em></tt>]<br>
               do<br>
               <tt
               class="REPLACEABLE"><em> command</em></tt>...<br>
               done</p>
              <br>
              <br>

              <p>Как и в случае с циклами <span
               class="TOKEN">for/in</span>, при размещении ключевого
              слова <strong
               class="COMMAND">do</strong> в одной строке с объявлением
              цикла, необходимо вставлять символ &quot;;&quot; перед
              <strong
               class="COMMAND">do</strong>.</p>

              <p><strong
               class="COMMAND">while</strong> [<tt
               class="REPLACEABLE"><em>condition</em></tt>] ; do</p>
              <br>
              <br>

              <p>Обратите внимание: в отдельных случаях, таких как
              использование конструкции <a
               href="#c5358_html_GETOPTSX">getopts</a> совместно с
              оператором <strong
               class="COMMAND">while</strong>, синтаксис несколько
              отличается от приводимого здесь.</p>

              <div
               class="EXAMPLE">
                <a
                 name="c4875_html_EX25"></a>

                <p><strong>Пример 10-14. Простой цикл
                while</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

var0=0
LIMIT=10

while [ &quot;$var0&quot; -lt &quot;$LIMIT&quot; ]
do
  echo -n &quot;$var0 &quot;        # -n подавляет перевод строки.
  var0=`expr $var0 + 1`   # допускается var0=$(($var0+1)).
done

echo

exit 0
</pre>
              </div>

              <div
               class="EXAMPLE">
                <a
                 name="c4875_html_EX26"></a>

                <p><strong>Пример 10-15. Другой пример цикла
                while</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

echo

while [ &quot;$var1&quot; != &quot;end&quot; ]     # возможна замена на while test &quot;$var1&quot; != &quot;end&quot;
do
  echo &quot;Введите значение переменной #1 (end - выход) &quot;
  read var1                    # Конструкция &#39;read $var1&#39; недопустима (почему?).
  echo &quot;переменная #1 = $var1&quot; # кавычки обязательны, потому что имеется символ &quot;#&quot;.
  # Если введено слово &#39;end&#39;, то оно тоже выводится на экран.
  # потому, что проверка переменной выполняется в начале итерации (перед вводом).
  echo
done  

exit 0
</pre>
              </div>

              <p>Оператор <strong
               class="COMMAND">while</strong> может иметь несколько
              условий. Но только последнее из них определяет
              возможность продолжения цикла. В этом случае синтаксис
              оператора цикла должен быть несколько иным.</p>

              <div
               class="EXAMPLE">
                <a
                 name="c4875_html_EX26A"></a>

                <p><strong>Пример 10-16. Цикл while с несколькими
                условиями</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

var1=unset
previous=$var1

while echo &quot;предыдущее значение = $previous&quot;
      echo
      previous=$var1     # запомнить предыдущее значение
      [ &quot;$var1&quot; != end ]
      # В операторе &quot;while&quot; присутствуют 4 условия, но только последнее управляет циклом.
      # *последнее* условие - единственное, которое вычисляется.
do
echo &quot;Введите значение переменной #1 (end - выход) &quot;
  read var1
  echo &quot;текущее значение = $var1&quot;
done

# попробуйте самостоятельно разобраться в сценарии works.

exit 0
</pre>
              </div>

              <p>Как и в случае с <strong
               class="COMMAND">for</strong>, цикл <strong
               class="COMMAND">while</strong> может быть записан в
              C-подобной нотации, с использованием двойных круглых
              скобок (см. так же <a
               href="#x4862_html_CVARS">Пример 9-28</a>).</p>

              <div
               class="EXAMPLE">
                <a
                 name="c4875_html_WHLOOPC"></a>

                <p><strong>Пример 10-17. C-подобный синтаксис
                оформления цикла while</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# wh-loopc.sh: Цикл перебора от 1 до 10.

LIMIT=10
a=1

while [ &quot;$a&quot; -le $LIMIT ]
do
  echo -n &quot;$a &quot;
  let &quot;a+=1&quot;
done           # Пока ничего особенного.

echo; echo

# +=================================================================+

# А теперь оформим в стиле языка C.

((a = 1))      # a=1
# Двойные скобки допускают наличие лишних пробелов в выражениях.

while (( a &lt;= LIMIT ))   # В двойных скобках символ &quot;$&quot; перед переменными опускается.
do
  echo -n &quot;$a &quot;
  ((a += 1))   # let &quot;a+=1&quot;
  # Двойные скобки позволяют наращивание переменной в стиле языка C.
done

echo

# Теперь, программисты, пишущие на C, могут чувствовать себя в Bash как дома.

exit 0
</pre>
              </div>

              <div
               class="NOTE">
                <table
                 class="NOTE"
                 width="90%"
                 border="0">
                  <tr>
                    <td
                     width="25"
                     align="center"
                     valign="top"><img
                     src="misc/abs-book/images/note.gif"
                     hspace="5"
                     alt="Note"></td>

                    <td
                     align="left"
                     valign="top">
                      <p>Стандартное устройство ввода <tt
                       class="FILENAME">stdin</tt>, для цикла <strong
                       class="COMMAND">while</strong>, можно <a
                       href="#x11731_html_REDIRREF">перенаправить на
                      файл</a> с помощью команды перенаправления <span
                       class="TOKEN">&lt;</span> в конце цикла.</p>
                    </td>
                  </tr>
                </table>
              </div>
            </dd>

            <dt><a
             name="c4875_html_UNTILLOOPREF"></a><strong
             class="COMMAND">until</strong></dt>

            <dd>
              <p>Оператор цикла <strong
               class="COMMAND">until</strong> проверяет условие в
              начале каждой итерации, но в отличие от <strong
               class="COMMAND">while</strong> итерация возможна только
              в том случае, если условие ложно.</p>

              <p><strong
               class="COMMAND">until</strong> [<tt
               class="REPLACEABLE"><em>condition-is-true</em></tt>]<br>
               do<br>
               <tt
               class="REPLACEABLE"><em> command</em></tt>...<br>
               done</p>
              <br>
              <br>

              <p>Обратите внимание: оператор <strong
               class="COMMAND">until</strong> проверяет условие
              завершения цикла ПЕРЕД очередной итерацией, а не после,
              как это принято в некоторых языках программирования.</p>

              <p>Как и в случае с циклами <span
               class="TOKEN">for/in</span>, при размещении ключевого
              слова <strong
               class="COMMAND">do</strong> в одной строке с объявлением
              цикла, необходимо вставлять символ &quot;;&quot; перед
              <strong
               class="COMMAND">do</strong>.</p>

              <p><strong
               class="COMMAND">until</strong> [<tt
               class="REPLACEABLE"><em>condition-is-true</em></tt>] ;
              do</p>
              <br>
              <br>

              <div
               class="EXAMPLE">
                <a
                 name="c4875_html_EX27"></a>

                <p><strong>Пример 10-18. Цикл until</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

until [ &quot;$var1&quot; = end ] # Проверка условия производится в начале итерации.
do
  echo &quot;Введите значение переменной #1 &quot;
  echo &quot;(end - выход)&quot;
  read var1
  echo &quot;значение переменной #1 = $var1&quot;
done  

exit 0
</pre>
              </div>
            </dd>
          </dl>
        </div>
      </div>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x4862_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x5140_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Двойные круглые скобки</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#p3268_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Вложенные циклы</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="c5358_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x5210_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#c6407_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="CHAPTER">
      <h1><a
       name="c5358_html_INTERNAL"></a>Глава 11. Внутренние команды</h1>

      <p><a
       name="c5358_html_BUILTINREF"></a><em
       class="FIRSTTERM">Внутренняя</em> команда -- это <strong
       class="COMMAND">команда</strong>, которая встроена
      непосредственно в Bash. Команды делаются встроенными либо из
      соображений производительности -- встроенные команды исполняются
      быстрее, чем внешние, которые, как правило, запускаются в
      дочернем процессе, либо из-за необходимости прямого доступа к
      внутренним структурам командного интерпретатора.</p>

      <p><a
       name="c5358_html_FORKREF"></a></p>

      <table
       class="SIDEBAR"
       border="1"
       cellpadding="5">
        <tr>
          <td>
            <div
             class="SIDEBAR">
              <a
               name="c5358_html_AEN5368"></a>

              <p>Действие, когда какая либо команда или сама командная
              оболочка инициирует (<span
               class="emphasis"><em
               class="EMPHASIS">порождает</em></span>) новый
              подпроцесс, что бы выполнить какую либо работу,
              называется <span
               class="emphasis"><em
               class="EMPHASIS">ветвлением</em></span> (<span
               class="emphasis"><em
               class="EMPHASIS">forking</em></span>) процесса. Новый
              процесс называется <span
               class="QUOTE">&quot;дочерним&quot;</span> (или
              &quot;потомком&quot;), а породивший его процесс -- <span
               class="QUOTE">&quot;родительским&quot;</span> (или
              &quot;предком&quot;). В результате и <span
               class="emphasis"><em
               class="EMPHASIS">потомок</em></span> и <span
               class="emphasis"><em
               class="EMPHASIS">предок</em></span> продолжают
              исполняться одновременно -- параллельно друг другу.</p>

              <p>В общем случае, <span
               class="emphasis"><em
               class="EMPHASIS">встроенные команды</em></span> Bash,
              при исполнении внутри сценария, не порождают новый
              подпроцесс, в то время как вызов внешних команд, как
              правило, приводит к созданию нового подпроцесса.</p>
            </div>
          </td>
        </tr>
      </table>

      <p>Внутренние команды могут иметь внешние аналоги. Например,
      внутренняя команда Bash -- <strong
       class="COMMAND">echo</strong> имеет внешний аналог <tt
       class="FILENAME">/bin/echo</tt> и их поведение практически
      идентично.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

echo &quot;Эта строка выводится внутренней командой \&quot;echo\&quot;.&quot;
/bin/echo &quot;А эта строка выводится внешней командой the /bin/echo.&quot;
</pre>
      <br>
      <br>

      <p><a
       name="c5358_html_KEYWORDREF"></a><em
       class="FIRSTTERM">Ключевое слово</em> (keyword) -- это <span
       class="emphasis"><em
       class="EMPHASIS">зарезервированное</em></span> слово,
      синтаксический элемент (token) или оператор. Ключевые слова имеют
      специальное назначение для командного интерпретатора, и
      фактически являются элементами синтаксиса языка командной
      оболочки. В качестве примера можно привести <span
       class="QUOTE">&quot;<span
       class="TOKEN">for</span>&quot;</span>, <span
       class="QUOTE">&quot;<span
       class="TOKEN">while</span>&quot;</span>, <span
       class="QUOTE">&quot;do&quot;</span>, <span
       class="QUOTE">&quot;<span
       class="TOKEN">!</span>&quot;</span>, которые являются ключевыми
      (или зарезервированными) словами. Подобно <span
       class="emphasis"><em
       class="EMPHASIS">встроенным командам</em></span>, ключевые слова
      жестко зашиты в Bash, но в отличие от встроенных команд, ключевые
      слова не являются командами как таковыми, хотя при этом могут
      являться их составной частью. <a
       name="AEN5395"
       href="#c5358_html_FTN_AEN5395"><span
       class="footnote">[1]</span></a></p>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="c5358_html_INTIO1"></a>Ввод/вывод</strong></p>

        <dl>
          <dt><a
           name="c5358_html_ECHOREF"></a><strong
           class="COMMAND">echo</strong></dt>

          <dd>
            <p>выводит (на <tt
             class="FILENAME">stdout</tt>) выражение или содержимое
            переменной (см. <a
             href="#c1613_html_EX9">Пример 4-1</a>).</p>
<pre
 class="PROGRAMLISTING">
echo Hello
echo $a
</pre>
            <br>
            <br>

            <p>Для вывода экранированных символов, <strong
             class="COMMAND">echo</strong> требует наличие ключа <tt
             class="OPTION">-e</tt>. См. <a
             href="#c1833_html_ESCAPED">Пример 5-2</a>.</p>

            <p>Обычно, командв <strong
             class="COMMAND">echo</strong> выводит в конце символ
            перевода строки. Подавить вывод это символа можно ключом
            <tt
             class="OPTION">-n</tt>.</p>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Команда <strong
                     class="COMMAND">echo</strong> может использоваться
                    для передачи информации по конвейеру другим
                    командам.</p>
<pre
 class="PROGRAMLISTING">
if echo &quot;$VAR&quot; | grep -q txt   # if [[ $VAR = *txt* ]]
then
  echo &quot;$VAR содержит подстроку \&quot;txt\&quot;&quot;
fi
</pre>
                    <br>
                    <br>
                  </td>
                </tr>
              </table>
            </div>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Кроме того, команда <strong
                     class="COMMAND">echo</strong>, в комбинации с <a
                     href="#c11441_html_COMMANDSUBREF">подстановкой
                    команд</a> может учавствовать в операции присвоения
                    значения переменной.</p>

                    <p><tt
                     class="USERINPUT"><strong>a=`echo
                    &quot;HELLO&quot; | tr A-Z a-z`</strong></tt></p>

                    <p>См. так же <a
                     href="#x7050_html_LOWERCASE">Пример 12-15</a>, <a
                     href="#x6646_html_EX57">Пример 12-2</a>, <a
                     href="#x9199_html_MONTHLYPMT">Пример 12-32</a> и <a
                     href="#x9199_html_BASE">Пример 12-33</a>.</p>
                  </td>
                </tr>
              </table>
            </div>

            <p>Следует запомнить, что команда <strong
             class="COMMAND">echo `command`</strong> удалит все символы
            перевода строки, которые будут выведены командой <tt
             class="REPLACEABLE"><em>command</em></tt>.</p>

            <p>Переменная <a
             href="#c3270_html_IFSREF">$IFS</a> обычно содержит символ
            перевода строки <span
             class="TOKEN">\n</span>, как один из вариантов <a
             href="#c301_html_WHITESPACEREF">пробельного</a> символа.
            Bash разобьет вывод команды <tt
             class="REPLACEABLE"><em>command</em></tt>, по пробельным
            символам, на аргументы и передаст их команде <strong
             class="COMMAND">echo</strong>, которая выведет эти
            аргументы, разделенные пробелами.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>ls -l /usr/share/apps/kjezz/sounds</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">-rw-r--r--    1 root     root         1407 Nov  7  2000 reflect.au
-rw-r--r--    1 root     root          362 Nov  7  2000 seconds.au</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>echo `ls -l /usr/share/apps/kjezz/sounds`</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">total 40 -rw-r--r-- 1 root root 716 Nov 7 2000 reflect.au -rw-r--r-- 1 root root 362 Nov 7 2000 seconds.au</tt>
             
</pre>
            <br>
            <br>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Это встроенная команда Bash и имеет внешний
                    аналог <tt
                     class="FILENAME">/bin/echo</tt>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>type -a echo</strong></tt>
<tt
 class="COMPUTEROUTPUT">echo is a shell builtin
echo is /bin/echo</tt>
             
</pre>
                    <br>
                    <br>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><a
           name="c5358_html_PRINTFREF"></a><strong
           class="COMMAND">printf</strong></dt>

          <dd>
            <p><strong
             class="COMMAND">printf</strong> -- команда
            форматированного вывода, расширенный вариант команды
            <strong
             class="COMMAND">echo</strong> и ограниченный вариант
            библиотечной функции <tt
             class="FUNCTION">printf()</tt> в языке C, к тому же
            синтаксис их несколько отдичается друг от друга.</p>

            <p><strong
             class="COMMAND">printf</strong> <tt
             class="REPLACEABLE"><em>format-string</em></tt>... <tt
             class="REPLACEABLE"><em>parameter</em></tt>...</p>

            <p>Это встроенная команда Bash. Имеет внешний аналог <tt
             class="FILENAME">/bin/printf</tt> или <tt
             class="FILENAME">/usr/bin/printf</tt>. За более подробной
            информацией обращайтесь к страницам справочного руководства
            <strong
             class="COMMAND">man 1 printf</strong> по системным
            командам.</p>

            <div
             class="CAUTION">
              <table
               class="CAUTION"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/caution.gif"
                   hspace="5"
                   alt="Caution"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Старые версии Bash могут не поддерживать команду
                    <strong
                     class="COMMAND">printf</strong>.</p>
                  </td>
                </tr>
              </table>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="c5358_html_EX47"></a>

              <p><strong>Пример 11-1. printf в действии</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# printf demo

# От переводчика:
# Считаю своим долгом напомнить, что в качестве разделителя дробной и целой
# частей в вещественных числах, может использоваться символ &quot;запятая&quot;
# (в русских локалях), поэтому данный сценарий может выдавать сообщение
# об ошибке (у меня так и произошло) при выводе числа PI.
# Тогда попробуйте заменить в определении числа PI десятичную точку
# на запятую -- это должно помочь. ;-)

PI=3,14159265358979
DecimalConstant=31373
Message1=&quot;Поздравляю,&quot;
Message2=&quot;Землянин.&quot;

echo

printf &quot;Число пи с точностью до 2 знака после запятой = %1.2f&quot; $PI
echo
printf &quot;Число пи с точностью до 9 знака после запятой = %1.9f&quot; $PI  # Даже округляет правильно.

printf &quot;\n&quot;                                  # Перевод строки,

printf &quot;Константа = \t%d\n&quot; $DecimalConstant  # Вставлен символ табуляции (\t)

printf &quot;%s %s \n&quot; $Message1 $Message2

echo

# ==========================================#
# Эмуляция функции &#39;sprintf&#39; в языке C.
# Запись форматированной строки в переменную.

echo

Pi12=$(printf &quot;%1.12f&quot; $PI)
echo &quot;Число пи с точностью до 12 знака после запятой = $Pi12&quot;

Msg=`printf &quot;%s %s \n&quot; $Message1 $Message2`
echo $Msg; echo $Msg

exit 0
</pre>
            </div>

            <p>Одно из полезных применений команды <strong
             class="COMMAND">printf</strong> -- форматированный вывод
            сообщений об ошибках</p>
<pre
 class="PROGRAMLISTING">
E_BADDIR=65

var=nonexistent_directory

error()
{
  printf &quot;$@&quot; &gt;&amp;2
  # Форматированный вывод аргументов на stderr.
  echo
  exit $E_BADDIR
}

cd $var || error $&quot;Невозможно перейти в каталог %s.&quot; &quot;$var&quot;

# Спасибо S.C.
</pre>
            <br>
            <br>
          </dd>

          <dt><a
           name="c5358_html_READREF"></a><strong
           class="COMMAND">read</strong></dt>

          <dd>
            <p><span
             class="QUOTE">&quot;Читает&quot;</span> значение
            переменной с устройства стандартного ввода -- <tt
             class="FILENAME">stdin</tt>, в интерактивном режиме это
            означает клавиатуру. Ключ <tt
             class="OPTION">-a</tt> позволяет записывать значения в
            массивы (см. <a
             href="#c12790_html_EX67">Пример 25-3</a>).</p>

            <div
             class="EXAMPLE">
              <a
               name="c5358_html_EX36"></a>

              <p><strong>Пример 11-2. Ввод значений переменных с
              помощью read</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

echo -n &quot;дите значение переменной &#39;var1&#39;: &quot;
# Ключ -n подавляет вывод символа перевода строки.

read var1
# Обратите внимание -- перед именем переменной отсутствует символ &#39;$&#39;.

echo &quot;var1 = $var1&quot;


echo

# Одной командой &#39;read&#39; можно вводить несколько переменных.
echo -n &quot;дите значения для переменных &#39;var2&#39; и &#39;var3&#39; (через пробел или табуляцию): &quot;
read var2 var3
echo &quot;var2 = $var2      var3 = $var3&quot;
# Если было введено значение только одной переменной, то вторая останется &quot;пустой&quot;.

exit 0
</pre>
            </div>

            <p>Если команде <strong
             class="COMMAND">read</strong> не была передано ни одной
            переменной, то ввод будет осуществлен в переменную <a
             href="#c3270_html_REPLYREF">$REPLY</a>.</p>

            <div
             class="EXAMPLE">
              <a
               name="c5358_html_READNOVAR"></a>

              <p><strong>Пример 11-3. Пример использования команды read
              без указания переменной для ввода</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

echo

# -------------------------- #
# Первый блок кода.
echo -n &quot;Введите значение: &quot;
read var
echo &quot;\&quot;var\&quot; = &quot;$var&quot;&quot;
# Здесь нет ничего неожиданного.
# -------------------------- #

echo

echo -n &quot;Введите другое значение: &quot;
read           #  Команда &#39;read&#39; употребляется без указания переменной для ввода,
               #+ тем не менее...
               #+ По-умолчанию ввод осуществляется в переменную $REPLY.
var=&quot;$REPLY&quot;
echo &quot;\&quot;var\&quot; = &quot;$var&quot;&quot;
# Эта часть сценария эквивалентна первому блоку, выделенному выше.

echo

exit 0
</pre>
            </div>

            <p>Обычно, при вводе в окне терминала с помощью команды
            &quot;read&quot;, символ <tt
             class="USERINPUT"><strong>\</strong></tt> служит для
            экранирования символа перевода строки. Ключ <tt
             class="OPTION">-r</tt> заставляет интерпретировать символ
            <tt
             class="USERINPUT"><strong>\</strong></tt> как обычный
            символ.</p>

            <div
             class="EXAMPLE">
              <a
               name="c5358_html_READR"></a>

              <p><strong>Пример 11-4. Ввод многострочного текста с
              помощью read</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

echo

echo &quot;Введите строку, завершающуюся символом \\, и нажмите ENTER.&quot;
echo &quot;Затем введите вторую строку, и снова нажмите ENTER.&quot;
read var1     # При чтении, символ &quot;\&quot; экранирует перевод строки.
              #     первая строка \
              #     вторая строка

echo &quot;var1 = $var1&quot;
#     var1 = первая строка вторая строка

# После ввода каждой строки, завершающейся символом &quot;\&quot;,
# вы можете продолжать ввод на другой строке.

echo; echo

echo &quot;Введите другую строку, завершающуюся символом \\, и нажмите ENTER.&quot;
read -r var2  # Ключ -r заставляет команду &quot;read&quot; воспринимать &quot;\&quot;
              # как обычный символ.
              #     первая строка \

echo &quot;var2 = $var2&quot;
#     var2 = первая строка \

# Ввод данных прекращается сразу же после первого нажатия на клавишу ENTER.

echo 

exit 0
</pre>
            </div>

            <p>Команда <strong
             class="COMMAND">read</strong> имеет ряд очень любопытных
            опций, которые позволяют выводить подсказку - приглашение
            ко вводу (prompt), и даже читать данные не дожидаясь
            нажатия на клавишу <strong
             class="KEYCAP">ENTER</strong>.</p>
<pre
 class="PROGRAMLISTING">
# Чтение данных, не дожидаясь нажатия на клавишу ENTER.

read -s -n1 -p &quot;Нажмите клавишу &quot; keypress
echo; echo &quot;Была нажата клавиша &quot;\&quot;$keypress\&quot;&quot;.&quot;

# -s   -- подавляет эхо-вывод, т.е. ввод с клавиатуры не отображается на экране.
# -n N -- ввод завершается автоматически, сразу же после ввода N-го символа.
# -p   -- задает вид строки подсказки - приглашения к вводу (prompt).

# Использование этих ключей немного осложняется тем, что они должны следовать в определенном порядке.
</pre>
            <br>
            <br>

            <p>Ключ <tt
             class="OPTION">-n</tt>, кроме всего прочего, позволяет
            команде <strong
             class="COMMAND">read</strong> обнаруживать нажатие <span
             class="emphasis"><em
             class="EMPHASIS">курсорных</em></span> и некоторых других
            служебных клавиш.</p>

            <div
             class="EXAMPLE">
              <a
               name="c5358_html_ARROWDETECT"></a>

              <p><strong>Пример 11-5. Обнаружение нажатия на курсорные
              клавиши</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# arrow-detect.sh: Обнаружение нажатия на курсорные клавиши, и не только...
# Спасибо Sandro Magi за то что показал мне -- как.

# --------------------------------------------
# Коды клавиш.
arrowup=&#39;\[A&#39;
arrowdown=&#39;\[B&#39;
arrowrt=&#39;\[C&#39;
arrowleft=&#39;\[D&#39;
insert=&#39;\[2&#39;
delete=&#39;\[3&#39;
# --------------------------------------------

SUCCESS=0
OTHER=65

echo -n &quot;Нажмите на клавишу...  &quot;
# Может потребоваться нажать на ENTER, если была нажата клавиша
# не входящая в список выше.
read -n3 key                      # Прочитать 3 символа.

echo -n &quot;$key&quot; | grep &quot;$arrowup&quot;  #Определение нажатой клавиши.
if [ &quot;$?&quot; -eq $SUCCESS ]
then
  echo &quot;Нажата клавиша \&quot;.&quot;
  exit $SUCCESS
fi

echo -n &quot;$key&quot; | grep &quot;$arrowdown&quot;
if [ &quot;$?&quot; -eq $SUCCESS ]
then
  echo &quot;Нажата клавиша \&quot;
  exit $SUCCESS
fi

echo -n &quot;$key&quot; | grep &quot;$arrowrt&quot;
if [ &quot;$?&quot; -eq $SUCCESS ]
then
  echo &quot;Нажата клавиша \&quot;О\&quot;.&quot;
  exit $SUCCESS
fi

echo -n &quot;$key&quot; | grep &quot;$arrowleft&quot;
if [ &quot;$?&quot; -eq $SUCCESS ]
then
  echo &quot;Нажата клавиша \&quot;.&quot;
  exit $SUCCESS
fi

echo -n &quot;$key&quot; | grep &quot;$insert&quot;
if [ &quot;$?&quot; -eq $SUCCESS ]
then
  echo &quot;Нажата клавиша \&quot;Insert\&quot;.&quot;
  exit $SUCCESS
fi

echo -n &quot;$key&quot; | grep &quot;$delete&quot;
if [ &quot;$?&quot; -eq $SUCCESS ]
then
  echo &quot;Нажата клавиша \&quot;Delete\&quot;.&quot;
  exit $SUCCESS
fi


echo &quot; Нажата какая-то другая клавиша.&quot;

exit $OTHER

#  Упражнения:
#  ---------
#  1) Упростите сценарий, заменив множество if-ов
#+    одной конструкцией &#39;case&#39;.
#  2) Добавьте определение нажатий на клавиши &quot;Home&quot;, &quot;End&quot;, &quot;PgUp&quot; и &quot;PgDn&quot;.
</pre>
            </div>

            <p>Ключ <tt
             class="OPTION">-t</tt> позволяет ограничивать время
            ожидания ввода командой <strong
             class="COMMAND">read</strong> (см. <a
             href="#c3270_html_TOUT">Пример 9-4</a>).</p>

            <p>Команда <strong
             class="COMMAND">read</strong> может считывать значения для
            переменных из файла, <a
             href="#c11620_html_IOREDIRREF">перенаправленного</a> на <tt
             class="FILENAME">stdin</tt>. Если файл содержит не одну
            строку, то переменной будет присвоена только первая строка.
            Если команде <strong
             class="COMMAND">read</strong> будет передано несколько
            переменных, то первая строка файла будет разбита, по
            пробелам, на несколько подстрок, каждая из которых будет
            записана в свою переменную. Будьте осторожны!</p>

            <div
             class="EXAMPLE">
              <a
               name="c5358_html_READREDIR"></a>

              <p><strong>Пример 11-6. Чтение командой read из файла
              через <a
               href=
              "#c11620_html_IOREDIRREF">перенаправление</a></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

read var1 &lt;data-file
echo &quot;var1 = $var1&quot;
# Первая строка из &quot;data-file&quot; целиком записывается в переменную var1

read var2 var3 &lt;data-file
echo &quot;var2 = $var2   var3 = $var3&quot;
# Обратите внимание!
# Поведение команды &quot;read&quot; далеко от ожидаемого!
# 1) Произошел возврат к началу файла.
# 2) Вместо того, чтобы последовательно читать строки из файла,
#    по числу переменных, первая строка файла была разбита на подстроки,
#    разделенные пробелами, которые и были записаны в переменные.
# 3) В последнюю переменную была записана вся оставшаяся часть строки.
# 4) Если команде &quot;read&quot; будет передано большее число переменных, чем подстрок
#    в первой строке файла, то последние переменные останутся &quot;пустыми&quot;.

echo &quot;------------------------------------------------&quot;

# Эта проблема легко разрешается с помощью цикла:
while read line
do
  echo &quot;$line&quot;
done &lt;data-file
# Спасибо Heiner Steven за разъяснения.

echo &quot;------------------------------------------------&quot;

# Разбор строки, разделенной на поля
# Для задания разделителя полей, используется переменная $IFS,

echo &quot;Список всех пользователей:&quot;
OIFS=$IFS; IFS=:       # В файле /etc/passwd, в качестве разделителя полей
                       # используется символ &quot;:&quot; .
while read name passwd uid gid fullname ignore
do
  echo &quot;$name ($fullname)&quot;
done &lt;/etc/passwd      # перенаправление ввода.
IFS=$OIFS              # Восстановление предыдущего состояния переменной $IFS.
# Эту часть кода написал Heiner Steven.



#  Если переменная $IFS устанавливается внутри цикла,
#+ то отпадает необходимость сохранения ее первоначального значения
#+ во временной переменной.
#  Спасибо Dim Segebart за разъяснения.
echo &quot;------------------------------------------------&quot;
echo &quot;Список всех пользователей:&quot;

while IFS=: read name passwd uid gid fullname ignore
do
  echo &quot;$name ($fullname)&quot;
done &lt;/etc/passwd   # перенаправление ввода.

echo
echo &quot;Значение переменной \$IFS осталось прежним: $IFS&quot;

exit 0
</pre>
            </div>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Передача информации, выводимой командой <a
                     href="#c5358_html_ECHOREF">echo</a>, <a
                     href="#c301_html_PIPEREF">по конвейеру</a> команде
                    <strong
                     class="COMMAND">read</strong>, <a
                     href="#c13371_html_BADREAD0">будет вызывать
                    ошибку</a>.</p>

                    <p>Тем не менее, передача данных по конвейеру от <a
                     href="#c6407_html_CATREF">cat</a>, кажется
                    срабатывает.</p>
<pre
 class="PROGRAMLISTING">
cat file1 file2 |
while read line
do
echo $line
done
</pre>
                    <br>
                    <br>
                  </td>
                </tr>
              </table>
            </div>
          </dd>
        </dl>
      </div>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="c5358_html_INTFILESYSTEM1"></a>Файловая система</strong></p>

        <dl>
          <dt><strong
           class="COMMAND">cd</strong></dt>

          <dd>
            <p>Уже знакомая нам команда <strong
             class="COMMAND">cd</strong>, изменяющая текущий каталог,
            может быть использована в случаях, когда некоторую команду
            необходимо запустить только находясь в определенном
            каталоге.</p>
<pre
 class="PROGRAMLISTING">
(cd /source/directory &amp;&amp; tar cf - . ) | (cd /dest/directory &amp;&amp; tar xpvf -)
</pre>
            [взято из <a
             href="#c301_html_COXEX">упоминавшегося ранее</a>
            примера]<br>
            <br>

            <p>Команда <strong
             class="COMMAND">cd</strong> с ключом <tt
             class="OPTION">-P</tt> (physical) игнорирует символические
            ссылки.</p>

            <p>Команда <span
             class="QUOTE">&quot;<strong
             class="COMMAND">cd -</strong>&quot;</span> выполняет
            переход в каталог <a
             href="#c3270_html_OLDPWD">$OLDPWD</a> -- предыдущий рабочий
            каталог.</p>

            <p><a
             name="c5358_html_DOUBLESLASHREF"></a></p>

            <div
             class="CAUTION">
              <table
               class="CAUTION"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/caution.gif"
                   hspace="5"
                   alt="Caution"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Неожиданным образом выполняется команда <strong
                     class="COMMAND">cd</strong>, если ей передать, в
                    качестве каталога назначения, два слэша.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>cd //</strong></tt>
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>pwd</strong></tt>
<tt
 class="COMPUTEROUTPUT">//</tt>
             
</pre>
                    Само собой разумеется, это должен был бы быть
                    каталог <tt
                     class="COMPUTEROUTPUT">/</tt>. Эта проблема
                    наблюдается как в командной строке, так и в
                    сценариях.<br>
                    <br>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><a
           name="c5358_html_PWD2REF"></a><strong
           class="COMMAND">pwd</strong></dt>

          <dd>
            <p>Выводит название текущего рабочего каталога (Print
            Working Directory) (см. <a
             href="#c5358_html_EX37">Пример 11-7</a>). Кроме того, имя
            текущего каталога хранится во внутренней переменной <a
             href="#c3270_html_PWDREF">$PWD</a>.</p>
          </dd>

          <dt><a
           name="c5358_html_DIRSD"></a><strong
           class="COMMAND">pushd</strong>, <strong
           class="COMMAND">popd</strong>, <strong
           class="COMMAND">dirs</strong></dt>

          <dd>
            <p>Этот набор команд является составной частью механизма
            &quot;закладок&quot; на каталоги и позволяет перемещаться
            по каталогам вперед и назад в заданном порядке. Для
            хранения имен каталогов используется стек (LIFO --
            &quot;последний вошел, первый вышел&quot;).</p>

            <p><a
             name="c5358_html_PUSHDREF"></a><tt
             class="USERINPUT"><strong>pushd dir-name</strong></tt> --
            помещает имя текущего каталога в стек и осуществляет
            переход в каталог <tt
             class="REPLACEABLE"><em>dir-name</em></tt>.</p>

            <p><a
             name="c5358_html_POPDREF"></a><strong
             class="COMMAND">popd</strong> -- выталкивает, находящееся
            на вершине стека, имя каталога и одновременно осуществляет
            переход в каталог, оказавшийся на врешине стека.</p>

            <p><strong
             class="COMMAND">dirs</strong> -- выводит содержимое стека
            каталогов (сравните с переменной <a
             href="#c3270_html_DIRSTACKREF">$DIRSTACK</a>). В случае
            успеха, обе команды -- <strong
             class="COMMAND">pushd</strong> и <strong
             class="COMMAND">popd</strong> автоматически вызывают
            <strong
             class="COMMAND">dirs</strong>.</p>

            <p>Эти команды могут оказаться весьма полезными, когда в
            сценарии нужно производить частую смену каталогов, но при
            этом не хочется жестко &quot;зашивать&quot; имена
            каталогов. Обратите внимание: содержимое стека каталогов
            постоянно хранится в переменной-массиве -- <tt
             class="VARNAME">$DIRSTACK</tt>.</p>

            <div
             class="EXAMPLE">
              <a
               name="c5358_html_EX37"></a>

              <p><strong>Пример 11-7. Смена текущего
              каталога</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

dir1=/usr/local
dir2=/var/spool

pushd $dir1
# Команда &#39;dirs&#39; будет вызвана автоматически (на stdout будет выведено содержимое стека).
echo &quot;Выполнен переход в каталог `pwd`.&quot; # Обратные одиночные кавычки.

# Теперь можно выполнить какие либо действия в каталоге &#39;dir1&#39;.
pushd $dir2
echo &quot;Выполнен переход в каталог `pwd`.&quot;

# Теперь можно выполнить какие либо действия в каталоге &#39;dir2&#39;.
echo &quot;На вершине стека находится: $DIRSTACK.&quot;
popd
echo &quot;Возврат в каталог `pwd`.&quot;

# Теперь можно выполнить какие либо действия в каталоге &#39;dir1&#39;.
popd
echo &quot;Возврат в первоначальный рабочий каталог `pwd`.&quot;

exit 0
</pre>
            </div>
          </dd>
        </dl>
      </div>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="c5358_html_INTVAR1"></a>Переменные</strong></p>

        <dl>
          <dt><a
           name="c5358_html_LETREF"></a><strong
           class="COMMAND">let</strong></dt>

          <dd>
            <p>Команда <strong
             class="COMMAND">let</strong> производит арифметические
            операции над переменными. В большинстве случаев, ее можно
            считать упрощенным вариантом команды <a
             href="#x6646_html_EXPRREF">expr</a>.</p>

            <div
             class="EXAMPLE">
              <a
               name="c5358_html_EX46"></a>

              <p><strong>Пример 11-8. Команда let, арифметические
              операции.</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

echo

let a=11          # То же, что и &#39;a=11&#39;
let a=a+5         # Эквивалентно &quot;a = a + 5&quot;
                  # (Двойные кавычки и дополнительные пробелы делают код более удобочитаемым)
echo &quot;11 + 5 = $a&quot;

let &quot;a &lt;&lt;= 3&quot;     # Эквивалентно  let &quot;a = a &lt;&lt; 3&quot;
echo &quot;\&quot;\$a\&quot; (=16) после сдвига влево на 3 разряда = $a&quot;

let &quot;a /= 4&quot;      # Эквивалентно let &quot;a = a / 4&quot;
echo &quot;128 / 4 = $a&quot;

let &quot;a -= 5&quot;      # Эквивалентно let &quot;a = a - 5&quot;
echo &quot;32 - 5 = $a&quot;

let &quot;a = a * 10&quot;  # Эквивалентно let &quot;a = a * 10&quot;
echo &quot;27 * 10 = $a&quot;

let &quot;a %= 8&quot;      # Эквивалентно let &quot;a = a % 8&quot;
echo &quot;270 mod 8 = $a  (270 / 8 = 33, остаток = $a)&quot;

echo

exit 0
</pre>
            </div>
          </dd>

          <dt><a
           name="c5358_html_EVALREF"></a><strong
           class="COMMAND">eval</strong></dt>

          <dd>
            <p><tt
             class="USERINPUT"><strong>eval arg1 [arg2] ...
            [argN]</strong></tt></p>

            <p>Транслирует список аргументов, из списка, в команды.</p>

            <div
             class="EXAMPLE">
              <a
               name="c5358_html_EX43"></a>

              <p><strong>Пример 11-9. Демонстрация команды
              eval</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

y=`eval ls -l`  # Подобно y=`ls -l`
echo $y         # но символы перевода строки не выводятся, поскольку имя переменной не в кавычках.
echo
echo &quot;$y&quot;       # Если имя переменной записать в кавычках -- символы перевода строки сохраняются.

echo; echo

y=`eval df`     # Аналогично y=`df`
echo $y         # но без символов перевода строки.

#  Когда производится подавление вывода символов LF (перевод строки), то анализ
#+ результатов различными утилитами, такими как awk, можно сделать проще.

exit 0
</pre>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="c5358_html_EX44"></a>

              <p><strong>Пример 11-10. Принудительное завершение
              сеанса</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

y=`eval ps ax | sed -n &#39;/ppp/p&#39; | awk &#39;{ print $1 }&#39;`
# Выяснить PID процесса &#39;ppp&#39;.

kill -9 $y   # &quot;Прихлопнуть&quot; его

# Предыдущие строки можно заменить одной строкой
#  kill -9 `ps ax | awk &#39;/ppp/ { print $1 }&#39;


chmod 666 /dev/ttyS3
# Завершенный, по сигналу SIGKILL, ppp изменяет права доступа
# к последовательному порту. Вернуть их в первоначальное состояние.

rm /var/lock/LCK..ttyS3   # Удалить lock-файл последовательного порта.

exit 0
</pre>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="c5358_html_ROT14"></a>

              <p><strong>Пример 11-11. Шифрование по алгоритму <span
               class="QUOTE">&quot;rot13&quot;</span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Реализация алгоритма шифрования &quot;rot13&quot; с помощью &#39;eval&#39;.
# Сравните со сценарием &quot;rot13.sh&quot;.

setvar_rot_13()              # Криптование по алгоритму &quot;rot13&quot;
{
  local varname=$1 varvalue=$2
  eval $varname=&#39;$(echo &quot;$varvalue&quot; | tr a-z n-za-m)&#39;
}


setvar_rot_13 var &quot;foobar&quot;   # Пропустить слово &quot;foobar&quot; через rot13.
echo $var                    # sbbone

echo $var | tr a-z n-za-m    # foobar
                             # Расшифровывание.

# Пример предоставил Stephane Chazelas.

exit 0
</pre>
            </div>

            <p>Rory Winston представил следующий пример, как образец
            практического использования команды <strong
             class="COMMAND">eval</strong>.</p>

            <div
             class="EXAMPLE">
              <a
               name="c5358_html_EVALEX"></a>

              <p><strong>Пример 11-12. Замена имени переменной на ее
              значение, в исходном тексте программы на языке Perl, с
              помощью eval</strong></p>
<pre
 class="PROGRAMLISTING">
В программе &quot;test.pl&quot;, на языке Perl:
        ...
        my $WEBROOT = &lt;WEBROOT_PATH&gt;;
        ...

Эта попытка подстановки значения переменной вместо ее имени:
        $export WEBROOT_PATH=/usr/local/webroot
        $sed &#39;s/&lt;WEBROOT_PATH&gt;/$WEBROOT_PATH/&#39; &lt; test.pl &gt; out

даст такой результат:
        my $WEBROOT = $WEBROOT_PATH;

Тем не менее:
        $export WEBROOT_PATH=/usr/local/webroot
        $eval sed &#39;s/&lt;WEBROOT_PATH&gt;/$WEBROOT_PATH/&#39; &lt; test.pl &gt; out
#        ====

Этот вариант дал желаемый результат -- имя переменной, в тексте программы,
благополучно было заменено на ее значение:
        my $WEBROOT = /usr/local/webroot
</pre>
            </div>

            <div
             class="CAUTION">
              <table
               class="CAUTION"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/caution.gif"
                   hspace="5"
                   alt="Caution"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Команда <strong
                     class="COMMAND">eval</strong> может быть
                    небезопасна. Если существует приемлемая
                    альтернатива, то желательно воздерживаться от
                    использования <strong
                     class="COMMAND">eval</strong>. Так, <tt
                     class="USERINPUT"><strong>eval
                    $COMMANDS</strong></tt> исполняет код, который
                    записан в переменную <tt
                     class="REPLACEABLE"><em>COMMANDS</em></tt>,
                    которая, в свою очередь, может содержать весьма
                    неприятные сюрпризы, например <strong
                     class="COMMAND">rm -rf *</strong>. Использование
                    команды <strong
                     class="COMMAND">eval</strong>, для исполнения кода
                    неизвестного происхождения, крайне опасно.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><a
           name="c5358_html_SETREF"></a><strong
           class="COMMAND">set</strong></dt>

          <dd>
            <p>Команда <strong
             class="COMMAND">set</strong> изменяет значения внутренних
            переменных сценария. Она может использоваться для
            переключения <a
             href="#c13228_html_OPTIONSREF">опций (ключей, флагов)</a>,
            определяющих поведение скрипта. Еще одно применение --
            сброс/установка <a
             href="#c3270_html_POSPARAMREF">позиционных параметров
            (аргументов)</a>, значения которых будут восприняты как
            результат работы команды (<tt
             class="USERINPUT"><strong>set
            `command`</strong></tt>).</p>

            <div
             class="EXAMPLE">
              <a
               name="c5358_html_EX34"></a>

              <p><strong>Пример 11-13. Установка значений аргументов с
              помощью команды set</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# script &quot;set-test&quot;

# Вызовите сценарий с тремя аргументами командной строки,
# например: &quot;./set-test one two three&quot;.

echo
echo &quot;Аргументы перед вызовом set \`uname -a\` :&quot;
echo &quot;Аргумент #1 = $1&quot;
echo &quot;Аргумент #2 = $2&quot;
echo &quot;Аргумент #3 = $3&quot;


set `uname -a` # Изменение аргументов
               # значения которых берутся из результата работы `uname -a`

echo $_

echo &quot;Аргументы после вызова set \`uname -a\` :&quot;
#  $1, $2, $3 и т.д. будут переустановлены в соответствии с выводом
#+ команды `uname -a`
echo &quot;Поле #1 &#39;uname -a&#39; = $1&quot;
echo &quot;Поле #2 &#39;uname -a&#39; = $2&quot;
echo &quot;Поле #3 &#39;uname -a&#39; = $3&quot;
echo ---
echo $_        # ---
echo

exit 0
</pre>
            </div>

            <p>Вызов <strong
             class="COMMAND">set</strong> без параметров просто выводит
            список инициализированных переменных <a
             href="#x1716_html_ENVREF">окружения</a>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>set</strong></tt>
<tt
 class="COMPUTEROUTPUT">AUTHORCOPY=/home/bozo/posts
 BASH=/bin/bash
 BASH_VERSION=$&#39;2.05.8(1)-release&#39;
 ...
 XAUTHORITY=/home/bozo/.Xauthority
 _=/etc/bashrc
 variable22=abc
 variable23=xzy</tt>
             
</pre>
            <br>
            <br>

            <p>Если команда <strong
             class="COMMAND">set</strong> используется с ключом <span
             class="QUOTE">&quot;<tt
             class="OPTION">--</tt>&quot;</span>, после которого
            следует переменная, то значение переменной переносится в
            позиционные параметры (аргументы). Если имя переменной
            отсутствует, то эта команда приводит к сбросу позиционных
            параметров.</p>

            <div
             class="EXAMPLE">
              <a
               name="c5358_html_SETPOS"></a>

              <p><strong>Пример 11-14. Изменение значений позиционных
              параметров (аргументов)</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

variable=&quot;one two three four five&quot;

set -- $variable
# Значения позиционных параметров берутся из &quot;$variable&quot;.

first_param=$1
second_param=$2
shift; shift        # сдвиг двух первых параметров.
remaining_params=&quot;$*&quot;

echo
echo &quot;первый параметр = $first_param&quot;            # one
echo &quot;второй параметр = $second_param&quot;           # two
echo &quot;остальные параметры = $remaining_params&quot;   # three four five

echo; echo

# Снова.
set -- $variable
first_param=$1
second_param=$2
echo &quot;первый параметр = $first_param&quot;             # one
echo &quot;второй параметр = $second_param&quot;            # two

# ======================================================

set --
# Позиционные параметры сбрасываются, если не задано имя переменной.

first_param=$1
second_param=$2
echo &quot;первый параметр = $first_param&quot;            # (пустое значение)
echo &quot;второй параметр = $second_param&quot;           # (пустое значение)

exit 0
</pre>
            </div>

            <p>См. так же <a
             href="#c4875_html_EX22A">Пример 10-2</a> и <a
             href="#x9307_html_EX33A">Пример 12-40</a>.</p>
          </dd>

          <dt><a
           name="c5358_html_UNSETREF"></a><strong
           class="COMMAND">unset</strong></dt>

          <dd>
            <p>Команда <strong
             class="COMMAND">unset</strong> удаляет переменную,
            фактически -- устанавливает ее значение в <span
             class="emphasis"><em
             class="EMPHASIS">null</em></span>. Обратите внимание: эта
            команда не может сбрасывать позиционные параметры
            (аргументы).</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>unset PATH</strong></tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo $PATH</strong></tt>
<tt
 class="COMPUTEROUTPUT"></tt>
<tt
 class="PROMPT">bash$</tt>
</pre>
            <br>
            <br>

            <div
             class="EXAMPLE">
              <a
               name="c5358_html_UNS"></a>

              <p><strong>Пример 11-15. <span
               class="QUOTE">&quot;Сброс&quot;</span>
              переменной</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# unset.sh: Сброс переменной.

variable=hello                       # Инициализация.
echo &quot;variable = $variable&quot;

unset variable                       # Сброс.
                                     # Тот же эффект дает   variable=
echo &quot;(unset) variable = $variable&quot;  # $variable = null.

exit 0
</pre>
            </div>
          </dd>

          <dt><a
           name="c5358_html_EXPORTREF"></a><strong
           class="COMMAND">export</strong></dt>

          <dd>
            <p>Команда <strong
             class="COMMAND">export</strong> экспортирует переменную,
            делая ее доступной дочерним процессам. К сожалению,
            невозможно экспортировать переменную родительскому
            процессу. В качестве примера использования команды <strong
             class="COMMAND">export</strong> можно привести <a
             href="#c12891_html_FILESREF1">сценарии инициализации
            системы</a>, вызываемые в процессе загрузки, которые
            инициализируют и экспортируют <a
             href="#x1716_html_ENVREF">переменные окружения</a>, делая
            их доступными для пользовательских процессов.</p>

            <div
             class="EXAMPLE">
              <a
               name="c5358_html_COLTOTALER3"></a>

              <p><strong>Пример 11-16. Передача переменных во вложенный
              сценарий <a
               href="#x14802_html_AWKREF">awk</a>, с помощью
              export</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Еще одна версия сценария &quot;column totaler&quot; (col-totaler.sh)
# который суммирует заданную колонку (чисел) в заданном файле.
# Здесь используются переменные окружения, которые передаются сценарию &#39;awk&#39;.

ARGS=2
E_WRONGARGS=65

if [ $# -ne &quot;$ARGS&quot; ] # Проверка количества входных аргументов.
then
   echo &quot;Порядок использования: `basename $0` filename column-number&quot;
   exit $E_WRONGARGS
fi

filename=$1
column_number=$2

#===== До этой строки идентично первоначальному варианту сценария =====#

export column_number
# Экспорт номера столбца.


# Начало awk-сценария.
# ------------------------------------------------
awk &#39;{ total += $ENVIRON[&quot;column_number&quot;]
}
END { print total }&#39; $filename
# ------------------------------------------------
# Конец awk-сценария.


# Спасибо Stephane Chazelas.

exit 0
</pre>
            </div>

            <div
             class="TIP">
              <table
               class="TIP"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/tip.gif"
                   hspace="5"
                   alt="Tip"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Допускается объединение инициализации и экспорта
                    переменной в одну инструкцию: <strong
                     class="COMMAND">export var1=xxx</strong>.</p>

                    <p>Однако, как заметил Greg Keraunen, в некоторых
                    ситуациях такая комбинация может давать иной
                    результат, нежели раздельная инициализация и
                    экспорт.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>export var=(a b); echo ${var[0]}</strong></tt>
<tt
 class="COMPUTEROUTPUT">(a b)</tt>
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>var=(a b); export var; echo ${var[0]}</strong></tt>
<tt
 class="COMPUTEROUTPUT">a</tt>
             
</pre>
                    <br>
                    <br>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">declare</strong>, <strong
           class="COMMAND">typeset</strong></dt>

          <dd>
            <p>Команды <a
             href="#x4704_html">declare</a> и <a
             href="#x4704_html">typeset</a> задают и/или накладывают
            ограничения на переменные.</p>
          </dd>

          <dt><strong
           class="COMMAND">readonly</strong></dt>

          <dd>
            <p>То же самое, что и <a
             href="#x4704_html">declare -r</a>, делает переменную
            доступной только для чтения, т.е. переменная становится
            подобна константе. При попытке изменить значение такой
            переменной выводится сообщение об ошибке. Эта команда может
            расцениваться как квалификатор типа <strong
             class="COMMAND">const</strong> в языке C.</p>
          </dd>

          <dt><a
           name="c5358_html_GETOPTSX"></a><strong
           class="COMMAND">getopts</strong></dt>

          <dd>
            <p>Мощный инструмент, используемый для разбора аргументов,
            передаваемых сценарию из командной строки. Это встроенная
            команда Bash, но имеется и ее &quot;внешний&quot; аналог <a
             href="#x9307_html_GETOPTY">/usr/bin/getopt</a>, а так же
            программистам, пишущим на C, хорошо знакома похожая
            библиотечная функция <strong
             class="COMMAND">getopt</strong>. Она позволяет
            обрабатывать серии опций, объединенных в один аргумент <a
             name="AEN5877"
             href="#c5358_html_FTN_AEN5877"><span
             class="footnote">[2]</span></a> и дополнительные
            аргументы, передаваемые сценарию (например, <tt
             class="USERINPUT"><strong>scriptname -abc -e
            /usr/local</strong></tt>).</p>

            <p>С командой <strong
             class="COMMAND">getopts</strong> очень тесно взаимосвязаны
            скрытые переменные. <tt
             class="VARNAME">$OPTIND</tt> -- указатель на аргумент (<em
             class="WORDASWORD">OPTion INDex</em>) и <tt
             class="VARNAME">$OPTARG</tt> (<em
             class="WORDASWORD">OPTion ARGument</em>) -- дополнительный
            аргумент опции. Символ двоеточия, следующий за именем
            опции, указывает на то, что она имеет дополнительный
            аргумент.</p>

            <p>Обычно <strong
             class="COMMAND">getopts</strong> упаковывается в цикл <a
             href="#c4875_html_WHILELOOPREF">while</a>, в каждом проходе
            цикла извлекается очередная опция и ее аргумент (если он
            имеется), обрабатывается, затем уменьшается на 1 скрытая
            переменная <tt
             class="VARNAME">$OPTIND</tt> и выполняется переход к
            началу новой итерации.</p>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <ol
                     type="1">
                      <li>
                        <p>Опциям (ключам), передаваемым в сценарий из
                        командной строки, должен предшествовать символ
                        &quot;минус&quot; (<tt
                         class="OPTION">-</tt>) или &quot;плюс&quot;
                        (<tt
                         class="OPTION">+</tt>). Этот префикс (<tt
                         class="OPTION">-</tt> или <tt
                         class="OPTION">+</tt>) позволяет <strong
                         class="COMMAND">getopts</strong> отличать
                        опции (ключи) от прочих аргументов. Фактически,
                        <strong
                         class="COMMAND">getopts</strong> не будет
                        обрабатывать аргументы, если им не предшествует
                        символ <tt
                         class="OPTION">-</tt> или <tt
                         class="OPTION">+</tt>, выделение опций будет
                        прекращено как только встретится первый
                        аргумент.</p>
                      </li>

                      <li>
                        <p>Типичная конструкция цикла <strong
                         class="COMMAND">while</strong> с <strong
                         class="COMMAND">getopts</strong> несколько
                        отличается от стандартной из-за отсутствия
                        квадратных скобок, проверяющих условие
                        продолжения цикла.</p>
                      </li>

                      <li>
                        <p>Пример <strong
                         class="COMMAND">getopts</strong>, заменившей
                        устаревшую, и не такую мощную, внешнюю команду
                        <a
                         href="#x9307_html_GETOPTY">getopt</a>.</p>
                      </li>
                    </ol>
                    <br>
                    <br>
                  </td>
                </tr>
              </table>
            </div>
<pre
 class="PROGRAMLISTING">
while getopts &quot;:abcde:fg&quot; Option
# Начальное объявление цикла анализа опций.
# a, b, c, d, e, f, g -- это возможные опции (ключи).
# Символ : после опции &#39;e&#39; указывает на то, что с данной опцией может идти
# дополнительный аргумент.
do
  case $Option in
    a ) # Действия, предусмотренные опцией &#39;a&#39;.
    b ) # Действия, предусмотренные опцией &#39;b&#39;.
    ...
    e)  # Действия, предусмотренные опцией &#39;e&#39;, а так же необходимо обработать $OPTARG,
        # в которой находится дополнительный аргумент этой опции.
    ...
    g ) # Действия, предусмотренные опцией &#39;g&#39;.
  esac
done
shift $(($OPTIND - 1))
# Перейти к следующей опции.

# Все не так сложно, как может показаться ;-)
             
</pre>
            <br>
            <br>

            <div
             class="EXAMPLE">
              <a
               name="c5358_html_EX33"></a>

              <p><strong>Пример 11-17. Прием опций/аргументов,
              передаваемых сценарию, с помощью getopts</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# ex33.sh

# Обработка опций командной строки с помощью &#39;getopts&#39;.

# Попробуйте вызвать этот сценарий как:
# &#39;scriptname -mn&#39;
# &#39;scriptname -oq qOption&#39; (qOption может быть любой произвольной строкой.)
# &#39;scriptname -qXXX -r&#39;
#
# &#39;scriptname -qr&#39;    - Неожиданный результат: &quot;r&quot; будет воспринят как дополнительный аргумент опции &quot;q&quot;
# &#39;scriptname -q -r&#39;  - То же самое, что и выше
#  Если опция ожидает дополнительный аргумент (&quot;flag:&quot;), то следующий параметр
#  в командной строке, будет воспринят как дополнительный аргумент этой опции.

NO_ARGS=0
E_OPTERROR=65

if [ $# -eq &quot;$NO_ARGS&quot; ]  # Сценарий вызван без аргументов?
then
  echo &quot;Порядок использования: `basename $0` options (-mnopqrs)&quot;
  exit $E_OPTERROR        # Если аргументы отсутствуют -- выход с сообщением
                          # о порядке использования скрипта
fi
# Порядок использования: scriptname -options
# Обратите внимание: дефис (-) обязателен


while getopts &quot;:mnopq:rs&quot; Option
do
echo $OPTIND
  case $Option in
    m     ) echo &quot;Сценарий #1: ключ -m-&quot;;;
    n | o ) echo &quot;Сценарий #2: ключ -$Option-&quot;;;
    p     ) echo &quot;Сценарий #3: ключ -p-&quot;;;
    q     ) echo &quot;Сценарий #4: ключ -q-, с аргументом \&quot;$OPTARG\&quot;&quot;;;
    # Обратите внимание: с ключом &#39;q&#39; должен передаваться дополнительный аргумент,
    # в противном случае отработает выбор &quot;по-умолчанию&quot;.
    r | s ) echo &quot;Сценарий #5: ключ -$Option-&quot;&#39;&#39;;;
    *     ) echo &quot;Выбран недопустимый ключ.&quot;;;   # ПО-УМОЛЧАНИЮ
  esac
done
shift $(($OPTIND - 1))
# Переход к очередному параметру командной строки.

exit 0
</pre>
            </div>
          </dd>
        </dl>
      </div>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="c5358_html_INTSCRBEH1"></a>Управление сценарием</strong></p>

        <dl>
          <dt><a
           name="c5358_html_SOURCEREF"></a><strong
           class="COMMAND">source</strong>, <span
           class="TOKEN">.</span> (<a
           href="#c301_html_DOTREF">точка</a>)</dt>

          <dd>
            <p>Когда эта команда вызывается из командной строки, то это
            приводит к запуску указанного сценария. Внутри сценария,
            команда <tt
             class="USERINPUT"><strong>source file-name</strong></tt>
            загружает файл <tt
             class="FILENAME">file-name</tt>. Таким образом она очень
            напоминает директиву препроцессора языка C/C++ --
            &quot;#include&quot;. Может найти применение в ситуациях,
            когда несколько сценариев пользуются одним файлом с данными
            или библиотекой функций.</p>

            <div
             class="EXAMPLE">
              <a
               name="c5358_html_EX38"></a>

              <p><strong>Пример 11-18. <span
               class="QUOTE">&quot;Подключение&quot;</span> внешнего
              файла</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

. data-file    # Загрузка файла с данными.
# Тот же эффект дает &quot;source data-file&quot;, но этот вариант более переносим.

#  Файл &quot;data-file&quot; должен находиться в текущем каталоге,
#+ т.к. путь к нему не указан.

# Теперь, выведем некоторые переменные из этого файла.

echo &quot;variable1 (из data-file) = $variable1&quot;
echo &quot;variable3 (из data-file) = $variable3&quot;

let &quot;sum = $variable2 + $variable4&quot;
echo &quot;Сумма variable2 + variable4 (из data-file) = $sum&quot;
echo &quot;message1 (из data-file):  \&quot;$message1\&quot;&quot;
# Обратите внимание:             кавычки экранированы

print_message Вызвана функция вывода сообщений, находящаяся в data-file.


exit 0
</pre>

              <p>Файл <tt
               class="FILENAME">data-file</tt> для <a
               href="#c5358_html_EX38">Пример 11-18</a>, представленного
              выше, должен находиться в том же каталоге.</p>
<pre
 class="PROGRAMLISTING">
# Этот файл подключается к сценарию.
# Подключаемые файлы могут содержать об&quot;явления переменных, функций и т.п.
# Загружаться может командой &#39;source&#39; или &#39;.&#39; .

# Инициализация некоторых переменных.

variable1=22
variable2=474
variable3=5
variable4=97

message1=&quot;Привет! Как поживаете?&quot;
message2=&quot;Досвидания!&quot;

print_message ()
{
# Вывод сообщения переданного в эту функцию.

  if [ -z &quot;$1&quot; ]
  then
    return 1
    # Ошибка, если аргумент отсутствует.
  fi

  echo

  until [ -z &quot;$1&quot; ]
  do
    # Цикл по всем аргументам функции.
    echo -n &quot;$1&quot;
    # Вывод аргумента с подавлением символа перевода строки.
    echo -n &quot; &quot;
    # Вставить пробел, для разделения выводимых аргументов.
    shift
    # Переход к следующему аргументу.
  done  

  echo

  return 0
} 
</pre>
            </div>

            <p>Сценарий может подключить даже самого себя, только этому
            едва ли можно найти какое либо практическое применение.</p>

            <div
             class="EXAMPLE">
              <a
               name="c5358_html_SELFSOURCE"></a>

              <p><strong>Пример 11-19. Пример (бесполезный) сценария,
              который подключает себя самого.</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# self-source.sh: сценарий, который рекурсивно подключает себя самого.&quot;
# Из &quot;Бестолковые трюки&quot;, том II.

MAXPASSCNT=100    # Максимальное количество проходов.

echo -n  &quot;$pass_count  &quot;
#  На первом проходе выведет два пробела,
#+ т.к. $pass_count еще не инициализирована.

let &quot;pass_count += 1&quot;
#  Операция инкремента неинициализированной переменной $pass_count
#+ на первом проходе вполне допустима.
#  Этот прием срабатывает в Bash и pdksh, но,
#+ при переносе сценария в другие командные оболочки,
#+ он может оказаться неработоспособным или даже опасным.
#  Лучшим выходом из положения, будет присвоить переменной $pass_count
#+ значение 0, если она неинициализирована.

while [ &quot;$pass_count&quot; -le $MAXPASSCNT ]
do
  . $0   # &quot;Подключение&quot; самого себя.
         # ./$0 (истинная рекурсия) в данной ситуации не сработает.
done  

#  Происходящее здесь фактически не является рекурсией как таковой,
#+ т.к. сценарий как бы &quot;расширяет&quot; себя самого
#+ (добавляя новый блок кода)
#+ на каждом проходе цикла &#39;while&#39;,
#+ командой &#39;source&#39; в строке 22.
#
#  Само собой разумеется, что первая строка (#!), вновь подключенного сценария,
#+ интерпретируется как комментарий, а не как начало нового сценария (sha-bang)

echo

exit 0   # The net effect is counting from 1 to 100.
         # Very impressive.

# Упражнение:
# ----------
# Напишите сценарий, который использовал бы этот трюк для чего либо полезного.
</pre>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">exit</strong></dt>

          <dd>
            <p>Безусловное завершение работы сценария. Команде <strong
             class="COMMAND">exit</strong> можно передать целое число,
            которое будет возвращено вызывающему процессу как <a
             href="#c2105_html_EXITSTATUSREF">код завершения</a>.
            Вообще, считается хорошей практикой завершать работу
            сценария, за исключением простейших случаев, командой <tt
             class="USERINPUT"><strong>exit 0</strong></tt>, чтобы
            проинформировать родительский процесс об успешном
            завершении.</p>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Если сценарий завершается командой <strong
                     class="COMMAND">exit</strong> без аргументов, то в
                    качестве кода завершения сценария принимается код
                    завершения последней выполненной команды, не считая
                    самой команды <strong
                     class="COMMAND">exit</strong>.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><a
           name="c5358_html_EXECREF"></a><strong
           class="COMMAND">exec</strong></dt>

          <dd>
            <p>Это встроенная команда интерпретатора shell, заменяет
            текущий процесс новым процессом, запускаемым командой exec.
            Обычно, когда командный интерпретатор встречает эту
            команду, то он <a
             href="#c5358_html_FORKREF">порождает</a> дочерний процесс,
            чтобы исполнить команду. При использовании встроенной
            команды <strong
             class="COMMAND">exec</strong>, оболочка не порождает еще
            один процесс, а заменяет текущий процесс другим. Для
            сценария это означает его завершение сразу после исполнения
            команды <strong
             class="COMMAND">exec</strong>. По этой причине, если вам
            встретится <strong
             class="COMMAND">exec</strong> в сценарии, то, скорее всего
            это будет последняя команда в сценарии.</p>

            <div
             class="EXAMPLE">
              <a
               name="c5358_html_EX54"></a>

              <p><strong>Пример 11-20. Команда exec</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

exec echo &quot;Завершение \&quot;$0\&quot;.&quot;   # Это завершение работы сценария.

# ----------------------------------
# Следующие ниже строки никогда не будут исполнены
echo &quot;Эта строка никогда не будет выведена на экран.&quot;

exit 99                       #  Сценарий завершит работу не здесь.
                              #  Проверьте код завершения сценария
                              #+ командой &#39;echo $?&#39;.
                              #  Он точно не будет равен 99.
</pre>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="c5358_html_SELFEXEC"></a>

              <p><strong>Пример 11-21. Сценарий, который запускает себя
              самого</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# self-exec.sh

echo

echo &quot;Эта строка в сценарии единственная, но она продолжает выводиться раз за разом.&quot;
echo &quot;PID остался равным $$.&quot;
#     Демонстрация того, что команда exec не порождает дочерний процесс.

echo &quot;==================== Для завершения - нажмите Ctl-C ====================&quot;

sleep 1

exec $0   #  Запуск очередного экземпляра этого же сценария
          #+ который замещает предыдущий.

echo &quot;Эта строка никогда не будет выведена!&quot;  # Почему?

exit 0
</pre>
            </div>

            <p>Команда <strong
             class="COMMAND">exec</strong> так же может использоваться
            для перенаправления. Так, команда <tt
             class="USERINPUT"><strong>exec &lt;zzz-file</strong></tt>
            заменит стандартное устройство ввода (<tt
             class="FILENAME">stdin</tt>) файлом <tt
             class="FILENAME">zzz-file</tt> (см. <a
             href="#c11620_html_REDIR1">Пример 16-1</a>).</p>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Ключ <tt
                     class="OPTION">-exec</tt> команды <a
                     href="#x6646_html_FINDREF">find</a> -- это не то же
                    самое, что встроенная команда <strong
                     class="COMMAND">exec</strong>.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">shopt</strong></dt>

          <dd>
            <p>Эта команда позволяет изменять ключи (опции) оболочки на
            лету (см. <a
             href="#c12683_html_AL">Пример 23-1</a> и <a
             href="#c12683_html_UNAL">Пример 23-2</a>). Ее часто можно
            встретить в <a
             href="#c12891_html_FILESREF1">стартовых файлах</a>, но
            может использоваться и в обычных сценариях. Требует Bash <a
             href="#c13936_html_BASH2REF">версии 2</a> или выше.</p>
<pre
 class="PROGRAMLISTING">
shopt -s cdspell
# Исправляет незначительные орфографические ошибки в именах каталогов в команде &#39;cd&#39;

cd /hpme  # Oops! Имелось ввиду &#39;/home&#39;.
pwd       # /home
          # Shell исправил опечатку.
</pre>
            <br>
            <br>
          </dd>
        </dl>
      </div>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="c5358_html_INTCOMMAND1"></a>Команды</strong></p>

        <dl>
          <dt><a
           name="c5358_html_TRUEREF"></a><strong
           class="COMMAND">true</strong></dt>

          <dd>
            <p>Команда возвращает код завершения -- <span
             class="RETURNVALUE">ноль</span>, или успешное завершение,
            и ничего больше.</p>
<pre
 class="PROGRAMLISTING">
# Бесконечный цикл
while true   # вместо &quot;:&quot;
do
   operation-1
   operation-2
   ...
   operation-n
   # Следует предусмотреть способ завершения цикла.
done
</pre>
            <br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">false</strong></dt>

          <dd>
            <p>Возвращает <a
             href="#c2105_html_EXITSTATUSREF">код завершения</a>,
            свидетельствующий о неудаче, и ничего более.</p>
<pre
 class="PROGRAMLISTING">
# Цикл, который никогда не будет исполнен
while false
do
   # Следующий код не будет исполнен никогда.
   operation-1
   operation-2
   ...
   operation-n
done  
</pre>
            <br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">type [cmd]</strong></dt>

          <dd>
            <p>Очень похожа на внешнюю команду <a
             href="#x7794_html_WHICHREF">which</a>, <strong
             class="COMMAND">type cmd</strong> выводит полный путь к
            <span
             class="QUOTE">&quot;cmd&quot;</span>. В отличие от <strong
             class="COMMAND">which</strong>, <strong
             class="COMMAND">type</strong> является внутренней командой
            Bash. С опцией <tt
             class="OPTION">-a</tt> не только различает ключевые слова
            и внутренние команды, но и определяет местоположение
            внешних команд с именами, идентичными внутренним.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>type &#39;[&#39;</strong></tt>
<tt
 class="COMPUTEROUTPUT">[ is a shell builtin</tt>
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>type -a &#39;[&#39;</strong></tt>
<tt
 class="COMPUTEROUTPUT">[ is a shell builtin
 [ is /usr/bin/[</tt>
             
</pre>
            <br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">hash [cmds]</strong></dt>

          <dd>
            <p>Запоминает путь к заданной команде (в хэш-таблице
            командной оболочки), благодаря чему, при повторном
            обращении к ней, оболочка или сценарий уже не будет искать
            путь к команде в <tt
             class="VARNAME">$PATH</tt>. При вызове команды <strong
             class="COMMAND">hash</strong> без аргументов, просто
            выводит содержимое хэш-таблицы. С ключом <tt
             class="OPTION">-r</tt> -- очищает хэш-таблицу.</p>
          </dd>

          <dt><strong
           class="COMMAND">help</strong></dt>

          <dd>
            <p><strong
             class="COMMAND">help</strong> COMMAND -- выводит краткую
            справку по использованию внутренней команды COMMAND. Аналог
            команды <a
             href="#x7794_html_WHATISREF">whatis</a>, только для
            внутренних команд.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>help exit</strong></tt>
<tt
 class="COMPUTEROUTPUT">exit: exit [n]
    Exit the shell with a status of N.  If N is omitted, the exit status
    is that of the last command executed.</tt>
             
</pre>
            <br>
            <br>
          </dd>
        </dl>
      </div>

      <div
       class="SECT1">
        <h1
         class="SECT1"><a
         name="c5358_html_AEN6110"></a>11.1. Команды управления заданиями</h1>

        <p>Некоторые из нижеследующих команд принимают, в качестве
        аргумента, <span
         class="QUOTE">&quot;идентификатор задания&quot;</span>. См. <a
         href="#c5358_html_JOBIDTABLE">таблицу</a> в конце главы.</p>

        <div
         class="VARIABLELIST">
          <dl>
            <dt><strong
             class="COMMAND">jobs</strong></dt>

            <dd>
              <p>Выводит список заданий, исполняющихся в фоне. Команда
              <strong
               class="COMMAND">ps</strong> более информативна.</p>

              <div
               class="NOTE">
                <table
                 class="NOTE"
                 width="90%"
                 border="0">
                  <tr>
                    <td
                     width="25"
                     align="center"
                     valign="top"><img
                     src="misc/abs-book/images/note.gif"
                     hspace="5"
                     alt="Note"></td>

                    <td
                     align="left"
                     valign="top">
                      <p><span
                       class="emphasis"><em
                       class="EMPHASIS">Задания</em></span> и <span
                       class="emphasis"><em
                       class="EMPHASIS">процессы</em></span> легко
                      спутать. Некоторые <a
                       href="#c5358_html_BUILTINREF">внутренние
                      команды</a>, такие как <strong
                       class="COMMAND">kill</strong>, <strong
                       class="COMMAND">disown</strong> и <strong
                       class="COMMAND">wait</strong> принимают в
                      качестве параметра либо номер задания, либо номер
                      процесса. Команды <strong
                       class="COMMAND">fg</strong>, <strong
                       class="COMMAND">bg</strong> и <strong
                       class="COMMAND">jobs</strong> принимают только
                      номер задания.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>sleep 100 &amp;</strong></tt>
<tt
 class="COMPUTEROUTPUT">[1] 1384</tt>

<tt
 class="PROMPT">bash $</tt> <tt
 class="USERINPUT"><strong>jobs</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">[1]+  Running                 sleep 100 &amp;</tt>
</pre>
                      <br>
                      <br>

                      <p><span
                       class="QUOTE">&quot;1&quot;</span> -- это номер
                      задания (управление заданиями осуществляет
                      текущий командный интерпретатор), а <span
                       class="QUOTE">&quot;1384&quot;</span> -- номер
                      процесса (управление процессами осуществляется
                      системой). Завершить задание/процесс
                      (&quot;прихлопнуть&quot;) можно либо командой
                      <strong
                       class="COMMAND">kill %1</strong>, либо <strong
                       class="COMMAND">kill 1384</strong>.</p>

                      <p><span
                       class="emphasis"><em
                       class="EMPHASIS">Спасибо S.C.</em></span></p>
                    </td>
                  </tr>
                </table>
              </div>
            </dd>

            <dt><strong
             class="COMMAND">disown</strong></dt>

            <dd>
              <p>Удаляет задание из таблицы активных заданий командной
              оболочки.</p>
            </dd>

            <dt><strong
             class="COMMAND">fg</strong>, <strong
             class="COMMAND">bg</strong></dt>

            <dd>
              <p>Команда <strong
               class="COMMAND">fg</strong> переводит задание из фона на
              передний план. Команда <strong
               class="COMMAND">bg</strong> перезапускает
              приостановленное задание в фоновом режиме. Если эти
              команды были вызваны без указания номера задания, то они
              воздействуют на текущее исполняющееся задание.</p>
            </dd>

            <dt><a
             name="c5358_html_WAITREF"></a><strong
             class="COMMAND">wait</strong></dt>

            <dd>
              <p>Останавливает работу сценария до тех пор пока не будут
              завершены все фоновые задания или пока не будет завершено
              задание/процесс с указанным номером задания/PID процесса.
              Возвращает <a
               href="#c2105_html_EXITSTATUSREF">код завершения</a>
              указанного задания/процесса.</p>

              <p>Вы можете использовать команду <strong
               class="COMMAND">wait</strong> для предотвращения
              преждевременного завершения сценария до того, как
              завершит работу фоновое задание.</p>

              <div
               class="EXAMPLE">
                <a
                 name="c5358_html_EX39"></a>

                <p><strong>Пример 11-22. Ожидание завершения процесса
                перед тем как продолжить работу</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

ROOT_UID=0   # Только пользователь с $UID = 0 имеет привилегии root.
E_NOTROOT=65
E_NOPARAMS=66

if [ &quot;$UID&quot; -ne &quot;$ROOT_UID&quot; ]
then
  echo &quot;Для запуска этого сценария вы должны обладать привилегиями root.&quot;
  exit $E_NOTROOT
fi

if [ -z &quot;$1&quot; ]
then
  echo &quot;Порядок использования: `basename $0` имя-файла&quot;
  exit $E_NOPARAMS
fi


echo &quot;Обновляется база данных &#39;locate&#39;...&quot;
echo &quot;Это может занять продолжительное время.&quot;
updatedb /usr &amp;     # Должна запускаться с правами root.

wait
# В этом месте сценарий приостанавливает свою работу до тех пор, пока не отработает &#39;updatedb&#39;.
# Желательно обновить базу данных перед тем как выполнить поиск файла.

locate $1

# В худшем случае, без команды wait, сценарий завершил бы свою работу до того,
# как завершила бы работу утилита &#39;updatedb&#39;,
# сделав из нее &quot;осиротевший&quot; процесс.

exit 0
</pre>
              </div>

              <p>Команда <strong
               class="COMMAND">wait</strong> может принимать
              необязательный параметр -- номер задания/процесса,
              например, <strong
               class="COMMAND">wait %1</strong> или <strong
               class="COMMAND">wait $PPID</strong>. См. таблицу <a
               href="#c5358_html_JOBIDTABLE">идентификации
              заданий</a>.</p>

              <p><a
               name="c5358_html_WAITHANG"></a></p>

              <div
               class="TIP">
                <table
                 class="TIP"
                 width="90%"
                 border="0">
                  <tr>
                    <td
                     width="25"
                     align="center"
                     valign="top"><img
                     src="misc/abs-book/images/tip.gif"
                     hspace="5"
                     alt="Tip"></td>

                    <td
                     align="left"
                     valign="top">
                      <p>При запуске команды в фоне из сценария может
                      возникнуть ситуация, когда сценарий
                      приостанавливает свою работу до тех пор, пока не
                      будет нажата клавиша <strong
                       class="KEYCAP">ENTER</strong>. Это, кажется,
                      происходит с командами, делающими вывод на <tt
                       class="FILENAME">stdout</tt>. Такое поведение
                      может вызывать раздражение у пользователя.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# test.sh

ls -l &amp;
echo &quot;Done.&quot;
</pre>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>./test.sh</strong></tt>
<tt
 class="COMPUTEROUTPUT">Done.
 [bozo@localhost test-scripts]$ total 1
 -rwxr-xr-x    1 bozo     bozo           34 Oct 11 15:09 test.sh
 _</tt>
              
</pre>
                      <br>
                      <br>

                      <p>Разместив команду <strong
                       class="COMMAND">wait</strong>, после запуска
                      фонового задания, можно предотвратить такое
                      поведение сценария.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# test.sh

ls -l &amp;
echo &quot;Done.&quot;
wait
</pre>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>./test.sh</strong></tt>
<tt
 class="COMPUTEROUTPUT">Done.
 [bozo@localhost test-scripts]$ total 1
 -rwxr-xr-x    1 bozo     bozo           34 Oct 11 15:09 test.sh</tt>
              
</pre>
                      <a
                       href=
                      "#c11620_html_IOREDIRREF">Перенаправление</a>
                      вывода в файл или даже на устройство <tt
                       class="FILENAME">/dev/null</tt> также снимает
                      эту проблему. <br>
                      <br>
                    </td>
                  </tr>
                </table>
              </div>
            </dd>

            <dt><strong
             class="COMMAND">suspend</strong></dt>

            <dd>
              <p>Действует аналогично нажатию на комбинацию клавиш
              <strong
               class="KEYCAP">Control+</strong>-<strong
               class="KEYCAP">Z</strong>, за исключением того, что она
              приостанавливает работу командной оболочки.</p>
            </dd>

            <dt><strong
             class="COMMAND">logout</strong></dt>

            <dd>
              <p>Завершает сеанс работы командной оболочки, можно
              указать необязательный <a
               href="#c2105_html_EXITSTATUSREF">код завершения</a>.</p>
            </dd>

            <dt><a
             name="c5358_html_TIMESREF"></a><strong
             class="COMMAND">times</strong></dt>

            <dd>
              <p>Выдает статистику исполнения команд в единицах
              системного времени, в следующем виде:</p>
<pre
 class="SCREEN">
<tt
 class="COMPUTEROUTPUT">0m0.020s 0m0.020s</tt>
</pre>
              Имеет весьма ограниченную сферу применения, так как
              сценарии крайне редко подвергаются профилированию.<br>
              <br>
            </dd>

            <dt><a
             name="c5358_html_KILLREF"></a><strong
             class="COMMAND">kill</strong></dt>

            <dd>
              <p>Принудительное завершение процесса путем передачи ему
              соответствующего сигнала (см. <a
               href="#c9708_html_KILLPROCESS">Пример 13-4</a>).</p>

              <div
               class="EXAMPLE">
                <a
                 name="c5358_html_SELFDESTRUCT"></a>

                <p><strong>Пример 11-23. Сценарий, завершающий себя сам
                с помощью команды kill</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# self-destruct.sh

kill $$  # Сценарий завершает себя сам.
         # Надеюсь вы еще не забыли, что &quot;$$&quot; -- это PID сценария.

echo &quot;Эта строка никогда не будет выведена.&quot;
# Вместо него на stdout будет выведено сообщение &quot;Terminated&quot;.

exit 0

#  Какой код завершения вернет сценарий?
#
# sh self-destruct.sh
# echo $?
# 143
#
# 143 = 128 + 15
#             сигнал TERM
</pre>
              </div>

              <div
               class="NOTE">
                <table
                 class="NOTE"
                 width="90%"
                 border="0">
                  <tr>
                    <td
                     width="25"
                     align="center"
                     valign="top"><img
                     src="misc/abs-book/images/note.gif"
                     hspace="5"
                     alt="Note"></td>

                    <td
                     align="left"
                     valign="top">
                      <p>Команда <tt
                       class="USERINPUT"><strong>kill -l</strong></tt>
                      выведет список всех <a
                       href="#c13099_html_SIGNALD">сигналов</a>. Команда
                      <tt
                       class="USERINPUT"><strong>kill -9</strong></tt>
                      -- это <span
                       class="QUOTE">&quot;жесткий kill&quot;</span>,
                      она используется, как правило, для завершения
                      зависших процессов, которые упорно отказываются
                      &quot;умирать&quot;, отвергая простой <strong
                       class="COMMAND">kill</strong>. Иногда достаточно
                      подать команду <tt
                       class="USERINPUT"><strong>kill
                      -15</strong></tt>. <span
                       class="QUOTE">&quot;Процессы-зомби&quot;</span>,
                      т.е. процессы, <a
                       href=
                      "#c5358_html_FORKREF">&quot;родители&quot;</a>
                      которых уже завершили работу, не могут быть
                      &quot;убиты&quot; таким способом (невозможно
                      &quot;убить&quot; &quot;мертвого&quot;), рано или
                      поздно с ними &quot;расправится&quot; процесс
                      <strong
                       class="COMMAND">init</strong>.</p>
                    </td>
                  </tr>
                </table>
              </div>
            </dd>

            <dt><strong
             class="COMMAND">command</strong></dt>

            <dd>
              <p>Директива <strong
               class="COMMAND">command COMMAND</strong> запрещает
              использование псевдонимов и функций с именем <span
               class="QUOTE">&quot;COMMAND&quot;</span>.</p>

              <div
               class="NOTE">
                <table
                 class="NOTE"
                 width="90%"
                 border="0">
                  <tr>
                    <td
                     width="25"
                     align="center"
                     valign="top"><img
                     src="misc/abs-book/images/note.gif"
                     hspace="5"
                     alt="Note"></td>

                    <td
                     align="left"
                     valign="top">
                      <p>Это одна из трех директив командного
                      интерпретатора, которая влияет на обработку
                      команд. Другие две -- <a
                       href="#c5358_html_BLTREF">builtin</a> и <a
                       href="#c5358_html_ENABLEREF">enable</a>.</p>
                    </td>
                  </tr>
                </table>
              </div>
            </dd>

            <dt><a
             name="c5358_html_BLTREF"></a><strong
             class="COMMAND">builtin</strong></dt>

            <dd>
              <p>Конструкция <strong
               class="COMMAND">builtin BUILTIN_COMMAND</strong>
              запускает <a
               href="#c5358_html_BUILTINREF">внутреннюю команду</a>
              <span
               class="QUOTE">&quot;BUILTIN_COMMAND&quot;</span>, на
              время запрещая использование функций и внешних системных
              команд с тем же именем.</p>
            </dd>

            <dt><a
             name="c5358_html_ENABLEREF"></a><strong
             class="COMMAND">enable</strong></dt>

            <dd>
              <p>Либо запрещает, либо разрешает вызов внутренних
              команд. Например, <strong
               class="COMMAND">enable -n kill</strong> запрещает
              использование внутренней команды <a
               href="#c5358_html_KILLREF">kill</a>, в результате, когда
              интерпретатор встретит команду <strong
               class="COMMAND">kill</strong>, то он вызовет внешнюю
              команду <strong
               class="COMMAND">kill</strong>, т.е. <tt
               class="FILENAME">/bin/kill</tt>.</p>

              <p><a
               name="c5358_html_ENABLEREF1"></a>Команда <tt
               class="OPTION">enable -a</tt> выведет список всех
              внутренних команд, указывая для каждой -- действительно
              ли она разрешена. Команда <tt
               class="OPTION">enable -f filename</tt> загрузит <a
               href="#c5358_html_BUILTINREF">внутренние команды</a> как
              разделяемую библиотеку (DLL) из указанного объектного
              файла. <a
               name="AEN6343"
               href="#c5358_html_FTN_AEN6343"><span
               class="footnote">[3]</span></a>.</p>
            </dd>

            <dt><strong
             class="COMMAND">autoload</strong></dt>

            <dd>
              <p>Перенесена в Bash из <span
               class="emphasis"><em
               class="EMPHASIS">ksh</em></span>. Если функция объявлена
              как <strong
               class="COMMAND">autoload</strong>, то она будет
              загружена из внешнего файла в момент первого вызова. <a
               name="AEN6361"
               href="#c5358_html_FTN_AEN6361"><span
               class="footnote">[4]</span></a> Такой прием помогает
              экономить системные ресурсы.</p>

              <p>Обратите внимание: <strong
               class="COMMAND">autoload</strong> не является частью
              ядра Bash. Ее необходимо загрузить с помощью команды
              <strong
               class="COMMAND">enable -f</strong> (см. выше).</p>
            </dd>
          </dl>
        </div>

        <div
         class="TABLE">
          <a
           name="c5358_html_JOBIDTABLE"></a>

          <p><strong>Таблица 11-1. Идентификация заданий</strong></p>

          <table
           border="1"
           class="CALSTABLE">
            <thead>
              <tr>
                <th
                 align="left"
                 valign="top">Нотация</th>

                <th
                 align="left"
                 valign="top">Описание</th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">%N</tt></td>

                <td
                 align="left"
                 valign="top">Номер задания [N]</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">%S</tt></td>

                <td
                 align="left"
                 valign="top">Вызов (командная строка) задания, которая
                начинается со строки <span
                 class="emphasis"><em
                 class="EMPHASIS">S</em></span></td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">%?S</tt></td>

                <td
                 align="left"
                 valign="top">Вызов (командная строка) задания, которая
                содержит строку <span
                 class="emphasis"><em
                 class="EMPHASIS">S</em></span></td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">%%</tt></td>

                <td
                 align="left"
                 valign="top"><span
                 class="QUOTE">&quot;текущее&quot;</span> задание
                (последнее задание приостановленное на переднем плане
                или запущенное в фоне)</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">%+</tt></td>

                <td
                 align="left"
                 valign="top"><span
                 class="QUOTE">&quot;текущее&quot;</span> задание
                (последнее задание приостановленное на переднем плане
                или запущенное в фоне)</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">%-</tt></td>

                <td
                 align="left"
                 valign="top">Последнее задание</td>
              </tr>

              <tr>
                <td
                 align="left"
                 valign="top"><tt
                 class="OPTION">$!</tt></td>

                <td
                 align="left"
                 valign="top">Последний фоновый процесс</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN5395"
         href="#c5358_html_AEN5395"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Исключение из правил -- команда <a
           href="#x6837_html_TIMREF">time</a>, которая в официальной
          документации к Bash называется ключевым словом.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN5877"
         href="#c5358_html_AEN5877"><span
         class="footnote">[2]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Опция -- это аргумент, который управляет поведением
          сценария и может быть либо включен, либо выключен. Аргумент,
          который объединяет в себе несколько опций (ключей),
          определяет поведение сценария в соответствии с отдельными
          опциями, объединенными в данном аргументе..</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN6343"
         href="#c5358_html_AEN6343"><span
         class="footnote">[3]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Как правило, исходные тексты подобных библиотек, на языке
          C, располагаются в каталоге <tt
           class=
          "FILENAME">/usr/share/doc/bash-?.??/functions</tt>.</p>

          <p>Обратите внимание: ключ <tt
           class="OPTION">-f</tt> команды <strong
           class="COMMAND">enable</strong> может отсутствовать в
          некоторых системах.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN6361"
         href="#c5358_html_AEN6361"><span
         class="footnote">[4]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Тот же эффект можно получить с помощью <a
           href="#x4704_html">typeset -fu</a>.</p>
        </td>
      </tr>
    </table>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x5210_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#c6407_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Операторы выбора</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#p3268_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Внешние команды, программы и утилиты</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="c6407_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#c5358_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x6646_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="CHAPTER">
      <h1><a
       name="c6407_html_EXTERNAL"></a>Глава 12. Внешние команды, программы и
      утилиты</h1>

      <p>Благодаря стандартизации набора команд UNIX-систем, сценарии,
      на языке командной оболочки, могут быть легко перенесены из
      системы в систему практически без изменений. Мощь сценариев
      складывется из наборв системных команд и директив командной
      оболочки с простыми программными конструкциями.</p>

      <div
       class="SECT1">
        <h1
         class="SECT1"><a
         name="c6407_html_BASIC"></a>12.1. Базовые команды</h1>

        <div
         class="VARIABLELIST">
          <p><strong><a
           name="c6407_html_BASICCOMMANDS1"></a>Первая команда, с которой
          сталкиваются новички</strong></p>

          <dl>
            <dt><a
             name="c6407_html_LSREF"></a><strong
             class="COMMAND">ls</strong></dt>

            <dd>
              <p>Команда вывода <span
               class="QUOTE">&quot;списка&quot;</span> файлов. Многие
              недооценивают всю мощь этой скромной команды. Например, с
              ключом <tt
               class="OPTION">-R</tt>, рекурсивный обход дерева
              каталогов, командв <strong
               class="COMMAND">ls</strong> выводит содержимое каталогов
              в виде древовидной структуры. Вот еще ряд любопытных
              ключей (опций) команды <strong
               class="COMMAND">ls</strong>: <tt
               class="OPTION">-S</tt> -- сортировка по размеру файлов,
              <tt
               class="OPTION">-t</tt> -- сортировка по времени
              последней модификации файла и <tt
               class="OPTION">-i</tt> -- выводит список файлов с их
              inode (см. <a
               href="#x6646_html_IDELETE">Пример 12-3</a>).</p>

              <div
               class="EXAMPLE">
                <a
                 name="c6407_html_EX40"></a>

                <p><strong>Пример 12-1. Создание оглавления диска для
                записи <span
                 class="ABBREV">CDR</span>, с помощью команды
                ls</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# burn-cd.sh
# Сценарий, автоматизирующий процесс прожигания CDR.


SPEED=2          # Если ваше &quot;железо&quot; поддерживает более высокую скорость записи -- можете увеличить этот параметр
IMAGEFILE=cdimage.iso
CONTENTSFILE=contents
DEFAULTDIR=/opt  # В этом каталоге находятся файлы, которые будут записаны на CD.
                 # Каталог должен существовать.

# Используется пакет &quot;cdrecord&quot; от Joerg Schilling.
# (http://www.fokus.gmd.de/nthp/employees/schilling/cdrecord.html)

#  Если этот сценарий предполагается запускать с правами обычного пользователя,
#+ то необходимо установить флаг suid на cdrecord
#+ (chmod u+s /usr/bin/cdrecord, эта команда должна быть выполнена root-ом).

if [ -z &quot;$1&quot; ]
then
  IMAGE_DIRECTORY=$DEFAULTDIR
  # Каталог по-умолчанию, если иной каталог не задан из командной строки.
else
    IMAGE_DIRECTORY=$1
fi

# Создать файл &quot;table of contents&quot;.
ls -lRF $IMAGE_DIRECTORY &gt; $IMAGE_DIRECTORY/$CONTENTSFILE
# Ключ &quot;l&quot; -- &quot;расширенный&quot; формат вывода списка файлов.
# Ключ &quot;R&quot; -- рекурсивный обход дерева каталогов.
# Ключ &quot;F&quot; -- добавляет дополнительные метки к именам файлов (к именам каталогов добавдяет оконечный символ /).
echo &quot;Создано оглавление.&quot;

# Создать iso-образ.
mkisofs -r -o $IMAGFILE $IMAGE_DIRECTORY
echo &quot;Создан iso-образ файловой системы ISO9660 ($IMAGEFILE).&quot;

# &quot;Прожигание&quot; CDR.
cdrecord -v -isosize speed=$SPEED dev=0,0 $IMAGEFILE
echo &quot;Запись диска.&quot;
echo &quot;Наберитесь терпения, это может потребовать некоторого времени.&quot;

exit 0
</pre>
              </div>
            </dd>

            <dt><a
             name="c6407_html_CATREF"></a><strong
             class="COMMAND">cat</strong>, <strong
             class="COMMAND">tac</strong></dt>

            <dd>
              <p><strong
               class="COMMAND">cat</strong> -- это акроним от <em
               class="WORDASWORD">concatenate</em>, выводит содержимое
              списка файлов на <tt
               class="FILENAME">stdout</tt>. Для объединения файлов в
              один файл может использоваться в комбинации с операциями
              перенаправления (<span
               class="TOKEN">&gt;</span> или <span
               class="TOKEN">&gt;&gt;</span>).</p>
<pre
 class="PROGRAMLISTING">
cat filename cat file.1 file.2 file.3 &gt; file.123
</pre>
              Ключ <tt
               class="OPTION">-n</tt>, команды <strong
               class="COMMAND">cat</strong>, вставляет порядковые
              номера строк в выходном файле. Ключ <tt
               class="OPTION">-b</tt> -- нумерут только не пустые
              строки. Ключ <tt
               class="OPTION">-v</tt> выводит непечатаемые символы в
              нотации с символом <span
               class="TOKEN">^</span>. Ключ <tt
               class="OPTION">-s</tt> заменяет несколько пустых строк,
              идущих подряд, одной пустой строкой.<br>
              <br>

              <p>см. также <a
               href="#x7050_html_LNUM">Пример 12-21</a> and <a
               href="#x7050_html_ROT13">Пример 12-17</a>.</p>

              <p><strong
               class="COMMAND">tac</strong> -- выводит содержимое
              файлов в обратном порядке, от последней строки к
              первой.</p>
            </dd>

            <dt><strong
             class="COMMAND">rev</strong></dt>

            <dd>
              <p>выводит все строки файла задом наперед на <tt
               class="FILENAME">stdout</tt>. Это не то же самое, что
              <strong
               class="COMMAND">tac</strong>. Команда <strong
               class="COMMAND">rev</strong> сохраняет порядок
              следования строк, но переворачивает каждую строку задом
              наперед.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>cat file1.txt</strong></tt>
<tt
 class="COMPUTEROUTPUT">Это строка 1.
 Это строка 2.</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>tac file1.txt</strong></tt>
<tt
 class="COMPUTEROUTPUT">Это строка 2.
 Это строка 1.</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>rev file1.txt</strong></tt>
<tt
 class="COMPUTEROUTPUT">.1 акортс отЭ
 .2 акортс отЭ</tt>
             
</pre>
              <br>
              <br>
            </dd>

            <dt><strong
             class="COMMAND">cp</strong></dt>

            <dd>
              <p>Команда копирования файлов. <tt
               class="USERINPUT"><strong>cp file1 file2</strong></tt>
              скопирует <tt
               class="FILENAME">file1</tt> в <tt
               class="FILENAME">file2</tt>, перезаписав <tt
               class="FILENAME">file2</tt> если он уже существовал (см.
              <a
               href="#x6646_html_EX42">Пример 12-5</a>).</p>

              <div
               class="TIP">
                <table
                 class="TIP"
                 width="90%"
                 border="0">
                  <tr>
                    <td
                     width="25"
                     align="center"
                     valign="top"><img
                     src="misc/abs-book/images/tip.gif"
                     hspace="5"
                     alt="Tip"></td>

                    <td
                     align="left"
                     valign="top">
                      <p>С флагами <tt
                       class="OPTION">-a</tt> и <tt
                       class="OPTION">-r</tt>, или <tt
                       class="OPTION">-R</tt> выполняет копирование
                      дерева каталогов.</p>
                    </td>
                  </tr>
                </table>
              </div>
            </dd>

            <dt><strong
             class="COMMAND">mv</strong></dt>

            <dd>
              <p>Команда <span
               class="emphasis"><em
               class="EMPHASIS">перемещения</em></span> файла.
              Эквивалентна комбинации команд <strong
               class="COMMAND">cp</strong> и <strong
               class="COMMAND">rm</strong>. Может использоваться для
              перемещения большого количества файлов или для
              переименования каталогов. Примеры использования команды
              <strong
               class="COMMAND">mv</strong> вы найдете в <a
               href="#x4462_html_RFE">Пример 9-17</a> и <a
               href="#a14477_html_RN">Пример A-3</a>.</p>

              <div
               class="NOTE">
                <table
                 class="NOTE"
                 width="90%"
                 border="0">
                  <tr>
                    <td
                     width="25"
                     align="center"
                     valign="top"><img
                     src="misc/abs-book/images/note.gif"
                     hspace="5"
                     alt="Note"></td>

                    <td
                     align="left"
                     valign="top">
                      <p>При использовании в неинтерактивных сценариях,
                      команде <strong
                       class="COMMAND">mv</strong> следует передавать
                      ключ <tt
                       class="OPTION">-f</tt>, чтобы подавить запрос
                      подтверждения на перемещение.</p>

                      <p>Если в качестве каталога назначения указан
                      существующий каталог, то перемещаемый каталог
                      становится подкаталогом каталога назначения..</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>mv source_directory target_directory</strong></tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ls -lF target_directory</strong></tt>
<tt
 class="COMPUTEROUTPUT">total 1
 drwxrwxr-x    2 bozo  bozo      1024 May 28 19:20 source_directory/</tt>
             
</pre>
                      <br>
                      <br>
                    </td>
                  </tr>
                </table>
              </div>
            </dd>

            <dt><strong
             class="COMMAND">rm</strong></dt>

            <dd>
              <p>Удаляет (remove) файл(ы). Ключ <tt
               class="OPTION">-f</tt> позволяет удалять даже файлы
              ТОЛЬКО-ДЛЯ-ЧТЕНИЯ и подавляет запрос подтверждения на
              удаление.</p>

              <div
               class="WARNING">
                <table
                 class="WARNING"
                 width="90%"
                 border="0">
                  <tr>
                    <td
                     width="25"
                     align="center"
                     valign="top"><img
                     src="misc/abs-book/images/warning.gif"
                     hspace="5"
                     alt="Warning"></td>

                    <td
                     align="left"
                     valign="top">
                      <p>С ключом <tt
                       class="OPTION">-r</tt>, удаляет все файлы в
                      подкаталогах.</p>
                    </td>
                  </tr>
                </table>
              </div>
            </dd>

            <dt><strong
             class="COMMAND">rmdir</strong></dt>

            <dd>
              <p>Удаляет каталог. Удаляемый каталог не должен содержать
              файлов, включая <a
               name="c6407_html_DOTFILESREF"></a> <span
               class="QUOTE">&quot;скрытые файлы&quot;</span>, <a
               name="AEN6567"
               href="#c6407_html_FTN_AEN6567"><span
               class="footnote">[1]</span></a> иначе каталог не будет
              удален.</p>
            </dd>

            <dt><strong
             class="COMMAND">mkdir</strong></dt>

            <dd>
              <p>Создает новый каталог. <tt
               class="USERINPUT"><strong>mkdir -p
              project/programs/December</strong></tt> создает каталог с
              заданным именем в требуемом каталоге. Ключ <tt
               class="REPLACEABLE"><em>-p</em></tt> позволяет создавать
              промежуточные родительские каталоги.</p>
            </dd>

            <dt><a
             name="c6407_html_CHMODREF"></a><strong
             class="COMMAND">chmod</strong></dt>

            <dd>
              <p>Изменяет атрибуты существующего файла (см. <a
               href="#c5358_html_EX44">Пример 11-10</a>).</p>
<pre
 class="PROGRAMLISTING">
chmod +x filename
# Делает файл &quot;filename&quot; доступным для исполнения всем пользователям.

chmod u+s filename
# Устанавливается бит &quot;suid&quot; для &quot;filename&quot;.
# В результате, любой пользователь сможет запустить &quot;filename&quot; с привилегиями владельца файла.
# (Это не относится к файлам-сценариям на языке командной оболочки.)
</pre>
              <br>
              <br>
<pre
 class="PROGRAMLISTING">
chmod 644 filename
# Выдает право на запись/чтение владельцу файла &quot;filename&quot;, и право на чтение
# всем остальным
# (восьмеричное число).
</pre>
              <br>
              <br>
<pre
 class="PROGRAMLISTING">
chmod 1777 directory-name
# Выдает право на чтение, запись и исполнение файлов в каталоге,
# дополнительно устанавливает &quot;sticky bit&quot;.
# Это означает, что удалять файлы в этом каталоге могут только владельцы файлов,
# владелец каталога и, само собой разумеется, root.
</pre>
              <br>
              <br>
            </dd>

            <dt><strong
             class="COMMAND">chattr</strong></dt>

            <dd>
              <p>Изменяет атрибуты файла. Эта команда подобна команде
              <strong
               class="COMMAND">chmod</strong>, за исключением
              синтаксиса вызова, и работает исключительно в файловой
              системе <span
               class="emphasis"><em
               class="EMPHASIS">ext2</em></span>.</p>
            </dd>

            <dt><strong
             class="COMMAND">ln</strong></dt>

            <dd>
              <p>Создает ссылку на существующий файл. Чаще всего
              используется с ключом <tt
               class="OPTION">-s</tt>, что означает символическую, или
              <span
               class="QUOTE">&quot;мягкую&quot;</span> (symbolic или
              <span
               class="QUOTE">&quot;soft&quot;</span>) ссылку. Позволяет
              задавать несколько имен одному и тому же файлу и
              превосходная альтернатива &quot;псевдонимам&quot;
              (алиасам) (см. <a
               href="#x1716_html_EX18">Пример 4-6</a>).</p>

              <p><tt
               class="USERINPUT"><strong>ln -s oldfile
              newfile</strong></tt> создает ссылку, с именем <tt
               class="FILENAME">newfile</tt>, на существующий файл <tt
               class="FILENAME">oldfile</tt>, .</p>
            </dd>

            <dt><strong
             class="COMMAND">man</strong>, <strong
             class="COMMAND">info</strong></dt>

            <dd>
              <p>Команды доступа к справочным и информационным
              страницам по системным командам и установленным
              программам и утилитам. Как правило, страницы <span
               class="emphasis"><em
               class="EMPHASIS">info</em></span> содержат более
              подробную информацию, чем <span
               class="emphasis"><em
               class="EMPHASIS">man</em></span>.</p>
            </dd>
          </dl>
        </div>
      </div>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN6567"
         href="#c6407_html_AEN6567"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Скрытыми считаются файлы, имена которых начинаются с
          точки, например, <tt
           class="FILENAME">~/.Xdefaults</tt>. Такие файлы не выводятся
          простой командой <strong
           class="COMMAND">ls</strong>, и не могут быть удалены
          командой <strong
           class="COMMAND">rm -rf *</strong>. Как правило, скрытыми
          делаются конфигурационные файлы в домашнем каталоге
          пользователя.</p>
        </td>
      </tr>
    </table>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#c5358_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x6646_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Внутренние команды</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#p3268_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Более сложные команды</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="c9708_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x9307_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#c11441_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="CHAPTER">
      <h1><a
       name="c9708_html_SYSTEM"></a>Глава 13. Команды системного
      администрирования</h1>

      <p>Примеры использования большинства этих команд вы найдете в
      сценариях начальной загрузки и остановки системы, в каталогах <tt
       class="FILENAME">/etc/rc.d</tt>. Они, обычно, вызываются
      пользователем root и используются для администрирования системы
      или восстановления файловой системы. Эти команды должны
      использоваться с большой осторожностью, так как некоторые из них
      могут разрушить систему, при неправильном использовании.</p>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="c9708_html_USERSGROUPS1"></a>Пользователи и группы</strong></p>

        <dl>
          <dt><strong
           class="COMMAND">users</strong></dt>

          <dd>
            <p>Выведет список всех зарегистрировавшихся пользователей.
            Она, до некоторой степени, является эквивалентом команды
            <strong
             class="COMMAND">who -q</strong>.</p>
          </dd>

          <dt><strong
           class="COMMAND">groups</strong></dt>

          <dd>
            <p>Выводит список групп, в состав которых входит текущий
            пользователь. Эта команда соответствует внутренней
            переменной <a
             href="#c3270_html_GROUPSREF">$GROUPS</a>, но выводит
            названия групп, а не их числовые идентификаторы.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>groups</strong></tt>
<tt
 class="COMPUTEROUTPUT">bozita cdrom cdwriter audio xgrp</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo $GROUPS</strong></tt>
<tt
 class="COMPUTEROUTPUT">501</tt>
</pre>
          </dd>

          <dt><strong
           class="COMMAND">chown</strong>, <strong
           class="COMMAND">chgrp</strong></dt>

          <dd>
            <p>Команда <strong
             class="COMMAND">chown</strong> изменяет владельца файла
            или файлов. Эта команда полезна в случаях, когда <tt
             class="REPLACEABLE"><em>root</em></tt> хочет передать
            монопольное право на файл от одного пользователя другому.
            Обычный пользователь не в состоянии изменить владельца
            файла, за исключением своих собственных файлов.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">root#</tt> <tt
 class="USERINPUT"><strong>chown bozo *.txt</strong></tt>

             
</pre>
            <br>
            <br>

            <p>Команда <strong
             class="COMMAND">chgrp</strong> изменяет группу, которой
            принадлежит файл или файлы. Чтобы изменить группу, вы
            должны быть владельцем файла (при этом должны входить в
            состав указываемой группы) или привилегированным
            пользователем (<tt
             class="REPLACEABLE"><em>root</em></tt>).</p>
<pre
 class="PROGRAMLISTING">
chgrp --recursive dunderheads *.data
#  Группа &quot;dunderheads&quot; станет владельцем всех файлов &quot;*.data&quot;
#+ во всех подкаталогах текущей директории ($PWD) (благодаря ключу &quot;--recursive&quot;).
</pre>
            <br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">useradd</strong>, <strong
           class="COMMAND">userdel</strong></dt>

          <dd>
            <p>Команда <strong
             class="COMMAND">useradd</strong> добавляет учетную запись
            нового пользователя в систему и создает домашний каталог
            для данного пользователя. Противоположная, по смыслу,
            команда <strong
             class="COMMAND">userdel</strong> удаляет учетную запись
            пользователя из системы. <a
             name="AEN9791"
             href="#c9708_html_FTN_AEN9791"><span
             class="footnote">[1]</span></a> и удалит соответствующие
            файлы.</p>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Команда <strong
                     class="COMMAND">adduser</strong> является
                    синонимом для <strong
                     class="COMMAND">useradd</strong> и, как правило,
                    является обычной символической ссылкой на <strong
                     class="COMMAND">useradd</strong>.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><a
           name="c9708_html_IDREF"></a><strong
           class="COMMAND">id</strong></dt>

          <dd>
            <p>Команда <strong
             class="COMMAND">id</strong> выводит идентификатор
            пользователя (реальный и эффективный) и идентификаторы
            групп, в состав которых входит пользователь. По сути --
            выводит содержимое переменных <a
             href="#c3270_html_UIDREF">$UID</a>, <a
             href="#c3270_html_EUIDREF">$EUID</a> и <a
             href="#c3270_html_GROUPSREF">$GROUPS</a>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>id</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">uid=501(bozo) gid=501(bozo) groups=501(bozo),22(cdrom),80(cdwriter),81(audio)</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo $UID</strong></tt>
<tt
 class="COMPUTEROUTPUT">501</tt>
</pre>

            <p>См. также <a
             href="#c3270_html_AMIROOT">Пример 9-5</a>.</p>
          </dd>

          <dt><a
           name="c9708_html_WHOREF"></a><strong
           class="COMMAND">who</strong></dt>

          <dd>
            <p>Выводит список пользователей, работающих в настоящий
            момент в системе.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>who</strong></tt>
<tt
 class="COMPUTEROUTPUT">bozo  tty1     Apr 27 17:45
 bozo  pts/0    Apr 27 17:46
 bozo  pts/1    Apr 27 17:47
 bozo  pts/2    Apr 27 17:49</tt>
             
</pre>
            <br>
            <br>

            <p>С ключом <tt
             class="OPTION">-m</tt> -- выводит информацию только о
            текущем пользователе. Если число аргументов, передаваемых
            команде, равно двум, то это эквивалентно вызову <strong
             class="COMMAND">who -m</strong>, например <strong
             class="COMMAND">who am i</strong> или <strong
             class="COMMAND">who The Man</strong>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>who -m</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">localhost.localdomain!bozo  pts/2    Apr 27 17:49</tt>
             
</pre>
            <br>
            <br>

            <p><a
             name="c9708_html_WHOAMIREF"></a><strong
             class="COMMAND">whoami</strong> -- похожа на <strong
             class="COMMAND">who -m</strong>, но выводит только имя
            пользователя.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>whoami</strong></tt>
<tt
 class="COMPUTEROUTPUT">bozo</tt>
             
</pre>
            <br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">w</strong></dt>

          <dd>
            <p>Выводит информацию о системе, список пользователей,
            подключенных к системе и процессы, связанные с
            пользователями. Это расширенная версия команды <strong
             class="COMMAND">who</strong>. Вывод от команды <strong
             class="COMMAND">w</strong> может быть передан по конвейеру
            команде <strong
             class="COMMAND">grep</strong>, с целью поиска требуемого
            пользователя и/или процесса.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>w | grep startx</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">bozo  tty1     -                 4:22pm  6:41   4.47s  0.45s  startx</tt>
</pre>
          </dd>

          <dt><strong
           class="COMMAND">logname</strong></dt>

          <dd>
            <p>Выводит имя текущего пользователя (из файла <tt
             class="FILENAME">/var/run/utmp</tt>). Это довольно близкий
            эквивалент команды <a
             href="#c9708_html_WHOAMIREF">whoami</a>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>logname</strong></tt>
<tt
 class="COMPUTEROUTPUT">bozo</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>whoami</strong></tt>
<tt
 class="COMPUTEROUTPUT">bozo</tt>
</pre>

            <p>Однако...</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>su</strong></tt>
<tt
 class="COMPUTEROUTPUT">Password: ......</tt>

<tt
 class="PROMPT">bash#</tt> <tt
 class="USERINPUT"><strong>whoami</strong></tt>
<tt
 class="COMPUTEROUTPUT">root</tt>
<tt
 class="PROMPT">bash#</tt> <tt
 class="USERINPUT"><strong>logname</strong></tt>
<tt
 class="COMPUTEROUTPUT">bozo</tt>
</pre>
          </dd>

          <dt><a
           name="c9708_html_SUREF"></a><strong
           class="COMMAND">su</strong></dt>

          <dd>
            <p>Команда предназначена для запуска программы или сценария
            от имени другого пользователя. <strong
             class="COMMAND">su rjones</strong> -- запускает командную
            оболочку от имени пользователя <span
             class="emphasis"><em
             class="EMPHASIS">rjones</em></span>. Запуск команды
            <strong
             class="COMMAND">su</strong> без параметров означает запуск
            командной оболочки от имени привилегированного пользователя
            <span
             class="emphasis"><em
             class="EMPHASIS">root</em></span>. См. <a
             href="#a14477_html_FIFO">Пример A-17</a>.</p>
          </dd>

          <dt><strong
           class="COMMAND">sudo</strong></dt>

          <dd>
            <p>Исполняет заданную команду от имени пользователя root
            (или другого пользователя).</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Доступ к &quot;секретным&quot; файлам.
sudo cp /root/secretfile /home/bozo/secret
</pre>
            <br>
            <br>

            <p>Имена пользователей, которым разрешено использовать
            команду <strong
             class="COMMAND">sudo</strong>, хранятся в файле <tt
             class="FILENAME">/etc/sudoers</tt>.</p>
          </dd>

          <dt><strong
           class="COMMAND">passwd</strong></dt>

          <dd>
            <p>Устанавливает или изменяет пароль пользователя.</p>

            <p>Команда <strong
             class="COMMAND">passwd</strong> может использоваться в
            сценариях, но это плохая практика.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
#  set-new-password.sh: Плохая идея.
#  Этот сценарий должен запускаться пользователем root,
#+ а еще лучше -- не запускать его вообще.

ROOT_UID=0         # $UID root = 0.
E_WRONG_USER=65    # Не root?

if [ &quot;$UID&quot; -ne &quot;$ROOT_UID&quot; ]
then
  echo; echo &quot;Только root может запускать этот сценарий.&quot;; echo
  exit $E_WRONG_USER
else
  echo; echo &quot;Вам не следовало бы запускать этот сценарий.&quot;
fi


username=bozo
NEWPASSWORD=security_violation

echo &quot;$NEWPASSWORD&quot; | passwd --stdin &quot;$username&quot;
#  Ключ &#39;--stdin&#39; указывает &#39;passwd&#39;
#+ получить новый пароль со stdin (или из конвейера).

echo; echo &quot;Пароль пользователя $username изменен!&quot;

# Использование команды &#39;passwd&#39; в сценариях -- опасно.

exit 0
</pre>
            <br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">ac</strong></dt>

          <dd>
            <p>Выводит время работы пользователей, основываясь на
            записях в файле <tt
             class="FILENAME">/var/log/wtmp</tt>. Это одна из утилит
            пакета GNU acct.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ac</strong></tt>
 <tt
 class="COMPUTEROUTPUT">       total       68.08</tt>
</pre>
          </dd>

          <dt><strong
           class="COMMAND">last</strong></dt>

          <dd>
            <p>Выводит информацию о <span
             class="emphasis"><em
             class="EMPHASIS">последних</em></span> входах/выходах
            пользователей в ситему, основываясь на записях в файле <tt
             class="FILENAME">/var/log/wtmp</tt>. Эта команда может
            отображать информацию об удаленных (в смысле -- с
            удаленного терминала) соединениях.</p>
          </dd>

          <dt><strong
           class="COMMAND">newgrp</strong></dt>

          <dd>
            <p>Позволяет сменить активную группу пользователя.
            Пользователь остается в системе и текущий каталог не
            изменяется, но права доступа к файлам вычисляются в
            соответствии с новыми реальным и эффективным
            идентификаторами группы. Эта команда используется довольно
            редко, так как пользователь, обычно, является членом
            нескольких групп.</p>
          </dd>
        </dl>
      </div>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="c9708_html_TERMINALSSYS1"></a>Терминалы</strong></p>

        <dl>
          <dt><strong
           class="COMMAND">tty</strong></dt>

          <dd>
            <p>Выводит имя терминала текущего пользователя. Обратите
            внимание: каждое отдельное окно xterm считается отдельным
            терминалом.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>tty</strong></tt>
<tt
 class="COMPUTEROUTPUT">/dev/pts/1</tt>
</pre>
          </dd>

          <dt><a
           name="c9708_html_STTYREF"></a><strong
           class="COMMAND">stty</strong></dt>

          <dd>
            <p>Выводит и/или изменяет настройки терминала. Эта сложная
            команда используется в сценариях для управления поведением
            терминала.</p>

            <div
             class="EXAMPLE">
              <a
               name="c9708_html_ERASE"></a>

              <p><strong>Пример 13-1. Установка символа
              &quot;забоя&quot;</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# erase.sh: Использование команды &quot;stty&quot; для смены клавиши &quot;забоя&quot; при чтении ввода.

echo -n &quot;Как Вас зовут? &quot;
read name                      # Попробуйте стереть последние символы при вводе.
                               # Все работает.
echo &quot;Вас зовут $name.&quot;

stty erase &#39;#&#39;                 # Теперь, чтобы стереть символ нужно использовать клавишу &quot;#&quot;.
echo -n &quot;Как Вас зовут? &quot;
read name                      # Попробуйте стереть последние символы при вводе с помощью &quot;#&quot;.
echo &quot;Вас зовут $name.&quot;

exit 0
</pre>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="c9708_html_SECRETPW"></a>

              <p><strong>Пример 13-2. невидимый пароль: Отключение
              эхо-вывода на терминал</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

echo
echo -n &quot;Введите пароль &quot;
read passwd
echo &quot;Вы ввели пароль: $passwd&quot;
echo -n &quot;Если кто-нибудь в это время заглядывал Вам через плечо, &quot;
echo &quot;то теперь он знает Ваш пароль.&quot;

echo &amp;&amp; echo  # Две пустых строки через &quot;and list&quot;.

stty -echo    # Отключить эхо-вывод.

echo -n &quot;Введите пароль еще раз &quot;
read passwd
echo
echo &quot;Вы ввели пароль: $passwd&quot;
echo

stty echo     # Восстановить эхо-вывод.

exit 0
</pre>
            </div>

            <p>Перехват нажатия на клавиши с помощью <strong
             class="COMMAND">stty</strong>.</p>

            <div
             class="EXAMPLE">
              <a
               name="c9708_html_KEYPRESS"></a>

              <p><strong>Пример 13-3.</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# keypress.sh: Определение нажатых клавиш.

echo

old_tty_settings=$(stty -g)   # Сохранить прежние настройки.
stty -icanon
Keypress=$(head -c1)          # или $(dd bs=1 count=1 2&gt; /dev/null)
                              # для других, не GNU, систем

echo
echo &quot;Была нажата клавиша \&quot;&quot;$Keypress&quot;\&quot;.&quot;
echo

stty &quot;$old_tty_settings&quot;      # Восстановить прежние настройки.

# Спасибо, Stephane Chazelas.

exit 0
</pre>
            </div>

            <p>См. также <a
             href="#c3270_html_TIMEOUT">Пример 9-3</a>.</p>

            <table
             class="SIDEBAR"
             border="1"
             cellpadding="5">
              <tr>
                <td>
                  <div
                   class="SIDEBAR">
                    <a
                     name="c9708_html_AEN10028"></a>

                    <p><strong>терминалы и их режимы
                    работы</strong></p>

                    <p>Как правило, терминалы работают в <span
                     class="emphasis"><em
                     class="EMPHASIS">каноническом</em></span> режиме.
                    Когда пользователь нажимает какую-либо клавишу, то
                    соответствующий ей символ не сразу передается
                    программе, исполняемой в окне терминала. Этот
                    символ поступает сначала в локальный буфер
                    терминала. Когда пользователь нажимает клавишу
                    <strong
                     class="KEYCAP">ENTER</strong>, то тогда все
                    содержимое буфера передается программе.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>stty -a</strong></tt>
<tt
 class="COMPUTEROUTPUT">speed 9600 baud; rows 36; columns 96; line = 0;
intr = ^C; quit = ^\; erase = ^H; kill = ^U; eof = ^D; eol = &lt;undef&gt;; eol2 = &lt;undef&gt;;
start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; flush = ^O;
...
isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt</tt>
               
</pre>
                    <br>
                    <br>

                    <p>В каноническом режиме можно использовать символы
                    редактирования во время ввода.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>cat &gt; filexxx</strong></tt>
<tt
 class=
"USERINPUT"><strong>wha&lt;ctl-W&gt;I&lt;ctl-H&gt;foo bar&lt;ctl-U&gt;hello world&lt;ENTER&gt;</strong></tt>
<tt
 class="USERINPUT"><strong>&lt;ctl-D&gt;</strong></tt>
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>cat filexxx</strong></tt>
<tt
 class="COMPUTEROUTPUT">hello world</tt>
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>bash$ wc -c &lt; file</strong></tt>
<tt
 class="COMPUTEROUTPUT">13</tt>
               
</pre>
                    Процесс в терминале получит только 13 символов (12
                    алфавитных символов и символ перевода строки), хотя
                    пользователь нажал 26 клавиш. <br>
                    <br>

                    <p>В неканоническом (<span
                     class="QUOTE">&quot;сыром&quot;</span>) режиме,
                    каждая нажатая клавиша (включая специальные символы
                    редактирования, такие как <strong
                     class="KEYCAP">ctl-H</strong>) сразу же передается
                    исполняющемуся в терминале процессу.</p>

                    <p>Под управлением Bash, базовый терминальный
                    редактор заменяется более сложным терминальным
                    редактором Bash. Например, если вы нажмете
                    комбинацию клавиш <strong
                     class="KEYCAP">ctl-A</strong> в командной строке
                    Bash, то вы не увидите символов <strong
                     class="KEYCAP">^A</strong>, которые выводит
                    терминал, вместо этого Bash получит символ <strong
                     class="KEYCAP">\1</strong>, проанализирует его и
                    переместит курсор в начало строки.</p>

                    <p><span
                     class="emphasis"><em
                     class="EMPHASIS">Stephane Chazelas</em></span></p>
                  </div>
                </td>
              </tr>
            </table>
          </dd>

          <dt><strong
           class="COMMAND">tset</strong></dt>

          <dd>
            <p>Выводит или изменяет настройки терминала. Это более
            слабая версия <strong
             class="COMMAND">stty</strong>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>tset -r</strong></tt>
<tt
 class="COMPUTEROUTPUT">Terminal type is xterm-xfree86.
Kill is control-U (^U).
Interrupt is control-C (^C).</tt>
             
</pre>
            <br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">setserial</strong></dt>

          <dd>
            <p>Настройка параметров последовательного порта. Эта
            команда должна запускаться пользователем, обладающим
            привилегиями root. Эту команду можно встретить в сценариях
            настройки системы.</p>
<pre
 class="PROGRAMLISTING">
# Взято из /etc/pcmcia/serial :

IRQ=`setserial /dev/$DEVICE | sed -e &#39;s/.*IRQ: //&#39;`
setserial /dev/$DEVICE irq 0 ; setserial /dev/$DEVICE irq $IRQ
</pre>
            <br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">getty</strong>, <strong
           class="COMMAND">agetty</strong></dt>

          <dd>
            <p>Программа <strong
             class="COMMAND">getty</strong> или <strong
             class="COMMAND">agetty</strong> запускается процессом init
            и обслуживает процедуру входа пользователя в систему. Эти
            команды не используются в сценариях.</p>
          </dd>

          <dt><a
           name="c9708_html_MESGREF"></a><strong
           class="COMMAND">mesg</strong></dt>

          <dd>
            <p>Разрешает или запрещает доступ к терминалу текущего
            пользователя командой <a
             href="#x8707_html_WRITEREF">write</a>.</p>

            <div
             class="TIP">
              <table
               class="TIP"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/tip.gif"
                   hspace="5"
                   alt="Tip"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Наверное это очень неприятно, когда, во время
                    работы над текстовым файлом, в окне терминала,
                    прямо среди текста, вдруг появляется предложение
                    заказать пиццу. Поэтому, при работе в
                    многопользовательской системе, вам наверняка
                    захочется отключить доступ к своему терминалу.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">wall</strong></dt>

          <dd>
            <p>Имя этой команды -- аббревиатура от <span
             class="QUOTE">&quot;<a
             href="#x8707_html_WRITEREF">write</a> all&quot;</span>,
            т.е., передать сообщение всем пользователям на все
            терминалы в сети. Это, в первую очередь, инструмет
            администратора, который можно использовать, например, для
            оповещения всех пользователей о предстоящей, в ближайшее
            время, перезагрузке системы (см. <a
             href="#c11785_html_EX70">Пример 17-2</a>).</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>wall System going down for maintenance in 5 minutes!</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">Broadcast message from bozo (pts/1) Sun Jul  8 13:53:27 2001...

 System going down for maintenance in 5 minutes!</tt>
             
</pre>
            <br>
            <br>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Если доступ к терминалу был закрыт командой
                    <strong
                     class="COMMAND">mesg</strong>, то сообщение на
                    этом терминале выводиться не будет.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">dmesg</strong></dt>

          <dd>
            <p>Выводит все сообщения, выдаваемые системой во время
            загрузки на <tt
             class="FILENAME">stdout</tt>. Очень полезная утилита для
            отладочных целей. Вывод <strong
             class="COMMAND">dmesg</strong> может анализироваться с
            помощью <a
             href="#x7050_html_GREPREF">grep</a>, <a
             href="#a14586_html_SEDREF">sed</a> или <a
             href="#x14802_html_AWKREF">awk</a> внутри сценария.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>dmesg | grep hda</strong></tt>
<tt
 class="COMPUTEROUTPUT">Kernel command line: ro root=/dev/hda2
 hda: IBM-DLGA-23080, ATA DISK drive
 hda: 6015744 sectors (3080 MB) w/96KiB Cache, CHS=746/128/63
 hda: hda1 hda2 hda3 &lt; hda5 hda6 hda7 &gt; hda4</tt>
             
</pre>
            <br>
            <br>
          </dd>
        </dl>
      </div>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="c9708_html_STATISTICSSYS1"></a>Информационные и статистические
        утилиты</strong></p>

        <dl>
          <dt><strong
           class="COMMAND">uname</strong></dt>

          <dd>
            <p>Выводит на <tt
             class="FILENAME">stdout</tt> имя системы. С ключом <tt
             class="OPTION">-a</tt>, выводит подробную информацию,
            содержащую имя системы, имя узла (то есть имя, под которым
            система известна в сети), версию операционной системы,
            наименование модификации операционной системы, аппаратную
            архитектуру (см. <a
             href="#x6646_html_EX41">Пример 12-4</a>).</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>uname -a</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">Linux localhost.localdomain 2.2.15-2.5.0 #1 Sat Feb 5 00:13:43 EST 2000 i686 unknown</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>uname -s</strong></tt>
<tt
 class="COMPUTEROUTPUT">Linux</tt>
</pre>
          </dd>

          <dt><strong
           class="COMMAND">arch</strong></dt>

          <dd>
            <p>Выводит тип аппаратной платформы компьютерв.
            Эквивалентна команде <strong
             class="COMMAND">uname -m</strong>. См. <a
             href="#x5210_html_CASECMD">Пример 10-26</a>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>arch</strong></tt>
<tt
 class="COMPUTEROUTPUT">i686</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>uname -m</strong></tt>
<tt
 class="COMPUTEROUTPUT">i686</tt>
</pre>
          </dd>

          <dt><strong
           class="COMMAND">lastcomm</strong></dt>

          <dd>
            <p>Выводит информацию, о ранее выполненных командах, из
            файла <tt
             class="FILENAME">/var/account/pacct</tt>. Дополнительно
            могут указываться команда и пользователь. Это одна из
            утилит пакета GNU acct.</p>
          </dd>

          <dt><strong
           class="COMMAND">lastlog</strong></dt>

          <dd>
            <p>Выводит список всех пользователей, с указанием времени
            последнего входа в систему. Данные берутся из файла <tt
             class="FILENAME">/var/log/lastlog</tt>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>lastlog</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">root          tty1                      Fri Dec  7 18:43:21 -0700 2001
 bin                                     **Never logged in**
 daemon                                  **Never logged in**
 ...
 bozo          tty1                      Sat Dec  8 21:14:29 -0700 2001</tt>



<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>lastlog | grep root</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">root          tty1                      Fri Dec  7 18:43:21 -0700 2001</tt>
             
</pre>
            <br>
            <br>

            <div
             class="CAUTION">
              <table
               class="CAUTION"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/caution.gif"
                   hspace="5"
                   alt="Caution"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Исполнение этой команды будет завершаться
                    неудачей, если пользователь, вызвавший утилиту, не
                    имеет прав на чтение файла <tt
                     class="FILENAME">/var/log/lastlog</tt>.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">lsof</strong></dt>

          <dd>
            <p>Выводит детальный список открытых, в настоящий момент
            времени, файлов в виде таблицы. В таблице указаны --
            владелец файла, размер файла, тип файла, процесс, открывший
            файл, и многое другое. Само собой разумеется, что вывод
            команды <strong
             class="COMMAND">lsof</strong> может быть обработан, в
            конвейере, с помощью утилит <a
             href="#x7050_html_GREPREF">grep</a> и/или <a
             href="#x14802_html_AWKREF">awk</a>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>lsof</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">COMMAND    PID    USER   FD   TYPE     DEVICE    SIZE     NODE NAME
 init         1    root  mem    REG        3,5   30748    30303 /sbin/init
 init         1    root  mem    REG        3,5   73120     8069 /lib/ld-2.1.3.so
 init         1    root  mem    REG        3,5  931668     8075 /lib/libc-2.1.3.so
 cardmgr    213    root  mem    REG        3,5   36956    30357 /sbin/cardmgr
 ...</tt>
             
</pre>
            <br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">strace</strong></dt>

          <dd>
            <p>Диагностическая и отладочная утилита, предназначенная
            для трассировки системных вызовов и сигналов. В простейшем
            случае, запускается как: <strong
             class="COMMAND">strace COMMAND</strong>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>strace df</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">execve(&quot;/bin/df&quot;, [&quot;df&quot;], [/* 45 vars */]) = 0
 uname({sys=&quot;Linux&quot;, node=&quot;bozo.localdomain&quot;, ...}) = 0
 brk(0)                                  = 0x804f5e4
 ...</tt>
           
</pre>
            <br>
            <br>

            <p>Эквивалентна команде <strong
             class="COMMAND">truss</strong>.</p>
          </dd>

          <dt><strong
           class="COMMAND">nmap</strong></dt>

          <dd>
            <p>Сканер сетевых портов. Эта утилита сканирует сервер в
            поисках открытых портов и сервисов. Это очень важный
            инструмент, используемый для поиска уязвимостей при
            настройке системы.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

SERVER=$HOST                           # localhost.localdomain (127.0.0.1).
PORT_NUMBER=25                         # порт службы SMTP.

nmap $SERVER | grep -w &quot;$PORT_NUMBER&quot;  # Проверить -- открыт ли данный порт?
#              grep -w -- поиск только целых слов,
#+             так, например, порт 1025 будет пропущен.

exit 0

# 25/tcp     open        smtp
</pre>
            <br>
            <br>
          </dd>

          <dt><a
           name="c9708_html_FREEREF"></a><strong
           class="COMMAND">free</strong></dt>

          <dd>
            <p>Показывает информацию об использовании памяти, в
            табличной форме. Вывод команды может быть проанализирован с
            помощью <a
             href="#x7050_html_GREPREF">grep</a>, <a
             href="#x14802_html_AWKREF">awk</a> или <strong
             class="COMMAND">Perl</strong>. Команда <strong
             class="COMMAND">procinfo</strong> тоже выводит эту
            информацию, среди всего прочего.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <strong
 class="COMMAND">free</strong>
 <tt
 class=
"COMPUTEROUTPUT">               total       used       free     shared    buffers     cached
   Mem:         30504      28624       1880      15820       1608       16376
   -/+ buffers/cache:      10640      19864
   Swap:        68540       3128      65412</tt>
</pre>

            <p>Показать размер неиспользуемой памяти RAM:</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <strong
 class="COMMAND">free | grep Mem | awk &#39;{ print $4 }&#39;</strong>
<tt
 class="COMPUTEROUTPUT">1880</tt>
</pre>
          </dd>

          <dt><a
           name="c9708_html_PROCINFOREF"></a><strong
           class="COMMAND">procinfo</strong></dt>

          <dd>
            <p>Извлекает и выводит информацию из <a
             href="#c12942_html_DEVPROCREF">файловой системы <tt
             class="FILENAME">/proc</tt></a>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>procinfo | grep Bootup</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">Bootup: Wed Mar 21 15:15:50 2001    Load average: 0.04 0.21 0.34 3/47 6829</tt>
</pre>
          </dd>

          <dt><a
           name="c9708_html_LSDEVREF"></a><strong
           class="COMMAND">lsdev</strong></dt>

          <dd>
            <p>Список аппаратных устройств в системе.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>lsdev</strong></tt>
<tt
 class="COMPUTEROUTPUT">Device            DMA   IRQ  I/O Ports
 ------------------------------------------------
 cascade             4     2
 dma                          0080-008f
 dma1                         0000-001f
 dma2                         00c0-00df
 fpu                          00f0-00ff
 ide0                     14  01f0-01f7 03f6-03f6
 ...</tt>
             
</pre>
            <br>
            <br>
          </dd>

          <dt><a
           name="c9708_html_DUREF"></a><strong
           class="COMMAND">du</strong></dt>

          <dd>
            <p>Выводит сведения о занимаемом дисковом пространстве в
            каталоге и вложенных подкаталогах. Если каталог не указан,
            то по-умолчанию выводятся сведения о текущем каталоге.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <strong
 class="COMMAND">du -ach</strong>
<tt
 class="COMPUTEROUTPUT">1.0k    ./wi.sh
 1.0k    ./tst.sh
 1.0k    ./random.file
 6.0k    .
 6.0k    total</tt>
</pre>
          </dd>

          <dt><a
           name="c9708_html_DFREF"></a><strong
           class="COMMAND">df</strong></dt>

          <dd>
            <p>Выводит в табличной форме сведения о смонтированных
            файловых системах.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <strong
 class="COMMAND">df</strong>
<tt
 class=
"COMPUTEROUTPUT">Filesystem           1k-blocks      Used Available Use% Mounted on
/dev/hda5               273262     92607    166547  36% /
/dev/hda8               222525    123951     87085  59% /home
/dev/hda7              1408796   1075744    261488  80% /usr</tt>
</pre>
          </dd>

          <dt><strong
           class="COMMAND">stat</strong></dt>

          <dd>
            <p>Дает подробную информацию о заданном файле (каталоге или
            файле устройства) или наборе файлов.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>stat test.cru</strong></tt>
 <tt
 class="COMPUTEROUTPUT"> File: &quot;test.cru&quot;
   Size: 49970        Allocated Blocks: 100          Filetype: Regular File
   Mode: (0664/-rw-rw-r--)         Uid: (  501/ bozo)  Gid: (  501/ bozo)
 Device:  3,8   Inode: 18185     Links: 1
 Access: Sat Jun  2 16:40:24 2001
 Modify: Sat Jun  2 16:40:24 2001
 Change: Sat Jun  2 16:40:24 2001</tt>
             
</pre>
            <br>
            <br>

            <p>Если заданный файл отсутствует, то <strong
             class="COMMAND">stat</strong> вернет сообщение об
            ошибке.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>stat nonexistent-file</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">nonexistent-file: No such file or directory</tt>
             
</pre>
            <br>
            <br>
          </dd>

          <dt><a
           name="c9708_html_VMSTATREF"></a><strong
           class="COMMAND">vmstat</strong></dt>

          <dd>
            <p>Выводит информацию о виртуальной памяти.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>vmstat</strong></tt>
 <tt
 class=
"COMPUTEROUTPUT">  procs                      memory    swap          io system         cpu
 r  b  w   swpd   free   buff  cache  si  so    bi    bo   in    cs  us  sy id
 0  0  0      0  11040   2636  38952   0   0    33     7  271    88   8   3 89</tt>
           
</pre>
            <br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">netstat</strong></dt>

          <dd>
            <p>Показывает сведения о сетевой подсистеме, такие как:
            таблицы маршрутизации и активные соединения. Эта утилита
            получает сведения из <tt
             class="FILENAME">/proc/net</tt> (<a
             href="#c12942_html">Глава 27</a>). См. <a
             href="#x12987_html_CONSTAT">Пример 27-2</a>.</p>

            <p><strong
             class="COMMAND">netstat -r</strong> -- эквивалентна
            команде <a
             href="#c9708_html_ROUTEREF">route</a>.</p>
          </dd>

          <dt><a
           name="c9708_html_UPTIMEREF"></a><strong
           class="COMMAND">uptime</strong></dt>

          <dd>
            <p>Показывает количество времени, прошедшего с момента
            последней перезагрузки системы.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>uptime</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">10:28pm  up  1:57,  3 users,  load average: 0.17, 0.34, 0.27</tt>
</pre>
          </dd>

          <dt><a
           name="c9708_html_HNAMEREF"></a><strong
           class="COMMAND">hostname</strong></dt>

          <dd>
            <p>Выводит имя узла (сетевое имя системы). С помощью этой
            команды устанавливается сетевое имя системы в сценарии <tt
             class="FILENAME">/etc/rc.d/rc.sysinit</tt>. Эквивалентна
            команде <strong
             class="COMMAND">uname -n</strong> и внутренней переменной
            <a
             href="#c3270_html_HOSTNAMEREF">$HOSTNAME</a>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>hostname</strong></tt>
<tt
 class="COMPUTEROUTPUT">localhost.localdomain</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo $HOSTNAME</strong></tt>
<tt
 class="COMPUTEROUTPUT">localhost.localdomain</tt>
</pre>
          </dd>

          <dt><a
           name="c9708_html_HOSTIDREF"></a><strong
           class="COMMAND">hostid</strong></dt>

          <dd>
            <p>Выводит 32-битный шестнадцатиричный идентификатор
            системы.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>hostid</strong></tt>
<tt
 class="COMPUTEROUTPUT">7f0100</tt>
</pre>
            <br>
            <br>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Эта команда генерирует <span
                     class="QUOTE">&quot;уникальный&quot;</span>
                    числовой идентификатор системы. Некоторые
                    программные продукты используют этот идентификатор
                    в процедуре регистрации. К сожалению, при генерации
                    идентификатора, <strong
                     class="COMMAND">hostid</strong> использует только
                    IP адрес системы, переводя его в шестнадцатиричное
                    представление и переставляя местами пары байт.</p>

                    <p>Обычно, IP адрес системы можно найти в файле <tt
                     class="FILENAME">/etc/hosts</tt>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>cat /etc/hosts</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">127.0.0.1               localhost.localdomain localhost</tt>
</pre>
                    <br>
                    <br>

                    <p>Переставив местами байты, попарно, в начальном
                    адресе <tt
                     class="USERINPUT"><strong>127.0.0.1</strong></tt>,
                    мы получим <tt
                     class="USERINPUT"><strong>0.127.1.0</strong></tt>,
                    в шестнадцатиричном представлении это будет <tt
                     class="USERINPUT"><strong>007f0100</strong></tt>,
                    что в точности совпадает с приведенным выше
                    результатом выполнения <strong
                     class="COMMAND">hostid</strong>. Наверняка можно
                    найти несколько миллионов компьютеров с таким же
                    <span
                     class="QUOTE">&quot;уникальным&quot;</span>
                    идентификатором.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">sar</strong></dt>

          <dd>
            <p>Команда <strong
             class="COMMAND">sar</strong> (system activity report)
            выводит очень подробную статистику о функционировании
            операционной системы. Эту команду можно найти в отдельных
            коммерческих дистрибутивах UNIX-систем. Она, как правило,
            не входит в базовый комплект пакетов Linux-систем. Она
            входит в состав пакета <a
             href="http://perso.wanadoo.fr/sebastien.godard/"
             target="_top">sysstat utilities</a>, автор: <a
             href="mailto:sebastien.godard@wanadoo.fr"
             target="_top">Sebastien Godard</a>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>sar</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">Linux 2.4.7-10 (localhost.localdomain)         12/31/2001

 10:30:01 AM       CPU     %user     %nice   %system     %idle
 10:40:00 AM       all      1.39      0.00      0.77     97.84
 10:50:00 AM       all     76.83      0.00      1.45     21.72
 11:00:00 AM       all      1.32      0.00      0.69     97.99
 11:10:00 AM       all      1.17      0.00      0.30     98.53
 11:20:00 AM       all      0.51      0.00      0.30     99.19
 06:30:00 PM       all    100.00      0.00    100.01      0.00
 Average:          all      1.39      0.00      0.66     97.95</tt>
          
</pre>
          </dd>

          <dt><strong
           class="COMMAND">readelf</strong></dt>

          <dd>
            <p>Показывает сведения о заданном бинарном файле формата
            <span
             class="emphasis"><em
             class="EMPHASIS">elf</em></span>. Входит в состав пакета
            <span
             class="emphasis"><em
             class="EMPHASIS">binutils</em></span>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>readelf -h /bin/bash</strong></tt>
<tt
 class="COMPUTEROUTPUT">ELF Header:
   Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
   Class:                             ELF32
   Data:                              2&#39;s complement, little endian
   Version:                           1 (current)
   OS/ABI:                            UNIX - System V
   ABI Version:                       0
   Type:                              EXEC (Executable file)
   . . .</tt>
</pre>
          </dd>

          <dt><strong
           class="COMMAND">size</strong></dt>

          <dd>
            <p>Команда <strong
             class="COMMAND">size [/path/to/binary]</strong> выведет
            информацию о размерах различных сегментов в исполняемых или
            библиотечных файлах. В основном используется
            программистами.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>size /bin/bash</strong></tt>
 <tt
 class="COMPUTEROUTPUT">  text    data     bss     dec     hex filename
  495971   22496   17392  535859   82d33 /bin/bash</tt>
             
</pre>
            <br>
            <br>
          </dd>
        </dl>
      </div>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="c9708_html_SYSLOG1"></a>Системный журнал</strong></p>

        <dl>
          <dt><strong
           class="COMMAND">logger</strong></dt>

          <dd>
            <p>Добавляет в системный журнал (<tt
             class="FILENAME">/var/log/messages</tt>) сообщение от
            пользователя. Для добавления сообщения пользователь не
            должен обладать привилегиями суперпользователя.</p>
<pre
 class="PROGRAMLISTING">
logger Experiencing instability in network connection at 23:10, 05/21.
# Теперь попробуйте дать команду &#39;tail /var/log/messages&#39;.
</pre>
            <br>
            <br>

            <p>Встраивая вызов <strong
             class="COMMAND">logger</strong> в сценарии, вы получаете
            возможность заносить отладочную информацию в системный
            журнал <tt
             class="FILENAME">/var/log/messages</tt>.</p>
<pre
 class="PROGRAMLISTING">
logger -t $0 -i Logging at line &quot;$LINENO&quot;.
# Ключ &quot;-t&quot; задает тэг записи в журнале.
# Ключ &quot;-i&quot; -- записывает ID процесса.

# tail /var/log/message
# ...
# Jul  7 20:48:58 localhost ./test.sh[1712]: Logging at line 3.
</pre>
            <br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">logrotate</strong></dt>

          <dd>
            <p>Эта утилита производит манипуляции над системным
            журналом: ротация, сжатие, удаление и/или отправляет его по
            электронной почте, по мере необходимости. Как правило,
            утилита <strong
             class="COMMAND">logrotate</strong> вызывается демоном <a
             href="#c9708_html_CRONREF">crond</a> ежедневно.</p>

            <p>Добавляя соответствующие строки в <tt
             class="FILENAME">/etc/logrotate.conf</tt>, можно заставить
            <strong
             class="COMMAND">logrotate</strong> обрабатывать не только
            системный журнал, но и ваш личный.</p>
          </dd>
        </dl>
      </div>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="c9708_html_JOBCONTROLSYS1"></a>Управление заданиями</strong></p>

        <dl>
          <dt><strong
           class="COMMAND">ps</strong></dt>

          <dd>
            <p><tt
             class="REPLACEABLE"><em>P</em></tt>rocess <tt
             class="REPLACEABLE"><em>S</em></tt>tatistics: Список
            исполняющихся в данный момент процессов. Обычно вызывается
            с ключами <tt
             class="OPTION">ax</tt>, вывод команды может быть обработан
            командами <a
             href="#x7050_html_GREPREF">grep</a> или <a
             href="#a14586_html_SEDREF">sed</a>, с целью поиска
            требуемого процесса (см. <a
             href="#c5358_html_EX44">Пример 11-10</a> и <a
             href="#x12987_html_PIDID">Пример 27-1</a>).</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ps ax | grep sendmail</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">295 ?     S      0:00 sendmail: accepting connections on port 25</tt>
</pre>
          </dd>

          <dt><strong
           class="COMMAND">pstree</strong></dt>

          <dd>
            <p>Список исполняющихся процессов в виде <span
             class="QUOTE">&quot;дерева&quot;</span>. С ключом <tt
             class="OPTION">-p</tt> -- вместе с именами процессов
            отображает их PID.</p>
          </dd>

          <dt><strong
           class="COMMAND">top</strong></dt>

          <dd>
            <p>Выводит список наиболее активных процессов. С ключом <tt
             class="OPTION">-b</tt> -- отображение ведется в обычном
            текстовом режиме, что дает возможность анализа вывода от
            команды внутри сценария.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>top -b</strong></tt>
 <tt
 class=
"COMPUTEROUTPUT"> 8:30pm  up 3 min,  3 users,  load average: 0.49, 0.32, 0.13
 45 processes: 44 sleeping, 1 running, 0 zombie, 0 stopped
 CPU states: 13.6% user,  7.3% system,  0.0% nice, 78.9% idle
 Mem:    78396K av,   65468K used,   12928K free,       0K shrd,    2352K buff
 Swap:  157208K av,       0K used,  157208K free                   37244K cached

   PID USER     PRI  NI  SIZE  RSS SHARE STAT %CPU %MEM   TIME COMMAND
   848 bozo      17   0   996  996   800 R     5.6  1.2   0:00 top
     1 root       8   0   512  512   444 S     0.0  0.6   0:04 init
     2 root       9   0     0    0     0 SW    0.0  0.0   0:00 keventd
   ...</tt>
             
</pre>
            <br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">nice</strong></dt>

          <dd>
            <p>Запускает фоновый процесс с заданным приоритетом.
            Приоритеты могут задаваться числом из диапазона от 19
            (низший приоритет) до -20 (высший приоритет). Но только
            <span
             class="emphasis"><em
             class="EMPHASIS">root</em></span> может указать значение
            приоритета меньше нуля (отрицательные значения). См. так же
            команды <strong
             class="COMMAND">renice</strong>, <strong
             class="COMMAND">snice</strong> и <strong
             class="COMMAND">skill</strong>.</p>
          </dd>

          <dt><strong
           class="COMMAND">nohup</strong></dt>

          <dd>
            <p>Запуск команд в режиме игнорирования сигналов прерывания
            и завершения, что предотвращает завершение работы команды
            даже если пользователь, запустивший ее, вышел из системы.
            Если после команды не указан символ <span
             class="TOKEN">&amp;</span>, то она будет исполняться как
            процесс &quot;переднего плана&quot;. Если вы собираетесь
            использовать <strong
             class="COMMAND">nohup</strong> в сценариях, то вам
            потребуется использовать его в связке с командой <a
             href="#c5358_html_WAITREF">wait</a>, чтобы не породить
            процесс &quot;зомби&quot;.</p>
          </dd>

          <dt><a
           name="c9708_html_PIDOFREF"></a><strong
           class="COMMAND">pidof</strong></dt>

          <dd>
            <p>Возвращает идентификатор процесса <span
             class="emphasis"><em
             class="EMPHASIS">(pid)</em></span> по его имени. Поскольку
            многие команды управления процессами, такие как <a
             href="#c5358_html_KILLREF">kill</a> и <strong
             class="COMMAND">renice</strong>, требуют указать <span
             class="emphasis"><em
             class="EMPHASIS">pid</em></span> процесса, а не его имя,
            то <strong
             class="COMMAND">pidof</strong> может сослужить неплохую
            службу при идентификации процесса по его имени. Эта коменда
            может рассматриваться как приблизительный эквивалент
            внутренней переменной <a
             href="#c3270_html_PPIDREF">$PPID</a>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>pidof xclock</strong></tt>
<tt
 class="COMPUTEROUTPUT">880</tt>
             
</pre>
            <br>
            <br>

            <div
             class="EXAMPLE">
              <a
               name="c9708_html_KILLPROCESS"></a>

              <p><strong>Пример 13-4. Использование команды pidof при
              остановке процесса</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# kill-process.sh

NOPROCESS=2

process=xxxyyyzzz  # Несуществующий процесс.
# Только в демонстрационных целях...
# ... чтобы не уничтожить этим сценарием какой-нибудь процесс.
#
# Если с помощью этого сценария вы задумаете разрыватть связь с Internet, то
#     process=pppd

t=`pidof $process`       # Поиск pid (process id) процесса $process.
# pid требует команда &#39;kill&#39; (невозможно остановить процесс, указав его имя).

if [ -z &quot;$t&quot; ]           # Если процесс с таким именем не найден, то &#39;pidof&#39; вернет null.
then
  echo &quot;Процесс $process не найден.&quot;
  exit $NOPROCESS
fi

kill $t                  # В некоторых случаях может потребоваться &#39;kill -9&#39;.

# Здесь нужно проверить -- был ли уничтожен процесс.
# Возможно так: &quot; t=`pidof $process` &quot;.


# Этот сценарий мог бы быть заменен командой
#    kill $(pidof -x process_name)
# но это было бы не так поучительно.

exit 0
</pre>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">fuser</strong></dt>

          <dd>
            <p>Возвращает идентификаторы процессов, использующих
            указанный файл(ы) или каталог. С ключом <tt
             class="OPTION">-k</tt>, завершает найденные процессы.
            Может с успехом использоваться для защиты системы, особенно
            в сценариях разграничения доступа к системным службам.</p>
          </dd>

          <dt><a
           name="c9708_html_CRONREF"></a><strong
           class="COMMAND">crond</strong></dt>

          <dd>
            <p>Планировщик заданий. С его помощью выполняются такие
            задачи, как очистка и удаление устаревших файлов системных
            журналов, обновление базы данных <span
             class="DATABASE">slocate</span>. Это суперпользовательская
            версия команды <a
             href="#x6837_html_ATREF">at</a> (хотя любой пользователь
            может создать собственную таблицу <tt
             class="FILENAME">crontab</tt>). Эта утилита запускается
            как фоновый процесс-<a
             href="#x8707_html_DAEMONREF">daemon</a> и выполняет
            задания, находящиеся в файле <tt
             class="FILENAME">/etc/crontab</tt>.</p>
          </dd>
        </dl>
      </div>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="c9708_html_RUNCONTROLSYS1"></a>Команды управления процессами и
        загрузкой</strong></p>

        <dl>
          <dt><strong
           class="COMMAND">init</strong></dt>

          <dd>
            <p><strong
             class="COMMAND">init</strong> -- <a
             href="#c5358_html_FORKREF">предок (родитель)</a> всех
            процессов в системе. Вызывается на последнем этапе загрузки
            системы и определяет уровень загрузки (runlevel) из файла
            <tt
             class="FILENAME">/etc/inittab</tt>.</p>
          </dd>

          <dt><strong
           class="COMMAND">telinit</strong></dt>

          <dd>
            <p>Символическая ссылка на <strong
             class="COMMAND">init</strong> -- инструмент для смены
            уровня загрузки (runlevel), как правило используется при
            обслуживании системы или восстановлении файловой системы.
            Может быть вызвана только суперпользователем. Эта команда
            может быть очень опасна, при неумелом обращении -- прежде
            чем использовать ее, убедитесь в том, что вы совершенно
            точно понимаете что делаете!</p>
          </dd>

          <dt><strong
           class="COMMAND">runlevel</strong></dt>

          <dd>
            <p>Выводит предыдущий и текущий уровни загрузки (runlevel).
            Уровень загрузки может иметь одно из 6 значений: <tt
             class="LITERAL">0</tt> -- остановка системы, <tt
             class="LITERAL">1</tt> -- однопользовательский режим, <tt
             class="LITERAL">2</tt> или <tt
             class="LITERAL">3</tt> -- многопользовательский режим, <tt
             class="LITERAL">5</tt> -- многопользовательский режим и
            запуск X Window, <tt
             class="LITERAL">6</tt> -- перезагрузка. Уровни загрузки
            определяются из файла <tt
             class="FILENAME">/var/run/utmp</tt>.</p>
          </dd>

          <dt><strong
           class="COMMAND">halt</strong>, <strong
           class="COMMAND">shutdown</strong>, <strong
           class="COMMAND">reboot</strong></dt>

          <dd>
            <p>Набор команд для остановки системы, обычно перед
            выключением питания.</p>
          </dd>
        </dl>
      </div>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="c9708_html_NETWORKSYS1"></a>Команды для работы с сетью</strong></p>

        <dl>
          <dt><strong
           class="COMMAND">ifconfig</strong></dt>

          <dd>
            <p>Утилита конфигурирования и запуска сетевых интерфейсов.
            Чаще всего используется в сценариях начальной загрузки
            системы, для настройки и запуска сетевых интерфейсов или
            для их остановки перед остановкой или перезагрузкой.</p>
<pre
 class="PROGRAMLISTING">
# Фрагменты кода из /etc/rc.d/init.d/network

# ...

# Проверка сетевой полсистемы.
[ ${NETWORKING} = &quot;no&quot; ] &amp;&amp; exit 0

[ -x /sbin/ifconfig ] || exit 0

# ...

for i in $interfaces ; do
  if ifconfig $i 2&gt;/dev/null | grep -q &quot;UP&quot; &gt;/dev/null 2&gt;&amp;1 ; then
    action &quot;Останавливается $i: &quot; ./ifdown $i boot
  fi
# Ключ &quot;-q&quot;, характерный для GNU-версии &quot;grep&quot;, означает &quot;quiet&quot; (&quot;молча&quot;), т.е. подавляет вывод.
# Поэтому нет необходимости переадресовывать вывод на /dev/null.

# ...

echo &quot;В настоящее время активны устройства:&quot;
echo `/sbin/ifconfig | grep ^[a-z] | awk &#39;{print $1}&#39;`
#                            ^^^^^  скобки необходимы для предотвращения подстановки имен файлов (globbing).
#  Следующий код делает то же самое.
#    echo $(/sbin/ifconfig | awk &#39;/^[a-z]/ { print $1 })&#39;
#    echo $(/sbin/ifconfig | sed -e &#39;s/ .*//&#39;)
#  Спасибо S.C. за комментарии.
</pre>
            См. также <a
             href="#c13099_html_ONLINE">Пример 29-6</a>.<br>
            <br>
          </dd>

          <dt><a
           name="c9708_html_ROUTEREF"></a><strong
           class="COMMAND">route</strong></dt>

          <dd>
            <p>Выводит сведения о таблице маршрутизации ядра или вносит
            туда изменения.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>route</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
 pm3-67.bozosisp *               255.255.255.255 UH       40 0          0 ppp0
 127.0.0.0       *               255.0.0.0       U        40 0          0 lo
 default         pm3-67.bozosisp 0.0.0.0         UG       40 0          0 ppp0</tt>
             
</pre>
            <br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">chkconfig</strong></dt>

          <dd>
            <p>Проверка сетевой конфигурации. Обслуживает список,
            запускаемых на этапе загрузки, сетевых сервисов, список
            сервисов хранится в каталогах <tt
             class="FILENAME">/etc/rc?.d</tt> (строго говоря, chkconfig
            работает не только с сетевыми сервисами, а с сервисами
            вообще, не зависимо от того сетевые это службы или нет.
            прим. перев.).</p>

            <p>Изначально эта утилита была перенесена в Red Hat Linux
            из ОС IRIX, <strong
             class="COMMAND">chkconfig</strong> входит в состав далеко
            не всех дистрибутивов Linux.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>chkconfig --list</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">atd             0:off   1:off   2:off   3:on    4:on    5:on    6:off
rwhod           0:off   1:off   2:off   3:off   4:off   5:off   6:off
 ...</tt>
             
</pre>
            <br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">tcpdump</strong></dt>

          <dd>
            <p><span
             class="QUOTE">&quot;Сниффер&quot;</span> (<span
             class="QUOTE">&quot;sniffer&quot;</span>) сетевых пакетов.
            Инструмент для перехвата и анализа сетевого трафика по
            определенным критериям.</p>

            <p>Дамп трафика ip-пакетов между двумя узлами сети -- <span
             class="emphasis"><em
             class="EMPHASIS">bozoville</em></span> и <span
             class="emphasis"><em
             class="EMPHASIS">caduceus</em></span>:</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>tcpdump ip host bozoville and caduceus</strong></tt>
             
</pre>
            <br>
            <br>

            <p>Конечно же, вывод команды <strong
             class="COMMAND">tcpdump</strong> может быть
            проанализирован с помощью <a
             href="#x7050_html_TPCOMMANDLISTING1">команд обработки
            текста</a>, обсуждавшихся выше.</p>
          </dd>
        </dl>
      </div>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="c9708_html_FILESYSTEMSYS1"></a>Команды для работы с файловыми
        системами</strong></p>

        <dl>
          <dt><strong
           class="COMMAND">mount</strong></dt>

          <dd>
            <p>Выполняет монтирование файловой системы, обычно на
            устройстве со сменными носителями, такими как дискеты или
            CDROM. Файл <tt
             class="FILENAME">/etc/fstab</tt> содержит перечень
            доступных для монтирования файловых систем, разделов и
            устройств, включая опции монтирования, благодаря этому
            файлу, монтирование может производиться автоматически или
            вручеую. Файл <tt
             class="FILENAME">/etc/mtab</tt> содержит список
            смонтированных файловых систем и разделов (включая
            виртуальные, такие как <tt
             class="FILENAME">/proc</tt>).</p>

            <p><strong
             class="COMMAND">mount -a</strong> -- монтирует все (all)
            файловые системы и разделы, перечисленные в <tt
             class="FILENAME">/etc/fstab</tt>, за исключением тех,
            которые имеют флаг <tt
             class="OPTION">noauto</tt>. Эту команду можно встретить в
            сценариях начальной загрузки системы из <tt
             class="FILENAME">/etc/rc.d</tt> (<tt
             class="FILENAME">rc.sysinit</tt> или нечто похожее).</p>
<pre
 class="PROGRAMLISTING">
mount -t iso9660 /dev/cdrom /mnt/cdrom
# Монтирование CDROM-а
mount /mnt/cdrom
# Более короткий и удобный вариант, если точка монтирования /mnt/cdrom описана в /etc/fstab
</pre>
            <br>
            <br>

            <p>Эта команда может даже смонтировать обычный файл как
            блочное устройство. Достигается это за счет связывания
            файла с <a
             href="#c12942_html_LOOPBACKREF">loopback-устройством</a>.
            Эту возможность можно использовать для проверки ISO9660
            образа компакт-диска перед его записью на болванку. <a
             name="AEN10873"
             href="#c9708_html_FTN_AEN10873"><span
             class="footnote">[2]</span></a></p>

            <div
             class="EXAMPLE">
              <a
               name="c9708_html_ISOMOUNTREF"></a>

              <p><strong>Пример 13-5. Проверка образа CD</strong></p>
<pre
 class="PROGRAMLISTING">
# С правами root...

mkdir /mnt/cdtest  # Подготовка точки монтирования.

mount -r -t iso9660 -o loop cd-image.iso /mnt/cdtest   # Монтирование образа диска.
#             ключ &quot;-o loop&quot; эквивалентен &quot;losetup /dev/loop0&quot;
cd /mnt/cdtest     # Теперь проверим образ диска.
ls -alR            # Вывод списка файлов
</pre>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">umount</strong></dt>

          <dd>
            <p>Отмонтирует смонтированную файловую систему. Перед тем
            как физически вынуть компакт-диск или дискету из
            устройства, это устройство должно быть отмонтировано
            командой <strong
             class="COMMAND">umount</strong>, иначе файловая система
            может оказаться поврежденной (особенно это относится к
            накопителям на гибких магнитных дисках, прим. перев.).</p>
<pre
 class="PROGRAMLISTING">
umount /mnt/cdrom
# Теперь вы можете извлечь диск из привода.
</pre>
            <br>
            <br>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Утилита <strong
                     class="COMMAND">automount</strong>, если она
                    установлена, может выполнять атоматическое
                    монтирование/размонтирование устройств со сменными
                    носителями, такие как дискеты и компакт-диски. На
                    ноутбуках со сменными устройствами FDD и CDROM,
                    такой подход может привести к возникновению
                    определенных проблем.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">sync</strong></dt>

          <dd>
            <p>Принудительный сброс содержимого буферов на жесткий диск
            (синхронизация содержимого буферов ввода-вывода и
            устройства-носителя). Несмотря на то, что нет такой уж
            острой необходимости в этой утилите, тем не менее <strong
             class="COMMAND">sync</strong> придает уверенности
            системным администраторам или пользователям в том, что их
            данные будут сохранены на жестком диске, и не будут
            потеряны в случае какого-либо сбоя. В былые дни, команда
            <tt
             class="USERINPUT"><strong>sync; sync</strong></tt> (дважды
            -- для абсолютной уверенности) была упреждающей мерой перед
            перезагрузкой системы.</p>

            <p>Иногда возникает необходимость принудительной
            синхронизации буферов ввода-вывода с содержимым на
            магнитном носителе, как, например, при надежном удалении
            файла (см. <a
             href="#x9307_html_BLOTOUT">Пример 12-42</a>) или когда
            наблюдаются скачки напряжения в сети электроснабжения.</p>
          </dd>

          <dt><a
           name="c9708_html_LOSETUPREF"></a><strong
           class="COMMAND">losetup</strong></dt>

          <dd>
            <p>Устанавливает и конфигурирует <a
             href=
            "#c12942_html_LOOPBACKREF">loopback-устройства</a>.</p>

            <div
             class="EXAMPLE">
              <a
               name="c9708_html_CREATEFS"></a>

              <p><strong>Пример 13-6. Создание файловой системы в
              обычном файле</strong></p>
<pre
 class="PROGRAMLISTING">
SIZE=1048576  # 1 Мб

head -c $SIZE &lt; /dev/zero &gt; file  # Создается файл нужного размера.
losetup /dev/loop0 file           # Файл назначается как loopback-устройство.
mke2fs /dev/loop0                 # Создание файловой системы.
mount -o loop /dev/loop0 /mnt     # Монтирование только что созданной файловой системы.

# Спасибо S.C.
</pre>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">mkswap</strong></dt>

          <dd>
            <p>Создание swap-раздела или swap-файла. Созданный
            swap-раздел (файл) нужно затем подключить командой <strong
             class="COMMAND">swapon</strong>.</p>
          </dd>

          <dt><strong
           class="COMMAND">swapon</strong>, <strong
           class="COMMAND">swapoff</strong></dt>

          <dd>
            <p>Разрешает/запрещает использование swap-раздела (файла).
            Эта команда обычно используется во время загрузки системы
            или во время остановки.</p>
          </dd>

          <dt><a
           name="c9708_html_MKE2FSREF"></a><strong
           class="COMMAND">mke2fs</strong></dt>

          <dd>
            <p>Создает файловую систему ext2. Должна вызываться с
            правами суперпользователя.</p>

            <div
             class="EXAMPLE">
              <a
               name="c9708_html_ADDDRV"></a>

              <p><strong>Пример 13-7. Добавление нового жесткого
              диска</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Добавление в систему второго жесткого диска.
# Программное конфигурирование. Предполагается, что устройство уже подключено к аппаратуре компьютера.
# Взято из статьи автора документа.
# &quot;Linux Gazette&quot;, выпуск #38, http://www.linuxgazette.com.

ROOT_UID=0     # Этот сценарий должен запускать только root.
E_NOTROOT=67   # Код ошибки, если сценарий запущен простым пользователем.

if [ &quot;$UID&quot; -ne &quot;$ROOT_UID&quot; ]
then
  echo &quot;Для запуска этого сценария вы должны обладать правами root.&quot;
  exit $E_NOTROOT
fi

# Будьте крайне осторожны!
# Если что-то пойдет не так, то вы можете потерять текущую файловую систему.


NEWDISK=/dev/hdb         # Предполагается, что /dev/hdb -- это новое устройство. Проверьте!
MOUNTPOINT=/mnt/newdisk  # Или выберите иное устройство для монтирования.


fdisk $NEWDISK
mke2fs -cv $NEWDISK1   # Проверка на &quot;плохие&quot; блоки (bad blocks) и подробный вывод.
#  Обратите внимание:    /dev/hdb1, *не* то же самое, что /dev/hdb!
mkdir $MOUNTPOINT
chmod 777 $MOUNTPOINT  # Сделать новое устройство доступным для всех пользователей.


# Теперь проаерим...
# mount -t ext2 /dev/hdb1 /mnt/newdisk
# Попробуйте создать каталог.
# Если получилось -- отмонтируйте устройство и продолжим.

# Последний штрих:
# Добавьте следующую строку в /etc/fstab.
# /dev/hdb1  /mnt/newdisk  ext2  defaults  1 1

exit 0
</pre>
            </div>

            <p>См. также <a
             href="#c9708_html_CREATEFS">Пример 13-6</a> и <a
             href="#c13041_html_RAMDISK">Пример 28-3</a>.</p>
          </dd>

          <dt><strong
           class="COMMAND">tune2fs</strong></dt>

          <dd>
            <p>Настройка отдельных параметров файловой системы ext2,
            например счетчик максимального количества монтирований без
            проверки. Должна вызываться с привилегиями пользователя
            root.</p>

            <div
             class="WARNING">
              <table
               class="WARNING"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/warning.gif"
                   hspace="5"
                   alt="Warning"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Очень опасная утилита. Вы можете использовать ее
                    только на свой страх и риск, поскольку, по
                    неосторожности, вы запросто можете разрушить
                    файловую систему.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">dumpe2fs</strong></dt>

          <dd>
            <p>Выводит на <tt
             class="FILENAME">stdout</tt> очень подробную информацию о
            файловой системе. Должна вызываться с привилегиями
            пользователя root.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">root#</tt> <strong
 class=
"COMMAND">dumpe2fs /dev/hda7 | grep &#39;ount count&#39;</strong>
<tt
 class=
"COMPUTEROUTPUT">dumpe2fs 1.19, 13-Jul-2000 for EXT2 FS 0.5b, 95/08/09
 Mount count:              6
 Maximum mount count:      20</tt>
</pre>
          </dd>

          <dt><strong
           class="COMMAND">hdparm</strong></dt>

          <dd>
            <p>Выводит или изменяет параметры настройки жесткого диска.
            Должна вызываться с привилегиями пользователя root.
            Потенциально опасна при неправильном использовании.</p>
          </dd>

          <dt><a
           name="c9708_html_FDISKREF"></a><strong
           class="COMMAND">fdisk</strong></dt>

          <dd>
            <p>Создание или изменение таблицы разделов на устройствах
            хранения информации, обычно -- жестких дисках. Должна
            вызываться с привилегиями пользователя root.</p>

            <div
             class="WARNING">
              <table
               class="WARNING"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/warning.gif"
                   hspace="5"
                   alt="Warning"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Пользуйтесь этой утилитой с особой
                    осторожностью, т.к. при неправильном использовании
                    можно легко разрушить существующую файловую
                    систему.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><a
           name="c9708_html_FSCKREF"></a><strong
           class="COMMAND">fsck</strong>, <strong
           class="COMMAND">e2fsck</strong>, <strong
           class="COMMAND">debugfs</strong></dt>

          <dd>
            <p>Набор команд для проверки, восстановления и отладки
            файловой системы.</p>

            <p><strong
             class="COMMAND">fsck</strong>: интерфейсная утилита для
            проверки файловых систем в UNIX (может вызывать другие
            утилиты проверки).</p>

            <p><strong
             class="COMMAND">e2fsck</strong>: проверка файловой системы
            ext2.</p>

            <p><strong
             class="COMMAND">debugfs</strong>: отладчик файловой
            системы ext2. Одно из применений этой универсальной (и
            опасной) утилиты -- это восстановление удаленных файлов.
            Только для опытных пользователей!</p>

            <div
             class="CAUTION">
              <table
               class="CAUTION"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/caution.gif"
                   hspace="5"
                   alt="Caution"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Все эти утилиты должны вызываться с привилегиями
                    пользователя root. При неправильном использовании,
                    любая из них может разрушить файловую систему.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">badblocks</strong></dt>

          <dd>
            <p>Выполняет поиск плохих блоков (физические повреждения
            носителей) на устройствах хранения информации. Эта команда
            может использоваться для поиска плохих блоков при
            форматировании вновь устанавливаемых жестких дисков или для
            проверки устройств резервного копирования. <a
             name="AEN11062"
             href="#c9708_html_FTN_AEN11062"><span
             class="footnote">[3]</span></a> Например, <strong
             class="COMMAND">badblocks /dev/fd0</strong>, проверит
            дискету на наличие поврежденных блоков.</p>

            <p>Утилита <strong
             class="COMMAND">badblocks</strong> может быть вызвана в
            деструктивном (проверка осуществляется путем записи
            некоторого шаблона в каждый блок, а затем производится
            попытка чтения этого блока) или в недеструктивном
            (неразрушающем -- только чтение) режиме.</p>
          </dd>

          <dt><strong
           class="COMMAND">mkbootdisk</strong></dt>

          <dd>
            <p>Создание загрузочной дискеты, которая может быть
            использована для загрузки системы, если, например, была
            повреждена MBR (master boot record -- главная загрузочная
            запись). Команда <strong
             class="COMMAND">mkbootdisk</strong> -- это сценарий на
            языке командной оболочки Bash, автор: Erik Troan,
            располагается в каталоге <tt
             class="FILENAME">/sbin</tt>.</p>
          </dd>

          <dt><strong
           class="COMMAND">chroot</strong></dt>

          <dd>
            <p>CHange ROOT -- смена корневого каталога. Обычно, команды
            и утилиты ориентируются в файловой системе посредством
            переменной <a
             href="#c3270_html_PATHREF">$PATH</a>, относительно
            корневого каталога <tt
             class="FILENAME">/</tt>. Команда <strong
             class="COMMAND">chroot</strong> изменяет корневой каталог
            по-умолчанию на другой (рабочий каталог также изменяется).
            Эта утилита, как правило, используется с целью защиты
            системы, например, с ее помощью можно ограничить доступ к
            разделам файловой системы для пользователей, подключающихся
            к системе с помощью <a
             href="#x8707_html_TELNETREF">telnet</a> (это называется --
            <span
             class="QUOTE">&quot;поместить пользователя в chroot
            окружение&quot;</span>). Обратите внимание: после
            выполнения команды <strong
             class="COMMAND">chroot</strong> изменяется путь к
            исполняемым файлам системы.</p>

            <p>Команда <tt
             class="USERINPUT"><strong>chroot /opt</strong></tt>
            приведет к тому, что все обращения к каталогу <tt
             class="FILENAME">/usr/bin</tt> будут переводиться на
            каталог <tt
             class="FILENAME">/opt/usr/bin</tt>. Аналогично, <tt
             class="USERINPUT"><strong>chroot /aaa/bbb
            /bin/ls</strong></tt> будет пытаться вызвать команду
            <strong
             class="COMMAND">ls</strong> из каталога <tt
             class="FILENAME">/aaa/bbb/bin</tt>, при этом, корневым
            каталогом для ls станет каталог /aaa/bbb. Поместив строчку
            <strong
             class="COMMAND">alias XX &#39;chroot /aaa/bbb
            ls&#39;</strong> в пользовательский <tt
             class="FILENAME">~/.bashrc</tt>, можно эффективно
            ограничить доступ команде <span
             class="QUOTE">&quot;XX&quot;</span>, запускаемой
            пользователем, к разделам файловой системы.</p>

            <div
             class="CAUTION">
              <table
               class="CAUTION"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/caution.gif"
                   hspace="5"
                   alt="Caution"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>При изменении корневого каталога, вам наверняка
                    потребуется скопировать системные утилиты и
                    разделяемые библиотеки в новый корневой каталог,
                    поскольку после смены корневого каталога,
                    директории с системными утилитами могут оказаться
                    за пределами нового корневого каталога.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">lockfile</strong></dt>

          <dd>
            <p>Эта утилита входит в состав пакета <strong
             class="COMMAND">procmail</strong> (<a
             href="http://www.procmail.org"
             target="_top">www.procmail.org</a>). Она создает <span
             class="emphasis"><em
             class="EMPHASIS">lock file</em></span>, файл-семафор (или,
            если угодно, файл блокировки), который управляет доступом к
            заданному файлу, устройству или ресурсу. Lock file служит
            признаком того, что данный файл, устройство или ресурс
            <span
             class="QUOTE">&quot;занят&quot;</span> некоторым
            процессом, и ограничивает (или вообще запрещает) доступ к
            ресурсу другим процессам.</p>

            <p>Файлы блокировок широко применяются для защиты системных
            почтовых каталогов от одновременной записи несколькими
            пользователями, для индикации занятости порта модема, и
            т.п. Сценарии могут использовать файлы блокировок для того,
            чтобы выяснить -- запущен ли тот или иной процесс. Обратите
            внимание: если в сценарии будет предпринята попытка создать
            файл блокировки, когда он уже существует, то такой сценарий
            скорее всего зависнет.</p>

            <p>Как правило, файлы блокировки создаются в каталоге <tt
             class="FILENAME">/var/lock</tt>. Проверка наличия файла
            блокировки может быть проверена примерно таким
            образом:.</p>
<pre
 class="PROGRAMLISTING">
appname=xyzip
# Приложение &quot;xyzip&quot; создает файл блокировки &quot;/var/lock/xyzip.lock&quot;.

if [ -e &quot;/var/lock/$appname.lock ]
then
  ...
</pre>
            <br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">mknod</strong></dt>

          <dd>
            <p>Создает специальный файл для блочного или символьного
            устройства (может потребоваться при установке новых
            устройств в компьютер).</p>
          </dd>

          <dt><strong
           class="COMMAND">tmpwatch</strong></dt>

          <dd>
            <p>Автоматически удаляет файлы, к которым не было обращений
            в течение заданного периода времени. Обычно вызывается
            демоном <a
             href="#c9708_html_CRONREF">crond</a> для удаления
            устаревших файлов системного журнала.</p>
          </dd>

          <dt><strong
           class="COMMAND">MAKEDEV</strong></dt>

          <dd>
            <p>Утилита предназначена для создания файлов-устройств.
            Должна запускаться с привилегиями пользователя root, в
            каталоге <tt
             class="FILENAME">/dev</tt>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">root#</tt> <strong
 class="COMMAND">./MAKEDEV</strong>
</pre>
            Это своего рода расширенная версия утилиты <strong
             class="COMMAND">mknod</strong>.<br>
            <br>
          </dd>
        </dl>
      </div>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="c9708_html_PERIPHSYS1"></a>Команды резервного
        копирования</strong></p>

        <dl>
          <dt><strong
           class="COMMAND">dump</strong>, <strong
           class="COMMAND">restore</strong></dt>

          <dd>
            <p>Команда <strong
             class="COMMAND">dump</strong> создает резервные копии
            целых файловых систем, обычно используется в крупных
            системах и сетях. <a
             name="AEN11188"
             href="#c9708_html_FTN_AEN11188"><span
             class="footnote">[4]</span></a> Она считывает дисковые
            разделы и сохраняет их в файле, в двоичном формате.
            Созданные таким образом файлы, могут быть сохранены на
            каком-либо носителе -- на жестком диске или магнитной
            ленте. Команда <strong
             class="COMMAND">restore</strong> -- <span
             class="QUOTE">&quot;разворачивает&quot;</span> файлы,
            созданные утилитой <strong
             class="COMMAND">dump</strong>.</p>
          </dd>

          <dt><strong
           class="COMMAND">fdformat</strong></dt>

          <dd>
            <p>Выполняет низкоуровневое форматирование дискет.</p>
          </dd>
        </dl>
      </div>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="c9708_html_SYSRESOURCES1"></a>Команды управления системными
        ресурсами</strong></p>

        <dl>
          <dt><strong
           class="COMMAND">ulimit</strong></dt>

          <dd>
            <p>Устанавливает <span
             class="emphasis"><em
             class="EMPHASIS">верхний предел</em></span> для системных
            ресурсов. Как правило вызывается с ключом <tt
             class="OPTION">-f</tt>, что означает наложение ограничений
            на размер файлов (<strong
             class="COMMAND">ulimit -f 1000</strong> ограничит размер
            вновь создаваемых файлов одним мегабайтом). Ключ <tt
             class="OPTION">-c</tt> ограничивает размер файлов coredump
            (<strong
             class="COMMAND">ulimit -c 0</strong> запретит создание
            coredump-файлов). Обычно, все ограничения прописываются в
            файле <tt
             class="FILENAME">/etc/profile</tt> и/или <tt
             class="FILENAME">~/.bash_profile</tt> (см. <a
             href="#c12891_html">Глава 26</a>).</p>

            <div
             class="IMPORTANT">
              <table
               class="IMPORTANT"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/important.gif"
                   hspace="5"
                   alt="Important"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Грамотное использование <strong
                     class="COMMAND">ulimit</strong> поможет избежать
                    нападений, целью которых является исчерпание
                    системных ресурсов, известных под названием <span
                     class="emphasis"><em
                     class="EMPHASIS">fork bomb</em></span>.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

while 1     #  Бесконечный цикл.
do
  $0 &amp;      #  Этот сценарий вызывает сам себя . . .
            #+ порождая дочерние процессы бесконечное число раз . . .
            #+ точнее -- до тех пор, пока не иссякнут системные ресурсы.
done        #  Это печально известный сценарий <span
 class="QUOTE">&quot;sorcerer&#39;s appentice&quot;</span>.

exit 0      #  Сценарий никогда не завершит свою работу.
</pre>
                    <br>
                    <br>

                    <p>Команда <strong
                     class="COMMAND">ulimit -Hu XX</strong> (где <span
                     class="emphasis"><em
                     class="EMPHASIS">XX</em></span> -- это верхний
                    предел количества процессов, которые может
                    запустить пользователь одновременно) в <tt
                     class="FILENAME">/etc/profile</tt> вызовет
                    аварийное завершение этого сценария, когда
                    количество процессов превысит установленный
                    предел.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">umask</strong></dt>

          <dd>
            <p>Установка маски режима создания файлов. Накладывает
            ограничения на атрибуты по-умлчанию для создаваемых файлов.
            Маска представляет собой восьмеричное значение и определяет
            запрещенные атрибуты файла. Например, <strong
             class="COMMAND">umask 022</strong> удаляет права на запись
            для группы и прочих пользователей (у файлов, создававшихся
            с режимом 777, он оказывается равным 755; а режим 666
            преобразуется в 644, т.е. 777 NAND 022 = 755, 666 NAND 022
            = 644). <a
             name="AEN11247"
             href="#c9708_html_FTN_AEN11247"><span
             class="footnote">[5]</span></a> Конечно же, впоследствие,
            пользователь может откорректировать права доступа к своему
            файлу с помощью команды <a
             href="#c6407_html_CHMODREF">chmod</a>. Как правило,
            значение <strong
             class="COMMAND">umask</strong> устанавливается в файле <tt
             class="FILENAME">/etc/profile</tt> и/или <tt
             class="FILENAME">~/.bash_profile</tt> (см. <a
             href="#c12891_html">Глава 26</a>).</p>
          </dd>

          <dt><strong
           class="COMMAND">rdev</strong></dt>

          <dd>
            <p>Выводит или изменяет корневое устройство, размер
            RAM-диска или видео режим. Функциональные возможности
            утилиты <strong
             class="COMMAND">rdev</strong> вообще повторяются
            загрузчиком <strong
             class="COMMAND">lilo</strong>, но <strong
             class="COMMAND">rdev</strong> по прежнему остается
            востребованной, например, при установке электронного диска
            (RAM-диск). Это еще одна потенциально опасная, при неумелом
            использовании, утилита.</p>
          </dd>
        </dl>
      </div>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="c9708_html_MODULESSYS1"></a>Команды для работы с модулями
        ядра</strong></p>

        <dl>
          <dt><strong
           class="COMMAND">lsmod</strong></dt>

          <dd>
            <p>Выводит список загруженных модулей.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>lsmod</strong></tt>
<tt
 class="COMPUTEROUTPUT">Module                  Size  Used by
 autofs                  9456   2 (autoclean)
 opl3                   11376   0
 serial_cs               5456   0 (unused)
 sb                     34752   0
 uart401                 6384   0 [sb]
 sound                  58368   0 [opl3 sb uart401]
 soundlow                 464   0 [sound]
 soundcore               2800   6 [sb sound]
 ds                      6448   2 [serial_cs]
 i82365                 22928   2
 pcmcia_core            45984   0 [serial_cs ds i82365]</tt>
             
</pre>
            <br>
            <br>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Команда <strong
                     class="COMMAND">cat /proc/modules</strong> выведет
                    на экран эту же информацию.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">insmod</strong></dt>

          <dd>
            <p>Принудительная загрузка модуля ядра (старайтесь вместо
            <strong
             class="COMMAND">insmod</strong> использовать команду
            <strong
             class="COMMAND">modprobe</strong>). Должна вызываться с
            привилегиями пользователя root.</p>
          </dd>

          <dt><strong
           class="COMMAND">rmmod</strong></dt>

          <dd>
            <p>Выгружает модуль ядра. Должна вызываться с привилегиями
            пользователя root.</p>
          </dd>

          <dt><strong
           class="COMMAND">modprobe</strong></dt>

          <dd>
            <p>Загрузчик модулей, который обычно вызывается из
            сценариев начальной загрузки системы. Должна вызываться с
            привилегиями пользователя root.</p>
          </dd>

          <dt><strong
           class="COMMAND">depmod</strong></dt>

          <dd>
            <p>Создает файл зависимостей между модулями, обычно
            вызывается из сценариев начальной загрузки системы.</p>
          </dd>
        </dl>
      </div>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="c9708_html_MISCSYS1"></a>Прочие команды</strong></p>

        <dl>
          <dt><strong
           class="COMMAND">env</strong></dt>

          <dd>
            <p>Запускает указанную программу или сценарий с
            модифицированными <a
             href="#x1716_html_ENVREF">переменными окружения</a> (не
            изменяя среду системы в целом, изменения касаются только
            окружения запускаемой программы/сценария). Посредством <tt
             class="OPTION">[varname=xxx]</tt>, устанавливает значение
            переменной окружения <tt
             class="VARNAME">varname</tt>, которая будет доступна из
            запускаемой программы/сценария. Без параметров -- просто
            выводит список переменных окружения с их значениями.</p>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>В Bash, и других производных от Bourne shell,
                    имеется возможность установки переменных окружения
                    и запуска программы (или сценария) одной командной
                    строкой.</p>
<pre
 class="PROGRAMLISTING">
var1=value1 var2=value2 commandXXX
# $var1 и $var2 -- будут определены только в окружении для &#39;commandXXX&#39;.
</pre>
                    <br>
                    <br>
                  </td>
                </tr>
              </table>
            </div>

            <div
             class="TIP">
              <table
               class="TIP"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/tip.gif"
                   hspace="5"
                   alt="Tip"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>В первой строке сценария (<span
                     class="QUOTE">&quot;sha-bang&quot;</span>) можно
                    указать команду <strong
                     class="COMMAND">env</strong>, если путь к
                    командному интерпретатору не известен.</p>
<pre
 class="PROGRAMLISTING">
#! /usr/bin/env perl

print &quot;Этот сценарий, на языке программирования Perl, будет запущен,\n&quot;;
print &quot;даже если я не знаю где в системе находится Perl.\n&quot;;

# Прекрасно подходит для написания кросс-платформенных сценариев,
# когда Perl может находиться совсем не там, где вы ожидаете.
# Спасибо S.C.
</pre>
                    <br>
                    <br>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">ldd</strong></dt>

          <dd>
            <p>Выводит список разделяемых библиотек, необходимых для
            исполняемого файла.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ldd /bin/ls</strong></tt>
<tt
 class="COMPUTEROUTPUT">libc.so.6 =&gt; /lib/libc.so.6 (0x4000c000)
/lib/ld-linux.so.2 =&gt; /lib/ld-linux.so.2 (0x80000000)</tt>
</pre>
          </dd>

          <dt><a
           name="c9708_html_WATCHREF"></a><strong
           class="COMMAND">watch</strong></dt>

          <dd>
            <p>Периодически запускает указанную программу с заданным
            интервалом времени.</p>

            <p>По-умолчанию интервал между запусками принимается равным
            2 секундам, но может быть изменен ключом <tt
             class="OPTION">-n</tt>.</p>
<pre
 class="PROGRAMLISTING">
watch -n 5 tail /var/log/messages
# Выводит последние 10 строк из системного журнала, /var/log/messages, каждые пять секунд.
</pre>
            <br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">strip</strong></dt>

          <dd>
            <p>Удаляет отладочную информацию из исполняемого файла. Это
            значительно уменьщает размер исполняемого файла, но при
            этом делает отладку программы невозможной.</p>

            <p>Эту команду часто можно встретить в <a
             href="#x7794_html_MAKEFILEREF">Makefile</a>-ах, и редко --
            в сценариях на языке командной оболочки.</p>
          </dd>

          <dt><strong
           class="COMMAND">nm</strong></dt>

          <dd>
            <p>Выводит список символов (используемых в целях отладки),
            содержащихся в откомпилированном двоичном файле.</p>
          </dd>

          <dt><strong
           class="COMMAND">rdist</strong></dt>

          <dd>
            <p>Позволяет на заданных машинах хранить идентичные копии
            файлов. По умолчанию, rdist просматривает только те файлы,
            версия которых на удаленных машинах более старая, чем на
            локальной машине. Это делается сравнением последнего
            времени модификации и размера файла на локальной машине и
            на удаленных.</p>
          </dd>
        </dl>
      </div>

      <p>А теперь, используя полученные нами знания, попробуем
      разобраться с одним из системных сценариев. Один из самых
      коротких и простых -- это <strong
       class="COMMAND">killall</strong>, который вызывается для
      остановки процессов при перезагрузке или выключении
      компьютера.</p>

      <div
       class="EXAMPLE">
        <a
         name="c9708_html_EX55"></a>

        <p><strong>Пример 13-8. Сценарий killall, из каталога <tt
         class="FILENAME">/etc/rc.d/init.d</tt></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/sh

# --&gt; Комментарии, начинающиеся с &quot;# --&gt;&quot;, добавлены автором документа.

# --&gt; Этот сценарий является частью пакета &#39;rc&#39;-сценариев
# --&gt; Автор: Miquel van Smoorenburg, &lt;miquels@drinkel.nl.mugnet.org&gt;

# --&gt; Этот сценарий характерен для дистрибутива Red Hat
# --&gt; (в других дистрибутивах может отсутствовать).

# Остановить все ненужные сервисы которые еще работают (собственно,
# их уже не должно быть, это лишь формальная проверка, на всякий случай)

for i in /var/lock/subsys/*; do
        # --&gt; Стандартный заголовок цикла for/in, но, поскольку &quot;do&quot;
                                # --&gt; находится в той же самой строке, что и for,
        # --&gt; необходимо разделить их символом &quot;;&quot;.
        # Проверяется наличие сценария.
        [ ! -f $i ] &amp;&amp; continue
        # --&gt; Очень интересное использование &quot;И-списка&quot;, эквивалентно:
        # --&gt; if [ ! -f &quot;$i&quot; ]; then continue

        # Получить имя подсистемы.
        subsys=${i#/var/lock/subsys/}
        # --&gt; В данном случае совпадает с именем файла.
        # --&gt; Это точный эквивалент subsys=`basename $i`.

        # --&gt;  Таким образом получается имя файла блокировки (если он присутствует,
        # --&gt;+ то это означает, что процесс запущен).
        # --&gt;  См. описание команды &quot;lockfile&quot; выше.


        # Остановить службу.
        if [ -f /etc/rc.d/init.d/$subsys.init ]; then
            /etc/rc.d/init.d/$subsys.init stop
        else
            /etc/rc.d/init.d/$subsys stop
        # --&gt; Останавливает задачу или демона
        # --&gt; посредством встроенной команды &#39;stop&#39;.
        fi
done
</pre>
      </div>

      <p>Вобщем все довольно понятно. Кроме хитрого манипулирования с
      переменными, при определении имени подсистемы (службы), здесь нет
      ничего нового.</p>

      <div
       class="FORMALPARA">
        <p><strong>Упражнение 1.</strong> Просмотрите сценарий <strong
         class="COMMAND">halt</strong> в каталоге <tt
         class="FILENAME">/etc/rc.d/init.d</tt>. Он по размеру немного
        больше, чем <strong
         class="COMMAND">killall</strong>, но придерживается той же
        концепции. Создайте копию этого сценария в своем домашнем
        каталоге и поэкспериментируйте с ним (<span
         class="emphasis"><em
         class="EMPHASIS">НЕ</em></span> запускайте его с привилегиями
        суперпользователя). Попробуйте запустить его с ключами <tt
         class="OPTION">-vn</tt> (<tt
         class="USERINPUT"><strong>sh -vn scriptname</strong></tt>).
        Добавьте свои комментарии. Замените действующие команды на
        <span
         class="QUOTE">&quot;echo&quot;</span>.</p>
      </div>

      <div
       class="FORMALPARA">
        <p><strong>Упражнение 2.</strong> Просмотрите другие, более
        сложные сценарии из <tt
         class="FILENAME">/etc/rc.d/init.d</tt>. Попробуйте разобраться
        в их работе. Проверьте их работу, следуя рекомендациям,
        приведенным выше. За дополнительной информацией вы можете
        обратиться к документу <tt
         class="FILENAME">sysvinitfiles</tt> в каталоге <tt
         class="FILENAME">/usr/share/doc/initscripts-?.??</tt>, который
        входит в пакет документации к <span
         class="QUOTE">&quot;initscripts&quot;</span>.</p>
      </div>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN9791"
         href="#c9708_html_AEN9791"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Команда <strong
           class="COMMAND">userdel</strong> завершится неудачей, если
          удаляемый пользователь в этот момент работает с системой</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN10873"
         href="#c9708_html_AEN10873"><span
         class="footnote">[2]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Дополнительную информацию по записи компакт-дисков, вы
          найдете в статье Алекса Уизера (Alex Wither): <a
           href=
          "http://www2.linuxjournal.com/lj-issues/issue66/3335.html"
           target="_top">Creating CDs</a>, в октябрьском выпуске
          журнала <a
           href="http://www.linuxjournal.com"
           target="_top">Linux Journal</a> за 1999 год.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN11062"
         href="#c9708_html_AEN11062"><span
         class="footnote">[3]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Утилита <a
           href="#c9708_html_MKE2FSREF">mke2fs</a>, с ключом <tt
           class="OPTION">-c</tt>, так же производит поиск поврежденных
          блоков.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN11188"
         href="#c9708_html_AEN11188"><span
         class="footnote">[4]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Пользователи небольших, десктопных Linux-систем
          предпочитают утилиты попроще, например <strong
           class="COMMAND">tar</strong>.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN11247"
         href="#c9708_html_AEN11247"><span
         class="footnote">[5]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>NAND -- логическая операция <span
           class="QUOTE">&quot;И-НЕ&quot;</span>. В общих чертах она
          напоминает вычитание.</p>
        </td>
      </tr>
    </table>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x9307_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#c11441_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Прочие команды</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#p3268_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Подстановка команд</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="p112_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#index_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#c118_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="PART">
      <a
       name="p112_html_PART1"></a>

      <div
       class="TITLEPAGE">
        <h1
         class="TITLE">Часть 1. Введение</h1>

        <div
         class="PARTINTRO">
          <a
           name="p112_html_AEN114"></a>

          <p>Shell -- это командная оболочка. Но это не просто
          промежуточное звено между пользователем и операционой
          системой, это еще и мощный язык программирования. Программы
          на языке shell называют <span
           class="emphasis"><em
           class="EMPHASIS">сценариями</em></span>, или <span
           class="emphasis"><em
           class="EMPHASIS">скриптами</em></span>. Фактически, из
          скриптов доступен полный набор команд, утилит и программ
          UNIX. Если этого недостаточно, то к вашим услугам внутренние
          команды shell -- условные операторы, операторы циклов и пр.,
          которые увеличивают мощь и гибкость сценариев. Shell-скрипты
          исключительно хороши при программировании задач
          администрирования системы и др., которые не требуют для
          своего создания полновесных языков программирования.</p>
        </div>

        <div
         class="TOC">
          <dl>
            <dt><strong>Содержание</strong></dt>

            <dt>1. <a
             href="#c118_html">Зачем необходимо знание языка
            Shell?</a></dt>

            <dt>2. <a
             href="#c178_html">Для начала о Sha-Bang</a></dt>

            <dd>
              <dl>
                <dt>2.1. <a
                 href="#c178_html_INVOKING">Запуск сценария</a></dt>

                <dt>2.2. <a
                 href="#x288_html">Упражнения</a></dt>
              </dl>
            </dd>
          </dl>
        </div>
      </div>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#index_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#c118_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Advanced Bash-Scripting Guide</td>

          <td
           width="34%"
           align="center"
           valign="top"> </td>

          <td
           width="33%"
           align="right"
           valign="top">Зачем необходимо знание языка Shell?</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="p11889_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#c11785_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#c11895_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="PART">
      <a
       name="p11889_html_PART4"></a>

      <div
       class="TITLEPAGE">
        <h1
         class="TITLE">Часть 4. Материал повышенной сложности</h1>

        <div
         class="PARTINTRO">
          <a
           name="p11889_html_AEN11891"></a>

          <p>Итак, мы вплотную подошли к изучению очень сложных и
          необычных аспектов написания сценариев. В этой части мы
          попытаемся <span
           class="QUOTE">&quot;сбросить покров тайны&quot;</span> и
          <span
           class="emphasis"><em
           class="EMPHASIS">заглянуть за пределы известного нам
          мира</em></span> (представьте себе путешествие по территории,
          не отмеченной на карте).</p>
        </div>

        <div
         class="TOC">
          <dl>
            <dt><strong>Содержание</strong></dt>

            <dt>18. <a
             href="#c11895_html">Регулярные выражения</a></dt>

            <dd>
              <dl>
                <dt>18.1. <a
                 href="#c11895_html_AEN11904">Краткое введение в
                регулярные выражения</a></dt>

                <dt>18.2. <a
                 href="#x12282_html">Globbing -- Подстановка имен
                файлов</a></dt>
              </dl>
            </dd>

            <dt>19. <a
             href="#c12330_html">Подоболочки, или Subshells</a></dt>

            <dt>20. <a
             href="#c12376_html">Ограниченный режим командной
            оболочки</a></dt>

            <dt>21. <a
             href="#c12434_html">Подстановка процессов</a></dt>

            <dt>22. <a
             href="#c12483_html">Функции</a></dt>

            <dd>
              <dl>
                <dt>22.1. <a
                 href="#c12483_html_COMPLEXFUNCT">Сложные функции и
                сложности с функциями</a></dt>

                <dt>22.2. <a
                 href="#x12644_html">Локальные переменные</a></dt>

                <dd>
                  <dl>
                    <dt>22.2.1. <a
                     href="#x12644_html_LOCVARRECUR">Локальные
                    переменные делают возможной рекурсию.</a></dt>
                  </dl>
                </dd>
              </dl>
            </dd>

            <dt>23. <a
             href="#c12683_html">Псевдонимы</a></dt>

            <dt>24. <a
             href="#c12716_html">Списки команд</a></dt>

            <dt>25. <a
             href="#c12790_html">Массивы</a></dt>

            <dt>26. <a
             href="#c12891_html">Файлы</a></dt>

            <dt>27. <a
             href="#c12942_html">/dev и /proc</a></dt>

            <dd>
              <dl>
                <dt>27.1. <a
                 href="#c12942_html_DEVREF1"><tt
                 class="FILENAME">/dev</tt></a></dt>

                <dt>27.2. <a
                 href="#x12987_html"><tt
                 class="FILENAME">/proc</tt></a></dt>
              </dl>
            </dd>

            <dt>28. <a
             href="#c13041_html">/dev/zero и /dev/null</a></dt>

            <dt>29. <a
             href="#c13099_html">Отладка сценариев</a></dt>

            <dt>30. <a
             href="#c13228_html">Необязательные параметры
            (ключи)</a></dt>

            <dt>31. <a
             href="#c13371_html">Широко распространенные ошибки</a></dt>

            <dt>32. <a
             href="#c13468_html">Стиль программирования</a></dt>

            <dd>
              <dl>
                <dt>32.1. <a
                 href="#c13468_html_UNOFFICIALST">Неофициальные
                рекомендации по оформлению сценариев</a></dt>
              </dl>
            </dd>

            <dt>33. <a
             href="#c13505_html">Разное</a></dt>

            <dd>
              <dl>
                <dt>33.1. <a
                 href="#c13505_html_INTANDNONINT">Интерактивный и
                неинтерактивный режим работы</a></dt>

                <dt>33.2. <a
                 href="#x13541_html">Сценарии-обертки</a></dt>

                <dt>33.3. <a
                 href="#x13602_html">Операции сравнения: Альтернативные
                решения</a></dt>

                <dt>33.4. <a
                 href="#x13609_html">Рекурсия</a></dt>

                <dt>33.5. <a
                 href="#x13621_html"><span
                 class="QUOTE">&quot;Цветные&quot;</span>
                сценарии</a></dt>

                <dt>33.6. <a
                 href="#x13734_html">Оптимизация</a></dt>

                <dt>33.7. <a
                 href="#x13753_html">Разные советы</a></dt>

                <dt>33.8. <a
                 href="#x13884_html">Проблемы безопасности</a></dt>

                <dt>33.9. <a
                 href="#x13898_html">Проблемы переносимости</a></dt>

                <dt>33.10. <a
                 href="#x13930_html">Сценарии командной оболочки под
                Windows</a></dt>
              </dl>
            </dd>

            <dt>34. <a
             href="#c13936_html">Bash, версия 2</a></dt>
          </dl>
        </div>
      </div>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#c11785_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#c11895_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Встроенные документы</td>

          <td
           width="34%"
           align="center"
           valign="top"> </td>

          <td
           width="33%"
           align="right"
           valign="top">Регулярные выражения</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="p299_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x288_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#c301_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="PART">
      <a
       name="p299_html_PART2"></a>

      <div
       class="TITLEPAGE">
        <h1
         class="TITLE">Часть 2. Основы</h1>

        <div
         class="TOC">
          <dl>
            <dt><strong>Содержание</strong></dt>

            <dt>3. <a
             href="#c301_html">Служебные символы</a></dt>

            <dt>4. <a
             href="#c1613_html">Переменные и параметры.
            Введение.</a></dt>

            <dd>
              <dl>
                <dt>4.1. <a
                 href="#c1613_html_VARSUBN">Подстановка
                переменных</a></dt>

                <dt>4.2. <a
                 href="#x1673_html">Присваивание значений
                переменным</a></dt>

                <dt>4.3. <a
                 href="#x1705_html">Переменные Bash не имеют
                типа</a></dt>

                <dt>4.4. <a
                 href="#x1716_html">Специальные типы переменных</a></dt>
              </dl>
            </dd>

            <dt>5. <a
             href="#c1833_html">Кавычки</a></dt>

            <dt>6. <a
             href="#c2105_html">Завершение и код завершения</a></dt>

            <dt>7. <a
             href="#c2171_html">Проверка условий</a></dt>

            <dd>
              <dl>
                <dt>7.1. <a
                 href="#c2171_html_TESTCONSTRUCTS">Конструкции проверки
                условий</a></dt>

                <dt>7.2. <a
                 href="#x2389_html">Операции проверки файлов</a></dt>

                <dt>7.3. <a
                 href="#x2565_html">Операции сравнения</a></dt>

                <dt>7.4. <a
                 href="#x2770_html">Вложенные условные операторы
                if/then</a></dt>

                <dt>7.5. <a
                 href="#x2780_html">Проверка степени усвоения
                материала</a></dt>
              </dl>
            </dd>

            <dt>8. <a
             href="#c2792_html">Операции и смежные темы</a></dt>

            <dd>
              <dl>
                <dt>8.1. <a
                 href="#c2792_html_OPS">Операторы</a></dt>

                <dt>8.2. <a
                 href="#x3255_html">Числовые константы</a></dt>
              </dl>
            </dd>
          </dl>
        </div>
      </div>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x288_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#c301_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Упражнения</td>

          <td
           width="34%"
           align="center"
           valign="top"> </td>

          <td
           width="33%"
           align="right"
           valign="top">Служебные символы</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="p3268_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x3255_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">
          </td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#c3270_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="PART">
      <a
       name="p3268_html_PART3"></a>

      <div
       class="TITLEPAGE">
        <h1
         class="TITLE">Часть 3. Углубленный материал</h1>

        <div
         class="TOC">
          <dl>
            <dt><strong>Содержание</strong></dt>

            <dt>9. <a
             href="#c3270_html">К вопросу о переменных</a></dt>

            <dd>
              <dl>
                <dt>9.1. <a
                 href="#c3270_html_INTERNALVARIABLES">Внутренние
                переменные</a></dt>

                <dt>9.2. <a
                 href="#x4171_html">Работа со строками</a></dt>

                <dd>
                  <dl>
                    <dt>9.2.1. <a
                     href="#x4171_html_AWKSTRINGMANIP">Использование awk
                    при работе со строками</a></dt>

                    <dt>9.2.2. <a
                     href="#x4171_html_STRFDISC">Дальнейшее
                    обсуждение</a></dt>
                  </dl>
                </dd>

                <dt>9.3. <a
                 href="#x4462_html">Подстановка параметров</a></dt>

                <dt>9.4. <a
                 href="#x4704_html">Объявление переменных: <strong
                 class="COMMAND">declare</strong> и <strong
                 class="COMMAND">typeset</strong></a></dt>

                <dt>9.5. <a
                 href="#x4788_html">Косвенные ссылки на
                переменные</a></dt>

                <dt>9.6. <a
                 href="#x4812_html">$RANDOM: генерация псевдослучайных
                целых чисел</a></dt>

                <dt>9.7. <a
                 href="#x4862_html">Двойные круглые скобки</a></dt>
              </dl>
            </dd>

            <dt>10. <a
             href="#c4875_html">Циклы и ветвления</a></dt>

            <dd>
              <dl>
                <dt>10.1. <a
                 href="#c4875_html_LOOPS1">Циклы</a></dt>

                <dt>10.2. <a
                 href="#x5140_html">Вложенные циклы</a></dt>

                <dt>10.3. <a
                 href="#x5153_html">Управление ходом выполнения
                цикла</a></dt>

                <dt>10.4. <a
                 href="#x5210_html">Операторы выбора</a></dt>
              </dl>
            </dd>

            <dt>11. <a
             href="#c5358_html">Внутренние команды</a></dt>

            <dd>
              <dl>
                <dt>11.1. <a
                 href="#c5358_html_AEN6110">Команды управления
                заданиями</a></dt>
              </dl>
            </dd>

            <dt>12. <a
             href="#c6407_html">Внешние команды, программы и
            утилиты</a></dt>

            <dd>
              <dl>
                <dt>12.1. <a
                 href="#c6407_html_BASIC">Базовые команды</a></dt>

                <dt>12.2. <a
                 href="#x6646_html">Более сложные команды</a></dt>

                <dt>12.3. <a
                 href="#x6837_html">Команды для работы с датой и
                временем</a></dt>

                <dt>12.4. <a
                 href="#x7050_html">Команды обработки текста</a></dt>

                <dt>12.5. <a
                 href="#x7794_html">Команды для работы с файлами и
                архивами</a></dt>

                <dt>12.6. <a
                 href="#x8707_html">Команды для работы с сетью</a></dt>

                <dt>12.7. <a
                 href="#x9117_html">Команды управления
                терминалом</a></dt>

                <dt>12.8. <a
                 href="#x9199_html">Команды выполнения математических
                операций</a></dt>

                <dt>12.9. <a
                 href="#x9307_html">Прочие команды</a></dt>
              </dl>
            </dd>

            <dt>13. <a
             href="#c9708_html">Команды системного
            администрирования</a></dt>

            <dt>14. <a
             href="#c11441_html">Подстановка команд</a></dt>

            <dt>15. <a
             href="#c11565_html">Арифметические подстановки</a></dt>

            <dt>16. <a
             href="#c11620_html">Перенаправление ввода/вывода</a></dt>

            <dd>
              <dl>
                <dt>16.1. <a
                 href="#c11620_html_AEN11702">С помощью команды <strong
                 class="COMMAND">exec</strong></a></dt>

                <dt>16.2. <a
                 href="#x11731_html">Перенаправление для блоков
                кода</a></dt>

                <dt>16.3. <a
                 href="#x11778_html">Область применения</a></dt>
              </dl>
            </dd>

            <dt>17. <a
             href="#c11785_html">Встроенные документы</a></dt>
          </dl>
        </div>
      </div>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x3255_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#c3270_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Числовые константы</td>

          <td
           width="34%"
           align="center"
           valign="top"> </td>

          <td
           width="33%"
           align="right"
           valign="top">К вопросу о переменных</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x11731_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#c11620_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 16. Перенаправление ввода/вывода</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x11778_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x11731_html_REDIRCB"></a>16.2. Перенаправление для блоков кода</h1>

      <p><a
       name="x11731_html_REDIRREF"></a>Блоки кода, такие как циклы <a
       href="#c4875_html_WHILELOOPREF">while</a>, <a
       href="#c4875_html_UNTILLOOPREF">until</a> и <a
       href="#c4875_html_FORLOOPREF1">for</a>, условный оператор <a
       href="#c2171_html_IFTHEN">if/then</a>, так же могут смешиваться с
      перенаправлением <tt
       class="FILENAME">stdin</tt>. Даже функции могут использовать эту
      форму перенаправления (см. <a
       href="#c12483_html_REALNAME">Пример 22-7</a>). Оператор
      перенаправления <span
       class="TOKEN">&lt;</span>, в таких случаях, ставится в конце
      блока.</p>

      <div
       class="EXAMPLE">
        <a
         name="x11731_html_REDIR2"></a>

        <p><strong>Пример 16-4. Перенаправление в цикл <span
         class="emphasis"><em
         class="EMPHASIS">while</em></span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

if [ -z &quot;$1&quot; ]
then
  Filename=names.data       # По-умолчанию, если имя файла не задано.
else
  Filename=$1
fi
#  Конструкцию проверки выше, можно заменить следующей строкой (подстановка параметров):
#+ Filename=${1:-names.data}

count=0

echo

while [ &quot;$name&quot; != Smith ]  # Почему переменная $name взята в кавычки?
do
  read name                 # Чтение из $Filename, не со stdin.
  echo $name
  let &quot;count += 1&quot;
done &lt;&quot;$Filename&quot;           # Перенаправление на ввод из файла $Filename.
#    ^^^^^^^^^^^^

echo; echo &quot;Имен прочитано: $count&quot;; echo

#  Обратите внимание: в некоторых старых командных интерпретаторах,
#+ перенаправление в циклы приводит к запуску цикла в субоболочке (subshell).
#  Таким образом, переменная $count, по окончании цикла, будет содержать 0,
#  значение, записанное в нее до входа в цикл.
#  Bash и ksh стремятся избежать запуска субоболочки (subshell), если это возможно,
#+ так что этот сценарий, в этих оболочках, работает корректно.
#
# Спасибо Heiner Steven за это примечание.

exit 0
</pre>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="x11731_html_REDIR2A"></a>

        <p><strong>Пример 16-5. Альтернативная форма перенаправления в
        цикле <span
         class="emphasis"><em
         class="EMPHASIS">while</em></span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Это альтернативный вариант предыдущего сценария.

#  Предложил: by Heiner Steven
#+ для случаев, когда циклы с перенаправлением
#+ запускаются в субоболочке, из-за чего переменные, устанавливаемые в цикле,
#+ не сохраняют свои значения по завершении цикла.


if [ -z &quot;$1&quot; ]
then
  Filename=names.data     # По-умолчанию, если имя файла не задано.
else
  Filename=$1
fi


exec 3&lt;&amp;0                 # Сохранить stdin в дескр. 3.
exec 0&lt;&quot;$Filename&quot;        # Перенаправить stdin.

count=0
echo


while [ &quot;$name&quot; != Smith ]
do
  read name               # Прочитать с перенаправленного stdin ($Filename).
  echo $name
  let &quot;count += 1&quot;
done &lt;&quot;$Filename&quot;         # Цикл читает из файла $Filename.
#    ^^^^^^^^^^^^


exec 0&lt;&amp;3                 # Восстановить stdin.
exec 3&lt;&amp;-                 # Закрыть временный дескриптор 3.

echo; echo &quot;Имен прочитано: $count&quot;; echo

exit 0
</pre>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="x11731_html_REDIR3"></a>

        <p><strong>Пример 16-6. Перенаправление в цикл <span
         class="emphasis"><em
         class="EMPHASIS">until</em></span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# То же самое, что и в предыдущем примере, только для цикла &quot;until&quot;.

if [ -z &quot;$1&quot; ]
then
  Filename=names.data         # По-умолчанию, если файл не задан.
else
  Filename=$1
fi

# while [ &quot;$name&quot; != Smith ]
until [ &quot;$name&quot; = Smith ]     # Проверка != изменена на =.
do
  read name                   # Чтение из $Filename, не со stdin.
  echo $name
done &lt;&quot;$Filename&quot;             # Перенаправление на ввод из файла $Filename.
#    ^^^^^^^^^^^^

# Результаты получаются теми же, что и в случае с циклом &quot;while&quot;, в предыдущем примере.

exit 0
</pre>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="x11731_html_REDIR4"></a>

        <p><strong>Пример 16-7. Перенаправление в цикл <span
         class="emphasis"><em
         class="EMPHASIS">for</em></span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

if [ -z &quot;$1&quot; ]
then
  Filename=names.data          # По-умолчанию, если файл не задан.
else
  Filename=$1
fi

line_count=`wc $Filename | awk &#39;{ print $1 }&#39;`
#           Число строк в файле.
#
#  Слишком запутано, тем не менее показывает
#+ возможность перенаправления stdin внутри цикла &quot;for&quot;...
#+ если вы достаточно умны.
#
# Более короткий вариант    line_count=$(wc &lt; &quot;$Filename&quot;)


for name in `seq $line_count`  # &quot;seq&quot; выводит последовательность чисел.
# while [ &quot;$name&quot; != Smith ]   --   более запутанно, чем в случае с циклом &quot;while&quot;   --
do
  read name                    # Чтение из файла $Filename, не со stdin.
  echo $name
  if [ &quot;$name&quot; = Smith ]
  then
    break
  fi
done &lt;&quot;$Filename&quot;              # Перенаправление на ввод из файла $Filename.
#    ^^^^^^^^^^^^

exit 0
</pre>
      </div>

      <p>Предыдущий пример можно модифицировать так, чтобы
      перенаправить вывод из цикла.</p>

      <div
       class="EXAMPLE">
        <a
         name="x11731_html_REDIR4A"></a>

        <p><strong>Пример 16-8. Перенаправление устройств (<tt
         class="FILENAME">stdin</tt> и <tt
         class="FILENAME">stdout</tt>) в цикле <span
         class="emphasis"><em
         class="EMPHASIS">for</em></span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

if [ -z &quot;$1&quot; ]
then
  Filename=names.data          # По-умолчанию, если файл не задан.
else
  Filename=$1
fi

Savefile=$Filename.new         # Имя файла, в котором сохраняются результаты.
FinalName=Jonah                # Имя, на котором завершается чтение.

line_count=`wc $Filename | awk &#39;{ print $1 }&#39;`  # Число строк в заданном файле.


for name in `seq $line_count`
do
  read name
  echo &quot;$name&quot;
  if [ &quot;$name&quot; = &quot;$FinalName&quot; ]
  then
    break
  fi
done &lt; &quot;$Filename&quot; &gt; &quot;$Savefile&quot;     # Перенаправление на ввод из файла $Filename,
#    ^^^^^^^^^^^^^^^^^^^^^^^^^^^       и сохранение результатов в файле.

exit 0
</pre>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="x11731_html_REDIR5"></a>

        <p><strong>Пример 16-9. Перенаправление в конструкции <span
         class="emphasis"><em
         class="EMPHASIS">if/then</em></span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

if [ -z &quot;$1&quot; ]
then
  Filename=names.data   # По-умолчанию, если файл не задан.
else
  Filename=$1
fi

TRUE=1

if [ &quot;$TRUE&quot; ]          # конструкции &quot;if true&quot; и &quot;if :&quot; тоже вполне допустимы.
then
 read name
 echo $name
fi &lt;&quot;$Filename&quot;
#  ^^^^^^^^^^^^

# Читает только первую строку из файла.

exit 0
</pre>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="x11731_html_NAMESDATA"></a>

        <p><strong>Пример 16-10. Файл с именами <span
         class="QUOTE">&quot;names.data&quot;</span>, для примеров
        выше</strong></p>
<pre
 class="PROGRAMLISTING">
Aristotle
Belisarius
Capablanca
Euler
Goethe
Hamurabi
Jonah
Laplace
Maroczy
Purcell
Schmidt
Semmelweiss
Smith
Turing
Venn
Wilson
Znosko-Borowski

#  Это файл с именами для примеров
#+ &quot;redir2.sh&quot;, &quot;redir3.sh&quot;, &quot;redir4.sh&quot;, &quot;redir4a.sh&quot;, &quot;redir5.sh&quot;.
</pre>
      </div>

      <p>Перенаправление <tt
       class="FILENAME">stdout</tt> для блока кода, может
      использоваться для сохранения результатов работы этого блока в
      файл. См. <a
       href="#c301_html_RPMCHECK">Пример 3-2</a>.</p>

      <p><a
       href="#c11785_html_HEREDOCREF">Встроенный документ</a> -- это
      особая форма перенаправления для блоков кода.</p>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#c11620_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x11778_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Перенаправление ввода/вывода</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c11620_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Область применения</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x11778_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x11731_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 16. Перенаправление ввода/вывода</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#c11785_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x11778_html_REDIRAPPS"></a>16.3. Область применения</h1>

      <p>Как один из вариантов грамотного применения перенаправления
      ввода/вывода, можно назвать разбор и &quot;сшивание&quot; вывода
      от команд (см. <a
       href="#c5358_html_READREDIR">Пример 11-6</a>). Это позволяет
      создавать файлы отчетов и журналов регистрации событий.</p>

      <div
       class="EXAMPLE">
        <a
         name="x11778_html_LOGEVENTS"></a>

        <p><strong>Пример 16-11. Регистрация событий</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# logevents.sh, автор: Stephane Chazelas.

# Регистрация событий в файле.
# Сценарий должен запускаться с привилегиями root (что бы иметь право на запись в /var/log).

ROOT_UID=0     # Привилегии root имеет только пользователь с $UID = 0.
E_NOTROOT=67   # Код завершения, если не root.


if [ &quot;$UID&quot; -ne &quot;$ROOT_UID&quot; ]
then
  echo &quot;Сценарий должен запускаться с привилегиями root.&quot;
  exit $E_NOTROOT
fi


FD_DEBUG1=3
FD_DEBUG2=4
FD_DEBUG3=5

# Раскомментарьте одну из двух строк, ниже, для активизации сценария.
# LOG_EVENTS=1
# LOG_VARS=1


log()  # Запись даты и времени в файл.
{
echo &quot;$(date)  $*&quot; &gt;&amp;7     # Добавляет в конец файла.
                              # См. ниже.
}



case $LOG_LEVEL in
 1) exec 3&gt;&amp;2         4&gt; /dev/null 5&gt; /dev/null;;
 2) exec 3&gt;&amp;2         4&gt;&amp;2         5&gt; /dev/null;;
 3) exec 3&gt;&amp;2         4&gt;&amp;2         5&gt;&amp;2;;
 *) exec 3&gt; /dev/null 4&gt; /dev/null 5&gt; /dev/null;;
esac

FD_LOGVARS=6
if [[ $LOG_VARS ]]
then exec 6&gt;&gt; /var/log/vars.log
else exec 6&gt; /dev/null               # Подавить вывод.
fi

FD_LOGEVENTS=7
if [[ $LOG_EVENTS ]]
then
  # then exec 7 &gt;(exec gawk &#39;{print strftime(), $0}&#39; &gt;&gt; /var/log/event.log)
  # Строка, выше, не работает в Bash, версии 2.04.
  exec 7&gt;&gt; /var/log/event.log        # Добавление в конец &quot;event.log&quot;.
  log                                      # Записать дату и время.
else exec 7&gt; /dev/null                  # Подавить вывод.
fi

echo &quot;DEBUG3: beginning&quot; &gt;&amp;${FD_DEBUG3}

ls -l &gt;&amp;5 2&gt;&amp;4                       # command1 &gt;&amp;5 2&gt;&amp;4

echo &quot;Done&quot;                                # command2

echo &quot;sending mail&quot; &gt;&amp;${FD_LOGEVENTS}   # Написать &quot;sending mail&quot; в дескр. #7.


exit 0
</pre>
      </div>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x11731_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#c11785_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Перенаправление для блоков кода</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c11620_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Встроенные документы</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x12282_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#c11895_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 18. Регулярные выражения</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#c12330_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x12282_html_GLOBBINGREF"></a>18.2. Globbing -- Подстановка имен
      файлов</h1>

      <p>Bash, сам по себе, не распознает регулярные выражения. Но в
      сценариях можно использовать команды и утилиты, такие как <a
       href="#a14586_html_SEDREF">sed</a> и <a
       href="#x14802_html_AWKREF">awk</a>, которые прекрасно справляются
      с обработкой регулярных выражений.</p>

      <p>Фактически, Bash может выполнять подстановку имен файлов, этот
      процесс называется <span
       class="QUOTE">&quot;globbing&quot;</span>, но при этом <span
       class="emphasis"><em
       class="EMPHASIS">не</em></span> используется стандартный набор
      регулярных выражений. Вместо этого, при выполнении подстановки
      имен файлов, производится распознавание и интерпретация шаблонных
      символов. В число интерпретируемых шаблонов входят символы <span
       class="TOKEN">*</span> и <span
       class="TOKEN">?</span>, списки символов в квадратных скобках и
      некоторые специальные символы (например <span
       class="TOKEN">^</span>, используемый для выполнения операции
      отрицания). Применение шаблонных символов имеет ряд важных
      ограничений. Например, если имена файлов начинаются с точки
      (например так: <tt
       class="FILENAME">.bashrc</tt>), то они не будут соответствовать
      шаблону, содержащему символ <tt
       class="REPLACEABLE"><em>*</em></tt>. <a
       name="AEN12295"
       href="#x12282_html_FTN_AEN12295"><span
       class="footnote">[1]</span></a> Аналогично, символ <tt
       class="REPLACEABLE"><em>?</em></tt> в операции подстановки имен
      файлов имеет иной смысл, нежели в регулярных выражениях.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ls -l</strong></tt>
<tt
 class="COMPUTEROUTPUT">total 2
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 a.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 b.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 c.1
 -rw-rw-r--    1 bozo  bozo       466 Aug  6 17:48 t2.sh
 -rw-rw-r--    1 bozo  bozo       758 Jul 30 09:02 test1.txt</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ls -l t?.sh</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">-rw-rw-r--    1 bozo  bozo       466 Aug  6 17:48 t2.sh</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ls -l [ab]*</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">-rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 a.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 b.1</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ls -l [a-c]*</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">-rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 a.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 b.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 c.1</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ls -l [^ab]*</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">-rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 c.1
 -rw-rw-r--    1 bozo  bozo       466 Aug  6 17:48 t2.sh
 -rw-rw-r--    1 bozo  bozo       758 Jul 30 09:02 test1.txt</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ls -l {b*,c*,*est*}</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">-rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 b.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 c.1
 -rw-rw-r--    1 bozo  bozo       758 Jul 30 09:02 test1.txt</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo *</strong></tt>
<tt
 class="COMPUTEROUTPUT">a.1 b.1 c.1 t2.sh test1.txt</tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>echo t*</strong></tt>
<tt
 class="COMPUTEROUTPUT">t2.sh test1.txt</tt>
             
</pre>
      <br>
      <br>

      <p>Даже команда <a
       href="#c5358_html_ECHOREF">echo</a> может интерпретировать
      шаблонные символы в именах файлов.</p>

      <p>См. также <a
       href="#c4875_html_LISTGLOB">Пример 10-4</a>.</p>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN12295"
         href="#x12282_html_AEN12295"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Подстановка таких имен файлов <span
           class="emphasis"><em
           class="EMPHASIS">возможна</em></span>, но только при
          условии, что символ точки будет явно присутствовать в
          шаблоне.</p>
<pre
 class="PROGRAMLISTING">
~/[.]bashrc    # Не будет соответствовать имени ~/.bashrc
~/?bashrc      # То же самое.
               # Метасимволы не могут соответствовать символу точки при подстановке имен файлов.

~/.[b]ashrc    # Имя ~./bashrc будет соответствовать данному шаблону
~/.ba?hrc      # Аналогично.
~/.bashr*      # Аналогично.

# Установка ключа &quot;dotglob&quot; отключает такое поведение интерпретатора.
# Спасибо S.C.
</pre>
          <br>
          <br>
        </td>
      </tr>
    </table>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#c11895_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#c12330_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Регулярные выражения</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c11895_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Подоболочки, или Subshells</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x12644_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#c12483_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 22. Функции</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#c12683_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x12644_html_LOCALVAR"></a>22.2. Локальные переменные</h1>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="x12644_html_LOCALSREF1"></a>Что такое <span
         class="QUOTE">&quot;локальная&quot;</span>
        переменная?</strong></p>

        <dl>
          <dt>локальные переменные</dt>

          <dd>
            <p>Переменные, объявленные как <em
             class="FIRSTTERM">локальные</em>, имеют ограниченную
            область видимости, и доступны только в пределах <a
             href="#c301_html_CODEBLOCKREF">блока</a>, в котором они
            были объявлены. Для функций это означает, что локальная
            переменная &quot;видна&quot; только в теле самой
            функции.</p>

            <div
             class="EXAMPLE">
              <a
               name="x12644_html_EX62"></a>

              <p><strong>Пример 22-8. Область видимости локальных
              переменных</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

func ()
{
  local loc_var=23       # Объявление локальной переменной.
  echo
  echo &quot;\&quot;loc_var\&quot; в функции = $loc_var&quot;
  global_var=999         # Эта переменная не была объявлена локальной.
  echo &quot;\&quot;global_var\&quot; в функции = $global_var&quot;
}

func

# Проверим, &quot;видна&quot; ли локальная переменная за пределами функции.

echo
echo &quot;\&quot;loc_var\&quot; за пределами функции = $loc_var&quot;
                                      # &quot;loc_var&quot; за пределами функции =
                                      # Итак, $loc_var не видна в глобальном контексте.
echo &quot;\&quot;global_var\&quot; за пределами функции = $global_var&quot;
                                      # &quot;global_var&quot; за пределами функции = 999
                                      # $global_var имеет глобальную область видимости.
echo                                  

exit 0
</pre>
            </div>

            <div
             class="CAUTION">
              <table
               class="CAUTION"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/caution.gif"
                   hspace="5"
                   alt="Caution"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Переменные, объявляемые в теле функции,
                    считаются необъявленными до тех пор, пока функция
                    не будет вызвана. Это касается <span
                     class="emphasis"><em
                     class="EMPHASIS">всех</em></span> переменных.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

func ()
{
global_var=37    #  Эта переменная будет считаться необъявленной
                 #+ до тех пор, пока функция не будет вызвана.
}                # КОНЕЦ ФУНКЦИИ

echo &quot;global_var = $global_var&quot;  # global_var =
                                 #  Функция &quot;func&quot; еще не была вызвана,
                                 #+ поэтому $global_var пока еще не &quot;видна&quot; здесь.

func
echo &quot;global_var = $global_var&quot;  # global_var = 37
                                 # Переменная была инициализирована в функции.
</pre>
                    <br>
                    <br>
                  </td>
                </tr>
              </table>
            </div>
          </dd>
        </dl>
      </div>

      <div
       class="SECT2">
        <h2
         class="SECT2"><a
         name="x12644_html_LOCVARRECUR"></a>22.2.1. Локальные переменные делают
        возможной рекурсию.</h2>

        <p>Хотя локальные переменные и допускают рекурсию, <a
         name="AEN12669"
         href="#x12644_html_FTN_AEN12669"><span
         class="footnote">[1]</span></a> но она сопряжена с большими
        накладными расходами и не рекомендуется для использования в
        сценариях. <a
         name="AEN12675"
         href="#x12644_html_FTN_AEN12675"><span
         class="footnote">[2]</span></a></p>

        <div
         class="EXAMPLE">
          <a
           name="x12644_html_EX63"></a>

          <p><strong>Пример 22-9. Использование локальных переменных
          при рекурсии</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

#               факториал
#               ---------


# Действительно ли bash допускает рекурсию?
# Да! Но...
# Нужно быть действительно дубинноголовым, чтобы использовать ее в сценариях
# на языке командной оболочки.


MAX_ARG=5
E_WRONG_ARGS=65
E_RANGE_ERR=66


if [ -z &quot;$1&quot; ]
then
  echo &quot;Порядок использования: `basename $0` число&quot;
  exit $E_WRONG_ARGS
fi

if [ &quot;$1&quot; -gt $MAX_ARG ]
then
  echo &quot;Выход за верхний предел (максимально возможное число -- 5).&quot;
  # Вернитесь к реальности.
  # Если вам захочется поднять верхнюю границу,
  # то перепишите эту программу на настоящем языке программирования.
  exit $E_RANGE_ERR
fi

fact ()
{
  local number=$1
  # Переменная &quot;number&quot; должна быть объявлена как локальная,
  # иначе результат будет неверный.
  if [ &quot;$number&quot; -eq 0 ]
  then
    factorial=1    # Факториал числа 0 = 1.
  else
    let &quot;decrnum = number - 1&quot;
    fact $decrnum  # Рекурсивный вызов функции.
    let &quot;factorial = $number * $?&quot;
  fi

  return $factorial
}

fact $1
echo &quot;Факториал числа $1 = $?.&quot;

exit 0
</pre>
        </div>

        <p>Еще один пример использования рекурсии вы найдете в <a
         href="#a14477_html_PRIMES">Пример A-18</a>. Не забывайте, что
        рекурсия весьма ресурсоемкое удовольствие, к тому же она
        выполняется слишком медленно, поэтому не следует использовать
        ее в сценариях.</p>
      </div>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN12669"
         href="#x12644_html_AEN12669"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p><a
           name="x12644_html_RECURSIONREF"></a> <a
           href="#b14059_html_MAYERREF">Herbert Mayer</a> определяет
          <span
           class="emphasis"><em
           class="EMPHASIS">рекурсию</em></span>, как <span
           class="QUOTE">&quot;...описание алгоритма с помощью более
          простой версии того же самого алгоритма...&quot;</span>
          Рекурсивной называется функция, которая вызывает самого
          себя.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN12675"
         href="#x12644_html_AEN12675"><span
         class="footnote">[2]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Слишком глубокая рекурсия может вызвать крах сценария.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

recursive_function ()
{
(( $1 &lt; $2 )) &amp;&amp; recursive_function $(( $1 + 1 )) $2;
#  Увеличивать 1-й параметр до тех пор,
#+ пока он не станет равным, или не превысит, второму параметру.
}

recursive_function 1 50000  # Глубина рекурсии = 50,000!
# Само собой -- Segmentation fault.

#  Рекурсия такой глубины может &quot;обрушить&quot; даже программу, написанную на C,
#+ по исчерпании памяти, выделенной под сегмент стека.

# Спасибо S.C.

exit 0  # Этот сценарий завершает работу не здесь, а в результате ошибки Segmentation fault.
</pre>
          <br>
          <br>
        </td>
      </tr>
    </table>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#c12483_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#c12683_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Функции</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c12483_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Псевдонимы</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x12987_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#c12942_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 27. /dev и /proc</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#c13041_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x12987_html_PROCREF1"></a>27.2. <tt
       class="FILENAME">/proc</tt></h1>

      <p>Фактически, каталог <tt
       class="FILENAME">/proc</tt> -- это виртуальная файловая система.
      Файлы, в каталоге <tt
       class="FILENAME">/proc</tt>, содержат информацию о процессах, о
      состоянии и конфигурации ядра и системы.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>cat /proc/devices</strong></tt>
<tt
 class="COMPUTEROUTPUT">Character devices:
   1 mem
   2 pty
   3 ttyp
   4 ttyS
   5 cua
   7 vcs
  10 misc
  14 sound
  29 fb
  36 netlink
 128 ptm
 136 pts
 162 raw
 254 pcmcia

 Block devices:
   1 ramdisk
   2 fd
   3 ide0
   9 md</tt>



<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>cat /proc/interrupts</strong></tt>
 <tt
 class="COMPUTEROUTPUT">          CPU0
   0:      84505          XT-PIC  timer
   1:       3375          XT-PIC  keyboard
   2:          0          XT-PIC  cascade
   5:          1          XT-PIC  soundblaster
   8:          1          XT-PIC  rtc
  12:       4231          XT-PIC  PS/2 Mouse
  14:     109373          XT-PIC  ide0
 NMI:          0
 ERR:          0</tt>



<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>cat /proc/partitions</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">major minor  #blocks  name     rio rmerge rsect ruse wio wmerge wsect wuse running use aveq

    3     0    3007872 hda 4472 22260 114520 94240 3551 18703 50384 549710 0 111550 644030
    3     1      52416 hda1 27 395 844 960 4 2 14 180 0 800 1140
    3     2          1 hda2 0 0 0 0 0 0 0 0 0 0 0
    3     4     165280 hda4 10 0 20 210 0 0 0 0 0 210 210
    ...</tt>



<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>cat /proc/loadavg</strong></tt>
<tt
 class="COMPUTEROUTPUT">0.13 0.42 0.27 2/44 1119</tt>
        
</pre>
      <br>
      <br>

      <p>Сценарии командной оболочки могут извлекать необходимую
      информацию из соответствующих файлов в каталоге <tt
       class="FILENAME">/proc</tt>. <a
       name="AEN13009"
       href="#x12987_html_FTN_AEN13009"><span
       class="footnote">[1]</span></a></p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>cat /proc/filesystems | grep iso9660</strong></tt>
 <tt
 class="COMPUTEROUTPUT">       iso9660</tt>

             
</pre>
      <br>
      <br>
<pre
 class="PROGRAMLISTING">
kernel_version=$( awk &#39;{ print $3 }&#39; /proc/version )
</pre>
      <br>
      <br>
<pre
 class="PROGRAMLISTING">
CPU=$( awk &#39;/model name/ {print $4}&#39; &lt; /proc/cpuinfo )

if [ $CPU = Pentium ]
then
  выполнить_ряд_специфичных_команд
  ...
else
  выполнить_ряд_других_специфичных_команд
  ...
fi
</pre>
      <br>
      <br>

      <p>В каталоге <tt
       class="FILENAME">/proc</tt> вы наверняка заметите большое
      количество подкаталогов, с не совсем обычными именами, состоящими
      только из цифр. Каждый из них соответствует исполняющемуся
      процессу, а имя каталога -- это <a
       href="#c3270_html_PPIDREF">ID (идентификатор) процесса</a>.
      Внутри каждого такого подкаталога находится ряд файлов, в которых
      содержится полезная информация о соответствующих процессах. Файлы
      <tt
       class="FILENAME">stat</tt> и <tt
       class="FILENAME">status</tt> хранят статистику работы процесса,
      <tt
       class="FILENAME">cmdline</tt> -- команда, которой был запущен
      процесс, <tt
       class="FILENAME">exe</tt> -- символическая ссылка на исполняемый
      файл программы. Здесь же вы найдете ряд других файлов, но, с
      точки зрения написания сценариев, они не так интересны, как эти
      четыре.</p>

      <div
       class="EXAMPLE">
        <a
         name="x12987_html_PIDID"></a>

        <p><strong>Пример 27-1. Поиск файла программы по идентификатору
        процесса</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# pid-identifier.sh: Возвращает полный путь к исполняемому файлу программы по идентификатору процесса (pid).

ARGNO=1  # Число, ожидаемых из командной строки, аргументов.
E_WRONGARGS=65
E_BADPID=66
E_NOSUCHPROCESS=67
E_NOPERMISSION=68
PROCFILE=exe

if [ $# -ne $ARGNO ]
then
  echo &quot;Порядок использования: `basename $0` PID-процесса&quot; &gt;&amp;2  # Сообщение об ошибке на &gt;stderr.
  exit $E_WRONGARGS
fi

ps ax

pidno=$( ps ax | grep $1 | awk &#39;{ print $1 }&#39; | grep $1 )
# Проверка наличия процесса с заданным pid в списке, выданном командой  &quot;ps&quot;, поле #1.
# Затем следует убедиться, что этот процесс не был запущен этим сценарием (&#39;ps&#39;).
# Это делает последний &quot;grep $1&quot;.
if [ -z &quot;$pidno&quot; ]  # Если после фильтрации получается пустая строка,
then                # то это означает, что в системе нет процесса с заданым pid.
  echo &quot;Нет такого процесса.&quot;
  exit $E_NOSUCHPROCESS
fi

# Альтернативный вариант:
#   if ! ps $1 &gt; /dev/null 2&gt;&amp;1
#   then                # в системе нет процесса с заданым pid.
#     echo &quot;Нет такого процесса.&quot;
#     exit $E_NOSUCHPROCESS
#    fi


if [ ! -r &quot;/proc/$1/$PROCFILE&quot; ]  # Проверить право на чтение.
then
  echo &quot;Процесс $1 найден, однако...&quot;
  echo &quot;у вас нет права на чтение файла /proc/$1/$PROCFILE.&quot;
  exit $E_NOPERMISSION  # Обычный пользователь не имеет прав
                        # на доступ к некоторым файлам в каталоге /proc.
fi

# Последние две проверки могут быть заменены на:
#    if ! kill -0 $1 &gt; /dev/null 2&gt;&amp;1 # &#39;0&#39; -- это не сигнал, но
                                      # команда все равно проверит наличие
                                      # процесса-получателя.
#    then echo &quot;Процесс с данным PID не найден, либо вы не являетесь его владельцем&quot; &gt;&amp;2
#    exit $E_BADPID
#    fi



exe_file=$( ls -l /proc/$1 | grep &quot;exe&quot; | awk &#39;{ print $11 }&#39; )
# Или      exe_file=$( ls -l /proc/$1/exe | awk &#39;{print $11}&#39; )
#
# /proc/pid-number/exe -- это символическая ссылка
# на исполняемый файл работающей программы.

if [ -e &quot;$exe_file&quot; ]  # Если файл /proc/pid-number/exe существует...
then                 # то существует и соответствующий процесс.
  echo &quot;Исполняемый файл процесса #$1: $exe_file.&quot;
else
  echo &quot;Нет такого процесса.&quot;
fi


# В большинстве случаев, этот, довольно сложный сценарий, может быть заменен командой
# ps ax | grep $1 | awk &#39;{ print $5 }&#39;
# В большинстве, но не всегда...
# поскольку пятое поле листинга,выдаваемого командой &#39;ps&#39;, это argv[0] процесса,
# а не путь к исполняемому файлу.
#
# Однако, оба следующих варианта должны работать безотказно.
#       find /proc/$1/exe -printf &#39;%l\n&#39;
#       lsof -aFn -p $1 -d txt | sed -ne &#39;s/^n//p&#39;

# Автор последнего комментария: Stephane Chazelas.

exit 0
</pre>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="x12987_html_CONSTAT"></a>

        <p><strong>Пример 27-2. Проверка состояния
        соединения</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

PROCNAME=pppd        # демон ppp
PROCFILENAME=status  # Что смотреть.
NOTCONNECTED=65
INTERVAL=2           # Период проверки -- раз в 2 секунды.

pidno=$( ps ax | grep -v &quot;ps ax&quot; | grep -v grep | grep $PROCNAME | awk &#39;{ print $1 }&#39; )
# Найти идентификатор процесса &#39;pppd&#39;, &#39;ppp daemon&#39;.
# По пути убрать из листинга записи о процессах, порожденных сценарием.
#
#  Однако, как отмечает Oleg Philon,
#+ Эта последовательность команд может быть заменена командой &quot;pidof&quot;.
#  pidno=$( pidof $PROCNAME )
#
#  Мораль:
#+ Когда последовательность команд становится слишком сложной,
#+ это повод к тому, чтобы поискать более короткий вариант.


if [ -z &quot;$pidno&quot; ]   # Если получилась пустая строка, значит процесс не запущен.
then
  echo &quot;Соединение не установлено.&quot;
  exit $NOTCONNECTED
else
  echo &quot;Соединение установлено.&quot;; echo
fi

while [ true ]       # Бесконечный цикл.
do

  if [ ! -e &quot;/proc/$pidno/$PROCFILENAME&quot; ]
  # Пока работает процесс, файл &quot;status&quot; существует.
  then
    echo &quot;Соединение разорвано.&quot;
    exit $NOTCONNECTED
  fi

netstat -s | grep &quot;packets received&quot;  # Получить некоторые сведения о соединении.
netstat -s | grep &quot;packets delivered&quot;


  sleep $INTERVAL
  echo; echo

done

exit 0

# Как обычно, этот сценарий может быть остановлен комбинацией клавиш Control-C.

#    Упражнение:
#    ----------
#    Добавьте возможность завершения работы сценария, по нажатии на клавишу &quot;q&quot;.
#    Это сделает скрипт более жружественным к пользователю.
</pre>
      </div>

      <div
       class="WARNING">
        <table
         class="WARNING"
         width="100%"
         border="0">
          <tr>
            <td
             width="25"
             align="center"
             valign="top"><img
             src="misc/abs-book/images/warning.gif"
             hspace="5"
             alt="Warning"></td>

            <td
             align="left"
             valign="top">
              <p>Будьте предельно осторожны при работе с файловой
              системой <tt
               class="FILENAME">/proc</tt>, так как попытка записи в
              некоторые файлы может повредить файловую систему или
              привести к краху системы.</p>
            </td>
          </tr>
        </table>
      </div>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN13009"
         href="#x12987_html_AEN13009"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Отдельные системные команды, такие как <a
           href="#c9708_html_PROCINFOREF">procinfo</a>, <a
           href="#c9708_html_FREEREF">free</a>, <a
           href="#c9708_html_VMSTATREF">vmstat</a>, <a
           href="#c9708_html_LSDEVREF">lsdev</a> и <a
           href="#c9708_html_UPTIMEREF">uptime</a> делают это именно
          таким образом.</p>
        </td>
      </tr>
    </table>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#c12942_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#c13041_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">/dev и /proc</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c12942_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">/dev/zero и /dev/null</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x13541_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#c13505_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 33. Разное</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x13602_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x13541_html_WRAPPER"></a>33.2. Сценарии-обертки</h1>

      <p><a
       name="x13541_html_SHWRAPPER"></a></p>

      <p><span
       class="QUOTE">&quot;Обертки&quot;</span> -- это сценарии,
      которые содержат один или несколько вызовов системных команд или
      утилит, с длинным списком параметров. Такой прием освобождает
      пользователя от необходимости вводить вручную сложные и длинные
      команды из командной строки. Он особенно полезен при работе с <a
       href="#a14586_html_SEDREF">sed</a> и <a
       href="#x14802_html_AWKREF">awk</a>.</p>

      <p>Сценарии <strong
       class="COMMAND">sed</strong> или <strong
       class="COMMAND">awk</strong>, как правило вызываются в форме:
      <tt
       class="USERINPUT"><strong>sed -e <tt
       class=
      "REPLACEABLE"><em>&#39;commands&#39;</em></tt></strong></tt> или
      <tt
       class="USERINPUT"><strong>awk <tt
       class=
      "REPLACEABLE"><em>&#39;commands&#39;</em></tt></strong></tt>.
      &quot;Заворачивая&quot; такие вызовы в сценарий на языке
      командной оболочки, мы делаем их использование более простым для
      конечного пользователя. Кроме того, этот прием позволяет
      комбинировать вызовы <strong
       class="COMMAND">sed</strong> и <strong
       class="COMMAND">awk</strong>, например в <a
       href="#c301_html_PIPEREF">конвейере</a>, позволяя передавать
      данные с выхода одной утилиты на вход другой.</p>

      <div
       class="EXAMPLE">
        <a
         name="x13541_html_EX3"></a>

        <p><strong>Пример 33-1. сценарий-обертка</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Этот простой сценарий удаляет пустые строки из текстового файла.
# Проверка входных аргументов не производится.
#
# Однако вы можете дополнить сценарий такой проверкой,
# добавив нечто подобное:
# if [ -z &quot;$1&quot; ]
# then
#  echo &quot;Порядок использования: `basename $0` текстовый_файл&quot;
#  exit 65
# fi

# Для выполнения этих же действий,
# из командной строки можно набрать
#    sed -e &#39;/^$/d&#39; filename


sed -e /^$/d &quot;$1&quot;
#  &#39;-e&#39; -- означает команду &quot;editing&quot; (правка), за которой следуют необязательные параметры.
#  &#39;^&#39; -- с начала строки, &#39;$&#39; -- до ее конца.
#  Что соответствует строкам, которые не содержат символов между началом и концом строки,
#+ т.е. -- пустым строкам.
#  &#39;d&#39; -- команда &quot;delete&quot; (удалить).

#  Использование кавычек дает возможность
#+ обрабатывать файлы, чьи имена содержат пробелы.

exit 0
</pre>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="x13541_html_EX4"></a>

        <p><strong>Пример 33-2. Более сложный пример
        сценария-обертки</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# &quot;subst&quot;, Сценарий замены по шаблону
# т.е., &quot;subst Smith Jones letter.txt&quot;.

ARGS=3
E_BADARGS=65   # Неверное число аргументов.

if [ $# -ne &quot;$ARGS&quot; ]
# Проверка числа аргументов.
then
  echo &quot;Проядок использования: `basename $0` old-pattern new-pattern filename&quot;
  exit $E_BADARGS
fi

old_pattern=$1
new_pattern=$2

if [ -f &quot;$3&quot; ]
then
    file_name=$3
else
    echo &quot;Файл \&quot;$3\&quot; не найден.&quot;
    exit $E_BADARGS
fi

# Здесь, собственно, выполняется сама работа по поиску и замене.
sed -e &quot;s/$old_pattern/$new_pattern/g&quot; $file_name
# &#39;s&#39; -- команда &quot;substitute&quot; (замены),
# а /pattern/ -- задает шаблон искомого текста.
# &quot;g&quot; -- флаг &quot;global&quot; (всеобщий), означает &quot;выполнить подстановку для *каждого*
# обнаруженного $old_pattern во всех строках, а не только в первой строке.

exit 0    # При успешном завершении сценария -- вернуть 0.
</pre>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="x13541_html_COLTOTALER"></a>

        <p><strong>Пример 33-3. Сценарий-обертка вокруг сценария
        awk</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Суммирует числа в заданном столбце из заданного файла.

ARGS=2
E_WRONGARGS=65

if [ $# -ne &quot;$ARGS&quot; ] # Проверка числа аргументов.
then
   echo &quot;Порядок использования: `basename $0` имя_файла номер_столбца&quot;
   exit $E_WRONGARGS
fi

filename=$1
column_number=$2

# Здесь используется прием передачи переменных
# из командной оболочки в сценарий awk .

# Многострочный сценарий awk должен записываться в виде:   awk &#39; ..... &#39;


# Начало awk-сценария.
# -----------------------------
awk &#39;

{ total += $&#39;&quot;${column_number}&quot;&#39;
}
END {
     print total
}

&#39; &quot;$filename&quot;
# -----------------------------
# Конец awk-сценария.


#   С точки зрения безопасности, передача shell-переменных
#   во встроенный awk-скрипт, потенциально опасна,
#   поэтому, Stephane Chazelas предлагает следующую альтернативу:
#   ---------------------------------------
#   awk -v column_number=&quot;$column_number&quot; &#39;
#   { total += $column_number
#   }
#   END {
#       print total
#   }&#39; &quot;$filename&quot;
#   ---------------------------------------


exit 0
</pre>
      </div>

      <p><a
       name="x13541_html_PERLREF"></a>Для сценариев, которые должны строиться по
      принципу швейцарского армейского ножа -- &quot;все в одном&quot;,
      можно порекомендовать Perl. Perl совмещает в себе мощь и гибкость
      <strong
       class="COMMAND">sed</strong>, <strong
       class="COMMAND">awk</strong> и языка программирования <strong
       class="COMMAND">C</strong>. Он поддерживает модульность и
      объектно-ориентированный стиль программирования. Короткие
      сценарии Perl могут легко встраиваться в сценарии командной
      оболочки, и даже полностью заменить из (хотя автор весьма
      скептически относится к последнему утверждению).</p>

      <div
       class="EXAMPLE">
        <a
         name="x13541_html_EX56"></a>

        <p><strong>Пример 33-4. Сценарий на языке Perl, встроенный в
        Bash-скрипт</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Это команды shell, предшествующий сценарию на Perl.
echo &quot;Эта строка выводится средствами Bash, перед выполнением встроенного Perl-скрипта, в \&quot;$0\&quot;.&quot;
echo &quot;==============================================================================================&quot;

perl -e &#39;print &quot;Эта строка выводится средствами Perl.\n&quot;;&#39;
# Подобно sed, Perl тоже использует ключ &quot;-e&quot;.

echo &quot;=====================================&quot;

exit 0
</pre>
      </div>

      <p>Допускается даже комбинирование сценариев на Bash и на Perl, в
      пределах одного файла. В зависимости от того, какая часть
      сценария должна исполняться, сценарий вызывается с указанием
      требуемого интерпретатора.</p>

      <div
       class="EXAMPLE">
        <a
         name="x13541_html_BASHANDPERL"></a>

        <p><strong>Пример 33-5. Комбинирование сценария Bash и Perl в
        одном файле</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# bashandperl.sh

echo &quot;Вас приветствует часть сценария, написанная на Bash.&quot;
# Далее могут следовать другие команды Bash.

exit 0
# Конец сценария на Bash.

# =======================================================

#!/usr/bin/perl
# Эта часть сценария должна вызываться с ключом -x.

print &quot;Вас приветствует часть сценария, написанная на Perl.\n&quot;;
# Далее могут следовать другие команды Perl.

# Конец сценария на Perl.
</pre>
      </div>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>bash bashandperl.sh</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">Вас приветствует часть сценария, написанная на Bash.</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>perl -x bashandperl.sh</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">Вас приветствует часть сценария, написанная на Perl.</tt>
             
</pre>
      <br>
      <br>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#c13505_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x13602_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Разное</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c13505_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Операции сравнения: Альтернативные решения</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x13602_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x13541_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 33. Разное</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x13609_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x13602_html_TESTSANDCOMPARISONS"></a>33.3. Операции сравнения:
      Альтернативные решения</h1>

      <p>Операции сравнения, выполняемые с помощью конструкции <a
       href="#c2171_html_DBLBRACKETS">[[ ]]</a>, могут оказаться
      предпочтительнее, чем <tt
       class="USERINPUT"><strong>[ ]</strong></tt>. Аналогично, при
      сравнении чисел, в более выгодном свете представляется
      конструкция <a
       href="#x4862_html">(( ))</a>.</p>
<pre
 class="PROGRAMLISTING">
a=8

# Все, приведенные ниже, операции сравнения -- эквивалентны.
test &quot;$a&quot; -lt 16 &amp;&amp; echo &quot;да, $a &lt; 16&quot;         # &quot;И-список&quot;
/bin/test &quot;$a&quot; -lt 16 &amp;&amp; echo &quot;да, $a &lt; 16&quot;
[ &quot;$a&quot; -lt 16 ] &amp;&amp; echo &quot;да, $a &lt; 16&quot;
[[ $a -lt 16 ]] &amp;&amp; echo &quot;да, $a &lt; 16&quot;          # Внутри [[ ]] и (( )) переменные
(( a &lt; 16 )) &amp;&amp; echo &quot;да, $a &lt; 16&quot;             # не обязательно брать в кавычки.

city=&quot;New York&quot;
# Опять же, все, приведенные ниже, операции -- эквивалентны.
test &quot;$city&quot; \&lt; Paris &amp;&amp; echo &quot;Да, Paris больше, чем $city&quot;  # В смысле ASCII-строк.
/bin/test &quot;$city&quot; \&lt; Paris &amp;&amp; echo &quot;Да, Paris больше, чем $city&quot;
[ &quot;$city&quot; \&lt; Paris ] &amp;&amp; echo &quot;Да, Paris больше, чем $city&quot;
[[ $city &lt; Paris ]] &amp;&amp; echo &quot;Да, Paris больше, чем $city&quot;    # Кавычки вокруг $city не обязательны.

# Спасибо S.C.
</pre>
      <br>
      <br>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x13541_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x13609_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Сценарии-обертки</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c13505_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Рекурсия</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x13609_html"></a>
<div
     class="NAVHEADER">
      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x13602_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 33. Разное</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x13621_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x13609_html_RECURSIONSCT"></a>33.4. Рекурсия</h1>

      <p>Может ли сценарий <a
       href="#x12644_html_RECURSIONREF">рекурсивно</a> вызывать себя
      самого? Да, может!</p>

      <div
       class="EXAMPLE">
        <a
         name="x13609_html_RECURSE"></a>

        <p><strong>Пример 33-6. Сценарий (бесполезный), который
        вызывает себя сам</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# recurse.sh

#  Может ли сценарий вызвать себя сам?
#  Да, но есть ли в этом смысл?

RANGE=10
MAXVAL=9

i=$RANDOM
let &quot;i %= $RANGE&quot;  # Генерация псевдослучайного числа в диапазоне 0 .. $MAXVAL.

if [ &quot;$i&quot; -lt &quot;$MAXVAL&quot; ]
then
  echo &quot;i = $i&quot;
  ./$0             #  Сценарий запускает новый экземпляр себя самого.
fi                 #  если число $i больше или равно $MAXVAL.

#  Если конструкцию &quot;if/then&quot; заменить на цикл &quot;while&quot;, то это вызовет определенные проблемы.
#  Объясните -- почему?.

exit 0
</pre>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="x13609_html_PBOOK"></a>

        <p><strong>Пример 33-7. Сценарий имеющий практическую
        ценность), который вызывает себя сам</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# pb.sh: телефонная книга

# Автор: Rick Boivie
# используется с его разрешения.
# Дополнен автором документа.

MINARGS=1     # Сценарию должен быть передан, по меньшей мере, один аргумент.
DATAFILE=./phonebook
PROGNAME=$0
E_NOARGS=70   # Ошибка, нет аргументов.

if [ $# -lt $MINARGS ]; then
      echo &quot;Порядок использования: &quot;$PROGNAME&quot; data&quot;
      exit $E_NOARGS
fi


if [ $# -eq $MINARGS ]; then
      grep $1 &quot;$DATAFILE&quot;
else
      ( shift; &quot;$PROGNAME&quot; $* ) | grep $1
      # Рекурсивный вызов.
fi

exit 0        #  Сценарий завершает свою работу здесь.
              #  Далее следует пример файла телефонной книги
              #+ в котором не используются символы комментария.

# ------------------------------------------------------------------------
# Пример файла телефонной книги

John Doe        1555 Main St., Baltimore, MD 21228          (410) 222-3333
Mary Moe        9899 Jones Blvd., Warren, NH 03787          (603) 898-3232
Richard Roe     856 E. 7th St., New York, NY 10009          (212) 333-4567
Sam Roe         956 E. 8th St., New York, NY 10009          (212) 444-5678
Zoe Zenobia     4481 N. Baker St., San Franciso, SF 94338   (415) 501-1631
# ------------------------------------------------------------------------

$bash pb.sh Roe
Richard Roe     856 E. 7th St., New York, NY 10009          (212) 333-4567
Sam Roe         956 E. 8th St., New York, NY 10009          (212) 444-5678

$bash pb.sh Roe Sam
Sam Roe         956 E. 8th St., New York, NY 10009          (212) 444-5678

#  Если сценарию передаются несколько аргументов,
#+ то выводятся только те строки, которые содержат их все.
</pre>
      </div>

      <div
       class="CAUTION">
        <table
         class="CAUTION"
         width="100%"
         border="0">
          <tr>
            <td
             width="25"
             align="center"
             valign="top"><img
             src="misc/abs-book/images/caution.gif"
             hspace="5"
             alt="Caution"></td>

            <td
             align="left"
             valign="top">
              <p>Слишком глубокая рекурсия может привести к исчерпанию
              пространства, выделенного под стек, и
              &quot;вываливанию&quot; сценария по
              &quot;segfault&quot;.</p>
            </td>
          </tr>
        </table>
      </div>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x13602_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x13621_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Операции сравнения: Альтернативные решения</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c13505_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><span
           class="QUOTE">&quot;Цветные&quot;</span> сценарии</td>
        </tr>
      </table>
    </div>
<hr>

<a name="x13621_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x13609_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 33. Разное</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x13734_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x13621_html_COLORIZING"></a>33.5. <span
       class="QUOTE">&quot;Цветные&quot;</span> сценарии</h1>

      <p>Для установки атрибутов отображения информации на экране,
      таких как: жирный текст, цвет символов, цвет фона и т.п., с
      давних пор используются ANSI <a
       name="AEN13625"
       href="#x13621_html_FTN_AEN13625"><span
       class="footnote">[1]</span></a> escape-последовательности. Эти
      последовательности широко используются в <a
       href="#a15138_html_DOSBATCH1">пакетных файлах DOS</a>, эти же
      последовательности используются и в сценариях Bash.</p>

      <div
       class="EXAMPLE">
        <a
         name="x13621_html_EX30A"></a>

        <p><strong>Пример 33-8. <span
         class="QUOTE">&quot;Цветная&quot;</span> адресная
        книга</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# ex30a.sh: Версия сценария ex30.sh, с добавлением цвета .
#           Грубый пример базы данных


clear                                   # Очистка экрана

echo -n &quot;          &quot;
echo -e &#39;\E[37;44m&#39;&quot;\033[1mСписок\033[0m&quot;
                                        # Белый текст на синем фоне
echo; echo
echo -e &quot;\033[1mВыберите интересующую Вас персону:\033[0m&quot;
                                        # Жирный шрифт
tput sgr0
echo &quot;(Введите только первую букву имени.)&quot;
echo
echo -en &#39;\E[47;34m&#39;&quot;\033[1mE\033[0m&quot;   # Синий
tput sgr0                               # сброс цвета
echo &quot;vans, Roland&quot;                     # &quot;[E]vans, Roland&quot;
echo -en &#39;\E[47;35m&#39;&quot;\033[1mJ\033[0m&quot;   # Пурпурный
tput sgr0
echo &quot;ones, Mildred&quot;
echo -en &#39;\E[47;32m&#39;&quot;\033[1mS\033[0m&quot;   # Зеленый
tput sgr0
echo &quot;mith, Julie&quot;
echo -en &#39;\E[47;31m&#39;&quot;\033[1mZ\033[0m&quot;   # Красный
tput sgr0
echo &quot;ane, Morris&quot;
echo

read person

case &quot;$person&quot; in
# Обратите внимание: переменная взята в кавычки.

  &quot;E&quot; | &quot;e&quot; )
  # Пользователь может ввести как заглавную, так и строчную букву.
  echo
  echo &quot;Roland Evans&quot;
  echo &quot;4321 Floppy Dr.&quot;
  echo &quot;Hardscrabble, CO 80753&quot;
  echo &quot;(303) 734-9874&quot;
  echo &quot;(303) 734-9892 fax&quot;
  echo &quot;revans@zzy.net&quot;
  echo &quot;Старый друг и партнер по бизнесу&quot;
  ;;

  &quot;J&quot; | &quot;j&quot; )
  echo
  echo &quot;Mildred Jones&quot;
  echo &quot;249 E. 7th St., Apt. 19&quot;
  echo &quot;New York, NY 10009&quot;
  echo &quot;(212) 533-2814&quot;
  echo &quot;(212) 533-9972 fax&quot;
  echo &quot;milliej@loisaida.com&quot;
  echo &quot;Подружка&quot;
  echo &quot;День рождения: 11 февраля&quot;
  ;;

# Информация о Smith и Zane будет добавлена позднее.

          * )
   # Выбор по-умолчанию.
   # &quot;Пустой&quot; ввод тоже обрабатывается здесь.
   echo
   echo &quot;Нет данных.&quot;
  ;;

esac

tput sgr0                               # Сброс цвета

echo

exit 0
</pre>
      </div>

      <p>Самая простая и, на мой взгляд, самая полезная
      escape-последовательность -- это &quot;жирный текст&quot;,
      <strong
       class="COMMAND">\033[1m ... \033[0m</strong>. Здесь, комбинация
      <span
       class="TOKEN">\033</span> представляет <span
       class="emphasis"><em
       class="EMPHASIS">escape</em></span>-символ, кобинация <span
       class="QUOTE">&quot;[1&quot;</span> -- включает вывод жирным
      текстом, а <span
       class="QUOTE">&quot;[0&quot;</span> -- выключает. Символ <span
       class="QUOTE">&quot;m&quot;</span> -- завершает каждую из
      escape-последовательностей.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>echo -e &quot;\033[1mЭто жирный текст.\033[0m&quot;</strong></tt>
             
</pre>
      <br>
      <br>

      <p>Простая escape-последовательность, которая управляет атрибутом
      подчеркивания (в <span
       class="emphasis"><em
       class="EMPHASIS">rxvt</em></span> и <span
       class="emphasis"><em
       class="EMPHASIS">aterm</em></span>).</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>echo -e &quot;\033[4mЭто подчеркнутый текст.\033[0m&quot;</strong></tt>
             
</pre>
      <br>
      <br>

      <div
       class="NOTE">
        <table
         class="NOTE"
         width="100%"
         border="0">
          <tr>
            <td
             width="25"
             align="center"
             valign="top"><img
             src="misc/abs-book/images/note.gif"
             hspace="5"
             alt="Note"></td>

            <td
             align="left"
             valign="top">
              <p>Ключ <tt
               class="OPTION">-e</tt>, в команде <strong
               class="COMMAND">echo</strong>, разрешает интерпретацию
              escape-последовательностей.</p>
            </td>
          </tr>
        </table>
      </div>

      <p>Другие escape-последовательности, изменяющие атрибуты
      цвета:</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>echo -e &#39;\E[34;47mЭтот текст выводится синим цветом.&#39;; tput sgr0</strong></tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>echo -e &#39;\E[33;44m&#39;&quot;желтый текст на синем фоне&quot;; tput sgr0</strong></tt>
             
</pre>
      Команда <strong
       class="COMMAND">tput sgr0</strong> возвращает настройки
      терминала в первоначальное состояние.<br>
      <br>

      <table
       class="SIDEBAR"
       border="1"
       cellpadding="5">
        <tr>
          <td>
            <div
             class="SIDEBAR">
              <a
               name="x13621_html_AEN13659"></a>

              <p>Вывод цветного текста осуществляется по следующему
              шаблону:.</p>

              <p><tt
               class="USERINPUT"><strong>echo -e
              &#39;\E[COLOR1;COLOR2mКакой либо
              текст.&#39;</strong></tt></p>

              <p>Где <span
               class="QUOTE">&quot;\E[&quot;</span> -- начало
              escape-последовательности. Числа <span
               class="QUOTE">&quot;COLOR1&quot;</span> и <span
               class="QUOTE">&quot;COLOR2&quot;</span>, разделенные
              точкой с запятой, задают цвет символов и цвет фона, в
              соответствии с таблицей цветов, приведенной ниже.
              (Порядок указания цвета текста и фона не имеет значения,
              поскольку диапазоны числовых значений цвета для текста и
              фона не пересекаются). Символ <span
               class="QUOTE">&quot;m&quot;</span> -- должен завершать
              escape-последовательность.</p>

              <p>Обратите внимание: <a
               href="#c1613_html_SNGLQUO">одиночные кавычки</a> окружают
              все, что следует за <strong
               class="COMMAND">echo -e</strong>.</p>
            </div>
          </td>
        </tr>
      </table>

      <p>Числовые значения цвета, приведенные ниже, справедливы для
      <span
       class="emphasis"><em
       class="EMPHASIS">rxvt</em></span>. Для других эмуляторов они
      могут несколько отличаться.</p>

      <div
       class="TABLE">
        <a
         name="x13621_html_AEN13673"></a>

        <p><strong>Таблица 33-1. Числовые значения цвета в
        escape-последовательностях</strong></p>

        <table
         border="1"
         class="CALSTABLE">
          <thead>
            <tr>
              <th
               align="left"
               valign="top">Цвет</th>

              <th
               align="left"
               valign="top">Текст</th>

              <th
               align="left"
               valign="top">Фон</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">черный</tt></td>

              <td
               align="left"
               valign="top">30</td>

              <td
               align="left"
               valign="top">40</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">красный</tt></td>

              <td
               align="left"
               valign="top">31</td>

              <td
               align="left"
               valign="top">41</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">зеленый</tt></td>

              <td
               align="left"
               valign="top">32</td>

              <td
               align="left"
               valign="top">42</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">желтый</tt></td>

              <td
               align="left"
               valign="top">33</td>

              <td
               align="left"
               valign="top">43</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">синий</tt></td>

              <td
               align="left"
               valign="top">34</td>

              <td
               align="left"
               valign="top">44</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">пурпурный</tt></td>

              <td
               align="left"
               valign="top">35</td>

              <td
               align="left"
               valign="top">45</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">зеленовато-голубой</tt></td>

              <td
               align="left"
               valign="top">36</td>

              <td
               align="left"
               valign="top">46</td>
            </tr>

            <tr>
              <td
               align="left"
               valign="top"><tt
               class="OPTION">белый</tt></td>

              <td
               align="left"
               valign="top">37</td>

              <td
               align="left"
               valign="top">47</td>
            </tr>
          </tbody>
        </table>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="x13621_html_COLORECHO"></a>

        <p><strong>Пример 33-9. Вывод цветного текста</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# color-echo.sh: Вывод цветных сообщений.

black=&#39;\E[30;47m&#39;
red=&#39;\E[31;47m&#39;
green=&#39;\E[32;47m&#39;
yellow=&#39;\E[33;47m&#39;
blue=&#39;\E[34;47m&#39;
magenta=&#39;\E[35;47m&#39;
cyan=&#39;\E[36;47m&#39;
white=&#39;\E[37;47m&#39;


cecho ()                     # Color-echo.
                             # Аргумент $1 = текст сообщения
                             # Аргумент $2 = цвет
{
local default_msg=&quot;Нет сообщений.&quot;
                             # Не обязательно должна быть локальной.

message=${1:-$default_msg}   # Текст сообщения по-умолчанию.
color=${2:-$black}           # Цвет по-умолчанию черный.

  echo -e &quot;$color&quot;
  echo &quot;$message&quot;
  tput sgr0                  # Восстановление первоначальных настроек терминала.
  return
}


# Попробум что-нибудь вывести.
# ----------------------------------------------------
cecho &quot;Синий текст...&quot; $blue
cecho &quot;Пурпурный текст.&quot; $magenta
cecho &quot;Позеленевший от зависти.&quot; $green
cecho &quot;Похоже на красный?&quot; $red
cecho &quot;Циан, более известный как цвет морской волны.&quot; $cyan
cecho &quot;Цвет не задан (по-умолчанию черный).&quot;
       # Аргумент $color отсутствует.
cecho &quot;\&quot;Пустой\&quot; цвет (по-умолчанию черный).&quot; &quot;&quot;
       # Передан &quot;пустой&quot; аргумент цвета.
cecho
       # Ни сообщение ни цвет не переданы.
cecho &quot;&quot; &quot;&quot;
       # Функции переданы &quot;пустые&quot; аргументы $message и $color.
# ----------------------------------------------------

echo

exit 0

# Упражнения:
# ---------
# 1) Добавьте в функцию &#39;cecho ()&#39; возможность вывода &quot;жирного текста&quot;.
# 2) Добавьте возможность управления цветом фона.
</pre>
      </div>

      <div
       class="CAUTION">
        <table
         class="CAUTION"
         width="100%"
         border="0">
          <tr>
            <td
             width="25"
             align="center"
             valign="top"><img
             src="misc/abs-book/images/caution.gif"
             hspace="5"
             alt="Caution"></td>

            <td
             align="left"
             valign="top">
              <p>Однако, как обычно, в бочке меда есть ложка дегтя.
              <span
               class="emphasis"><em
               class="EMPHASIS">Escape-последовательности ANSI
              совершенно не переносимы</em></span>. Вывод в одном
              эмуляторе терминала (или в консоли) может разительно
              отличаться от вывода в другом эмуляторе. <span
               class="QUOTE">&quot;Расцвеченные&quot;</span> сценарии,
              дающие изумительно красивый вывод текста на одном
              терминале, могут давать совершенно нечитаемый текст на
              другом. Это ставит под сомнение практическую ценность
              <span
               class="QUOTE">&quot;расцвечивания&quot;</span> вывода в
              сценариях, низводя ее до уровня никчемной <span
               class="QUOTE">&quot;игрушки&quot;</span>.</p>
            </td>
          </tr>
        </table>
      </div>

      <p>Moshe Jacobson разработал утилиту <strong
       class="COMMAND">color</strong> (<a
       href="http://runslinux.net/projects/color"
       target="_top">http://runslinux.net/projects/color</a>), которая
      значительно упрощает работу с ANSI escape-последовательностями,
      заменяя, только что обсуждавшиеся, неуклюжие конструкции,
      логичным и понятным синтаксисом.</p>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN13625"
         href="#x13621_html_AEN13625"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>ANSI -- аббревиатура от American National Standards
          Institute.</p>
        </td>
      </tr>
    </table>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x13609_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x13734_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Рекурсия</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c13505_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Оптимизация</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x13734_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x13621_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 33. Разное</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x13753_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x13734_html_OPTIMIZATIONS"></a>33.6. Оптимизация</h1>

      <p>По большей части, сценарии на языке командной оболочки,
      используются для быстрого решения несложных задач. Поэтому
      оптимизация сценариев, по скорости исполнения, не является
      насущной проблемой. Тем не менее, представьте себе ситуацию,
      когда сценарий, выполняющий довольно важную работу, в принципе
      справляется со своей задачей, но делает это очень медленно.
      Написание же аналогичной программы на языке компилирующего типа
      -- неприемлемо. Самое простое решение -- переписать самые
      медленные участки кода сценария. Возможно ли применить принципы
      оптимизации к сценарию на практике?</p>

      <p>Для начала проверьте все циклы в сценарии. Основная масса
      времени уходит на работу в циклах. Если это возможно, вынесите
      все ресурсоемкие операции за пределы циклов.</p>

      <p>Старайтесь использовать <a
       href="#c5358_html_BUILTINREF">встроенные</a> команды. Они
      исполняются значительно быстрее и, как правило, не запускают
      подоболочку при вызове.</p>

      <p>Избегайте использования избыточных команд, особенно это
      относится к <a
       href="#c301_html_PIPEREF">конвейерам</a>.</p>
<pre
 class="PROGRAMLISTING">
cat &quot;$file&quot; | grep &quot;$word&quot;

grep &quot;$word&quot; &quot;$file&quot;

#  Эти команды дают один и тот же результат,
#+ но вторая работает быстрее, поскольку запускает на один подпроцесс меньше.
</pre>
      Не следует злоупотреблять командой <a
       href="#c6407_html_CATREF">cat</a>.<br>
      <br>

      <p>Для профилирования сценариев, можно воспользоваться командами
      <a
       href="#x6837_html_TIMREF">time</a> и <a
       href="#c5358_html_TIMESREF">times</a>. Не следует пренебрегать
      возможностью переписать особенно критичные участки кода на языке
      C или даже на ассемблере.</p>

      <p>Попробуйте минимизировать количество операций с файлами. Bash
      не &quot;страдает&quot; излишней эффективностью при работе с
      файлами, попробуйте применить специализированные средства для
      работы с файлами в сценариях, такие как <a
       href="#x14802_html_AWKREF">awk</a> или <a
       href="#x13541_html_PERLREF">Perl</a>.</p>

      <p>Записывайте сценарии в структурированной форме, это облегчит
      их последующую реорганизацию и оптимизацию. Помните, что
      значительная часть методов оптимизации кода, существующих в
      языках высокого уровня, вполне применима и к сценариям, однако
      есть и такие, которые не могут применяться. Основной критерий
      здесь -- это здравый смысл.</p>

      <p>Прекрасный пример того, как оптимизация может сократить время
      работы сценария, вы найдете в <a
       href="#x9199_html_MONTHLYPMT">Пример 12-32</a>.</p>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x13621_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x13753_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><span
           class="QUOTE">&quot;Цветные&quot;</span> сценарии</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c13505_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Разные советы</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x13753_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x13734_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 33. Разное</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x13884_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x13753_html_ASSORTEDTIPS"></a>33.7. Разные советы</h1>

      <ul>
        <li>
          <p>Для ведения учета использования сценария пользователями,
          добавьте следующие строки в сценарий. Они запишут в файл
          отчета название сценария и время запуска.</p>
<pre
 class="PROGRAMLISTING">
# Добавление (&gt;&gt;) учетной записи, об использовании сценария, в файл отчета.

date&gt;&gt; $SAVE_FILE      # Дата и время.
echo $0&gt;&gt; $SAVE_FILE   # Название сценария.
echo&gt;&gt; $SAVE_FILE      # Пустая строка -- как разделитель записей.

# Не забудьте определить переменную окружения SAVE_FILE в ~/.bashrc
# (что нибудь, типа: ~/.scripts-run)
</pre>
          <br>
          <br>
        </li>

        <li>
          <p><a
           name="x13753_html_PREPENDREF"></a></p>

          <p>Оператор <span
           class="TOKEN">&gt;&gt;</span> производит добавление строки в
          конец файла. А как быть, если надо добавить строку в начало
          существующего файла?</p>
<pre
 class="PROGRAMLISTING">
file=data.txt
title=&quot;***Это титульная строка в текстовом файле***&quot;

echo $title | cat - $file &gt;$file.new
# &quot;cat -&quot; объединяет stdout с содержимым $file.
#  В результате получится
#+ новый файл $file.new, в начало которого добавлена строка $title.
</pre>
          <br>
          <br>

          <p>Само собой разумеется, то же самое можно сделать с помощью
          <a
           href="#a14586_html_SEDREF">sed</a>.</p>
        </li>

        <li>
          <p>Сценарий командной оболочки может использоваться как
          команда внутри другого сценария командной оболочки, <span
           class="emphasis"><em
           class="EMPHASIS">Tcl</em></span>, или <span
           class="emphasis"><em
           class="EMPHASIS">wish</em></span> сценария или, даже в <a
           href="#x7794_html_MAKEFILEREF">Makefile</a>. Он может быть
          вызван как внешняя команда из программы на языке C, с помощью
          функции <tt
           class="REPLACEABLE"><em>system()</em></tt>, т.е. <tt
           class=
          "REPLACEABLE"><em>system(&quot;script_name&quot;);</em></tt>.</p>
        </li>

        <li>
          <p>Собирайте свои библиотеки часто используемых функций и
          определений. Эти &quot;библиотеки&quot; могут быть <span
           class="QUOTE">&quot;подключены&quot;</span> к сценариям, с
          помощью команды <a
           href="#c301_html_DOTREF">точка</a> (<strong
           class="COMMAND">.</strong>) или <a
           href="#c5358_html_SOURCEREF">source</a>.</p>
<pre
 class="PROGRAMLISTING">
# Сценарий-библиотека
# ------ -------

# Обратите внимание:
# Здесь нет sha-bang (&quot;#!&quot;).
# И нет &quot;живого кода&quot;.


# Определения переменных

ROOT_UID=0             # UID root-а, 0.
E_NOTROOT=101          # Ошибка -- &quot;обычный пользователь&quot;.
MAXRETVAL=255          # Максимальное значение, которое могут возвращать функции.
SUCCESS=0
FAILURE=-1



# Функции

Usage ()               # Сообщение &quot;Порядок использования:&quot;.
{
  if [ -z &quot;$1&quot; ]       # Нет аргументов.
  then
    msg=filename
  else
    msg=$@
  fi

  echo &quot;Порядок использования: `basename $0` &quot;$msg&quot;&quot;
}


Check_if_root ()       # Проверка прав пользователя.
{                      # из примера &quot;ex39.sh&quot;.
  if [ &quot;$UID&quot; -ne &quot;$ROOT_UID&quot; ]
  then
    echo &quot;Этот сценарий должен запускаться с привилегиями root.&quot;
    exit $E_NOTROOT
  fi
}


CreateTempfileName ()  # Создание &quot;уникального&quot; имени для временного файла.
{                      # Из примера &quot;ex51.sh&quot;.
  prefix=temp
  suffix=`eval date +%s`
  Tempfilename=$prefix.$suffix
}


isalpha2 ()            # Проверка, состоит ли строка только из алфавитных символов.
{                      # Из примера &quot;isalpha.sh&quot;.
  [ $# -eq 1 ] || return $FAILURE

  case $1 in
  *[!a-zA-Z]*|&quot;&quot;) return $FAILURE;;
  *) return $SUCCESS;;
  esac                 # Спасибо S.C.
}


abs ()                           # Абсолютное значение.
{                                # Внимание: Максимально возможное возвращаеиое значение
                                 # не может превышать 255.
  E_ARGERR=-999999

  if [ -z &quot;$1&quot; ]                 # Проверка наличия входного аргумента.
  then
    return $E_ARGERR             # Код ошибки, обычно возвращаемый в таких случаях.
  fi

  if [ &quot;$1&quot; -ge 0 ]              # Если не отрицательное,
  then                           #
    absval=$1                    # оставить как есть.
  else                           # Иначе,
    let &quot;absval = (( 0 - $1 ))&quot;  # изменить знак.
  fi

  return $absval
}


tolower ()             #  Преобразование строк символов в нижний регистр
{

  if [ -z &quot;$1&quot; ]       #  Если нет входного аргумента,
  then                 #+ выдать сообщение об ошибке
    echo &quot;(null)&quot;
    return             #+ и выйти из функции.
  fi

  echo &quot;$@&quot; | tr A-Z a-z
  # Преобразовать все входные аргументы ($@).

  return

# Для записи результата работы функции в переменную, используйте операцию подстановки команды.
# Например:
#    oldvar=&quot;A seT of miXed-caSe LEtTerS&quot;
#    newvar=`tolower &quot;$oldvar&quot;`
#    echo &quot;$newvar&quot;    # a set of mixed-case letters
#
# Упражнение: Добавьте в эту библиотеку функцию перевода символов в верхний регистр.
#           toupper()  [это довольно просто].
}
</pre>
          <br>
          <br>
        </li>

        <li>
          <p>Для повышения ясности комментариев, выделяйте их особым
          образом.</p>
<pre
 class="PROGRAMLISTING">
## Внимание!
rm -rf *.zzy   ##  Комбинация ключей &quot;-rf&quot;, в команде &quot;rm&quot;, чрезвычайно опасна,
               ##+ особенно при удалении по шаблону.

#+ Продолжение комментария на новой строке.
#  Это первая строка комментария
#+ это вторая строка комментария,
#+ это последняя строка комментария.

#* Обратите внимание.

#o Элемент списка.

#&gt; Альтернативный вариант.
while [ &quot;$var1&quot; != &quot;end&quot; ]    #&gt; while test &quot;$var1&quot; != &quot;end&quot;
</pre>
          <br>
          <br>
        </li>

        <li>
          <p>Для создания блочных комментариев, можно использовать
          конструкцию <a
           href="#c2171_html_TESTCONSTRUCTS1">if-test</a>.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

COMMENT_BLOCK=
#  Если попробовать инициализировать эту переменную чем нибудь,
#+ то вы получите неожиданный результат.

if [ $COMMENT_BLOCK ]; then

Блок комментария --
=================================
Это строка комментария.
Это другая строка комментария.
Это еще одна строка комментария.
=================================

echo &quot;Эта строка не выводится.&quot;

Этот блок комментария не вызывает сообщения об ошибке! Круто!

fi

echo &quot;Эта строка будет выведена на stdout.&quot;

exit 0
</pre>
          <br>
          <br>

          <p>Сравните этот вариант создания блочных комментариев со <a
           href="#c11785_html_CBLOCK1">встроенным документом,
          использующимся для создания блочных комментариев</a>.</p>
        </li>

        <li>
          <p>С помощью служебной переменной <a
           href="#c3270_html_XSTATVARREF">$?</a>, можно проверить --
          является ли входной аргумент целым числом.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

SUCCESS=0
E_BADINPUT=65

test &quot;$1&quot; -ne 0 -o &quot;$1&quot; -eq 0 2&gt;/dev/null
# Проверка: &quot;равно нулю или не равно нулю&quot;.
# 2&gt;/dev/null подавление вывода сообщений об ошибках.

if [ $? -ne &quot;$SUCCESS&quot; ]
then
  echo &quot;Порядок использования: `basename $0` целое_число&quot;
  exit $E_BADINPUT
fi

let &quot;sum = $1 + 25&quot;             # Будет выдавать ошибку, если $1 не является целым числом.
echo &quot;Sum = $sum&quot;

# Любая переменная может быть проверена таким образом, а не только входные аргументы.

exit 0
</pre>
          <br>
          <br>
        </li>

        <li>
          <p><a
           name="x13753_html_RVT"></a>Диапазон, возвращаемых функциями значений, 0
          - 255 -- серьезное ограничение. Иногда может оказаться весьма
          проблематичным использование глобальных переменных, для
          передачи результата из функции. В таких случаях можно
          порекомендовать передачу результатов работы функции через
          запись в <tt
           class="FILENAME">stdout</tt>.</p>

          <div
           class="EXAMPLE">
            <a
             name="x13753_html_MULTIPLICATION"></a>

            <p><strong>Пример 33-10. Необычный способ передачи
            возвращаемого значения</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# multiplication.sh

multiply ()                     # Функции выполняет перемножение всех переданых аргументов.
{
  local product=1

  until [ -z &quot;$1&quot; ]             # Пока не дошли до последнего аргумента...
  do
    let &quot;product *= $1&quot;
    shift
  done

  echo $product                 #  Значение не будет выведено на экран,
}                               #+ поскольку оно будет записано в переменную.

mult1=15383; mult2=25211
val1=`multiply $mult1 $mult2`
echo &quot;$mult1 X $mult2 = $val1&quot;
                                # 387820813

mult1=25; mult2=5; mult3=20
val2=`multiply $mult1 $mult2 $mult3`
echo &quot;$mult1 X $mult2 X $mult3 = $val2&quot;
                                # 2500

mult1=188; mult2=37; mult3=25; mult4=47
val3=`multiply $mult1 $mult2 $mult3 $mult4`
echo &quot;$mult1 X $mult2 X $mult3 X mult4 = $val3&quot;
                                # 8173300

exit 0
</pre>
          </div>

          <p>Такой прием срабатывает и для строковых значений. Таким
          образом, функция может <span
           class="QUOTE">&quot;возвращать&quot;</span> и нечисловой
          результат.</p>
<pre
 class="PROGRAMLISTING">
capitalize_ichar ()          #  Первый символ всех строковых аргументов
{                            #+ переводится в верхний регистр.

  string0=&quot;$@&quot;               # Принять все аргументы.

  firstchar=${string0:0:1}   # Первый символ.
  string1=${string0:1}       # Остаток строки.

  FirstChar=`echo &quot;$firstchar&quot; | tr a-z A-Z`
                             # Преобразовать в верхний регистр.

  echo &quot;$FirstChar$string1&quot;  # Выдать на stdout.

}

newstring=`capitalize_ichar &quot;each sentence should start with a capital letter.&quot;`
echo &quot;$newstring&quot;          # Each sentence should start with a capital letter.
</pre>
          <br>
          <br>

          <p>Используя этот прием, функция может <span
           class="QUOTE">&quot;возвращать&quot;</span> даже несколько
          значений.</p>

          <div
           class="EXAMPLE">
            <a
             name="x13753_html_SUMPRODUCT"></a>

            <p><strong>Пример 33-11. Необычный способ получения
            нескольких возвращаемых значений</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# sum-product.sh
# Функция может &quot;возвращать&quot; несколько значений.

sum_and_product ()   # Вычисляет сумму и произведение аргументов.
{
  echo $(( $1 + $2 )) $(( $1 * $2 ))
# Вывод на stdout двух значений, разделенных пробелом.
}

echo
echo &quot;Первое число: &quot;
read first

echo
echo &quot;Второе число: &quot;
read second
echo

retval=`sum_and_product $first $second`      # Получить результат.
sum=`echo &quot;$retval&quot; | awk &#39;{print $1}&#39;`      # Первое значение (поле).
product=`echo &quot;$retval&quot; | awk &#39;{print $2}&#39;`  # Второе значение (поле).

echo &quot;$first + $second = $sum&quot;
echo &quot;$first * $second = $product&quot;
echo

exit 0
</pre>
          </div>
        </li>

        <li>
          <p>Следующая хитрость -- передача <a
           href="#c12790_html_ARRAYREF">массива</a> в <a
           href="#c12483_html_FUNCTIONREF">функцию</a>, и <span
           class="QUOTE">&quot;возврат&quot;</span> массива из
          функции.</p>

          <p>Передача массива в функцию выполняется посредством записи
          элементов массива, разделенных пробелами, в переменную, с
          помощью операции <a
           href="#c11441_html_COMMANDSUBREF">подстановки команды</a>.
          Получить массив обратно можно, следуя вышеописанной
          стратегии, через вывод на stdout, а затем, с помощью все той
          же операции подстановки команды и оператора <strong
           class="COMMAND">( ... )</strong> -- записать в массив.</p>

          <div
           class="EXAMPLE">
            <a
             name="x13753_html_ARRFUNC"></a>

            <p><strong>Пример 33-12. Передача массива в функцию и
            возврат массива из функции</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# array-function.sh: Передача массива в функцию и...
#                   &quot;возврат&quot; массива из функции


Pass_Array ()
{
  local passed_array   # Локальная переменная.
  passed_array=( `echo &quot;$1&quot;` )
  echo &quot;${passed_array[@]}&quot;
  #  Список всех элементов в новом массиве,
  #+ объявленном и инициализированном в функции.
}


original_array=( element1 element2 element3 element4 element5 )

echo
echo &quot;original_array = ${original_array[@]}&quot;
#                      Список всех элементов исходного массива.


# Так можно отдать массив в функцию.
# **********************************
argument=`echo ${original_array[@]}`
# **********************************
#  Поместив все элементы массива в переменную,
#+ разделяя их пробелами.
#
# Обратите внимание: метод прямой передачи массива в функцию не сработает.


# Так можно получить массив из функции.
# *****************************************
returned_array=( `Pass_Array &quot;$argument&quot;` )
# *****************************************
# Записать результат в переменную-массив.

echo &quot;returned_array = ${returned_array[@]}&quot;

echo &quot;=============================================================&quot;

#  А теперь попробуйте получить доступ к локальному массиву
#+ за пределами функции.
Pass_Array &quot;$argument&quot;

# Функция выведет массив, но...
#+ доступ к локальному массиву, за пределами функции, окажется невозможен.
echo &quot;Результирующий массив (внутри функции) = ${passed_array[@]}&quot;
# &quot;ПУСТОЕ&quot; ЗНАЧЕНИЕ, поскольку это локальная переменная.

echo

exit 0
</pre>
          </div>

          <p>Более сложный пример передачи массивов в функции, вы
          найдете в <a
           href="#a14477_html_LIFESLOW">Пример A-11</a>.</p>
        </li>

        <li>
          <p>Использование конструкций с двойными круглыми скобками
          позволяет применять C-подобный синтаксис операций присвоения
          и инкремента переменных, а также оформления циклов <a
           href="#c4875_html_FORLOOPREF1">for</a> и <a
           href="#c4875_html_WHILELOOPREF">while</a>. См. <a
           href="#c4875_html_FORLOOPC">Пример 10-12</a> и <a
           href="#c4875_html_WHLOOPC">Пример 10-17</a>.</p>
        </li>

        <li>
          <p>Иногда очень удобно &quot;пропускать&quot; данные через
          один и тот же фильтр, но с разными параметрами, используя
          конвейерную обработку. Особенно это относится к <a
           href="#x7050_html_TRREF">tr</a> и <a
           href="#x7050_html_GREPREF">grep</a>.</p>
<pre
 class="PROGRAMLISTING">
# Из примера &quot;wstrings.sh&quot;.

wlist=`strings &quot;$1&quot; | tr A-Z a-z | tr &#39;[:space:]&#39; Z | \
tr -cs &#39;[:alpha:]&#39; Z | tr -s &#39;\173-\377&#39; Z | tr Z &#39; &#39;`
</pre>
          <br>
          <br>

          <div
           class="EXAMPLE">
            <a
             name="x13753_html_AGRAM"></a>

            <p><strong>Пример 33-13. Игры с анаграммами</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# agram.sh: Игры с анаграммами.

# Поиск анаграмм...
LETTERSET=etaoinshrdlu

anagram &quot;$LETTERSET&quot; | # Найти все анаграммы в наборе символов...
grep &#39;.......&#39; |       # состоящие, как минимум из 7 символов,
grep &#39;^is&#39; |           # начинающиеся с &#39;is&#39;
grep -v &#39;s$&#39; |         # исключая множественное число
grep -v &#39;ed$&#39;          # и глаголы в прошедшем времени

#  Здесь используется утилита &quot;anagram&quot;
#+ которая входит в состав пакета &quot;yawl&quot; , разработанного автором.
#  http://ibiblio.org/pub/Linux/libs/yawl-0.2.tar.gz

exit 0                 # Конец.

bash$ sh agram.sh
islander
isolate
isolead
isotheral
</pre>
          </div>

          <p>См. также <a
           href="#x12987_html_CONSTAT">Пример 27-2</a>, <a
           href="#x7050_html_CRYPTOQUOTE">Пример 12-18</a> и <a
           href="#a14477_html_SOUNDEX">Пример A-10</a>.</p>
        </li>

        <li>
          <p>Для создания блочных комментариев можно использовать <span
           class="QUOTE">&quot;<a
           href="#c11785_html_ANONHEREDOC0">анонимные встроенные
          документы</a>&quot;</span>. См. <a
           href="#c11785_html_COMMENTBLOCK">Пример 17-10</a>.</p>
        </li>

        <li>
          <p>Попытка вызова утилиты из сценария на машине, где эта
          утилита отсутствует, потенциально опасна. Для обхода подобных
          проблем можно воспользоваться утилитой <a
           href="#x7794_html_WHATISREF">whatis</a>.</p>
<pre
 class="PROGRAMLISTING">
CMD=command1                 # Основной вариант.
PlanB=command2               # Запасной вариант.

command_test=$(whatis &quot;$CMD&quot; | grep &#39;nothing appropriate&#39;)
#  Если &#39;command1&#39; не найдена в системе, то &#39;whatis&#39; вернет
#+ &quot;command1: nothing appropriate.&quot;
#==&gt; От переводчика: Будьте внимательны! Если у вас локализованная версия whatis
#==&gt; то вывод от нее может отличаться от используемого здесь (&#39;nothing appropriate&#39;)


if [[ -z &quot;$command_test&quot; ]]  # Проверка наличия утилиты в системе.
then
  $CMD option1 option2       #  Запуск команды с параметрами.
else                         #  Иначе,
  $PlanB                     #+ запустить command2 (запасной вариант).
fi
</pre>
          <br>
          <br>
        </li>

        <li>
          <p>Команда <a
           href="#x9307_html_RUNPARTSREF">run-parts</a> удобна для
          запуска нескольких сценариев, особенно в комбинации с <a
           href="#c9708_html_CRONREF">cron</a> или <a
           href="#x6837_html_ATREF">at</a>.</p>
        </li>

        <li>
          <p>Было бы неплохо снабдить сценарий графическим интерфейстом
          X-Window. Для этого можно порекомендовать пакеты <span
           class="emphasis"><em
           class="EMPHASIS">Xscript</em></span>, <span
           class="emphasis"><em
           class="EMPHASIS">Xmenu</em></span> и <span
           class="emphasis"><em
           class="EMPHASIS">widtools</em></span>. Правда, первые два,
          кажется больше не поддерживаются разработчиками. Зато <span
           class="emphasis"><em
           class="EMPHASIS">widtools</em></span> можно получить <a
           href=
          "http://www.batse.msfc.nasa.gov/~mallozzi/home/software/xforms/src/widtools-2.0.tgz"
           target="_top">здесь</a>.</p>

          <div
           class="CAUTION">
            <table
             class="CAUTION"
             width="90%"
             border="0">
              <tr>
                <td
                 width="25"
                 align="center"
                 valign="top"><img
                 src="misc/abs-book/images/caution.gif"
                 hspace="5"
                 alt="Caution"></td>

                <td
                 align="left"
                 valign="top">
                  <p>Пакет <span
                   class="emphasis"><em
                   class="EMPHASIS">widtools</em></span> (widget tools)
                  требует наличия библиотеки <span
                   class="emphasis"><em
                   class="EMPHASIS">XForms</em></span>. Кроме того,
                  необходимо слегка подправить <a
                   href="#x7794_html_MAKEFILEREF">Makefile</a>, чтобы
                  этот пакет можно было собрать на типичной
                  Linux-системе. Но хуже всего то, что три из шести
                  виджетов не работают :-(( (segfault).</p>
                </td>
              </tr>
            </table>
          </div>

          <p>Для постороения приложений с графическим интерфейсом,
          можно попробовать <span
           class="emphasis"><em
           class="EMPHASIS">Tk</em></span>, или <span
           class="emphasis"><em
           class="EMPHASIS">wish</em></span> (надстройка над <span
           class="emphasis"><em
           class="EMPHASIS">Tcl</em></span>), <span
           class="emphasis"><em
           class="EMPHASIS">PerlTk</em></span> (Perl с поддержкой Tk),
          <span
           class="emphasis"><em
           class="EMPHASIS">tksh</em></span> (ksh с поддержкой Tk),
          <span
           class="emphasis"><em
           class="EMPHASIS">XForms4Perl</em></span> (Perl с поддержкой
          XForms), <span
           class="emphasis"><em
           class="EMPHASIS">Gtk-Perl</em></span> (Perl с поддержкой
          Gtk) или <span
           class="emphasis"><em
           class="EMPHASIS">PyQt</em></span> (Python с поддержкой
          Qt).</p>
        </li>
      </ul>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x13734_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x13884_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Оптимизация</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c13505_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Проблемы безопасности</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x13884_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x13753_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 33. Разное</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x13898_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x13884_html_SECURITYISSUES"></a>33.8. Проблемы безопасности</h1>

      <p>Уместным будет лишний раз предупредить о соблюдении мер
      предосторожности при работе с незнакомыми сценариями. Сценарий
      может содержать <span
       class="emphasis"><em
       class="EMPHASIS">червя</em></span>, <span
       class="emphasis"><em
       class="EMPHASIS">трояна</em></span> или даже <span
       class="emphasis"><em
       class="EMPHASIS">вирус</em></span>. Если вы получили сценарий не
      из источника, которому доверяете, то никогда не запускайте его с
      привилегиями root и не позволяйте вставлять его в список
      сценариев начальной инициализации системы в <tt
       class="FILENAME">/etc/rc.d</tt>, пока не убедитесь в том, что он
      безвреден для системы.</p>

      <p>Исследователи из Bell Labs и других организаций, включая M.
      Douglas McIlroy, Tom Duff, и Fred Cohen исследовали вопрос о
      возможности создания вирусов на языке сценариев командной
      оболочки, и пришли к выводу, что это делается очень легко и
      доступно даже для новичков. <a
       name="AEN13892"
       href="#x13884_html_FTN_AEN13892"><span
       class="footnote">[1]</span></a></p>

      <p>Это еще одна из причин, по которым следует изучать язык
      командной оболочки. Способность читать и понимать сценарии
      поможет вам предотвратить возможность взлома и/или разрушения
      вашей системы.</p>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN13892"
         href="#x13884_html_AEN13892"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>См. статью Marius van Oers, <a
           href=
          "http://www.virusbtn.com/magazine/archives/200204/malshell.xml"
           target="_top">Unix Shell Scripting Malware</a>, а также
          ссылку на <span
           class="emphasis"><em
           class="EMPHASIS">Denning</em></span> в разделе <a
           href="#b14059_html_BIBLIOREF">Литература</a>.</p>
        </td>
      </tr>
    </table>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x13753_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x13898_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Разные советы</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c13505_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Проблемы переносимости</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x13898_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x13884_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 33. Разное</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x13930_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x13898_html_PORTABILITYISSUES"></a>33.9. Проблемы переносимости</h1>

      <p>Эта книга делает упор на создании сценариев для командной
      оболочки Bash, для операционной системы GNU/Linux. Тем не менее,
      многие рекомендации, приводимые здесь, могут быть вполне
      применимы и для других командных оболочек, таких как <strong
       class="COMMAND">sh</strong> и <strong
       class="COMMAND">ksh</strong>.</p>

      <p>Многие версии командных оболочек стремятся следовать стандарту
      POSIX 1003.2. Вызывая Bash с ключом <tt
       class="OPTION">--posix</tt>, или вставляя <strong
       class="COMMAND">set -o posix</strong> в начало сценария, вы
      можете заставить Bash очень близко следовать этому стандарту. Но,
      даже без этого ключа, большинство сценариев, написанных для Bash,
      будут работать под управлением <strong
       class="COMMAND">ksh</strong>, и наоборот, т.к. Chet Ramey
      перенес многие особенности, присущие <strong
       class="COMMAND">ksh</strong>, в последние версии Bash.</p>

      <p>В коммерческих версиях UNIX, сценарии, использующие GNU-версии
      стандартных утилит и команд, могут оказаться неработоспособными.
      Однако, с течением времени, таких проблем остается все меньше и
      меньше, поскольку утилиты GNU, в большинстве своем, заместили
      свои проприетарные аналоги в UNIX. После того, как <a
       href=
      "http://linux.oreillynet.com/pub/a/linux/2002/02/28/caldera.html"
       target="_top">Caldera дала разрешение на публикацию исходного
      кода</a> некоторых версий оригинальных утилит UNIX, этот процесс
      значительно ускорился.</p>

      <p>Bash имеет некоторые особенности, недоступные в традиционном
      Bourne shell. Среди них:</p>

      <ul>
        <li>
          <p>Некоторые дополнительные <a
           href="#c13228_html_INVOCATIONOPTIONSREF">ключи вызова</a></p>
        </li>

        <li>
          <p><a
           href="#c11441_html_COMMANDSUBREF">Подстановка команд</a>, с
          использованием нотации <strong
           class="COMMAND">$( )</strong></p>
        </li>

        <li>
          <p>Некоторые <a
           href="#x4171_html_STRINGMANIP">операции над строками</a></p>
        </li>

        <li>
          <p><a
           href="#c12434_html_PROCESSSUBREF">Подстановка
          процессов</a></p>
        </li>

        <li>
          <p><a
           href="#c5358_html_BUILTINREF">встроенные команды</a> Bash</p>
        </li>
      </ul>
      <br>
      <br>

      <p>Более подробный список характерных особенностей Bash, вы
      найдете в <a
       href="ftp://ftp.cwru.edu/pub/bash/FAQ"
       target="_top">Bash F.A.Q.</a>.</p>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x13884_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x13930_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Проблемы безопасности</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c13505_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Сценарии командной оболочки под Windows</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x13930_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x13898_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 33. Разное</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#c13936_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x13930_html_WINSCRIPT"></a>33.10. Сценарии командной оболочки под
      Windows</h1>

      <p>Даже те пользователи, которые работают в <span
       class="emphasis"><em
       class="EMPHASIS">другой</em></span>, не UNIX-подобной
      операционной системе, смогут запускать сценарии командной
      оболочки, а потому -- найти для себя много полезного в этой
      книге. Пакеты <a
       href="http://sourceware.cygnus.com/cygwin/"
       target="_top">Cygwin</a> от Cygnus, и <a
       href="http://www.mkssoftware.com/"
       target="_top">MKS utilities</a> от Mortice Kern Associates,
      позволяют дополнить Windows возможностями командной оболочки.</p>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x13898_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#c13936_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Проблемы переносимости</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c13505_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Bash, версия 2</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x13968_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#c13962_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 35. Замечания и дополнения</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x13981_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x13968_html_ABOUTAUTHOR"></a>35.2. Об авторе</h1>

      <p>Автор не стремится ни к званиям, ни к наградам, им движет
      неодолимое желание писать. <a
       name="AEN13971"
       href="#x13968_html_FTN_AEN13971"><span
       class="footnote">[1]</span></a> Эта книга -- своего рода отдых
      от основной работы, <a
       href="http://personal.riverusers.com/~thegrendel/hmw50.zip"
       target="_top">HOW-2 Meet Women: The Shy Man&#39;s Guide to
      Relationships</a> (Руководство Застенчивого Мужчины о том Как
      Познакомиться С Женщиной) . Он также написал <a
       href="http://tldp.org/HOWTO/Software-Building-HOWTO.html"
       target="_top">Software-Building HOWTO</a>.</p>

      <p>Пользуется Linux с 1995 года (Slackware 2.2, kernel 1.2.1).
      Выпустил несколько программ, среди которых <a
       href="http://ibiblio.org/pub/Linux/utils/file/cruft-0.2.tar.gz"
       target="_top">cruft</a> -- утилита шифрования, заменявшая
      стандартную UNIX-овую crypt, <a
       href=
      "http://ibiblio.org/pub/Linux/apps/financial/mcalc-1.6.tar.gz"
       target="_top">mcalc</a> -- финансовый калькулятор, для
      выполнения расчетов по займам, <a
       href=
      "http://ibiblio.org/pub/Linux/games/amusements/judge-1.0.tar.gz"
       target="_top">judge</a> и <a
       href="http://ibiblio.org/pub/Linux/libs/yawl-0.2.tar.gz"
       target="_top">yawl</a> -- пакет игр со словами. Программировать
      начинал с языка FORTRAN IV на CDC 3800, но не испытывает
      ностальгии по тем дням.</p>

      <p>Живет в глухой, заброшенной деревушке со своей женой и
      собакой.</p>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN13971"
         href="#x13968_html_AEN13971"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Кто может -- тот делает. Кто не может... тот получает
          сертификат MCSE.</p>
        </td>
      </tr>
    </table>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#c13962_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x13981_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Замечания и дополнения</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c13962_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Инструменты, использовавшиеся при создании
          книги</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x13981_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x13968_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 35. Замечания и дополнения</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x14001_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x13981_html_TOOLSUSED"></a>35.3. Инструменты, использовавшиеся при
      создании книги</h1>

      <div
       class="SECT2">
        <h2
         class="SECT2"><a
         name="x13981_html_SOFTWARE-HARDWARE"></a>35.3.1. Аппаратура</h2>

        <p>IBM Thinkpad, model 760XL laptop (P166, 104 Mb RAM) под
        управлением Red Hat 7.1/7.3. Несомненно, это довольно
        медлительный агрегат, но он имеет отличную клавиатуру, и это
        много лучше, чем пара карандашей и письменный стол.</p>
      </div>

      <div
       class="SECT2">
        <h2
         class="SECT2"><a
         name="x13981_html_SOFTWARE-PRINTWARE"></a>35.3.2. Программное
        обеспечение</h2>

        <ol
         type="i">
          <li>
            <p>Мощный текстовый редактор <a
             href="http://www.vim.org"
             target="_top">vim</a> (автор: Bram Moolenaar) .</p>
          </li>

          <li>
            <p><a
             href="http://www.netfolder.com/DSSSL/"
             target="_top">OpenJade</a> -- инструмент, выполняющий, на
            основе DSSSL, верификацию и преобразование SGML-документов
            в другие форматы.</p>
          </li>

          <li>
            <p><a
             href="http://nwalsh.com/docbook/dsssl/"
             target="_top">Таблицы стилей DSSSL от Norman
            Walsh</a>.</p>
          </li>

          <li>
            <p><span
             class="emphasis"><em
             class="EMPHASIS">DocBook, The Definitive Guide</em></span>
            (Norman Walsh, Leonard Muellner O&#39;Reilly, ISBN
            1-56592-580-7). Полное руководство по созданию документов в
            формате Docbook SGML.</p>
          </li>
        </ol>
      </div>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x13968_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x14001_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Об авторе</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c13962_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Благодарности</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x14001_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x13981_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 35. Замечания и дополнения</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#b14059_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x14001_html_CREDITS"></a>35.4. Благодарности</h1>

      <p>Без участия сообщества этот проект был бы невозможен. Автор
      признает, что без посторонней помощи, написание этой книги стало
      бы невыполнимой задачей и благодарит всех, кто оказал посильную
      помощь.</p>

      <p><a
       href="mailto:feloy@free.fr"
       target="_top">Philippe Martin</a> -- перевел этот документ в
      формат DocBook/SGML. Работает в маленькой французской компании, в
      качестве разработчика программного обеспечения. В свободное от
      работы время -- любит работать над документацией или программным
      обеспечением для GNU/Linux, читать книги, слушать музыку и
      веселиться с друзьями. Вы можете столкнуться с ним, где-нибудь во
      Франции, в провинции Басков, или написать ему письмо на <a
       href="mailto:feloy@free.fr"
       target="_top">feloy@free.fr</a>.</p>

      <p>Philippe Martin также отметил, что возможно использование
      позиционных параметров за $9, при использовании {фигурных
      скобок}, см. <a
       href="#x1716_html_EX17">Пример 4-5</a>.</p>

      <p><a
       href="mailto:stephane_chazelas@yahoo.fr"
       target="_top">Stephane Chazelas</a> -- выполнил титаническую
      работу по корректировке, дополнению и написанию примеров
      сценариев. Фактически, он взвалил на свои плечи обязанности
      <strong
       class="COMMAND">редактора</strong> этого документа. Огромное
      спасибо!</p>

      <p>Особенно я хотел бы поблагодарить <span
       class="emphasis"><em
       class="EMPHASIS">Patrick Callahan</em></span>, <span
       class="emphasis"><em
       class="EMPHASIS">Mike Novak</em></span> и <span
       class="emphasis"><em
       class="EMPHASIS">Pal Domokos</em></span> за исправление ошибок и
      неточностей, за разъяснения и дополнения. Их живое обсуждение
      проблем, связанных с созданием сценариев на языке командной
      оболочки вдохновило меня на попытку сделать этот документ более
      удобочитаемым.</p>

      <p>Я благодарен Jim Van Zandt за выявленные им ошибки и упущения,
      в версии 0.2 этого документа, и за поучительный пример
      сценария.</p>

      <p>Большое спасибо <a
       href="mailto:mikaku@fiwix.org"
       target="_top">Jordi Sanfeliu</a> за то, что он дал возможность
      использовать его прекрасный сценарий в этой книге (<a
       href="#a14477_html_TREE">Пример A-19</a>).</p>

      <p>Выражаю свою благодарность <a
       href="mailto:charpov@cs.unh.edu"
       target="_top">Michel Charpentier</a> за разрешение использовать
      его <a
       href="#x9199_html_DCREF">dc</a> сценарий разложения на простые
      множители (<a
       href="#x9199_html_FACTR">Пример 12-37</a>).</p>

      <p>Спасибо <a
       href="mailto:friedman@prep.ai.mit.edu"
       target="_top">Noah Friedman</a>, предоставившему право
      использовать его сценарий (<a
       href="#a14477_html_STRING">Пример A-20</a>).</p>

      <p><a
       href="mailto:emmanuel.rouat@wanadoo.fr"
       target="_top">Emmanuel Rouat</a> предложил несколько изменений и
      дополнений в разделах, посвященных <a
       href="#c11441_html_COMMANDSUBREF">подстановке команд</a> и <a
       href="#c12683_html_ALIASREF">псевдонимам</a>. Он так же
      предоставил замечательный пример файла <tt
       class="FILENAME">.bashrc</tt> (<a
       href="#a15124_html">Приложение G</a>).</p>

      <p><a
       href="mailto:heiner.steven@odn.de"
       target="_top">Heiner Steven</a> любезно разрешил опубликовать
      его сценарий <a
       href="#x9199_html_BASE">Пример 12-33</a>. Он сделал множество
      исправлений и внес большое количество предложений. Особое
      спасибо!</p>

      <p>Rick Boivie предоставил отличный сценарий, демонстрирующий
      рекурсию, <span
       class="emphasis"><em
       class="EMPHASIS">pb.sh</em></span> (<a
       href="#x13609_html_PBOOK">Пример 33-7</a>) и внес предложения по
      повышению производительности сценария <span
       class="emphasis"><em
       class="EMPHASIS">monthlypmt.sh</em></span> (<a
       href="#x9199_html_MONTHLYPMT">Пример 12-32</a>).</p>

      <p>Florian Wisser оказывал содействие при написании разделов,
      посвященных строкам (см. <a
       href="#x2565_html_STRTEST">Пример 7-6</a>).</p>

      <p>Oleg Philon передал свои предложения относительно команд <a
       href="#x7050_html_CUTREF">cut</a> и <a
       href="#c9708_html_PIDOFREF">pidof</a>.</p>

      <p>Michael Zick расширил пример с <a
       href="#c12790_html_EMPTYARRAY">пустыми массивами</a>, введя туда
      демонстрацию необычных свойств массивов. Он также предоставил ряд
      других примеров.</p>

      <p>Marc-Jano Knopp выполнил исправления в разделе, посвященном
      пакетным файлам DOS.</p>

      <p>Hyun Jin Cha, в процессе работы над корейским переводом,
      обнаружил несколько опечаток в документе. Спасибо ему за это!</p>

      <p>Andreas Abraham передал большое число типографских ошибок и
      внес ряд исправлений. Особое спасибо!</p>

      <p>Кроме того, я хотел бы выразить свою признательность Gabor
      Kiss, Leopold Toetsch, Peter Tillier, Marcus Berglof, Tony
      Richardson, Nick Drage, Rich Bartell, Jess Thrysoee, Adam Lazur,
      Bram Moolenaar, Baris Cicek, Greg Keraunen, Keith Matthews,
      Sandro Magi, Albert Reiner, Dim Segebart, Rory Winston, Lee
      Bigelow, Wayne Pollock, <span
       class="QUOTE">&quot;jipe&quot;</span>, Emilio Conti, Dennis
      Leeuw, Dan Jacobson и David Lawyer (автор 4-х HOWTO).</p>

      <p>Мои благодарности <a
       href="mailto:chet@po.cwru.edu"
       target="_top">Chet Ramey</a> и Brian Fox за создание <strong
       class="COMMAND">Bash</strong> -- этого элегантного и мощного
      инструмента!</p>

      <p>Особое спасибо добровольцам из <a
       href="http://www.tldp.org"
       target="_top">Linux Documentation Project</a>. Проект LDP сделал
      возможным публикацию этой книги в своем архиве.</p>

      <p>Больше всего я хотел бы выразить свою благодарность моей
      супруге, Anita, за ее эмоциональную поддержку.</p>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x13981_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#b14059_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Инструменты, использовавшиеся при создании
          книги</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c13962_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Литература</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x14802_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#a14586_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Приложение B. Маленький учебник по Sed и
          Awk</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#a14876_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x14802_html_AWK"></a>B.2. Awk</h1>

      <p><a
       name="x14802_html_AWKREF"></a></p>

      <p><strong
       class="COMMAND">Awk</strong> -- это полноценный язык обработки
      текстовой информации с синтаксисом, напоминающим синтаксис языка
      <strong
       class="COMMAND">C</strong>. Он обладает довольно широким набором
      возможностей, однако, мы рассмотрим лишь некоторые из них --
      наиболее употребимые в сценариях командной оболочки.</p>

      <p>Awk &quot;разбивает&quot; каждую строку на отдельные <span
       class="emphasis"><em
       class="EMPHASIS">поля</em></span>. По-умолчанию, поля -- это
      последовательности символов, отделенные друг от друга <a
       href="#c301_html_WHITESPACEREF">пробелами</a>, однако имеется
      возможность назначения других символов, в качестве разделителя
      полей. Awk анализирует и обрабатывает каждое поле в отдельности.
      Это делает его идеальным инструментом для работы со
      структурированными текстовыми файлами, осбенно с таблицами.</p>

      <p>Внутри сценариев командной оболочки, код awk, заключается в
      &quot;строгие&quot; (одиночные) кавычки и фигурные скобки.</p>
<pre
 class="PROGRAMLISTING">
awk &#39;{print $3}&#39; $filename
# Выводит содержимое 3-го поля из файла $filename на устройство stdout.

awk &#39;{print $1 $5 $6}&#39; $filename
# Выводит содержимое 1-го, 5-го и 6-го полей из файла $filename.
</pre>
      <br>
      <br>

      <p>Только что, мы рассмотрели действие команды <strong
       class="COMMAND">print</strong>. Еще, на чем мы остановимся --
      это переменные. Awk работает с переменными подобно сценариям
      командной оболочки, но более гибко.</p>
<pre
 class="PROGRAMLISTING">
{ total += ${column_number} }
</pre>
      Эта команда добавит содержимое переменной <span
       class="emphasis"><em
       class="EMPHASIS">column_number</em></span> к переменной <span
       class="QUOTE">&quot;total&quot;</span>. Чтобы, в завершение
      вывести <span
       class="QUOTE">&quot;total&quot;</span>, можно использовать
      команду <strong
       class="COMMAND">END</strong>, которая открывает блок кода,
      отрабатывающий после того, как будут обработаны все входные
      данные. 
<pre
 class="PROGRAMLISTING">
END { print total }
</pre>
      <br>
      <br>

      <p>Команде <strong
       class="COMMAND">END</strong>, соответствует команда <strong
       class="COMMAND">BEGIN</strong>, которая открывает блок кода,
      отрабатывающий перед началом обработки входных данных.</p>

      <p>Примеры использования awk в сценариях командной оболочки, вы
      найдете в:</p>

      <ol
       type="1">
        <li>
          <p><a
           href="#c5358_html_EX44">Пример 11-10</a></p>
        </li>

        <li>
          <p><a
           href="#x11731_html_REDIR4">Пример 16-7</a></p>
        </li>

        <li>
          <p><a
           href="#x7794_html_STRIPC">Пример 12-24</a></p>
        </li>

        <li>
          <p><a
           href="#x13541_html_COLTOTALER">Пример 33-3</a></p>
        </li>

        <li>
          <p><a
           href="#x4788_html_COLTOTALER2">Пример 9-22</a></p>
        </li>

        <li>
          <p><a
           href="#c5358_html_COLTOTALER3">Пример 11-16</a></p>
        </li>

        <li>
          <p><a
           href="#x12987_html_PIDID">Пример 27-1</a></p>
        </li>

        <li>
          <p><a
           href="#x12987_html_CONSTAT">Пример 27-2</a></p>
        </li>

        <li>
          <p><a
           href="#c4875_html_FILEINFO">Пример 10-3</a></p>
        </li>

        <li>
          <p><a
           href="#x9307_html_BLOTOUT">Пример 12-42</a></p>
        </li>

        <li>
          <p><a
           href="#x4812_html_SEEDINGRANDOM">Пример 9-26</a></p>
        </li>

        <li>
          <p><a
           href="#x6646_html_IDELETE">Пример 12-3</a></p>
        </li>

        <li>
          <p><a
           href="#x4171_html_SUBSTRINGEX">Пример 9-12</a></p>
        </li>

        <li>
          <p><a
           href="#x13753_html_SUMPRODUCT">Пример 33-11</a></p>
        </li>

        <li>
          <p><a
           href="#c4875_html_USERLIST">Пример 10-8</a></p>
        </li>
      </ol>
      <br>
      <br>

      <p>Это все, что я хотел рассказать об awk. Дополнительные ссылки
      на информацию об awk, вы найдете в разделе <a
       href="#b14059_html"><em>Литература</em></a>.</p>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#a14586_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#a14876_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Маленький учебник по Sed и Awk</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#a14586_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Коды завершения, имеющие предопределенный
          смысл</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x15542_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#a15523_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Приложение I. Упражнения</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#a15860_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x15542_html_WRITINGSCRIPTS"></a>I.2. Создание сценариев</h1>

      <p><a
       name="x15542_html_WRITINGSCRIPTS1"></a></p>

      <p>Напишите сценарии для выполнения повседневных задач.</p>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="x15542_html_EXEASY1"></a>Простые задания</strong></p>

        <dl>
          <dt><strong
           class="COMMAND">Содержимое домашнего каталога</strong></dt>

          <dd>
            <p>Выполните рекурсивный обход домашнего каталога и
            сохраните информацию в файл. Сожмите файл. Попросите
            пользователя вставить дискету и нажать клавишу <strong
             class="KEYCAP">ENTER</strong>. Запишите сжатый файл на
            дискету.</p>
          </dd>

          <dt><strong
           class="COMMAND">Замена цикла <a
           href="#c4875_html_FORLOOPREF1">for</a> циклами <a
           href="#c4875_html_WHILELOOPREF">while</a> и <a
           href="#c4875_html_UNTILLOOPREF">until</a></strong></dt>

          <dd>
            <p>Замените <span
             class="emphasis"><em
             class="EMPHASIS">циклы for</em></span> в <a
             href="#c4875_html_EX22">Пример 10-1</a> на <span
             class="emphasis"><em
             class="EMPHASIS">while</em></span>. Подсказка: запишите
            данные в <a
             href="#c12790_html_ARRAYREF">массив</a> и пройдите в цикле
            по элементам массива.</p>

            <p>Выполнив эту <span
             class="QUOTE">&quot;тяжелую работу&quot;</span>, замените
            циклы, в этом примере, на циклы <span
             class="emphasis"><em
             class="EMPHASIS">until</em></span> .</p>
          </dd>

          <dt><strong
           class="COMMAND">Изменение межстрочного интервала в текстовом
          файле</strong></dt>

          <dd>
            <p>Напишите сценарий, который будет читать текст из
            заданного файла, и выводить, построчно, на <tt
             class="FILENAME">stdout</tt>, добавляя при этом
            дополнительные пустые строки так, чтобы в результате
            получился вывод с <span
             class="emphasis"><em
             class="EMPHASIS">двойным межстрочным
            интервалом</em></span>.</p>

            <p>Добавьте код, который будет выполнять проверку наличия
            файла, передаваемого как аргумент.</p>

            <p>Когда сценарий будет отлажен, измените его так, чтобы он
            выводил текстовый файл с <span
             class="emphasis"><em
             class="EMPHASIS">тройным межстрочным
            интервалом</em></span>.</p>

            <p>И наконец, напишите сценарий, который будет удалять
            пустые строки из заданного файла.</p>
          </dd>

          <dt><strong
           class="COMMAND">Вывод
          &quot;задом-на-перед&quot;</strong></dt>

          <dd>
            <p>Напишите сценарий, который будет выводить себя на <tt
             class="FILENAME">stdout</tt>, но <span
             class="emphasis"><em
             class="EMPHASIS">в обратном порядке</em></span>.</p>
          </dd>

          <dt><strong
           class="COMMAND">Автоматическое
          разархивирование</strong></dt>

          <dd>
            <p>Для каждого файла, из заданного списка, сценарий должен
            определить тип архиватора, которым был создан тот или иной
            файл (с помощью утилиты <a
             href="#x7794_html_FILEREF">file</a>). Затем сценарий должен
            выполнить соответствующую команду разархивации (<strong
             class="COMMAND">gunzip</strong>, <strong
             class="COMMAND">bunzip2</strong>, <strong
             class="COMMAND">unzip</strong>, <strong
             class="COMMAND">uncompress</strong> или что-то иное). Если
            файл не является архивом, то сценарий должен оповестить
            пользователя об этом и ничего не делать с этим файлом.</p>
          </dd>

          <dt><strong
           class="COMMAND">Уникальный идентификатор
          системы</strong></dt>

          <dd>
            <p>Сценарий должен сгенерировать <span
             class="QUOTE">&quot;уникальный&quot;</span> 6-ти разрядный
            шестнадцатиричный идентификатор системы. <span
             class="emphasis"><em
             class="EMPHASIS">Не</em></span> пользуйтесь дефектной
            утилитой <a
             href="#c9708_html_HOSTIDREF">hostid</a>. Подсказка: <strong
             class="COMMAND"><a
             href="#x7794_html_MD5SUMREF">md5sum</a> <tt
             class="FILENAME">/etc/passwd</tt></strong>, затем отберите
            первые 6 цифр.</p>
          </dd>

          <dt><strong
           class="COMMAND">Резервное копирование</strong></dt>

          <dd>
            <p>Сценарий должен создать архив (<tt
             class="FILENAME">*.tar.gz</tt>) всех файлов в домашнем
            каталоге пользователя (<tt
             class="FILENAME">/home/user-name</tt>), которые изменялись
            в течение последних 24 часов. Подсказка: воспользуйтесь
            утилитой <a
             href="#x6646_html_FINDREF">find</a>.</p>
          </dd>

          <dt><strong
           class="COMMAND">Простые числа</strong></dt>

          <dd>
            <p>Сценарий должен вывести (на stdout) все простые числа, в
            диапазоне от 60000 до 63000. Вывод должен быть
            отформатирован по столбцам (подсказка: воспользуйтесь
            командой <a
             href="#c5358_html_PRINTFREF">printf</a>).</p>
          </dd>

          <dt><strong
           class="COMMAND">Лототрон</strong></dt>

          <dd>
            <p>Сценарий должен имитировать работу лототрона --
            извлекать 5 случайных неповторяющихся чисел в диапазоне 1 -
            50. Сценарий должен предусматривать как вывод на <tt
             class="FILENAME">stdout</tt>, так и запись чисел в файл,
            кроме того, вместе с числами должны выводиться дата и время
            генерации данного набора.</p>
          </dd>
        </dl>
      </div>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="x15542_html_EXMEDIUM1"></a>Задания повышенной сложности</strong></p>

        <dl>
          <dt><strong
           class="COMMAND">Управление дисковым
          пространством</strong></dt>

          <dd>
            <p>Сценарий должен отыскать в домашнем каталоге
            пользователя <tt
             class="FILENAME">/home/username</tt> файлы, имеющие размер
            больше 100K. Каждый раз предоставляя пользователю
            возможность удалить или сжать этот файл, затем переходить к
            поиску следующего файла.</p>
          </dd>

          <dt><strong
           class="COMMAND">Безопасное удаление</strong></dt>

          <dd>
            <p>Напишите сценарий <span
             class="QUOTE">&quot;безопасного&quot;</span> удаления
            файлов -- <tt
             class="FILENAME">srm.sh</tt>. Файлы, с именами,
            передаваемыми этому сценарию, не должны удаляться, вместо
            этого, файлы следует сжать утилитой <a
             href="#x7794_html_GZIPREF">gzip</a>, если они еще не сжаты
            (не забывайте про утилиту <a
             href="#x7794_html_FILEREF">file</a>), и переместить в
            каталог <tt
             class="FILENAME">/home/username/trash</tt>. При старте,
            сценарий должен удалять из каталога <span
             class="QUOTE">&quot;trash&quot;</span> файлы, которые были
            созданы более 48 часов тому назад.</p>
          </dd>

          <dt><strong
           class="COMMAND">Размен монет</strong></dt>

          <dd>
            <p>Как более рационально собрать сумму в $1.68, используя
            только монеты, с номиналом не выше 25c? Это будет шесть
            25-ти центовых монет, одна десятицентовая, одна
            пятицентовая и три монеты достоинством в 1 цент.</p>

            <p>Учитывая возможность произвольного ввода суммы в
            долларах и центах ($*.??), найдите такую комбинацию,
            которая требовала бы наименьшее число монет. Если вы
            проживаете не в США, то можете использовать свою денежную
            единицу и номиналы монет. Подсказка: взгляните на <a
             href="#c12483_html_EX61">Пример 22-4</a>.</p>
          </dd>

          <dt><strong
           class="COMMAND">Корни квадратного уравнения</strong></dt>

          <dd>
            <p>Напишите сценарий, который находил бы корни <span
             class="QUOTE">&quot;квадратного &quot;</span> уравнения,
            вида: <span
             class="emphasis"><em
             class="EMPHASIS">Ax^2 + Bx + C = 0</em></span>. Сценарий
            должен получать коэффициенты уравнения <tt
             class="USERINPUT"><strong>A</strong></tt>, <tt
             class="USERINPUT"><strong>B</strong></tt> и <tt
             class="USERINPUT"><strong>C</strong></tt>, как аргументы
            командной строки, и находить корни, с точностью до
            четвертого знака после запятой.</p>

            <p>Подсказка: воспользуйтесь <a
             href="#x9199_html_BCREF">bc</a>, для нахождения решения по
            хорошо известной формуле: <span
             class="emphasis"><em
             class="EMPHASIS">x = ( -B +/- sqrt( B^2 - 4AC ) ) /
            2A</em></span>.</p>
          </dd>

          <dt><strong
           class="COMMAND">Сумма чисел</strong></dt>

          <dd>
            <p>Найдите сумму всех пятизначных чисел (в диапазоне 10000
            - 99999), которые содержат <span
             class="emphasis"><em
             class="EMPHASIS">точно две</em></span> цифры из следующего
            набора: { 4, 5, 6 }.</p>

            <p>Примеры чисел, удовлетворяющих данному условию: 42057,
            74638 и 89515.</p>
          </dd>

          <dt><strong
           class="COMMAND">Счастливый билет</strong></dt>

          <dd>
            <p>&quot;Счастливым&quot; считается такой билет, в котором
            последовательное сложение цифр номера дает число 7.
            Например, 62431 -- номер &quot;счастливого&quot; билета (6
            + 2 + 4 + 3 + 1 = 16, 1 + 6 = 7). Найдите все
            &quot;счастливые&quot; номера, располагающиеся в диапазоне
            1000 - 10000.</p>
          </dd>

          <dt><strong
           class="COMMAND">Синтаксический анализ</strong></dt>

          <dd>
            <p>Проанализируйте файл <tt
             class="FILENAME">/etc/passwd</tt> и выведите его
            содержимое в табличном виде.</p>
          </dd>

          <dt><strong
           class="COMMAND">Просмотр файла с данными</strong></dt>

          <dd>
            <p>Некоторые базы данных и электронные таблицы используют
            формат CSV (<span
             class="emphasis"><em
             class="EMPHASIS">comma-separated values</em></span>), для
            хранения данных в файлах. Зачастую, эти файлы должны
            анализироваться другими приложениями.</p>

            <p>Пусть файл содержит следующие данные:</p>
<pre
 class="PROGRAMLISTING">
Jones,Bill,235 S. Williams St.,Denver,CO,80221,(303) 244-7989
Smith,Tom,404 Polk Ave.,Los Angeles,CA,90003,(213) 879-5612
...
</pre>
            Прочитайте данные и выведите их на <tt
             class="FILENAME">stdout</tt> в виде колонок с
            заголовками.<br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">Выравнивание</strong></dt>

          <dd>
            <p>Текст вводится с устройства <tt
             class="FILENAME">stdin</tt> или из файла. Его необходимо
            вывести на <tt
             class="FILENAME">stdout</tt>, с выравниванием по ширине,
            используя задаваемую пользователем ширину строк.</p>
          </dd>

          <dt><strong
           class="COMMAND">Список рассылки</strong></dt>

          <dd>
            <p>Напишите сценарий, который использовал бы команду <a
             href="#x8707_html_COMMMAIL1">mail</a>, для управления
            простым списком рассылки. Сценарий должен брать текст
            ежемесячного информационного бюллетеня из заданного файла,
            список адресатов из другого файла и выполнять рассылку
            новостей по электронной почте.</p>
          </dd>

          <dt><strong
           class="COMMAND">Пароли</strong></dt>

          <dd>
            <p>Сгенерируйте псевдослучайные 8-ми символьные пароли,
            используя символы из диапазона [0-9], [A-Z], [a-z]. Каждый
            пароль должен содержать не менее 2-х цифр.</p>
          </dd>
        </dl>
      </div>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="x15542_html_EXDIFFICULT1"></a>Сложные задания</strong></p>

        <dl>
          <dt><strong
           class="COMMAND">Регистрация обращений к файлам</strong></dt>

          <dd>
            <p>Попробуйте отследить все попытки обращения к файлам в
            каталоге <tt
             class="FILENAME">/etc</tt>, в течение дня. Сведения,
            которые включают в себя время обращения, имя файла, имя
            пользователя (если имели место какие либо изменения в
            файлах, то они тоже должны быть отмечены), запишите в виде
            аккуратно отформатированных записей в логфайл.</p>
          </dd>

          <dt><strong
           class="COMMAND">Удаление комментариев</strong></dt>

          <dd>
            <p>Удалите все комментарии из сценария, имя которого
            задается с командной строки. При этом, строка <span
             class="QUOTE">&quot;#! /bin/bash&quot;</span> не должна
            удаляться.</p>
          </dd>

          <dt><strong
           class="COMMAND">Преобразование в HTML</strong></dt>

          <dd>
            <p>Преобразуйте заданный текстовый файл в HTML формат. Этот
            сценарий должен автоматически вставлять необходимые теги
            HTML в тело файла.</p>
          </dd>

          <dt><strong
           class="COMMAND">Удаление тегов HTML</strong></dt>

          <dd>
            <p>Удалите все теги HTML из заданного HTML файла, затем
            переформатируйте его так, чтобы строки не были короче 60 и
            длиннее 75 символов. Предусмотрите оформление параграфов.
            Преобразуйте таблицы HTML в их приблизительный текстовый
            эквивалент.</p>
          </dd>

          <dt><strong
           class="COMMAND">Преобразование XML файлов</strong></dt>

          <dd>
            <p>Преобразуйте файл из формата XML в формат HTML и в
            простой текстовый файл.</p>
          </dd>

          <dt><a
           name="x15542_html_CSPAMMERS"></a><strong
           class="COMMAND">Борьба со спамом</strong></dt>

          <dd>
            <p>Напишите сценарий, который анализировал бы входящие
            почтовые сообщения на принадлежность к спаму и отыскивал бы
            в DNS имена узлов сети, по IP адресам из заголовка письма.
            Сценарий должен отправлять найденые спамерские сообщения
            ответственным за спам провайдерам (ISP). Естественно, вы
            должны отфильтровать <span
             class="emphasis"><em
             class="EMPHASIS">свой собственный IP адрес</em></span>,
            чтобы не случилось так, что вы жалуетесь на самого
            себя.</p>

            <p>По мере необходимости, используйте соответствующие <a
             href="#x8707_html_COMMUNINFO1">команды для работы с
            сетью</a>.</p>
          </dd>

          <dt><strong
           class="COMMAND">Азбука Морзе</strong></dt>

          <dd>
            <p>Преобразуйте текстовый файл в код Морзе. Символы из
            файла должны быть представлены в виде, соответствующих им,
            кодов Морзе, состоящих из точек и тире, и разделенных
            пробелами. Например, <span
             class="QUOTE">&quot;script&quot;</span> ===&gt; <span
             class="QUOTE">&quot;... _._. ._. .. .__.
            _&quot;</span>.</p>
          </dd>

          <dt><strong
           class="COMMAND">Шестнадцатиричный дамп</strong></dt>

          <dd>
            <p>Выведите, в виде шестнадцатиричного дампа, содержимое
            бинарного файла, передаваемого в сценарий, как аргумент
            командной строки. Вывод должен производиться в четкой
            табличной форме, первое поле таблицы -- адрес, далее должны
            следовать 8 полей, содержащие 4-х байтовые
            шестнадцатиричные числа, а завершать строку должно поле,
            содержащее эквивалентное отображение 8-ми предшествующих
            полей, в виде ASCII-символов.</p>
          </dd>

          <dt><strong
           class="COMMAND">Эмуляция сдвигового регистра</strong></dt>

          <dd>
            <p>Используя <a
             href="#c12790_html_STACKEX">Пример 25-9</a>, как образец,
            напишите сценарий, который эмулировал бы 64-х битный
            сдвиговый регистр в виде <a
             href="#c12790_html_ARRAYREF">массива</a>. Реализуйте
            функции <span
             class="emphasis"><em
             class="EMPHASIS">загрузки</em></span> значения в регистр,
            <span
             class="emphasis"><em
             class="EMPHASIS">сдвиг влево</em></span> и <span
             class="emphasis"><em
             class="EMPHASIS">сдвиг вправо</em></span>. В заключение,
            напишите функцию, которая интерпретировала бы содержимое
            &quot;регистра&quot; как восемь 8-ми битных символов
            ASCII.</p>
          </dd>

          <dt><strong
           class="COMMAND">Детерминант (определитель)</strong></dt>

          <dd>
            <p>Найдите детерминант (определитель) матрицы 4 x 4.</p>
          </dd>

          <dt><strong
           class="COMMAND">Анаграммы</strong></dt>

          <dd>
            <p>Сценарий должен запросить у пользователя 4-х символьное
            слово, и найти анаграммы для этого слова. Например,
            анаграммы к слову <span
             class="emphasis"><em
             class="EMPHASIS">word</em></span>: <span
             class="emphasis"><em
             class="EMPHASIS">do or rod row word</em></span>. Для
            поиска анаграмм можете использовать файл <tt
             class="FILENAME">/usr/share/dict/linux.words</tt>.</p>
          </dd>

          <dt><strong
           class="COMMAND">Индекс сложности текста</strong></dt>

          <dd>
            <p><span
             class="QUOTE">&quot;Индекс сложности текста&quot;</span>
            оценивает трудность понимания текста, как некое число,
            которое грубо соответствует количеству лет обучения в
            общеобразовательной школе. Например, индекс равный 8-ми
            говорит о том, что текст доступен для понимания человеку,
            окончившему 8-й класс общеобразовательной школы.</p>

            <p>Вычисление индекса ведется по следующему алгоритму.</p>

            <ol
             type="1">
              <li>
                <p>Выберите кусок текста, длиной не менее 100 слов.</p>
              </li>

              <li>
                <p>Сосчитайте количество предложений.</p>
              </li>

              <li>
                <p>Найдите среднее число слов в предложении.</p>

                <p>СРЕДНЕЕ_ЧИСЛО_СЛОВ = ОБЩЕЕ_ЧИСЛО_СЛОВ /
                ЧИСЛО_ПРЕДЛОЖЕНИЙ</p>
              </li>

              <li>
                <p>Сосчитайте количество <span
                 class="QUOTE">&quot;трудных&quot;</span> слов --
                которые содержат не менее 3-х слогов. Разделите это
                число на общее количество слов, в результате вы
                получите пропорцию сложных слов.</p>

                <p>ПРОПОРЦИЯ_СЛОЖНЫХ_СЛОВ = ЧИСЛО_ДЛИННЫХ_СЛОВ /
                ОБЩЕЕ_ЧИСЛО_СЛОВ</p>
              </li>

              <li>
                <p>Индекс сложности текста рассчитывается как сумма
                двух этих чисел, умноженная на 0.4 и округленная до
                ближайшего целого.</p>

                <p>ИНДЕКС_СЛОЖНОСТИ = int ( 0.4 * ( СРЕДНЕЕ_ЧИСЛО_СЛОВ
                + ПРОПОРЦИЯ_СЛОЖНЫХ_СЛОВ ) )</p>
              </li>
            </ol>

            <p>4-й пункт -- самый сложный. Существуют различные
            алгоритмы подсчета слогов в словах. В данном же случае, вы
            можете ограничиться подсчетом сочетаний
            &quot;гласный-согласный&quot;.</p>

            <p>Строго говоря, при расчете индекса сложности не следует
            считать составные слова и имена собственные как <span
             class="QUOTE">&quot;сложные&quot;</span> слова, но это
            слишком усложнит сценарий.</p>
          </dd>

          <dt><strong
           class="COMMAND">Вычисление числа пи по алгоритму &quot;Игла
          Баффона&quot;</strong></dt>

          <dd>
            <p>В 18 веке, французский математик де Баффон (de Buffon)
            проделывал эксперимент, который заключался в бросании иглы,
            длиной <span
             class="QUOTE">&quot;n&quot;</span>, на деревянный пол,
            собраный из длинных и узких досок. Ширина всех досок пола
            одинакова и равна <span
             class="QUOTE">&quot;d&quot;</span>. Оказалось, что
            отношение общего числа бросков, к числу бросков, когда игла
            ложилась на щель, кратно числу пи.</p>

            <p>Пользуясь <a
             href="#x9199_html_CANNON">Пример 12-35</a>, напишите
            сценарий, который использовал бы метод Монте Карло для
            эмуляции &quot;Иглы Баффона&quot;. Для простоты примите
            длину иглы раной ширине досок, <span
             class="emphasis"><em
             class="EMPHASIS">n = d</em></span>.</p>

            <p>Подсказка: особое значение здесь имеют переменные,
            которые будут вычисляться как расстояние от центра иглы до
            ближайшей щели и величина угла между иглой и щелью. Для
            выполнения расчетов можно воспользоваться утилитой <a
             href="#x9199_html_BCREF">bc</a>.</p>
          </dd>

          <dt><strong
           class="COMMAND">Шифрование по алгоритму
          Playfair</strong></dt>

          <dd>
            <p>Напишите сценарий, реализующий алгоритм шифрования
            Playfair (Wheatstone).</p>

            <p>В соответствии с этим алгоритмом, текст шифруется путем
            замены каждой 2-х символьной последовательности -- <span
             class="QUOTE">&quot;диграммы&quot;</span>. Традиционно, в
            качестве ключа, используется матрица символов алфавита 5 x
            5.</p>
<pre
 class="PROGRAMLISTING">
   C O D E S
   A B F G H
   I K L M N
   P Q R T U
   V W X Y Z
            
</pre>
            Матрица содержит все символы алфавита, за исключением
            символа &quot;J&quot;, который представляет символ
            &quot;I&quot;. Первая строка матрицы -- произвольно
            выбранное слово, в данном случае -- &quot;CODES&quot;,
            далее следуют символы алфавита, исключая те, которые входят
            в состав первой строки.<br>
            <br>

            <p>Шифрование производится по следующему алгоритму: для
            начала, текст сообщения разбивается на диграммы (группы по
            2 символа). Если в диграмму попадают два одинаковых
            символа, то второй символ удаляется, и формируется новая
            диграмма. Если в последней группе остается один символ, то
            такая &quot;неполная&quot; диграмма дополняется
            &quot;пустым&quot; символом, обычно &quot;X&quot;.</p>
<pre
 class="PROGRAMLISTING">
THIS IS A TOP SECRET MESSAGE

TH IS IS AT OP SE CR ET ME SA GE
            
</pre>
            Каждая диграмма может подпадать под одно из следующих
            определений:.<br>
            <br>

            <p>1) Оба символа находятся в одной строке ключа. Тогда,
            каждый из них заменяется символом, стоящим справа в той же
            строке. Если это последний символ строки ключа, то он
            заменяется первым символом в той же строке ключа.</p>

            <p>2) Оба символа находятся в одном столбце ключа. Тогда
            каждый из них заменяется на символ, стоящий ниже, в этом же
            столбце. Если это последний символ в столбце ключа, то он
            заменяется первым символом в том же столбце ключа.</p>

            <p>3) Символы диграммы стоят в вершинах прямоугольника.
            Тогда каждый из них заменяется символом из соседнего, по
            горизонтали, угла.</p>

            <p>Диграмма &quot;TH&quot; соответствует 3-му
            определению.</p>
<pre
 class="PROGRAMLISTING">
G H
M N
T U           (Прямоугольник с вершинами &quot;T&quot; и &quot;H&quot;)

T --&gt; U
H --&gt; G

            
</pre>
            <br>
            <br>

            <p>Диграмма &quot;SE&quot; соответствует 1-му
            определению.</p>
<pre
 class="PROGRAMLISTING">
C O D E S     (Строка содержит оба символа &quot;S&quot; и &quot;E&quot;)

S --&gt; C  (замена на первый символ в строке ключа)
E --&gt; S
            
</pre>
            <br>
            <br>

            <p>Дешифрация выполняется обратной процедурой, для случаев
            1 и 2 -- замена символом стоящим левее/выше. Для случая 3
            -- аналогично шифрации, т.е. заменяется символом из
            соседнего, по горизонтали, угла. Helen Fouche Gaines, в
            своей классической работе &quot;Elementary
            Cryptoanalysis&quot; (1939), приводит подробное описание
            алгоритма Playfair и методы его реализации.</p>

            <p>Этот сценарий должен иметь три основных раздела</p>

            <ol
             type="I">
              <li>
                <p>Генерация <span
                 class="QUOTE">&quot;ключевой матрицы&quot;</span>,
                основывающейся на слове, которое вводит
                пользователь.</p>
              </li>

              <li>
                <p>Шифрование <span
                 class="QUOTE">&quot;плоского&quot;</span> текста
                сообщения.</p>
              </li>

              <li>
                <p>Дешифрование зашифрованного текста.</p>
              </li>
            </ol>

            <p>Широкое применение, в этом сценарии, найдут <a
             href="#c12790_html_ARRAYREF">массивы</a> и <a
             href="#c12483_html_FUNCTIONREF">функции</a>.</p>
          </dd>
        </dl>
      </div>

      <p>--</p>

      <p>Пожалуйста, не присылайте автору свои варианты решения
      упражнений. Если вы хотите впечатлить его своим умом и
      сообразительностью -- присылайте обнаруженные вами ошибки и
      предложения по улучшению этой книги.</p>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#a15523_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#a15860_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Упражнения</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#a15523_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Авторские права</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x1673_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#c1613_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 4. Переменные и параметры.
          Введение.</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x1705_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x1673_html_VARASSIGNMENT"></a>4.2. Присваивание значений
      переменным</h1>

      <div
       class="VARIABLELIST">
        <dl>
          <dt><a
           name="x1673_html_EQREF"></a><span
           class="TOKEN">=</span></dt>

          <dd>
            <p>оператор присваивания (<span
             class="emphasis"><em
             class="EMPHASIS">пробельные символы до и после оператора
            -- недопустимы</em></span>)</p>

            <div
             class="CAUTION">
              <table
               class="CAUTION"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/caution.gif"
                   hspace="5"
                   alt="Caution"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Не путайте с операторами сравнения <a
                     href="#x2565_html_EQUALSIGNREF">=</a> и <a
                     href="#x2565_html_EQUALREF">-eq</a>!</p>

                    <p>Обратите внимание: символ <span
                     class="TOKEN">=</span> может использоваться как в
                    качестве оператора присваивания, так и в качестве
                    оператора сравнения, конкретная интерпретация
                    зависит от контекста применения.</p>
                  </td>
                </tr>
              </table>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="x1673_html_EX15"></a>

              <p><strong>Пример 4-2. Простое присваивание</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Явные переменные

echo

# Когда перед именем переменной не употребляется символ &#39;$&#39;?
# В операциях присваивания.

# Присваивание
a=879
echo &quot;Значение переменной \&quot;a\&quot; -- $a.&quot;

# Присваивание с помощью ключевого слова &#39;let&#39;
let a=16+5
echo &quot;Значение переменной \&quot;a\&quot; теперь стало равным: $a.&quot;

echo

# В заголовке цикла &#39;for&#39; (своего рода неявное присваивание)
echo -n &quot;Значения переменной \&quot;a\&quot; в цикле: &quot;
for a in 7 8 9 11
do
  echo -n &quot;$a &quot;
done

echo
echo

# При использовании инструкции &#39;read&#39; (тоже одна из разновидностей присваивания)
echo -n &quot;Введите значение переменной \&quot;a\&quot; &quot;
read a
echo &quot;Значение переменной \&quot;a\&quot; теперь стало равным: $a.&quot;

echo

exit 0
</pre>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="x1673_html_EX16"></a>

              <p><strong>Пример 4-3. Присваивание значений переменным
              простое и замаскированное</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

a=23              # Простейший случай
echo $a
b=$a
echo $b

# Теперь немного более сложный вариант (подстановка команд).

a=`echo Hello!`   # В переменную &#39;a&#39; попадает результат работы команды &#39;echo&#39;
echo $a
#  Обратите внимание на восклицательный знак (!) в подстанавливаемой команде
#+ этот вариант не будет работать при наборе в командной строке,
#+ поскольку здесь используется механизм &quot;истории команд&quot; BASH
#  Однако, в сценариях, механизм истории команд запрещен.

a=`ls -l`         # В переменную &#39;a&#39; записывается результат работы команды &#39;ls -l&#39;
echo $a           # Кавычки отсутствуют, удаляются лишние пробелы и пустые строки.
echo
echo &quot;$a&quot;         # Переменная в кавычках, все пробелы и пустые строки сохраняются.
                  # (См. главу &quot;Кавычки.&quot;)

exit 0
</pre>
            </div>

            <p>Присваивание переменных с использованием <span
             class="TOKEN">$(...)</span> (более современный метод, по
            сравнению с <a
             href="#c11441_html_BACKQUOTESREF">обратными
            кавычками</a>)</p>
<pre
 class="PROGRAMLISTING">
# Взято из /etc/rc.d/rc.local
R=$(cat /etc/redhat-release)
arch=$(uname -m)
</pre>
            <br>
            <br>
          </dd>
        </dl>
      </div>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#c1613_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x1705_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Переменные и параметры. Введение.</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c1613_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Переменные Bash не имеют типа</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x1705_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x1673_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 4. Переменные и параметры.
          Введение.</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x1716_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x1705_html_UNTYPED"></a>4.3. Переменные Bash не имеют типа</h1>

      <p><a
       name="x1705_html_BVUNTYPED"></a></p>

      <p>В отличие от большинства других языков программирования, Bash
      не производит разделения переменных по <span
       class="QUOTE">&quot;типам&quot;</span>. По сути, переменные Bash
      являются строковыми переменными, но, в зависимости от контекста,
      Bash допускает целочисленную арифметику с переменными.
      Определяющим фактором здесь служит содержимое переменных.</p>

      <div
       class="EXAMPLE">
        <a
         name="x1705_html_INTORSTRING"></a>

        <p><strong>Пример 4-4. Целое число или строка?</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# int-or-string.sh: Целое число или строка?

a=2334                   # Целое число.
let &quot;a += 1&quot;
echo &quot;a = $a &quot;           # a = 2335
echo                     # Все еще целое число.


b=${a/23/BB}             # замена &quot;23&quot; на &quot;BB&quot;.
                         # Происходит трансформация числа в строку.
echo &quot;b = $b&quot;            # b = BB35
declare -i b             # Явное указание типа здесь не поможет.
echo &quot;b = $b&quot;            # b = BB35

let &quot;b += 1&quot;             # BB35 + 1 =
echo &quot;b = $b&quot;            # b = 1
echo

c=BB34
echo &quot;c = $c&quot;            # c = BB34
d=${c/BB/23}             # замена &quot;BB&quot; на &quot;23&quot;.
                         # Переменная $d становится целочисленной.
echo &quot;d = $d&quot;            # d = 2334
let &quot;d += 1&quot;             # 2334 + 1 =
echo &quot;d = $d&quot;            # d = 2335
echo

# А что происходит с &quot;пустыми&quot; переменными?
e=&quot;&quot;
echo &quot;e = $e&quot;            # e =
let &quot;e += 1&quot;             # Арифметические операции допускают использование &quot;пустых&quot; переменных?
echo &quot;e = $e&quot;            # e = 1
echo                     # &quot;Пустая&quot; переменная становится целочисленной.

# А что происходит с необъявленными переменными?
echo &quot;f = $f&quot;            # f =
let &quot;f += 1&quot;             # Арифметические операции допустимы?
echo &quot;f = $f&quot;            # f = 1
echo                     # Необъявленная переменная трансформируется в целочисленную.



# Переменные Bash не имеют типов.

exit 0
</pre>
      </div>

      <p>Отсутствие типов -- это и благословение и проклятие. С одной
      стороны -- отсутствие типов делает сценарии более гибкими (чтобы
      повеситься -- достаточно иметь веревку!) и облегчает чтение кода.
      С другой -- является источником потенциальных ошибок и поощряет
      привычку к &quot;неряшливому&quot; программированию.</p>

      <p>Бремя отслеживания типа той или иной переменной полностью
      лежит на плечах программиста. Bash не будет делать это за
      вас!</p>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x1673_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x1716_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Присваивание значений переменным</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c1613_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Специальные типы переменных</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x1716_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x1705_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 4. Переменные и параметры.
          Введение.</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#c1833_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x1716_html_OTHERTYPESV"></a>4.4. Специальные типы переменных</h1>

      <div
       class="VARIABLELIST">
        <dl>
          <dt><tt
           class="REPLACEABLE"><em>локальные переменные</em></tt></dt>

          <dd>
            <p>переменные, область видимости которых ограничена <a
             href="#c301_html_CODEBLOCKREF">блоком кода</a> или телом
            функции (см так же <a
             href="#x12644_html">локальные переменные</a> в <a
             href="#c12483_html_FUNCTIONREF">функциях</a>)</p>
          </dd>

          <dt><a
           name="x1716_html_ENVREF"></a><tt
           class="REPLACEABLE"><em>переменные окружения</em></tt></dt>

          <dd>
            <p>переменные, которые затрагивают командную оболочку и
            порядок взаимодействия с пользователем</p>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>В более общем контексте, каждый процесс имеет
                    некоторое <span
                     class="QUOTE">&quot;окружение&quot;</span> (среду
                    исполнения), т.е. набор переменных, к которым
                    процесс может обращаться за получением определенной
                    информации. В этом смысле командная оболочка
                    подобна любому другому процессу.</p>

                    <p>Каждый раз, когда запускается командный
                    интерпретатор, для него создаются переменные,
                    соответствующие переменным окружения. Изменение
                    переменных или добавление новых переменных
                    окружения заставляет оболочку обновить свои
                    переменные, и все дочерние процессы (и команды,
                    исполняемые ею) наследуют это окружение.</p>
                  </td>
                </tr>
              </table>
            </div>

            <div
             class="CAUTION">
              <table
               class="CAUTION"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/caution.gif"
                   hspace="5"
                   alt="Caution"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Пространство, выделяемое под переменные
                    окружения, ограничено. Создание слишком большого
                    количества переменных окружения или одной
                    переменной, которая занимает слишком большое
                    пространство, может привести к возникновению
                    определенных проблем.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>eval &quot;`seq 10000 | sed -e &#39;s/.*/export var&amp;=ZZZZZZZZZZZZZZ/&#39;`&quot;</strong></tt>

<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>du</strong></tt>
<tt
 class="COMPUTEROUTPUT">bash: /usr/bin/du: Argument list too long</tt>
                 
</pre>
                    <br>
                    <br>

                    <p>(Спасибо S. C. за вышеприведенный пример и
                    пояснения.)</p>
                  </td>
                </tr>
              </table>
            </div>

            <p>Если сценарий изменяет переменные окружения, то они
            должны <span
             class="QUOTE">&quot;экспортироваться&quot;</span>, т.е
            передаваться окружению, локальному по отношению к сценарию.
            Эта функция возложена на команду <a
             href="#c5358_html_EXPORTREF">export</a>.</p>
            <a
             name="x1716_html_CHILDREF"></a>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Сценарий может <strong
                     class="COMMAND">экспортировать</strong> переменные
                    только дочернему процессу, т.е. командам и
                    процессам запускаемым из данного сценария.
                    Сценарий, запускаемый из командной строки <tt
                     class="REPLACEABLE"><em>не может</em></tt>
                    экспортировать переменные &quot;на верх&quot;
                    командной оболочке. <a
                     href="#c5358_html_FORKREF">Дочерний процесс</a> не
                    может экспортировать переменные родительскому
                    процессу.</p>
                  </td>
                </tr>
              </table>
            </div>

            <p>---</p>
          </dd>

          <dt><a
           name="x1716_html_POSPARAMREF1"></a><tt
           class="REPLACEABLE"><em>позиционные параметры</em></tt></dt>

          <dd>
            <p>аргументы, передаваемые скрипту из командной строки --
            $0, $1, $2, $3..., где $0 -- это название файла сценария,
            $1 -- это первый аргумент, $2 -- второй, $3 -- третий и так
            далее. <a
             name="AEN1772"
             href="#x1716_html_FTN_AEN1772"><span
             class="footnote">[1]</span></a> <a
             name="x1716_html_BRACKETNOTATION"></a>Аргументы, следующие за $9,
            должны заключаться в фигурные скобки, например: ${10},
            ${11}, ${12}.</p>

            <p>Специальные переменные <a
             href="#c3270_html_APPREF">$* и $@</a> содержат <span
             class="emphasis"><em
             class="EMPHASIS">все</em></span> позиционные параметры
            (аргументы командной строки).</p>

            <div
             class="EXAMPLE">
              <a
               name="x1716_html_EX17"></a>

              <p><strong>Пример 4-5. Позиционные параметры</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Команда вызова сценария должна содержать по меньшей мере 10 параметров, например
# ./scriptname 1 2 3 4 5 6 7 8 9 10
MINPARAMS=10

echo

echo &quot;Имя файла сценария: \&quot;$0\&quot;.&quot;
# Для текущего каталога добавит ./
echo &quot;Имя файла сценария: \&quot;`basename $0`\&quot;.&quot;
# Добавит путь к имени файла (см. &#39;basename&#39;)

echo

if [ -n &quot;$1&quot; ]              # Проверяемая переменная заключена в кавычки.
then
 echo &quot;Параметр #1: $1&quot;     # необходимы кавычки для экранирования символа #
fi

if [ -n &quot;$2&quot; ]
then
 echo &quot;Параметр #2: $2&quot;
fi

if [ -n &quot;$3&quot; ]
then
 echo &quot;Параметр #3: $3&quot;
fi

# ...


if [ -n &quot;${10}&quot; ]  # Параметры, следующие за $9 должны заключаться в фигурные скобки
then
 echo &quot;Параметр #10: ${10}&quot;
fi

echo &quot;-----------------------------------&quot;
echo &quot;Все аргументы командной строки: &quot;$*&quot;&quot;

if [ $# -lt &quot;$MINPARAMS&quot; ]
then
  echo
  echo &quot;Количество аргументов командной строки должно быть не менее $MINPARAMS !&quot;
fi

echo

exit 0
</pre>
            </div>

            <p><span
             class="emphasis"><em
             class="EMPHASIS">Скобочная нотация</em></span> позиционных
            параметров дает довольно простой способ обращения к <span
             class="emphasis"><em
             class="EMPHASIS">последнему</em></span> аргументу,
            переданному в сценарий из командной строки. Такой способ
            подразумевает использование <a
             href="#c13936_html_VARREFNEW">косвенной адресации</a>.</p>
<pre
 class="PROGRAMLISTING">
args=$#           # Количество переданных аргументов.
lastarg=${!args}  # Обратите внимание: lastarg=${!$#} неприменимо.
</pre>
            <br>
            <br>

            <p>В сценарии можно предусмотреть различные варианты
            развития событий, в зависимости от имени сценария. Для
            этого сценарий должен проанализировать аргумент <tt
             class="VARNAME">$0</tt> -- имя файла сценария. Это могут
            быть и имена символических ссылок на файл сценария.</p>

            <div
             class="TIP">
              <table
               class="TIP"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/tip.gif"
                   hspace="5"
                   alt="Tip"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Если сценарий ожидает передачи аргументов в
                    командной строке, то при их отсутствии он получит
                    &quot;пустые&quot; переменные, что может вызвать
                    нежелательный побочный эффект. Один из способов
                    борьбы с подобными ошибками -- добавить
                    дополнительный символ в обеих частях операции
                    присваивания, где используются аргументы командной
                    строки.</p>
                  </td>
                </tr>
              </table>
            </div>
<pre
 class="PROGRAMLISTING">
variable1_=$1_
# Это предотвратит появление ошибок, даже при отсутствии входного аргумента.

critical_argument01=$variable1_

# Дополнительные символы всегда можно &quot;убрать&quot; позднее.
# Это может быть сделано примерно так:
variable1=${variable1_/_/}   # Побочный эффект возникает только если имя переменной
                             # $variable1_ будет начинаться с символа &quot;_&quot;.
# Здесь используется один из вариантов подстановки параметров, обсуждаемых в Главе 9.
# Отсутствие шаблона замены приводит к удалению.

# Более простой способ заключается
#+ в обычной проверке наличия позиционного параметра.
if [ -z $1 ]
then
  exit $POS_PARAMS_MISSING
fi
</pre>

            <p>---</p>

            <div
             class="EXAMPLE">
              <a
               name="x1716_html_EX18"></a>

              <p><strong>Пример 4-6. wh, <a
               href="#x8707_html_WHOISREF">whois</a> выяснение имени
              домена</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Команда &#39;whois domain-name&#39; выясняет имя домена на одном из 3 серверов:
#                    ripe.net, cw.net, radb.net

# Разместите этот скрипт под именем &#39;wh&#39; в каталоге /usr/local/bin

# Требуемые символические ссылки:
# ln -s /usr/local/bin/wh /usr/local/bin/wh-ripe
# ln -s /usr/local/bin/wh /usr/local/bin/wh-cw
# ln -s /usr/local/bin/wh /usr/local/bin/wh-radb


if [ -z &quot;$1&quot; ]
then
  echo &quot;Порядок использования: `basename $0` [domain-name]&quot;
  exit 65
fi

case `basename $0` in
# Проверка имени скрипта и, соответственно, имени сервера
    &quot;wh&quot;     ) whois $1@whois.ripe.net;;
    &quot;wh-ripe&quot;) whois $1@whois.ripe.net;;
    &quot;wh-radb&quot;) whois $1@whois.radb.net;;
    &quot;wh-cw&quot;  ) whois $1@whois.cw.net;;
    *        ) echo &quot;Порядок использования: `basename $0` [domain-name]&quot;;;
esac

exit 0
</pre>
            </div>

            <p>---</p>

            <p><a
             name="x1716_html_SHIFTREF"></a></p>

            <p>Команда <strong
             class="COMMAND">shift</strong> &quot;сдвигает&quot;
            позиционные параметры, в результате чего парметры
            &quot;сдвигаются&quot; на одну позицию влево.</p>

            <p><tt
             class="VARNAME">$1</tt> &lt;--- <tt
             class="VARNAME">$2</tt>, <tt
             class="VARNAME">$2</tt> &lt;--- <tt
             class="VARNAME">$3</tt>, <tt
             class="VARNAME">$3</tt> &lt;--- <tt
             class="VARNAME">$4</tt>, и т.д.</p>

            <p>Прежний аргумент <tt
             class="VARNAME">$1</tt> теряется, но аргумент <span
             class="emphasis"><em
             class="EMPHASIS"><tt
             class="VARNAME">$0</tt> (имя файла сценария) остается без
            изменений</em></span>. Если вашему сценарию передается
            большое количество входных аргументов, то команда <strong
             class="COMMAND">shift</strong> позволит вам получить
            доступ к аргументам, с порядковым номером больше <tt
             class="LITERAL">9</tt>, без использования <a
             href="#x1716_html_BRACKETNOTATION">{фигурных
            скобок}</a>.</p>

            <div
             class="EXAMPLE">
              <a
               name="x1716_html_EX19"></a>

              <p><strong>Пример 4-7. Использование команды
              shift</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Использование команды &#39;shift&#39; с целью перебора всех аргументов командной строки.

#  Назовите файл с этим сценарием, например &quot;shft&quot;,
#+ и вызовите его с набором аргументов, например:
#          ./shft a b c def 23 skidoo

until [ -z &quot;$1&quot; ]  # До тех пор пока не будут разобраны все входные аргументы...
do
  echo -n &quot;$1 &quot;
  shift
done

echo               # Дополнительная пустая строка.

exit 0
</pre>
            </div>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Команда <strong
                     class="COMMAND">shift</strong> может применяться и
                    к входным аргументам <a
                     href="#c12483_html_FUNCTIONREF">функций</a>. См. <a
                     href="#x13753_html_MULTIPLICATION">Пример
                    33-10</a>.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>
        </dl>
      </div>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN1772"
         href="#x1716_html_AEN1772"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Аргумент <tt
           class="REPLACEABLE"><em>$0</em></tt> устанавливается
          вызывающим процессом. В соответствии с соглашениями, этот
          параметр содержит имя файла скрипта. См. страницы руководства
          для <strong
           class="COMMAND">execv</strong> (man execv).</p>
        </td>
      </tr>
    </table>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x1705_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#c1833_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Переменные Bash не имеют типа</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c1613_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Кавычки</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x2389_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#c2171_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 7. Проверка условий</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x2565_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x2389_html_FTO"></a>7.2. Операции проверки файлов</h1>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="x2389_html_RTIF"></a>Возвращает true если...</strong></p>

        <dl>
          <dt><span
           class="TOKEN">-e</span></dt>

          <dd>
            <p>файл существует</p>
          </dd>

          <dt><span
           class="TOKEN">-f</span></dt>

          <dd>
            <p><tt
             class="REPLACEABLE"><em>обычный</em></tt> файл (не каталог
            и не файл устройства)</p>
          </dd>

          <dt><span
           class="TOKEN">-s</span></dt>

          <dd>
            <p>ненулевой размер файла</p>
          </dd>

          <dt><span
           class="TOKEN">-d</span></dt>

          <dd>
            <p>файл является каталогом</p>
          </dd>

          <dt><span
           class="TOKEN">-b</span></dt>

          <dd>
            <p>файл является блочным устройством (floppy, cdrom и
            т.п.)</p>
          </dd>

          <dt><span
           class="TOKEN">-c</span></dt>

          <dd>
            <p>файл является символьным устройством (клавиатура, модем,
            звуковая карта и т.п.)</p>
          </dd>

          <dt><span
           class="TOKEN">-p</span></dt>

          <dd>
            <p>файл является каналом</p>
          </dd>

          <dt><span
           class="TOKEN">-h</span></dt>

          <dd>
            <p>файл является символической ссылкой</p>
          </dd>

          <dt><span
           class="TOKEN">-L</span></dt>

          <dd>
            <p>файл является символической ссылкой</p>
          </dd>

          <dt><span
           class="TOKEN">-S</span></dt>

          <dd>
            <p>файл является сокетом</p>
          </dd>

          <dt><span
           class="TOKEN">-t</span></dt>

          <dd>
            <p>файл (<a
             href="#c11620_html_FDREF">дескриптор</a>) связан с
            терминальным устройством</p>

            <p>Этот ключ может использоваться для проверки -- является
            ли файл стандартным устройством ввода <tt
             class="FILENAME">stdin</tt> (<tt
             class="USERINPUT"><strong>[ -t 0 ]</strong></tt>) или
            стандартным устройством вывода <tt
             class="FILENAME">stdout</tt> (<tt
             class="USERINPUT"><strong>[ -t 1 ]</strong></tt>).</p>
          </dd>

          <dt><span
           class="TOKEN">-r</span></dt>

          <dd>
            <p>файл доступен для чтения (<span
             class="emphasis"><em
             class="EMPHASIS">пользователю, запустившему
            сценарий</em></span>)</p>
          </dd>

          <dt><span
           class="TOKEN">-w</span></dt>

          <dd>
            <p>файл доступен для записи (пользователю, запустившему
            сценарий)</p>
          </dd>

          <dt><span
           class="TOKEN">-x</span></dt>

          <dd>
            <p>файл доступен для исполнения (пользователю, запустившему
            сценарий)</p>
          </dd>

          <dt><span
           class="TOKEN">-g</span></dt>

          <dd>
            <p>set-group-id (sgid) флаг для файла или каталога
            установлен</p>

            <p>Если для каталога установлен флаг <tt
             class="REPLACEABLE"><em>sgid</em></tt>, то файлы,
            создаваемые в таком каталоге, наследуют идентификатор
            группы каталога, который может не совпадать с
            идентификатором группы, к которой принадлежит пользователь,
            создавший файл. Это может быть полезно для каталогов, в
            которых хранятся файлы, общедоступные для группы
            пользователей.</p>
          </dd>

          <dt><span
           class="TOKEN">-u</span></dt>

          <dd>
            <p>set-user-id (suid) флаг для файла установлен</p>

            <p>Установленный флаг suid приводит к изменению привилегий
            запущенного процесса на привилегии владельца исполняемого
            файла. Исполняемые файлы, владельцем которых является <span
             class="emphasis"><em
             class="EMPHASIS">root</em></span>, с установленным флагом
            <tt
             class="REPLACEABLE"><em>set-user-id</em></tt> запускаются
            с привилегиями <span
             class="emphasis"><em
             class="EMPHASIS">root</em></span>, даже если их запускает
            обычный пользователь. <a
             name="AEN2488"
             href="#x2389_html_FTN_AEN2488"><span
             class="footnote">[1]</span></a> Это может оказаться
            полезным для некоторых программ (таких как <strong
             class="COMMAND">pppd</strong> и <strong
             class="COMMAND">cdrecord</strong>), которые осуществляют
            доступ к аппаратной части компьютера. В случае отсутствия
            флага <span
             class="emphasis"><em
             class="EMPHASIS">suid</em></span>, программы не смогут
            быть запущены рядовым пользователем, не обладающим
            привилегиями root.</p>
<pre
 class="SCREEN">
             <tt
 class=
"COMPUTEROUTPUT">-rwsr-xr-t    1 root       178236 Oct  2  2000 /usr/sbin/pppd</tt>
             
</pre>
            Файл с установленным флагом <tt
             class="REPLACEABLE"><em>suid</em></tt> отображается с
            включенным флагом <span
             class="emphasis"><em
             class="EMPHASIS">s</em></span> в поле прав доступа.<br>
            <br>
          </dd>

          <dt><span
           class="TOKEN">-k</span></dt>

          <dd>
            <p>флаг <tt
             class="REPLACEABLE"><em>sticky bit</em></tt> (бит
            фиксации) установлен</p>

            <p>Общеизвестно, что флаг <span
             class="QUOTE">&quot;sticky bit&quot;</span> -- это
            специальный тип прав доступа к файлам. Программы с
            установленным флагом <span
             class="QUOTE">&quot;sticky bit&quot;</span> остаются в
            системном кэше после своего завершения, обеспечивая тем
            самым более быстрый запуск программы. <a
             name="AEN2508"
             href="#x2389_html_FTN_AEN2508"><span
             class="footnote">[2]</span></a> Если флаг установлен для
            каталога, то это приводит к ограничению прав на запись.
            Установленный флаг &quot;sticky bit&quot; отображается в
            виде символа <span
             class="emphasis"><em
             class="EMPHASIS">t</em></span> в поле прав доступа.</p>
<pre
 class="SCREEN">
             <tt
 class=
"COMPUTEROUTPUT">drwxrwxrwt    7 root         1024 May 19 21:26 tmp/</tt>
             
</pre>
            Если пользователь не является владельцем каталога, с
            установленным &quot;sticky bit&quot;, но имеет право на
            запись в каталог, то он может удалять только те файлы в
            каталоге, владельцем которых он является. Это предотвращает
            удаление и перезапись &quot;чужих&quot; файлов в
            общедоступных каталогах, таких как <tt
             class="FILENAME">/tmp</tt>.<br>
            <br>
          </dd>

          <dt><span
           class="TOKEN">-O</span></dt>

          <dd>
            <p>вы являетесь владельцем файла</p>
          </dd>

          <dt><span
           class="TOKEN">-G</span></dt>

          <dd>
            <p>вы принадлежите к той же группе, что и файл</p>
          </dd>

          <dt><span
           class="TOKEN">-N</span></dt>

          <dd>
            <p>файл был модифицирован с момента последнего чтения</p>
          </dd>

          <dt><span
           class="TOKEN">f1 -nt f2</span></dt>

          <dd>
            <p>файл <tt
             class="REPLACEABLE"><em>f1</em></tt> более новый, чем <tt
             class="REPLACEABLE"><em>f2</em></tt></p>
          </dd>

          <dt><span
           class="TOKEN">f1 -ot f2</span></dt>

          <dd>
            <p>файл <tt
             class="REPLACEABLE"><em>f1</em></tt> более старый, чем <tt
             class="REPLACEABLE"><em>f2</em></tt></p>
          </dd>

          <dt><span
           class="TOKEN">f1 -ef f2</span></dt>

          <dd>
            <p>файлы <tt
             class="REPLACEABLE"><em>f1</em></tt> и <tt
             class="REPLACEABLE"><em>f2</em></tt> являются
            &quot;жесткими&quot; ссылками на один и тот же файл</p>
          </dd>

          <dt><span
           class="TOKEN">!</span></dt>

          <dd>
            <p><span
             class="QUOTE">&quot;НЕ&quot;</span> -- логическое
            отрицание (инверсия) результатов всех вышеприведенных
            проверок (возвращается true если условие отсутствует).</p>
          </dd>
        </dl>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="x2389_html_BROKENLINK"></a>

        <p><strong>Пример 7-4. Проверка &quot;битых&quot;
        ссылок</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# broken-link.sh
# Автор Lee Bigelow &lt;ligelowbee@yahoo.com&gt;
# Используется с его разрешения.

#Сценарий поиска &quot;битых&quot; ссылок и их вывод в &quot;окавыченном&quot; виде
#таким образом они могут передаваться утилите xargs для дальнейшей обработки :)
#например. broken-link.sh /somedir /someotherdir|xargs rm
#
#На всякий случай приведу лучший метод:
#
#find &quot;somedir&quot; -type l -print0|\
#xargs -r0 file|\
#grep &quot;broken symbolic&quot;|
#sed -e &#39;s/^\|: *broken symbolic.*$/&quot;/g&#39;
#
#но это не чисто BASH-евский метод, а теперь сам сценарий.
#Внимание! будьте осторожны с файловой системой /proc и циклическими ссылками!
##############################################################


#Если скрипт не получает входных аргументов,
#то каталогом поиска является текущая директория
#В противном случае, каталог поиска задается из командной строки
####################
[ $# -eq 0 ] &amp;&amp; directorys=`pwd` || directorys=$@

#Функция linkchk проверяет каталог поиска
#на наличие в нем ссылок на несуществующие файлы, и выводит их имена.
#Если анализируемый файл является каталогом,
#то он передается функции linkcheck рекурсивно.
##########
linkchk () {
    for element in $1/*; do
    [ -h &quot;$element&quot; -a ! -e &quot;$element&quot; ] &amp;&amp; echo \&quot;$element\&quot;
    [ -d &quot;$element&quot; ] &amp;&amp; linkchk $element
    # Само собой, &#39;-h&#39; проверяет символические ссылки, &#39;-d&#39; -- каталоги.
    done
}

#Вызов функции linkchk для каждого аргумента командной строки,
#если он является каталогом.  Иначе выводится сообщение об ошибке
#и информация о порядке пользования скриптом.
################
for directory in $directorys; do
    if [ -d $directory ]
        then linkchk $directory
        else
            echo &quot;$directory не является каталогом&quot;
            echo &quot;Порядок использования: $0 dir1 dir2 ...&quot;
    fi
done

exit 0
</pre>
      </div>

      <p><a
       href="#c13041_html_COOKIES">Пример 28-1</a>, <a
       href="#c4875_html_BINGREP">Пример 10-7</a>, <a
       href="#c4875_html_FILEINFO">Пример 10-3</a>, <a
       href="#c13041_html_RAMDISK">Пример 28-3</a> и <a
       href="#a14477_html_MAILFORMAT">Пример A-2</a> так же иллюстрируют
      операции проверки файлов.</p>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN2488"
         href="#x2389_html_AEN2488"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>С флагом <span
           class="emphasis"><em
           class="EMPHASIS">suid</em></span>, на двоичных исполняемых
          файлах, надо быть очень осторожным, поскольку это может быть
          небезопасным. Установка флага <span
           class="emphasis"><em
           class="EMPHASIS">suid</em></span> на файлы-сценарии не имеет
          никакого эффекта.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN2508"
         href="#x2389_html_AEN2508"><span
         class="footnote">[2]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>В современных UNIX-системах, &quot;sticky bit&quot; больше
          не используется для файлов, только для каталогов.</p>
        </td>
      </tr>
    </table>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#c2171_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x2565_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Проверка условий</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c2171_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Операции сравнения</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x2565_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x2389_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 7. Проверка условий</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x2770_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x2565_html_COMPARISON-OPS"></a>7.3. Операции сравнения</h1>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="x2565_html_ICOMPARISON1"></a>сравнение целых чисел</strong></p>

        <dl>
          <dt><span
           class="TOKEN">-eq</span></dt>

          <dd>
            <p><a
             name="x2565_html_EQUALREF"></a></p>

            <p>равно</p>

            <p><tt
             class="USERINPUT"><strong>if [ &quot;$a&quot; -eq
            &quot;$b&quot; ]</strong></tt></p>
          </dd>

          <dt><span
           class="TOKEN">-ne</span></dt>

          <dd>
            <p>не равно</p>

            <p><tt
             class="USERINPUT"><strong>if [ &quot;$a&quot; -ne
            &quot;$b&quot; ]</strong></tt></p>
          </dd>

          <dt><span
           class="TOKEN">-gt</span></dt>

          <dd>
            <p>больше</p>

            <p><tt
             class="USERINPUT"><strong>if [ &quot;$a&quot; -gt
            &quot;$b&quot; ]</strong></tt></p>
          </dd>

          <dt><span
           class="TOKEN">-ge</span></dt>

          <dd>
            <p>больше или равно</p>

            <p><tt
             class="USERINPUT"><strong>if [ &quot;$a&quot; -ge
            &quot;$b&quot; ]</strong></tt></p>
          </dd>

          <dt><span
           class="TOKEN">-lt</span></dt>

          <dd>
            <p>меньше</p>

            <p><tt
             class="USERINPUT"><strong>if [ &quot;$a&quot; -lt
            &quot;$b&quot; ]</strong></tt></p>
          </dd>

          <dt><span
           class="TOKEN">-le</span></dt>

          <dd>
            <p>меньше или равно</p>

            <p><tt
             class="USERINPUT"><strong>if [ &quot;$a&quot; -le
            &quot;$b&quot; ]</strong></tt></p>
          </dd>

          <dt><a
           name="x2565_html_INTLT"></a><span
           class="TOKEN">&lt;</span></dt>

          <dd>
            <p>меньше (внутри <a
             href="#x4862_html">двойных круглых скобок</a> )</p>

            <p><tt
             class="USERINPUT"><strong>((&quot;$a&quot; &lt;
            &quot;$b&quot;))</strong></tt></p>
          </dd>

          <dt><span
           class="TOKEN">&lt;=</span></dt>

          <dd>
            <p>меньше или равно (внутри двойных круглых скобок)</p>

            <p><tt
             class="USERINPUT"><strong>((&quot;$a&quot; &lt;=
            &quot;$b&quot;))</strong></tt></p>
          </dd>

          <dt><span
           class="TOKEN">&gt;</span></dt>

          <dd>
            <p>больше (внутри двойных круглых скобок)</p>

            <p><tt
             class="USERINPUT"><strong>((&quot;$a&quot; &gt;
            &quot;$b&quot;))</strong></tt></p>
          </dd>

          <dt><span
           class="TOKEN">&gt;=</span></dt>

          <dd>
            <p>больше или равно (внутри двойных круглых скобок)</p>

            <p><tt
             class="USERINPUT"><strong>((&quot;$a&quot; &gt;=
            &quot;$b&quot;))</strong></tt></p>
          </dd>
        </dl>
      </div>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="x2565_html_SCOMPARISON1"></a>сравнение строк</strong></p>

        <dl>
          <dt><span
           class="TOKEN">=</span></dt>

          <dd>
            <p><a
             name="x2565_html_EQUALSIGNREF"></a></p>

            <p>равно</p>

            <p><tt
             class="USERINPUT"><strong>if [ &quot;$a&quot; =
            &quot;$b&quot; ]</strong></tt></p>
          </dd>

          <dt><span
           class="TOKEN">==</span></dt>

          <dd>
            <p>равно</p>

            <p><tt
             class="USERINPUT"><strong>if [ &quot;$a&quot; ==
            &quot;$b&quot; ]</strong></tt></p>

            <p>Синоним оператора <span
             class="TOKEN">=</span>.</p>
<pre
 class="PROGRAMLISTING">
[[ $a == z* ]]    # истина, если $a начинается с символа &quot;z&quot; (сравнение по шаблону)
[[ $a == &quot;z*&quot; ]]  # истина, если $a равна z*

[ $a == z* ]      # имеют место подстановка имен файлов и разбиение на слова
[ &quot;$a&quot; == &quot;z*&quot; ]  # истина, если $a равна z*

# Спасибо S.C.
</pre>
            <br>
            <br>
          </dd>

          <dt><span
           class="TOKEN">!=</span></dt>

          <dd>
            <p>не равно</p>

            <p><tt
             class="USERINPUT"><strong>if [ &quot;$a&quot; !=
            &quot;$b&quot; ]</strong></tt></p>

            <p>Этот оператор используется при поиске по шаблону внутри
            <a
             href="#c2171_html_DBLBRACKETS">[[ ... ]]</a>.</p>
          </dd>

          <dt><a
           name="x2565_html_LTREF"></a><span
           class="TOKEN">&lt;</span></dt>

          <dd>
            <p>меньше, в смысле величины ASCII-кодов</p>

            <p><tt
             class="USERINPUT"><strong>if [[ &quot;$a&quot; &lt;
            &quot;$b&quot; ]]</strong></tt></p>

            <p><tt
             class="USERINPUT"><strong>if [ &quot;$a&quot; \&lt;
            &quot;$b&quot; ]</strong></tt></p>

            <p>Обратите внимание! Символ <span
             class="QUOTE">&quot;&lt;&quot;</span> необходимо
            экранировать внутри <tt
             class="USERINPUT"><strong>[ ]</strong></tt>.</p>
          </dd>

          <dt><a
           name="x2565_html_GTREF"></a><span
           class="TOKEN">&gt;</span></dt>

          <dd>
            <p>больше, в смысле величины ASCII-кодов</p>

            <p><tt
             class="USERINPUT"><strong>if [[ &quot;$a&quot; &gt;
            &quot;$b&quot; ]]</strong></tt></p>

            <p><tt
             class="USERINPUT"><strong>if [ &quot;$a&quot; \&gt;
            &quot;$b&quot; ]</strong></tt></p>

            <p>Обратите внимание! Символ <span
             class="QUOTE">&quot;&gt;&quot;</span> необходимо
            экранировать внутри <tt
             class="USERINPUT"><strong>[ ]</strong></tt>.</p>

            <p>См. <a
             href="#c12790_html_BUBBLE">Пример 25-6</a> относительно
            применения этого оператора сравнения.</p>
          </dd>

          <dt><span
           class="TOKEN">-z</span></dt>

          <dd>
            <p>строка <span
             class="QUOTE">&quot;пустая&quot;</span>, т.е. имеет
            нулевую длину</p>
          </dd>

          <dt><span
           class="TOKEN">-n</span></dt>

          <dd>
            <p>строка не <span
             class="QUOTE">&quot;пустая&quot;</span>.</p>

            <div
             class="CAUTION">
              <table
               class="CAUTION"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/caution.gif"
                   hspace="5"
                   alt="Caution"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Оператор <tt
                     class="USERINPUT"><strong>-n</strong></tt>
                    требует, чтобы строка была заключена в кавычки
                    внутри квадратных скобок. Как правило, проверка
                    строк, не заключенных в кавычки, оператором <tt
                     class="USERINPUT"><strong>! -z</strong></tt>, или
                    просто указание строки без кавычек внутри
                    квадратных скобок (см. <a
                     href="#x2565_html_STRTEST">Пример 7-6</a>),
                    проходит нормально, однако это небезопасная, с
                    точки зрения отказоустойчивости, практика. <span
                     class="emphasis"><em
                     class="EMPHASIS">Всегда</em></span> заключайте
                    проверяемую строку в кавычки. <a
                     name="AEN2722"
                     href="#x2565_html_FTN_AEN2722"><span
                     class="footnote">[1]</span></a></p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>
        </dl>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="x2565_html_EX13"></a>

        <p><strong>Пример 7-5. Операции сравнения</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

a=4
b=5

#  Здесь переменные &quot;a&quot; и &quot;b&quot; могут быть как целыми числами, так и строками.
#  Здесь наблюдается некоторое размывание границ
#+ между целочисленными и строковыми переменными,
#+ поскольку переменные в Bash не имеют типов.

#  Bash выполняет целочисленные операции над теми переменными,
#+ которые содержат только цифры
#  Будьте внимательны!

echo

if [ &quot;$a&quot; -ne &quot;$b&quot; ]
then
  echo &quot;$a не равно $b&quot;
  echo &quot;(целочисленное сравнение)&quot;
fi

echo

if [ &quot;$a&quot; != &quot;$b&quot; ]
then
  echo &quot;$a не равно $b.&quot;
  echo &quot;(сравнение строк)&quot;
  #     &quot;4&quot;  != &quot;5&quot;
  # ASCII 52 != ASCII 53
fi

# Оба варианта, &quot;-ne&quot; и &quot;!=&quot;, работают правильно.

echo

exit 0
</pre>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="x2565_html_STRTEST"></a>

        <p><strong>Пример 7-6. Проверка -- является ли строка <span
         class="emphasis"><em
         class="EMPHASIS">пустой</em></span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# str-test.sh: Проверка пустых строк и строк, не заключенных в кавычки,

# Используется конструкция   if [ ... ]


# Если строка не инициализирована, то она не имеет никакого определенного значения.
# Такое состояние называется &quot;null&quot; (пустая) (это не то же самое, что ноль).

if [ -n $string1 ]    # $string1 не была объявлена или инициализирована.
then
  echo &quot;Строка \&quot;string1\&quot; не пустая.&quot;
else
  echo &quot;Строка \&quot;string1\&quot; пустая.&quot;
fi
# Неверный результат.
# Выводится сообщение о том, что $string1 не пустая,
#+не смотря на то, что она не была инициализирована.


echo


# Попробуем еще раз.

if [ -n &quot;$string1&quot; ]  # На этот раз, переменная $string1 заключена в кавычки.
then
  echo &quot;Строка \&quot;string1\&quot; не пустая.&quot;
else
  echo &quot;Строка \&quot;string1\&quot; пустая.&quot;
fi      # Внутри квадратных скобок заключайте строки в кавычки!


echo


if [ $string1 ]       # Опустим оператор -n.
then
  echo &quot;Строка \&quot;string1\&quot; не пустая.&quot;
else
  echo &quot;Строка \&quot;string1\&quot; пустая.&quot;
fi
# Все работает прекрасно.
# Квадратные скобки -- [ ], без посторонней помощи определяют, что строка пустая.
# Тем не менее, хорошим тоном считается заключать строки в кавычки (&quot;$string1&quot;).
#
# Как указывает Stephane Chazelas,
#    if [ $string 1 ]   один аргумент &quot;]&quot;
#    if [ &quot;$string 1&quot; ]  два аргумента, пустая &quot;$string1&quot; и &quot;]&quot;



echo



string1=initialized

if [ $string1 ]       # Опять, попробуем строку без ничего.
then
  echo &quot;Строка \&quot;string1\&quot; не пустая.&quot;
else
  echo &quot;Строка \&quot;string1\&quot; пустая.&quot;
fi
# И снова получим верный результат.
# И опять-таки, лучше поместить строку в кавычки (&quot;$string1&quot;), поскольку...


string1=&quot;a = b&quot;

if [ $string1 ]       # И снова, попробуем строку без ничего..
then
  echo &quot;Строка \&quot;string1\&quot; не пустая.&quot;
else
  echo &quot;Строка \&quot;string1\&quot; пустая.&quot;
fi
# Строка без кавычек дает неверный результат!

exit 0
# Спвсибо Florian Wisser, за предупреждение.
</pre>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="x2565_html_EX14"></a>

        <p><strong>Пример 7-7. zmost</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

#Просмотр gz-файлов с помощью утилиты &#39;most&#39;

NOARGS=65
NOTFOUND=66
NOTGZIP=67

if [ $# -eq 0 ] # то же, что и:  if [ -z &quot;$1&quot; ]
# $1 должен существовать, но может быть пустым:  zmost &quot;&quot; arg2 arg3
then
  echo &quot;Порядок использования: `basename $0` filename&quot; &gt;&amp;2
  # Сообщение об ошибке на stderr.
  exit $NOARGS
  # Код возврата 65 (код ошибки).
fi

filename=$1

if [ ! -f &quot;$filename&quot; ]   # Кавычки необходимы на тот случай, если имя файла содержит пробелы.
then
  echo &quot;Файл $filename не найден!&quot; &gt;&amp;2
  # Сообщение об ошибке на stderr.
  exit $NOTFOUND
fi

if [ ${filename##*.} != &quot;gz&quot; ]
# Квадратные скобки нужны для выполнения подстановки значения переменной
then
  echo &quot;Файл $1 не является gz-файлом!&quot;
  exit $NOTGZIP
fi

zcat $1 | most

# Используется утилита &#39;most&#39; (очень похожа на &#39;less&#39;).
# Последние версии &#39;most&#39; могут просматривать сжатые файлы.
# Можно вставить &#39;more&#39; или &#39;less&#39;, если пожелаете.


exit $?   # Сценарий возвращает код возврата, полученный по конвейеру.
# На самом деле команда &quot;exit $?&quot; не является обязательной,
# так как работа скрипта завершится здесь в любом случае,
</pre>
      </div>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="x2565_html_CCOMPARISON1"></a>построение сложных условий
        проверки</strong></p>

        <dl>
          <dt><span
           class="TOKEN">-a</span></dt>

          <dd>
            <p>логическое И (and)</p>

            <p><tt
             class="REPLACEABLE"><em>exp1 -a exp2</em></tt> возвращает
            true, если <span
             class="emphasis"><em
             class="EMPHASIS">оба</em></span> выражения, и exp1, и exp2
            истинны.</p>
          </dd>

          <dt><span
           class="TOKEN">-o</span></dt>

          <dd>
            <p>логическое ИЛИ (or)</p>

            <p><tt
             class="REPLACEABLE"><em>exp1 -o exp2</em></tt> возвращает
            true, если хотябы одно из выражений, exp1 <span
             class="emphasis"><em
             class="EMPHASIS">или</em></span> exp2 истинно.</p>
          </dd>
        </dl>
      </div>

      <p>Они похожи на операторы Bash <strong
       class="COMMAND">&amp;&amp;</strong> и <strong
       class="COMMAND">||</strong>, употребляемые в <a
       href="#c2171_html_DBLBRACKETS">двойных квадратных
      скобках</a>.</p>
<pre
 class="PROGRAMLISTING">
[[ condition1 &amp;&amp; condition2 ]]
</pre>
      Операторы <strong
       class="COMMAND">-o</strong> и <strong
       class="COMMAND">-a</strong> употребляются совместно с командой
      <strong
       class="COMMAND">test</strong> или внутри одинарных квадратных
      скобок. 
<pre
 class="PROGRAMLISTING">
if [ &quot;$exp1&quot; -a &quot;$exp2&quot; ]
</pre>
      <br>
      <br>

      <p>Чтобы увидеть эти операторы в действии, смотрите <a
       href="#c2792_html_ANDOR">Пример 8-3</a> и <a
       href="#c12790_html_TWODIM">Пример 25-11</a>.</p>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN2722"
         href="#x2565_html_AEN2722"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Как указывает S.C., даже заключение строки в кавычки, при
          построении сложных условий проверки, может оказаться
          недостаточным. <tt
           class="USERINPUT"><strong>[ -n &quot;$string&quot; -o
          &quot;$a&quot; = &quot;$b&quot; ]</strong></tt> в некоторых
          версиях Bash такая проверка может вызвать сообщение об
          ошибке, если строка <tt
           class="VARNAME">$string</tt> пустая. Безопаснее, в смысле
          отказоустойчивости, было бы добавить какой-либо символ к,
          возможно пустой, строке: <tt
           class="USERINPUT"><strong>[ &quot;x$string&quot; != x -o
          &quot;x$a&quot; = &quot;x$b&quot; ]</strong></tt> (символ
          <span
           class="QUOTE">&quot;x&quot;</span> не учитывается).</p>
        </td>
      </tr>
    </table>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x2389_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x2770_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Операции проверки файлов</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c2171_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Вложенные условные операторы if/then</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x2770_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x2565_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 7. Проверка условий</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x2780_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x2770_html_NESTEDIFTHEN"></a>7.4. Вложенные условные операторы
      if/then</h1>

      <p>Операторы проверки условий <strong
       class="COMMAND">if/then</strong> могут быть вложенными друг в
      друга. Конечный результат будет таким же как если бы результаты
      всех проверок были объединены оператором <strong
       class="COMMAND">&amp;&amp;</strong>.</p>
<pre
 class="PROGRAMLISTING">
if [ condition1 ]
then
  if [ condition2 ]
  then
    do-something  # Только если оба условия &quot;condition1&quot; и &quot;condition2&quot; истинны.
  fi
fi
</pre>
      <br>
      <br>

      <p>См. <a
       href="#c13936_html_EX79">Пример 34-4</a> -- пример использования
      вложенных операторов <tt
       class="REPLACEABLE"><em>if/then</em></tt>.</p>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x2565_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x2780_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Операции сравнения</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c2171_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Проверка степени усвоения материала</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x2780_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x2770_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 7. Проверка условий</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#c2792_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x2780_html_TESTTEST"></a>7.5. Проверка степени усвоения
      материала</h1>

      <p>Для запуска X-сервера может быть использован файл <tt
       class="FILENAME">xinitrc</tt>. Этот файл содержит некоторое
      число операторов <span
       class="emphasis"><em
       class="EMPHASIS">if/then</em></span>. Ниже приводится отрывок из
      этого файла.</p>
<pre
 class="PROGRAMLISTING">
if [ -f $HOME/.Xclients ]; then
  exec $HOME/.Xclients
elif [ -f /etc/X11/xinit/Xclients ]; then
  exec /etc/X11/xinit/Xclients
else
     # failsafe settings.  Although we should never get here
     # (we provide fallbacks in Xclients as well) it can&#39;t hurt.
     xclock -geometry 100x100-5+5 &amp;
     xterm -geometry 80x50-50+150 &amp;
     if [ -f /usr/bin/netscape -a -f /usr/share/doc/HTML/index.html ]; then
             netscape /usr/share/doc/HTML/index.html &amp;
     fi
fi
</pre>
      <br>
      <br>

      <p>Объясните действия условных операторов в вышеприведенном
      отрывке, затем просмотрите файл <tt
       class="FILENAME">/etc/X11/xinit/xinitrc</tt> и проанализируйте
      его. Возможно вам придется обратиться к разделам, посвященным <a
       href="#x7050_html_GREPREF">grep</a>, <a
       href="#a14586_html_SEDREF">sed</a> и <a
       href="#c11895_html_REGEXREF">регулярным выражениям</a>.</p>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x2770_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#c2792_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Вложенные условные операторы if/then</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c2171_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Операции и смежные темы</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x288_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#c178_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 2. Для начала о Sha-Bang</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#p299_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x288_html_PRELIMEXER"></a>2.2. Упражнения</h1>

      <ol
       type="1">
        <li>
          <p>Системные администраторы часто создают скрипты для
          автоматизации своего труда. Подумайте, для выполнения каких
          задач могут быть написаны сценарии.</p>
        </li>

        <li>
          <p>Напишите сценарий, который выводит <a
           href="#x6837_html_DATEREF">дату, время</a>, <a
           href="#c9708_html_WHOREF">список зарегистрировавшихся
          пользователей</a>, и <a
           href="#c9708_html_UPTIMEREF">uptime</a> системы и <a
           href="#c11620_html_IOREDIRREF">сохраняет эту информацию</a> в
          системном журнале.</p>
        </li>
      </ol>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#c178_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#p299_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Для начала о Sha-Bang</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c178_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Основы</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x3255_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#c2792_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 8. Операции и смежные темы</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#p3268_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x3255_html_NUMERICAL-CONSTANTS"></a>8.2. Числовые константы</h1>

      <p><a
       name="x3255_html_NUMCONSTANTS"></a>Интерпретатор командной оболочки
      воспринимает числа как десятичные, в противном случае числу
      должен предшествовать специальный префикс, либо число должно быть
      записано в особой нотации. Числа, начинающиеся с символа <tt
       class="REPLACEABLE"><em>0</em></tt>, считаются <tt
       class="REPLACEABLE"><em>восьмеричными</em></tt>. если числу
      предшествует префикс <tt
       class="REPLACEABLE"><em>0x</em></tt>, то число считается <tt
       class="REPLACEABLE"><em>шестнадцатиричным</em></tt>. Число, в
      записи которого присутствует символ <tt
       class="REPLACEABLE"><em>#</em></tt>, расценивается как запись
      числа с указанием основы счисления в виде <tt
       class="REPLACEABLE"><em>ОСНОВА#ЧИСЛО</em></tt>.</p>

      <div
       class="EXAMPLE">
        <a
         name="x3255_html_NUMBERS"></a>

        <p><strong>Пример 8-4. Различные представления числовых
        констант</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# numbers.sh: Различные представления числовых констант.

# Десятичное: по-умолчанию
let &quot;dec = 32&quot;
echo &quot;десятичное число = $dec&quot;             # 32
# Вобщем-то ничего необычного.


# Восьмеричное: числа начинаются с &#39;0&#39; (нуля)
let &quot;oct = 032&quot;
echo &quot;восьмеричное число = $oct&quot;           # 26
# Результат печатается в десятичном виде.
# --------- ------ -- -------

# Шестнадцатиричное: числа начинаются с &#39;0x&#39; или &#39;0X&#39;
let &quot;hex = 0x32&quot;
echo &quot;шестнадцатиричное число = $hex&quot;      # 50
# Результат печатается в десятичном виде.

# Другие основы счисления: ОСНОВА#ЧИСЛО
# ОСНОВА должна быть между 2 и 64.
# для записи ЧИСЛА должен использоваться соответствующий ОСНОВЕ диапазон символов,
# см. ниже.

let &quot;bin = 2#111100111001101&quot;
echo &quot;двоичное число = $bin&quot;               # 31181

let &quot;b32 = 32#77&quot;
echo &quot;32-ричное число = $b32&quot;              # 231

let &quot;b64 = 64#@_&quot;
echo &quot;64-ричное число = $b64&quot;              # 4094
#
#  Нотация ОСНОВА#ЧИСЛО может использоваться на ограниченном
#+ диапазоне основ счисления (от 2 до 64)
#  10 цифр + 26 символов в нижнем регистре + 26 символов в верхнем регистре + @ + _

echo

echo $((36#zz)) $((2#10101010)) $((16#AF16)) $((53#1aA))
                                         # 1295 170 44822 3375


#  Важное замечание:
#  --------------
#  Использование символов, для записи числа, выходящих за диапазо,
#+ соответствующий ОСНОВЕ счисления
#+ будет приводить к появлению сообщений об ошибках.

let &quot;bad_oct = 081&quot;
# numbers.sh: let: oct = 081: value too great for base (error token is &quot;081&quot;)
#                  Для записи восьмеричных чисел допускается использовать
#+                 только цифры в диапазоне 0 - 7.

exit 0       # Спасибо Rich Bartell и Stephane Chazelas, за разъяснения.
</pre>
      </div>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#c2792_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#p3268_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Операции и смежные темы</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c2792_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Углубленный материал</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x4171_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#c3270_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 9. К вопросу о переменных</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x4462_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x4171_html_STRING-MANIPULATION"></a>9.2. Работа со строками</h1>

      <p><a
       name="x4171_html_STRINGMANIP"></a></p>

      <p>Bash поддерживает на удивление большое количество операций над
      строками. К сожалению, этот раздел Bash испытывает недостаток
      унификации. Одни операции являются подмножеством операций <a
       href="#x4462_html_PARAMSUBREF">подстановки параметров</a>, а
      другие -- совпадают с функциональностью команды UNIX -- <a
       href="#x6646_html_EXPRREF">expr</a>. Это приводит к противоречиям
      в синтаксисе команд и перекрытию функциональных возможностей, не
      говоря уже о возникающей путанице.</p>

      <div
       class="VARIABLELIST">
        <p><strong>Длина строки</strong></p>

        <dl>
          <dt>${#string}</dt>

          <dt>expr length $string</dt>

          <dt>expr &quot;$string&quot; : &#39;.*&#39;</dt>

          <dd>
<pre
 class="PROGRAMLISTING">
stringZ=abcABC123ABCabc

echo ${#stringZ}                 # 15
echo `expr length $stringZ`      # 15
echo `expr &quot;$stringZ&quot; : &#39;.*&#39;`    # 15
</pre>
            <br>
            <br>
          </dd>
        </dl>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="x4171_html_PARAGRAPHSPACE"></a>

        <p><strong>Пример 9-10. Вставка пустых строк между параграфами
        в текстовом файле</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# paragraph-space.sh

# Вставка пустых строк между параграфами в текстовом файле.
# Порядок использования: $0 &lt;FILENAME

MINLEN=45        # Возможно потребуется изменить это значение.
#  Строки, содержащие количество символов меньшее, чем $MINLEN
#+ принимаются за последнюю строку параграфа.

while read line  # Построчное чтение файла от начала до конца...
do
  echo &quot;$line&quot;   # Вывод строки.

  len=${#line}
  if [ &quot;$len&quot; -lt &quot;$MINLEN&quot; ]
    then echo    # Добавление пустой строки после последней строки параграфа.
  fi  
done

exit 0
</pre>
      </div>

      <div
       class="VARIABLELIST">
        <p><strong>Длина подстроки в строке (подсчет совпадающих
        символов ведется с начала строки)</strong></p>

        <dl>
          <dt>expr match &quot;$string&quot; &#39;$substring&#39;</dt>

          <dd>
            <p>где <tt
             class="REPLACEABLE"><em>$substring</em></tt> -- <a
             href="#c11895_html_REGEXREF">регулярное выражение</a>.</p>
          </dd>

          <dt>expr &quot;$string&quot; : &#39;$substring&#39;</dt>

          <dd>
            <p>где <tt
             class="REPLACEABLE"><em>$substring</em></tt> -- регулярное
            выражение.</p>

            <p></p>
<pre
 class="PROGRAMLISTING">
stringZ=abcABC123ABCabc
#       |------|

echo `expr match &quot;$stringZ&quot; &#39;abc[A-Z]*.2&#39;`   # 8
echo `expr &quot;$stringZ&quot; : &#39;abc[A-Z]*.2&#39;`       # 8
</pre>
            <br>
            <br>
          </dd>
        </dl>
      </div>

      <div
       class="VARIABLELIST">
        <p><strong>Index</strong></p>

        <dl>
          <dt>expr index $string $substring</dt>

          <dd>
            <p>Номер позиции первого совпадения в $string c первым
            символом в $substring.</p>
<pre
 class="PROGRAMLISTING">
stringZ=abcABC123ABCabc
echo `expr index &quot;$stringZ&quot; C12`             # 6
                                             # позиция символа C.

echo `expr index &quot;$stringZ&quot; 1c`              # 3
# символ &#39;c&#39; (в #3 позиции) совпал раньше, чем &#39;1&#39;.
</pre>
            <br>
            <br>

            <p>Эта функция довольно близка к функции <span
             class="emphasis"><em
             class="EMPHASIS">strchr()</em></span> в языке C.</p>
          </dd>
        </dl>
      </div>

      <div
       class="VARIABLELIST">
        <p><strong>Извлечение подстроки</strong></p>

        <dl>
          <dt>${string:position}</dt>

          <dd>
            <p>Извлекает подстроку из <tt
             class="REPLACEABLE"><em>$string</em></tt>, начиная с
            позиции <tt
             class="REPLACEABLE"><em>$position</em></tt>.</p>

            <p>Если строка <tt
             class="VARNAME">$string</tt> -- <span
             class="QUOTE">&quot;<span
             class="TOKEN">*</span>&quot;</span> или <span
             class="QUOTE">&quot;<span
             class="TOKEN">@</span>&quot;</span>, то извлекается <a
             href="#c3270_html_POSPARAMREF">позиционный параметр</a>
            (аргумент), <a
             name="AEN4257"
             href="#x4171_html_FTN_AEN4257"><span
             class="footnote">[1]</span></a> с номером <tt
             class="VARNAME">$position</tt>.</p>
          </dd>

          <dt>${string:position:length}</dt>

          <dd>
            <p>Извлекает <tt
             class="REPLACEABLE"><em>$length</em></tt> символов из <tt
             class="REPLACEABLE"><em>$string</em></tt>, начиная с
            позиции <tt
             class="REPLACEABLE"><em>$position</em></tt>.</p>
<pre
 class="PROGRAMLISTING">
stringZ=abcABC123ABCabc
#       0123456789.....
#       Индексация начинается с 0.

echo ${stringZ:0}                            # abcABC123ABCabc
echo ${stringZ:1}                            # bcABC123ABCabc
echo ${stringZ:7}                            # 23ABCabc

echo ${stringZ:7:3}                          # 23A
                                             # Извлекает 3 символа.



# Возможна ли индексация с &quot;правой&quot; стороны строки?

echo ${stringZ:-4}                           # abcABC123ABCabc
# По-умолчанию выводится полная строка.
# Однако . . .

echo ${stringZ:(-4)}                         # Cabc
echo ${stringZ: -4}                          # Cabc
# Теперь выводится правильно.
# Круглые скобки или дополнительный пробел &quot;экранируют&quot; параметр позиции.

# Спасибо Dan Jacobson, за разъяснения.
</pre>
            <br>
            <br>

            <p>Если <tt
             class="VARNAME">$string</tt> -- <span
             class="QUOTE">&quot;<span
             class="TOKEN">*</span>&quot;</span> или <span
             class="QUOTE">&quot;<span
             class="TOKEN">@</span>&quot;</span>, то извлекается до <tt
             class="VARNAME">$length</tt> позиционных параметров
            (аргументов), начиная с <tt
             class="VARNAME">$position</tt>.</p>
<pre
 class="PROGRAMLISTING">
echo ${*:2}          # Вывод 2-го и последующих аргументов.
echo ${@:2}          # То же самое.

echo ${*:2:3}        # Вывод 3-х аргументов, начиная со 2-го.
</pre>
            <br>
            <br>
          </dd>

          <dt>expr substr $string $position $length</dt>

          <dd>
            <p>Извлекает <tt
             class="REPLACEABLE"><em>$length</em></tt> символов из <tt
             class="REPLACEABLE"><em>$string</em></tt>, начиная с
            позиции <tt
             class="REPLACEABLE"><em>$position</em></tt>.</p>
<pre
 class="PROGRAMLISTING">
stringZ=abcABC123ABCabc
#       123456789......
#       Индексация начинается с 1.

echo `expr substr $stringZ 1 2`              # ab
echo `expr substr $stringZ 4 3`              # ABC
</pre>
            <br>
            <br>

            <p><a
             name="x4171_html_EXPRPAREN"></a></p>
          </dd>

          <dt>expr match &quot;$string&quot;
          &#39;\($substring\)&#39;</dt>

          <dd>
            <p>Находит и извлекает первое совпадение <tt
             class="REPLACEABLE"><em>$substring</em></tt> в <tt
             class="REPLACEABLE"><em>$string</em></tt>, где <tt
             class="REPLACEABLE"><em>$substring</em></tt> -- это <a
             href="#c11895_html_REGEXREF">регулярное выражение</a>.</p>
          </dd>

          <dt>expr &quot;$string&quot; : &#39;\($substring\)&#39;</dt>

          <dd>
            <p>Находит и извлекает первое совпадение <tt
             class="REPLACEABLE"><em>$substring</em></tt> в <tt
             class="REPLACEABLE"><em>$string</em></tt>, где <tt
             class="REPLACEABLE"><em>$substring</em></tt> -- это
            регулярное выражение.</p>
<pre
 class="PROGRAMLISTING">
stringZ=abcABC123ABCabc
#       =======

echo `expr match &quot;$stringZ&quot; &#39;\(.[b-c]*[A-Z]..[0-9]\)&#39;`   # abcABC1
echo `expr &quot;$stringZ&quot; : &#39;\(.[b-c]*[A-Z]..[0-9]\)&#39;`       # abcABC1
echo `expr &quot;$stringZ&quot; : &#39;\(.......\)&#39;`                   # abcABC1
# Все вышеприведенные операции дают один и тот же результат.
</pre>
            <br>
            <br>
          </dd>

          <dt>expr match &quot;$string&quot;
          &#39;.*\($substring\)&#39;</dt>

          <dd>
            <p>Находит и извлекает первое совпадение <tt
             class="REPLACEABLE"><em>$substring</em></tt> в <tt
             class="REPLACEABLE"><em>$string</em></tt>, где <tt
             class="REPLACEABLE"><em>$substring</em></tt> -- это
            регулярное выражение. Поиск начинается с конца <tt
             class="REPLACEABLE"><em>$string</em></tt>.</p>
          </dd>

          <dt>expr &quot;$string&quot; :
          &#39;.*\($substring\)&#39;</dt>

          <dd>
            <p>Находит и извлекает первое совпадение <tt
             class="REPLACEABLE"><em>$substring</em></tt> в <tt
             class="REPLACEABLE"><em>$string</em></tt>, где <tt
             class="REPLACEABLE"><em>$substring</em></tt> -- это
            регулярное выражение. Поиск начинается с конца <tt
             class="REPLACEABLE"><em>$string</em></tt>.</p>
<pre
 class="PROGRAMLISTING">
stringZ=abcABC123ABCabc
#                ======

echo `expr match &quot;$stringZ&quot; &#39;.*\([A-C][A-C][A-C][a-c]*\)&#39;`    # ABCabc
echo `expr &quot;$stringZ&quot; : &#39;.*\(......\)&#39;`                       # ABCabc
</pre>
            <br>
            <br>
          </dd>
        </dl>
      </div>

      <div
       class="VARIABLELIST">
        <p><strong>Удаление части строки</strong></p>

        <dl>
          <dt>${string#substring}</dt>

          <dd>
            <p>Удаление самой короткой, из найденных, подстроки <tt
             class="REPLACEABLE"><em>$substring</em></tt> в строке <tt
             class="REPLACEABLE"><em>$string</em></tt>. Поиск ведется с
            начала строки</p>
          </dd>

          <dt>${string##substring}</dt>

          <dd>
            <p>Удаление самой длинной, из найденных, подстроки <tt
             class="REPLACEABLE"><em>$substring</em></tt> в строке <tt
             class="REPLACEABLE"><em>$string</em></tt>. Поиск ведется с
            начала строки</p>
<pre
 class="PROGRAMLISTING">
stringZ=abcABC123ABCabc
#       |----|
#       |----------|

echo ${stringZ#a*C}      # 123ABCabc
# Удаление самой короткой подстроки.

echo ${stringZ##a*C}     # abc
# Удаление самой длинной подстроки.
</pre>
            <br>
            <br>
          </dd>

          <dt>${string%substring}</dt>

          <dd>
            <p>Удаление самой короткой, из найденных, подстроки <tt
             class="REPLACEABLE"><em>$substring</em></tt> в строке <tt
             class="REPLACEABLE"><em>$string</em></tt>. Поиск ведется с
            конца строки</p>
          </dd>

          <dt>${string%%substring}</dt>

          <dd>
            <p>Удаление самой длинной, из найденных, подстроки <tt
             class="REPLACEABLE"><em>$substring</em></tt> в строке <tt
             class="REPLACEABLE"><em>$string</em></tt>. Поиск ведется с
            конца строки</p>
<pre
 class="PROGRAMLISTING">
stringZ=abcABC123ABCabc
#                    ||
#        |------------|

echo ${stringZ%b*c}      # abcABC123ABCa
# Удаляется самое короткое совпадение. Поиск ведется с конца $stringZ.

echo ${stringZ%%b*c}     # a
# Удаляется самое длинное совпадение. Поиск ведется с конца $stringZ.
</pre>
            <br>
            <br>

            <div
             class="EXAMPLE">
              <a
               name="x4171_html_CVT"></a>

              <p><strong>Пример 9-11. Преобразование графических файлов
              из одного формата в другой, с изменением имени
              файла</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
#  cvt.sh:
#  Преобразование всех файлов в заданном  каталоге,
#+ из графического формата MacPaint, в формат &quot;pbm&quot;.

#  Используется утилита &quot;macptopbm&quot;, входящая в состав пакета &quot;netpbm&quot;,
#+ который сопровождается Brian Henderson (bryanh@giraffe-data.com).
#  Netpbm -- стандартный пакет для большинства дистрибутивов Linux.

OPERATION=macptopbm
SUFFIX=pbm          # Новое расширение файла.

if [ -n &quot;$1&quot; ]
then
  directory=$1      # Если каталог задан в командной строке при вызове сценария
else
  directory=$PWD    # Иначе просматривается текущий каталог.
fi

#  Все файлы в каталоге, имеющие расширение &quot;.mac&quot;, считаются файлами
#+ формата  MacPaint.

for file in $directory/* # Подстановка имен файлов.
do
  filename=${file%.*c}   #  Удалить расширение &quot;.mac&quot; из имени файла
                         #+ ( с шаблоном &#39;.*c&#39; совпадают все подстроки
                         #+ начинающиеся с &#39;.&#39; и заканчивающиеся &#39;c&#39;,
  $OPERATION $file &gt; &quot;$filename.$SUFFIX&quot;
                         # Преобразование с перенаправлением в файл с новым именем
  rm -f $file            # Удаление оригинального файла после преобразования.
  echo &quot;$filename.$SUFFIX&quot;  # Вывод на stdout.
done

exit 0

# Упражнение:
# --------
#  Сейчас этот сценарий конвертирует *все* файлы в каталоге
#  Измените его так, чтобы он конвертировал *только* те файлы,
#+ которые имеют расширение &quot;.mac&quot;.
</pre>
            </div>
          </dd>
        </dl>
      </div>

      <div
       class="VARIABLELIST">
        <p><strong>Замена подстроки</strong></p>

        <dl>
          <dt>${string/substring/replacement}</dt>

          <dd>
            <p>Замещает первое вхождение <tt
             class="REPLACEABLE"><em>$substring</em></tt> строкой <tt
             class="REPLACEABLE"><em>$replacement</em></tt>.</p>
          </dd>

          <dt>${string//substring/replacement}</dt>

          <dd>
            <p>Замещает все вхождения <tt
             class="REPLACEABLE"><em>$substring</em></tt> строкой <tt
             class="REPLACEABLE"><em>$replacement</em></tt>.</p>
<pre
 class="PROGRAMLISTING">
stringZ=abcABC123ABCabc

echo ${stringZ/abc/xyz}           # xyzABC123ABCabc
                                  # Замена первой подстроки &#39;abc&#39; строкой &#39;xyz&#39;.

echo ${stringZ//abc/xyz}          # xyzABC123ABCxyz
                                  # Замена всех подстрок &#39;abc&#39; строкой &#39;xyz&#39;.
</pre>
            <br>
            <br>
          </dd>

          <dt>${string/#substring/replacement}</dt>

          <dd>
            <p>Подстановка строки <tt
             class="REPLACEABLE"><em>$replacement</em></tt> вместо <tt
             class="REPLACEABLE"><em>$substring</em></tt>. Поиск
            ведется с начала строки <tt
             class="REPLACEABLE"><em>$string</em></tt>.</p>
          </dd>

          <dt>${string/%substring/replacement}</dt>

          <dd>
            <p>Подстановка строки <tt
             class="REPLACEABLE"><em>$replacement</em></tt> вместо <tt
             class="REPLACEABLE"><em>$substring</em></tt>. Поиск
            ведется с конца строки <tt
             class="REPLACEABLE"><em>$string</em></tt>.</p>
<pre
 class="PROGRAMLISTING">
stringZ=abcABC123ABCabc

echo ${stringZ/#abc/XYZ}          # XYZABC123ABCabc
                                  # Поиск ведется с начала строки

echo ${stringZ/%abc/XYZ}          # abcABC123ABCXYZ
                                  # Поиск ведется с конца строки
</pre>
            <br>
            <br>
          </dd>
        </dl>
      </div>

      <div
       class="SECT2">
        <h2
         class="SECT2"><a
         name="x4171_html_AWKSTRINGMANIP"></a>9.2.1. Использование awk при работе
        со строками</h2>

        <p>В качестве альтернативы, Bash-скрипты могут использовать
        средства <a
         href="#x14802_html_AWKREF">awk</a> при работе со строками.</p>

        <div
         class="EXAMPLE">
          <a
           name="x4171_html_SUBSTRINGEX"></a>

          <p><strong>Пример 9-12. Альтернативный способ извлечения
          подстрок</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# substring-extraction.sh

String=23skidoo1
#      012345678    Bash
#      123456789    awk
# Обратите внимание на различия в индексации:
# Bash начинает индексацию с &#39;0&#39;.
# Awk  начинает индексацию с &#39;1&#39;.

echo ${String:2:4} # с 3 позиции (0-1-2), 4 символа
                   # skid

# В эквивалент в awk: substr(string,pos,length).
echo | awk &#39;
{ print substr(&quot;&#39;&quot;${String}&quot;&#39;&quot;,3,4)      # skid
}
&#39;
#  Передача пустого &quot;echo&quot; по каналу в awk, означает фиктивный ввод,
#+ делая, тем самым, ненужным предоставление имени файла.

exit 0
</pre>
        </div>
      </div>

      <div
       class="SECT2">
        <h2
         class="SECT2"><a
         name="x4171_html_STRFDISC"></a>9.2.2. Дальнейшее обсуждение</h2>

        <p>Дополнительную информацию, по работе со строками, вы найдете
        в разделе <a
         href="#x4462_html">Section 9.3</a> и в <a
         href="#x6646_html_EXPEXTRSUB">секции</a>, посвященной команде
        <a
         href="#x6646_html_EXPRREF">expr</a>. Примеры сценариев:</p>

        <ol
         type="1">
          <li>
            <p><a
             href="#x6646_html_EX45">Пример 12-6</a></p>
          </li>

          <li>
            <p><a
             href="#x4462_html_LENGTH">Пример 9-15</a></p>
          </li>

          <li>
            <p><a
             href="#x4462_html_PATTMATCHING">Пример 9-16</a></p>
          </li>

          <li>
            <p><a
             href="#x4462_html_RFE">Пример 9-17</a></p>
          </li>

          <li>
            <p><a
             href="#x4462_html_VARMATCH">Пример 9-19</a></p>
          </li>
        </ol>
        <br>
        <br>
      </div>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN4257"
         href="#x4171_html_AEN4257"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Применяется к аргументам командной строки или входным
          параметрам <a
           href="#c12483_html_FUNCTIONREF">функций</a>.</p>
        </td>
      </tr>
    </table>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#c3270_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x4462_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">К вопросу о переменных</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c3270_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Подстановка параметров</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x4462_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x4171_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 9. К вопросу о переменных</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x4704_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x4462_html_PARAMETER-SUBSTITUTION"></a>9.3. Подстановка
      параметров</h1>

      <p><a
       name="x4462_html_PARAMSUBREF"></a></p>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="x4462_html_PSSUB1"></a>Работа с переменными и/или подстановка их
        значений</strong></p>

        <dl>
          <dt><tt
           class="USERINPUT"><strong>${parameter}</strong></tt></dt>

          <dd>
            <p>То же самое, что и <tt
             class="REPLACEABLE"><em>$parameter</em></tt>, т.е.
            значение переменной <tt
             class="REPLACEABLE"><em>parameter</em></tt>. В отдельных
            случаях, при возникновении неоднозначности интерпретации,
            корректно будет работать только такая форма записи: <tt
             class="REPLACEABLE"><em>${parameter}</em></tt>.</p>

            <p>Может использоваться для конкатенации (слияния)
            строковых переменных.</p>
<pre
 class="PROGRAMLISTING">
your_id=${USER}-on-${HOSTNAME}
echo &quot;$your_id&quot;
#
echo &quot;Старый \$PATH = $PATH&quot;
PATH=${PATH}:/opt/bin  #Добавление /opt/bin в $PATH.
echo &quot;Новый \$PATH = $PATH&quot;
</pre>
            <br>
            <br>
          </dd>

          <dt><tt
           class=
          "USERINPUT"><strong>${parameter-default}</strong></tt>, <tt
           class=
          "USERINPUT"><strong>${parameter:-default}</strong></tt></dt>

          <dd>
            <p>Если параметр отсутствует, то используется значение
            по-умолчанию.</p>
<pre
 class="PROGRAMLISTING">
echo ${username-`whoami`}
# Вывод результата работы команды `whoami`, если переменная $username не установлена.
</pre>
            <br>
            <br>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Формы записи <tt
                     class=
                    "REPLACEABLE"><em>${parameter-default}</em></tt> и
                    <tt
                     class=
                    "REPLACEABLE"><em>${parameter:-default}</em></tt> в
                    большинстве случаев можно считать эквивалентными.
                    Дополнительный символ <span
                     class="TOKEN">:</span> имеет значение только
                    тогда, когда <span
                     class="emphasis"><em
                     class="EMPHASIS">parameter</em></span> определен,
                    но имеет &quot;пустое&quot; (null) значение.</p>
                  </td>
                </tr>
              </table>
            </div>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

username0=
# переменная username0 объявлена, но инициализирована &quot;пустым&quot; значением.
echo &quot;username0 = ${username0-`whoami`}&quot;
# Вывод после символа &quot;=&quot; отсутствует.

echo &quot;username1 = ${username1-`whoami`}&quot;
# Переменная username1 не была объявлена.
# Выводится имя пользователя, выданное командой `whoami`.

username2=
# переменная username2 объявлена, но инициализирована &quot;пустым&quot; значением.
echo &quot;username2 = ${username2:-`whoami`}&quot;
# Выводится имя пользователя, выданное командой `whoami`, поскольку
#+здесь употребляется конструкция &quot;:-&quot; , а не  &quot;-&quot;.

exit 0
</pre>
            <br>
            <br>

            <p><span
             class="emphasis"><em
             class="EMPHASIS">Параметры по-умолчанию</em></span> очень
            часто находят применение в случаях, когда сценарию
            необходимы какие либо входные аргументы, передаваемые из
            командной строки, но такие аргументы не были переданы.</p>
<pre
 class="PROGRAMLISTING">
DEFAULT_FILENAME=generic.data
filename=${1:-$DEFAULT_FILENAME}
#  Если имя файла не задано явно, то последующие операторы будут работать
#+ с файлом &quot;generic.data&quot;.
#
</pre>
            <br>
            <br>

            <p>см. так же <a
             href="#c301_html_EX58">Пример 3-4</a>, <a
             href="#c13041_html_EX73">Пример 28-2</a> и <a
             href="#a14477_html_COLLATZ">Пример A-7</a>.</p>

            <p>Сравните этот подход с <a
             href="#c12716_html_ANDDEFAULT">методом списков <span
             class="emphasis"><em
             class="EMPHASIS">and list</em></span>, для задания
            параметров командной строки по-умолчанию</a> .</p>
          </dd>

          <dt><tt
           class=
          "USERINPUT"><strong>${parameter=default}</strong></tt>, <tt
           class=
          "USERINPUT"><strong>${parameter:=default}</strong></tt></dt>

          <dd>
            <p><a
             name="x4462_html_DEFPARAM"></a></p>

            <p>Если значения параметров не задананы явно, то они
            принимают значения по-умолчанию.</p>

            <p>Оба метода задания значений по-умолчанию до определенной
            степени идентичны. Символ <span
             class="TOKEN">:</span> имеет значение только когда <span
             class="emphasis"><em
             class="EMPHASIS">$parameter</em></span> был
            инициализирован &quot;пустым&quot; (null) значением, <a
             name="AEN4520"
             href="#x4462_html_FTN_AEN4520"><span
             class="footnote">[1]</span></a> как показано выше.</p>
<pre
 class="PROGRAMLISTING">
echo ${username=`whoami`}
# Переменная &quot;username&quot; принимает значение, возвращаемое командой `whoami`.
</pre>
            <br>
            <br>
          </dd>

          <dt><tt
           class=
          "USERINPUT"><strong>${parameter+alt_value}</strong></tt>, <tt
           class=
          "USERINPUT"><strong>${parameter:+alt_value}</strong></tt></dt>

          <dd>
            <p>Если параметр имеет какое либо значение, то используется
            <tt
             class="USERINPUT"><strong>alt_value</strong></tt>, иначе
            -- null (&quot;пустая&quot; строка).</p>

            <p>Оба варианта до определенной степени идентичны. Символ
            <span
             class="TOKEN">:</span> имеет значение только если <span
             class="emphasis"><em
             class="EMPHASIS">parameter</em></span> объявлен и
            &quot;пустой&quot;, см. ниже.</p>
<pre
 class="PROGRAMLISTING">
echo &quot;###### \${parameter+alt_value} ########&quot;
echo

a=${param1+xyz}
echo &quot;a = $a&quot;      # a =

param2=
a=${param2+xyz}
echo &quot;a = $a&quot;      # a = xyz

param3=123
a=${param3+xyz}
echo &quot;a = $a&quot;      # a = xyz

echo
echo &quot;###### \${parameter:+alt_value} ########&quot;
echo

a=${param4:+xyz}
echo &quot;a = $a&quot;      # a =

param5=
a=${param5:+xyz}
echo &quot;a = $a&quot;      # a =
# Вывод отличается от a=${param5+xyz}

param6=123
a=${param6+xyz}
echo &quot;a = $a&quot;      # a = xyz
</pre>
            <br>
            <br>
          </dd>

          <dt><a
           name="x4462_html_QERRMSG"></a><tt
           class=
          "USERINPUT"><strong>${parameter?err_msg}</strong></tt>, <tt
           class=
          "USERINPUT"><strong>${parameter:?err_msg}</strong></tt></dt>

          <dd>
            <p>Если parameter инициализирован, то используется его
            значение, в противном случае -- выводится err_msg.</p>

            <p>Обе формы записи можно, до определенной степени, считать
            идентичными. Символ <span
             class="TOKEN">:</span> имеет значение только когда <span
             class="emphasis"><em
             class="EMPHASIS">parameter</em></span> инициализирован
            &quot;пустым&quot; значением, см. ниже.</p>
          </dd>
        </dl>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="x4462_html_EX6"></a>

        <p><strong>Пример 9-13. Подстановка параметров и сообщения об
        ошибках</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

#  Проверка отдельных переменных окружения.
#  Если переменная, к примеру $USER, не установлена,
#+ то выводится сообщение об ошибке.

: ${HOSTNAME?} ${USER?} ${HOME?} ${MAIL?}
  echo
  echo &quot;Имя машины: $HOSTNAME.&quot;
  echo &quot;Ваше имя: $USER.&quot;
  echo &quot;Ваш домашний каталог: $HOME.&quot;
  echo &quot;Ваш почтовый ящик: $MAIL.&quot;
  echo
  echo &quot;Если перед Вами появилось это сообщение,&quot;
  echo &quot;то это значит, что все критические переменные окружения установлены.&quot;
  echo
  echo

# ------------------------------------------------------

#  Конструкция ${variablename?} так же выполняет проверку
#+ наличия переменной в сценарии.

ThisVariable=Value-of-ThisVariable
#  Обратите внимание, в строковые переменные могут быть записаны
#+ символы, которые запрещено использовать в именах переменных.
: ${ThisVariable?}
echo &quot;Value of ThisVariable is $ThisVariable&quot;.
echo
echo


: ${ZZXy23AB?&quot;Переменная ZZXy23AB не инициализирована.&quot;}
#  Если ZZXy23AB не инициализирована,
#+ то сценарий завершается с сообщением об ошибке.

# Текст сообщения об ошибке можно задать свой.
# : ${ZZXy23AB?&quot;Переменная ZZXy23AB не инициализирована.&quot;}


# То же самое:  dummy_variable=${ZZXy23AB?}
#               dummy_variable=${ZZXy23AB?&quot;Переменная ZXy23AB не инициализирована.&quot;}
#
#               echo ${ZZXy23AB?} &gt;/dev/null



echo &quot;Это сообщение не будет напечатано, поскольку сценарий завершится раньше.&quot;

HERE=0
exit $HERE   # Сценарий завершит работу не здесь.
</pre>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="x4462_html_USAGEMESSAGE"></a>

        <p><strong>Пример 9-14. Подстановка параметров и сообщение о
        <span
         class="QUOTE">&quot;порядке
        использования&quot;</span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# usage-message.sh

: ${1?&quot;Порядок использования: $0 ARGUMENT&quot;}
#  Сценарий завершит свою работу здесь, если входные аргументы отсутствуют,
#+ со следующим сообщением.
#    usage-message.sh: 1: Порядок использования: usage-message.sh ARGUMENT

echo &quot;Эти две строки появятся, только когда задан аргумент в командной строке.&quot;
echo &quot;Входной аргумент командной строки = \&quot;$1\&quot;&quot;

exit 0 # Точка выхода находится здесь, только когда задан аргумент командной строки.

# Проверьте код возврата в обеих случаях, с и без аргумента командной строки.
# Если аргумент задан, то код возврата будет равен 0.
# Иначе -- 1.
</pre>
      </div>

      <div
       class="FORMALPARA">
        <p><strong>Подстановка параметров и/или экспансия.</strong> <a
         name="x4462_html_PSUB2"></a>Следующие выражения могут служить
        дополнениями оператора <strong
         class="COMMAND">match</strong> команды <strong
         class="COMMAND">expr</strong>, применяемой к строкам (см. <a
         href="#x6646_html_EX45">Пример 12-6</a>). Как правило, они
        используются при разборе имен файлов и каталогов.</p>
      </div>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="x4462_html_PSOREX1"></a>Длина переменной / Удаление
        подстроки</strong></p>

        <dl>
          <dt><tt
           class="USERINPUT"><strong>${#var}</strong></tt></dt>

          <dd>
            <p><tt
             class="USERINPUT"><strong>String length</strong></tt>
            (число символов в переменной <tt
             class="VARNAME">$var</tt>). В случае <a
             href="#c12790_html_ARRAYREF">массивов</a>, команда <strong
             class="COMMAND">${#array}</strong> возвращает длину
            первого элемента массива.</p>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Исключения:</p>

                    <ul>
                      <li>
                        <p><strong
                         class="COMMAND">${#*}</strong> и <strong
                         class="COMMAND">${#@}</strong> возвращает
                        <span
                         class="emphasis"><em
                         class="EMPHASIS">количество аргументов
                        (позиционных параметров)</em></span>.</p>
                      </li>

                      <li>
                        <p>Для массивов, <strong
                         class="COMMAND">${#array[*]}</strong> и
                        <strong
                         class="COMMAND">${#array[@]}</strong>
                        возвращает количество элементов в массиве.</p>
                      </li>
                    </ul>
                    <br>
                    <br>
                  </td>
                </tr>
              </table>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="x4462_html_LENGTH"></a>

              <p><strong>Пример 9-15. Длина переменной</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# length.sh

E_NO_ARGS=65

if [ $# -eq 0 ]  # Для работы скрипта необходим хотя бы один входной параметр.
then
  echo &quot;Вызовите сценарий с одним или более параметром командной строки.&quot;
  exit $E_NO_ARGS
fi

var01=abcdEFGH28ij

echo &quot;var01 = ${var01}&quot;
echo &quot;Length of var01 = ${#var01}&quot;

echo &quot;Количество входных параметров = ${#@}&quot;
echo &quot;Количество входных параметров = ${#*}&quot;

exit 0
</pre>
            </div>
          </dd>

          <dt><tt
           class="USERINPUT"><strong>${var#Pattern}</strong></tt>, <tt
           class="USERINPUT"><strong>${var##Pattern}</strong></tt></dt>

          <dd>
            <p>Удаляет из переменной <tt
             class="VARNAME">$var</tt> наименьшую/наибольшую подстроку,
            совпадающую с шаблоном <tt
             class="VARNAME">$Pattern</tt>. Поиск ведется с начала
            строки <tt
             class="VARNAME">$var</tt>.</p>

            <p>Пример использования из <a
             href="#a14477_html_DAYSBETWEEN">Пример A-8</a>:</p>
<pre
 class="PROGRAMLISTING">
# Функцмя из сценария &quot;days-between.sh&quot;.
# Удаляет нули, стоящие в начале аргумента-строки.

strip_leading_zero () # Ведущие нули, которые согут находиться в номере дня/месяца,
                      # лучше удалить
  val=${1#0}          # В противном случае Bash будет интерпретировать числа
  return $val         # как восьмеричные (POSIX.2, sect 2.9.2.1).
}
</pre>
            <br>
            <br>

            <p>Другой пример:</p>
<pre
 class="PROGRAMLISTING">
echo `basename $PWD`        # Имя текущего рабочего каталога.
echo &quot;${PWD##*/}&quot;           # Имя текущего рабочего каталога.
echo
echo `basename $0`          # Имя файла-сценария.
echo $0                     # Имя файла-сценария.
echo &quot;${0##*/}&quot;             # Имя файла-сценария.
echo
filename=test.data
echo &quot;${filename##*.}&quot;      # data
                            # Расширение файла.
</pre>
            <br>
            <br>
          </dd>

          <dt><a
           name="x4462_html_PCTPATREF"></a><tt
           class="USERINPUT"><strong>${var%Pattern}</strong></tt>, <tt
           class="USERINPUT"><strong>${var%%Pattern}</strong></tt></dt>

          <dd>
            <p>Удаляет из переменной <tt
             class="VARNAME">$var</tt> наименьшую/наибольшую подстроку,
            совпадающую с шаблоном <tt
             class="VARNAME">$Pattern</tt>. Поиск ведется с конца
            строки <tt
             class="VARNAME">$var</tt>.</p>
          </dd>
        </dl>
      </div>

      <p>Bash <a
       href="#c13936_html_BASH2REF">версии 2</a> имеет ряд
      дополнительных возможностей.</p>

      <div
       class="EXAMPLE">
        <a
         name="x4462_html_PATTMATCHING"></a>

        <p><strong>Пример 9-16. Поиск по шаблону в подстановке
        параметров</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Поиск по шаблону в операциях подстановки параметров # ## % %%.

var1=abcd12345abc6789
pattern1=a*c  # * (символ шаблона), означает любые символы между a и c.

echo
echo &quot;var1 = $var1&quot;           # abcd12345abc6789
echo &quot;var1 = ${var1}&quot;         # abcd12345abc6789   (альтернативный вариант)
echo &quot;Число символов в ${var1} = ${#var1}&quot;
echo &quot;pattern1 = $pattern1&quot;   # a*c  (между &#39;a&#39; и &#39;c&#39; могут быть любые символы)
echo


echo &#39;${var1#$pattern1}  =&#39; &quot;${var1#$pattern1}&quot;    #         d12345abc6789
# Наименьшая подстрока, удаляются первые 3 символа  abcd12345abc6789
                                  ^^^^^^            |-|
echo &#39;${var1##$pattern1} =&#39; &quot;${var1##$pattern1}&quot;   #                  6789
# Наибольшая подстрока, удаляются первые 12 символов abcd12345abc6789
#                                 ^^^^^^             |----------|

echo; echo

pattern2=b*9            # все, что между &#39;b&#39; и &#39;9&#39;
echo &quot;var1 = $var1&quot;     # abcd12345abc6789
echo &quot;pattern2 = $pattern2&quot;
echo

echo &#39;${var1%pattern2}  =&#39; &quot;${var1%$pattern2}&quot;     #     abcd12345a
# Наименьшая подстрока, удаляются последние 6 символов  abcd12345abc6789
#                                 ^^^^^^^^^                       |----|
echo &#39;${var1%%pattern2} =&#39; &quot;${var1%%$pattern2}&quot;    #     a
# Наибольшая подстрока, удаляются последние 12 символов  abcd12345abc6789
#                                 ^^^^^^^^^               |-------------|

# Запомните, # и ## используются для поиска с начала строки,
#            % и %% используются для поиска с конца строки.

echo

exit 0
</pre>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="x4462_html_RFE"></a>

        <p><strong>Пример 9-17. Изменение расширений в именах
        файлов<span
         class="TOKEN">:</span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

#                 rfe
#                 ---

# Изменение расширений в именах файлов.
#
#         rfe old_extension new_extension
#
# Пример:
# Изменить все расширения *.gif в именах файлов на *.jpg, в текущем каталоге
#          rfe gif jpg

ARGS=2
E_BADARGS=65

if [ $# -ne &quot;$ARGS&quot; ]
then
  echo &quot;Порядок использования: `basename $0` old_file_suffix new_file_suffix&quot;
  exit $E_BADARGS
fi

for filename in *.$1
# Цикл прохода по списку имен файлов, имеющих расширение равное первому аргументу.
do
  mv $filename ${filename%$1}$2
  #  Удалить первое расширение и добавить второе,
done

exit 0
</pre>
      </div>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="x4462_html_EXPREPL1"></a>Подстановка значений переменных / Замена
        подстроки</strong></p>

        <dl>
          <dd>
            <p>Эти конструкции перекочевали в Bash из <span
             class="emphasis"><em
             class="EMPHASIS">ksh</em></span>.</p>
          </dd>

          <dt><tt
           class="USERINPUT"><strong>${var:pos}</strong></tt></dt>

          <dd>
            <p>Подстанавливается значение переменной <tt
             class="REPLACEABLE"><em>var</em></tt>, начиная с позиции
            <tt
             class="REPLACEABLE"><em>pos</em></tt>.</p>
          </dd>

          <dt><tt
           class="USERINPUT"><strong>${var:pos:len}</strong></tt></dt>

          <dd>
            <p>Подстанавливается значение переменной <tt
             class="REPLACEABLE"><em>var</em></tt>, начиная с позиции
            <tt
             class="REPLACEABLE"><em>pos</em></tt>, не более <tt
             class="REPLACEABLE"><em>len</em></tt> символов. См. <a
             href="#a14477_html_PW">Пример A-16</a>.</p>
          </dd>

          <dt><tt
           class=
          "USERINPUT"><strong>${var/Pattern/Replacement}</strong></tt></dt>

          <dd>
            <p>Первое совпадение с шаблоном <tt
             class="REPLACEABLE"><em>Pattern</em></tt>, в переменной
            <tt
             class="REPLACEABLE"><em>var</em></tt> замещается
            подстрокой <tt
             class="REPLACEABLE"><em>Replacement</em></tt>.</p>

            <p>Если подстрока <tt
             class="REPLACEABLE"><em>Replacement</em></tt> отсутствует,
            то найденное совпадение будет удалено.</p>
          </dd>

          <dt><tt
           class=
          "USERINPUT"><strong>${var//Pattern/Replacement}</strong></tt></dt>

          <dd>
            <div
             class="FORMALPARA">
              <p><strong>Глобальная замена.</strong> Все найденные
              совпадения с шаблоном <tt
               class="REPLACEABLE"><em>Pattern</em></tt>, в переменной
              <tt
               class="REPLACEABLE"><em>var</em></tt>, будут замещены
              подстрокой <tt
               class="REPLACEABLE"><em>Replacement</em></tt>.</p>
            </div>

            <p>Как и в первом случае, если подстрока <tt
             class="REPLACEABLE"><em>Replacement</em></tt> отсутствует,
            то все найденные совпадения будут удалены.</p>

            <div
             class="EXAMPLE">
              <a
               name="x4462_html_EX7"></a>

              <p><strong>Пример 9-18. Поиск по шаблону при анализе
              произвольных строк</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

var1=abcd-1234-defg
echo &quot;var1 = $var1&quot;

t=${var1#*-*}
echo &quot;var1 (все, от начала строки по первый символ \&quot;-\&quot;, включительно, удаляется) = $t&quot;
#  t=${var1#*-}  то же самое,
#+ поскольку оператор # ищет кратчайшее совпадение,
#+ а * соответствует любым предшествующим символам, включая пустую строку.
# (Спасибо S. C. за разъяснения.)

t=${var1##*-*}
echo &quot;Если var1 содержит \&quot;-\&quot;, то возвращается пустая строка...   var1 = $t&quot;


t=${var1%*-*}
echo &quot;var1 (все, начиная с последнего \&quot;-\&quot; удаляется) = $t&quot;

echo

# -------------------------------------------
path_name=/home/bozo/ideas/thoughts.for.today
# -------------------------------------------
echo &quot;path_name = $path_name&quot;
t=${path_name##/*/}
echo &quot;Из path_name удален путь к файлу = $t&quot;
#  В данном случае, тот эе эффект можно получить так:  t=`basename $path_name`
#  t=${path_name%/}; t=${t##*/}   более общее решение,
#+ но имеет некоторые ограничения.
#  Если $path_name заканчивается символом перевода строки, то `basename $path_name` не будет работать,
#+ но для данного случая вполне применимо.
# (Спасибо S.C.)

t=${path_name%/*.*}
# Тот же эффект дает    t=`dirname $path_name`
echo &quot;Из path_name удалено имя файла = $t&quot;
# Этот вариант будет терпеть неудачу в случаях: &quot;../&quot;, &quot;/foo////&quot;, # &quot;foo/&quot;, &quot;/&quot;.
#  Удаление имени файла, особенно когда его нет,
#+ использование dirname имеет свои особенности.
# (Спасибо S.C.)

echo

t=${path_name:11}
echo &quot;Из $path_name удалены первые 11 символов = $t&quot;
t=${path_name:11:5}
echo &quot;Из $path_name удалены первые 11 символов, выводится 5 символов = $t&quot;

echo

t=${path_name/bozo/clown}
echo &quot;В $path_name подстрока \&quot;bozo\&quot; заменена на \&quot;clown\&quot; = $t&quot;
t=${path_name/today/}
echo &quot;В $path_name подстрока \&quot;today\&quot; удалена = $t&quot;
t=${path_name//o/O}
echo &quot;В $path_name все символы \&quot;o\&quot; переведены в верхний регистр, = $t&quot;
t=${path_name//o/}
echo &quot;Из $path_name удалены все символы \&quot;o\&quot; = $t&quot;

exit 0
</pre>
            </div>
          </dd>

          <dt><tt
           class=
          "USERINPUT"><strong>${var/#Pattern/Replacement}</strong></tt></dt>

          <dd>
            <p>Если в переменной <tt
             class="REPLACEABLE"><em>var</em></tt> найдено совпадение с
            <tt
             class="REPLACEABLE"><em>Pattern</em></tt>, причем
            совпадающая подстрока расположена в начале строки
            (префикс), то оно заменяется на <tt
             class="REPLACEABLE"><em>Replacement</em></tt>. Поиск
            ведется с начала строки</p>
          </dd>

          <dt><tt
           class=
          "USERINPUT"><strong>${var/%Pattern/Replacement}</strong></tt></dt>

          <dd>
            <p>Если в переменной <tt
             class="REPLACEABLE"><em>var</em></tt> найдено совпадение с
            <tt
             class="REPLACEABLE"><em>Pattern</em></tt>, причем
            совпадающая подстрока расположена в конце строки (суффикс),
            то оно заменяется на <tt
             class="REPLACEABLE"><em>Replacement</em></tt>. Поиск
            ведется с конца строки</p>

            <div
             class="EXAMPLE">
              <a
               name="x4462_html_VARMATCH"></a>

              <p><strong>Пример 9-19. Поиск префиксов и суффиксов с
              заменой по шаблону</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Поиск с заменой по шаблону.

v0=abc1234zip1234abc    # Начальное значение переменной.
echo &quot;v0 = $v0&quot;         # abc1234zip1234abc
echo

# Поиск совпадения с начала строки.
v1=${v0/#abc/ABCDEF}    # abc1234zip1234abc
                        # |-|
echo &quot;v1 = $v1&quot;         # ABCDE1234zip1234abc
                        # |---|

# Поиск совпадения с конца строки.
v2=${v0/%abc/ABCDEF}    # abc1234zip123abc
                        #              |-|
echo &quot;v2 = $v2&quot;         # abc1234zip1234ABCDEF
                        #               |----|

echo

#  ----------------------------------------------------
#  Если совпадение находится не с начала/конца строки,
#+ то замена не производится.
#  ----------------------------------------------------
v3=${v0/#123/000}       # Совпадение есть, но не в начале строки.
echo &quot;v3 = $v3&quot;         # abc1234zip1234abc
                        # ЗАМЕНА НЕ ПРОИЗВОДТСЯ!
v4=${v0/%123/000}       # Совпадение есть, но не в конце строки.
echo &quot;v4 = $v4&quot;         # abc1234zip1234abc
                        # ЗАМЕНА НЕ ПРОИЗВОДТСЯ!

exit 0
</pre>
            </div>
          </dd>

          <dt><tt
           class="USERINPUT"><strong>${!varprefix*}</strong></tt>, <tt
           class="USERINPUT"><strong>${!varprefix@}</strong></tt></dt>

          <dd>
            <p>Поиск по шаблону всех, ранее объявленных переменных,
            имена которых начинаются с <span
             class="emphasis"><em
             class="EMPHASIS">varprefix</em></span>.</p>
<pre
 class="PROGRAMLISTING">
xyz23=whatever
xyz24=

a=${!xyz*}      # Подстановка имен объявленных переменных, которые начинаются с &quot;xyz&quot;.
echo &quot;a = $a&quot;   # a = xyz23 xyz24
a=${!xyz@}      # То же самое.
echo &quot;a = $a&quot;   # a = xyz23 xyz24

# Эта возможность была добавлена в Bash, в версии 2.04.
</pre>
            <br>
            <br>
          </dd>
        </dl>
      </div>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN4520"
         href="#x4462_html_AEN4520"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Если $parameter &quot;пустой&quot;,в неинтерактивных
          сценариях, то это будет приводить к завершению с <a
           href="#a14876_html_EXITCODESREF">кодом возврата <span
           class="RETURNVALUE">127</span></a> (<span
           class="QUOTE">&quot;command not found&quot;</span>).</p>
        </td>
      </tr>
    </table>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x4171_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x4704_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Работа со строками</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c3270_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Объявление переменных: <strong
           class="COMMAND">declare</strong> и <strong
           class="COMMAND">typeset</strong></td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x4704_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x4462_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 9. К вопросу о переменных</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x4788_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x4704_html_DECLAREREF"></a>9.4. Объявление переменных: <strong
       class="COMMAND">declare</strong> и <strong
       class="COMMAND">typeset</strong></h1>

      <p>Инструкции <strong
       class="COMMAND">declare</strong> и <strong
       class="COMMAND">typeset</strong> являются <a
       href="#c5358_html_BUILTINREF">встроенными</a> инструкциями (они
      абсолютно идентичны друг другу и являются синонимами) и
      предназначена для наложения ограничений на переменные. Это очень
      слабая попытка контроля над типами, которая имеется во многих
      языках программирования. Инструкция <strong
       class="COMMAND">declare</strong> появилась в Bash, начиная с
      версии 2. Кроме того, инструкция <strong
       class="COMMAND">typeset</strong> может использоваться и в
      ksh-сценариях.</p>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="x4704_html_DECLAREOPSREF1"></a>ключи инструкций
        declare/typeset</strong></p>

        <dl>
          <dt><span
           class="TOKEN">-r</span> <tt
           class="REPLACEABLE"><em>readonly</em></tt> (только для
          чтения)</dt>

          <dd>
<pre
 class="PROGRAMLISTING">
declare -r var1
</pre>
            <br>
            <br>

            <p>(<tt
             class="USERINPUT"><strong>declare -r var1</strong></tt>
            аналогично объявлению <tt
             class="USERINPUT"><strong>readonly var1</strong></tt>)</p>

            <p>Это грубый эквивалент констант (const) в языке C.
            Попытка изменения таких переменных завершается сообщением
            об ошибке.</p>
          </dd>

          <dt><span
           class="TOKEN">-i</span> <tt
           class="REPLACEABLE"><em>integer</em></tt></dt>

          <dd>
<pre
 class="PROGRAMLISTING">
declare -i number
# Сценарий интерпретирует переменную &quot;number&quot; как целое число.

number=3
echo &quot;number = $number&quot;     # number = 3

number=three
echo &quot;number = $number&quot;     # number = 0
# Строка &quot;three&quot; интерпретируется как целое число.
</pre>
            Примечательно, что допускается выполнение некоторых
            арифметических операций над переменными, объявленными как
            integer, не прибегая к инструкциям <a
             href="#x6646_html_EXPRREF">expr</a> или <a
             href="#c5358_html_LETREF">let</a>.<br>
            <br>
          </dd>

          <dt><span
           class="TOKEN">-a</span> <tt
           class="REPLACEABLE"><em>array</em></tt></dt>

          <dd>
<pre
 class="PROGRAMLISTING">
declare -a indices
</pre>
            <br>
            <br>

            <p>Переменная <tt
             class="VARNAME">indices</tt> объявляется массивом.</p>
          </dd>

          <dt><span
           class="TOKEN">-f</span> <tt
           class="REPLACEABLE"><em>functions</em></tt></dt>

          <dd>
<pre
 class="PROGRAMLISTING">
declare -f
</pre>
            <br>
            <br>

            <p>Инструкция <tt
             class="USERINPUT"><strong>declare -f</strong></tt>, без
            аргументов, приводит к выводу списка ранее объявленных
            функций в сценарии.</p>
<pre
 class="PROGRAMLISTING">
declare -f function_name
</pre>
            <br>
            <br>

            <p>Инструкция <tt
             class="USERINPUT"><strong>declare -f
            function_name</strong></tt> выводит имя функции
            function_name, если она была объявлена ранее.</p>
          </dd>

          <dt><span
           class="TOKEN">-x</span> <a
           href="#c5358_html_EXPORTREF">export</a></dt>

          <dd>
<pre
 class="PROGRAMLISTING">
declare -x var3
</pre>
            <br>
            <br>

            <p>Эта инструкция объявляет переменную, как доступную для
            экспорта.</p>
          </dd>

          <dt>var=$value</dt>

          <dd>
<pre
 class="PROGRAMLISTING">
declare -x var3=373
</pre>
            <br>
            <br>

            <p>Инструкция <strong
             class="COMMAND">declare</strong> допускает совмещение
            объявления и присваивания значения переменной
            одновременно.</p>
          </dd>
        </dl>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="x4704_html_EX20"></a>

        <p><strong>Пример 9-20. Объявление переменных с помощью
        инструкции declare</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

func1 ()
{
echo Это функция.
}

declare -f        # Список функций, объявленных выше.

echo

declare -i var1   # var1 -- целочисленная переменная.
var1=2367
echo &quot;переменная var1 объявлена как $var1&quot;
var1=var1+1       # Допустимая арифметическая операция над целочисленными переменными.
echo &quot;переменная var1 увеличена на 1 = $var1.&quot;
# Допустимая операция для целочисленных переменных
echo &quot;Возможно ли записать дробное число 2367.1 в var1?&quot;
var1=2367.1       # Сообщение об ошибке, переменная не изменяется.
echo &quot;значение переменной var1 осталось прежним = $var1&quot;

echo

declare -r var2=13.36         # инструкция &#39;declare&#39; допускает установку свойств переменной
                              #+ и одновременно присваивать значение.
echo &quot;var2 declared as $var2&quot; # Допускается ли изменять значение readonly переменных?
var2=13.37                    # Сообщение об ошибке и завершение работы сценария.

echo &quot;значение переменной var2 осталось прежним $var2&quot; # Эта строка никогда не будет выполнена.

exit 0                        # Сценарий завершит работу выше.
</pre>
      </div>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x4462_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x4788_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Подстановка параметров</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c3270_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Косвенные ссылки на переменные</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x4788_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x4704_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 9. К вопросу о переменных</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x4812_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x4788_html_IVR"></a>9.5. Косвенные ссылки на переменные</h1>

      <p><a
       name="x4788_html_IVRREF"></a></p>

      <p>Предположим, что значение одной переменной -- есть имя второй
      переменной. Возможно ли получить значение второй переменной через
      обращение к первой? Например, Пусть <tt
       class="REPLACEABLE"><em>a=letter_of_alphabet</em></tt> и <tt
       class="REPLACEABLE"><em>letter_of_alphabet=z</em></tt>, тогда
      вопрос будет звучать так: &quot;Возможно ли получить значение <tt
       class="REPLACEABLE"><em>z</em></tt>, обратившись к переменной
      <tt
       class="REPLACEABLE"><em>a</em></tt>?&quot;. В действительности
      это возможно и это называется <span
       class="emphasis"><em
       class="EMPHASIS">косвенной ссылкой</em></span>. Для этого
      необходимо прибегнуть к несколько необычной нотации <tt
       class="REPLACEABLE"><em>eval var1=\$$var2</em></tt>.</p>

      <div
       class="EXAMPLE">
        <a
         name="x4788_html_INDREF"></a>

        <p><strong>Пример 9-21. Косвенные ссылки</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Косвенные ссылки на переменные.

a=letter_of_alphabet
letter_of_alphabet=z

echo

# Прямое обращение к переменной.
echo &quot;a = $a&quot;

# Косвенное обращение к переменной.
eval a=\$$a
echo &quot;А теперь a = $a&quot;

echo


# Теперь попробуем изменить переменную, на которую делается ссылка.

t=table_cell_3
table_cell_3=24
echo &quot;\&quot;table_cell_3\&quot; = $table_cell_3&quot;
echo -n &quot;разыменование (получение ссылки) \&quot;t\&quot; = &quot;; eval echo \$$t
# В данном, простом, случае,
#   eval t=\$$t; echo &quot;\&quot;t\&quot; = $t&quot;
# дает тот же результат (почему?).

echo

t=table_cell_3
NEW_VAL=387
table_cell_3=$NEW_VAL
echo &quot;Значение переменной \&quot;table_cell_3\&quot; изменено на $NEW_VAL.&quot;
echo &quot;Теперь \&quot;table_cell_3\&quot; = $table_cell_3&quot;
echo -n &quot;разыменование (получение ссылки) \&quot;t\&quot; = &quot;; eval echo \$$t
# инструкция &quot;eval&quot; принимает два аргумента &quot;echo&quot; и &quot;\$$t&quot; (назначает равным $table_cell_3)
echo

# (Спасибо S.C. за разъяснения.)


# Еще один способ -- нотация ${!t}, будет обсуждаться в разделе &quot;Bash, версия 2&quot;.
# Так же, см. пример &quot;ex78.sh&quot;.

exit 0
</pre>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="x4788_html_COLTOTALER2"></a>

        <p><strong>Пример 9-22. Передача косвенных ссылок в <tt
         class="REPLACEABLE"><em>awk</em></tt></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Другая версия сценария &quot;column totaler&quot;
# который суммирует заданную колонку (чисел) в заданном файле.
# Здесь используются косвенные ссылки.

ARGS=2
E_WRONGARGS=65

if [ $# -ne &quot;$ARGS&quot; ] # Проверка количества входных аргументов.
then
   echo &quot;Порядок использования: `basename $0` filename column-number&quot;
   exit $E_WRONGARGS
fi

filename=$1
column_number=$2

#===== До этой строки идентично первоначальному варианту сценария =====#


# Мнгострочные скрипты awk вызываются конструкцией   awk &#39; ..... &#39;


# Начало awk-сценария.
# ------------------------------------------------
awk &quot;

{ total += \$${column_number} # косвенная ссылка
}
END {
     print total
     }

     &quot; &quot;$filename&quot;
# ------------------------------------------------
# Конец awk-сценария.

# Косвенные ссылки делают возможным бесконфликтное
# обращение к переменным shell внутри вложенных сценариев awk.
# Спасибо Stephane Chazelas.


exit 0
</pre>
      </div>

      <div
       class="CAUTION">
        <table
         class="CAUTION"
         width="100%"
         border="0">
          <tr>
            <td
             width="25"
             align="center"
             valign="top"><img
             src="misc/abs-book/images/caution.gif"
             hspace="5"
             alt="Caution"></td>

            <td
             align="left"
             valign="top">
              <p>Такой метод обращения к переменным имеет свои
              особенности. Если переменная, на которую делается ссылка,
              меняет свое значение, то переменная которая ссылается,
              должна быть должным образом разыменована, т.е. олжна быть
              выполнена операция получения ссылки, как это делается в
              примере выше. <a
               name="x4788_html_IVR2"></a>К счастью, нотация <tt
               class="REPLACEABLE"><em>${!variable}</em></tt>,
              введенная в Bash, начиная с <a
               href="#c13936_html_BASH2REF">версии 2</a> (см. <a
               href="#c13936_html_EX78">Пример 34-2</a>) позволяет
              выполнять косвенные ссылки более интуитивно понятным
              образом.</p>
            </td>
          </tr>
        </table>
      </div>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x4704_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x4812_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Объявление переменных: <strong
           class="COMMAND">declare</strong> и <strong
           class="COMMAND">typeset</strong></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c3270_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">$RANDOM: генерация псевдослучайных целых
          чисел</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x4812_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x4788_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 9. К вопросу о переменных</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x4862_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x4812_html_RANDOMVAR"></a>9.6. $RANDOM: генерация псевдослучайных
      целых чисел</h1>

      <p>$RANDOM -- внутренняя функция Bash (не константа), которая
      возвращает <span
       class="emphasis"><em
       class="EMPHASIS">псевдослучайные</em></span> целые числа в
      диапазоне 0 - 32767. Функция $RANDOM <tt
       class="REPLACEABLE"><em>не</em></tt> должна использоваться для
      генераци ключей шифрования.</p>

      <div
       class="EXAMPLE">
        <a
         name="x4812_html_EX21"></a>

        <p><strong>Пример 9-23. Генерация случайных чисел</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# $RANDOM возвращает различные случайные числа при каждом обращении к ней.
# Диапазон изменения: 0 - 32767 (16-битовое целое со знаком).

MAXCOUNT=10
count=1

echo
echo &quot;$MAXCOUNT случайных чисел:&quot;
echo &quot;-----------------&quot;
while [ &quot;$count&quot; -le $MAXCOUNT ]      # Генерация 10 ($MAXCOUNT) случайных чисел.
do
  number=$RANDOM
  echo $number
  let &quot;count += 1&quot;  # Нарастить счетчик.
done
echo &quot;-----------------&quot;

# Если вам нужны случайные числа не превышающие определенного числа,
# воспользуйтесь оператором деления по модулю (остаток от деления).

RANGE=500

echo

number=$RANDOM
let &quot;number %= $RANGE&quot;
echo &quot;Случайное число меньше $RANGE  ---  $number&quot;

echo

# Если вы желаете ограничить диапазон &quot;снизу&quot;,
# то просто производите генерацию псевдослучайных чисел в цикле до тех пор,
# пока не получите число большее нижней границы.

FLOOR=200

number=0   # инициализация
while [ &quot;$number&quot; -le $FLOOR ]
do
  number=$RANDOM
done
echo &quot;Случайное число, большее $FLOOR ---  $number&quot;
echo


# Эти два способа могут быть скомбинированы.
number=0   #initialize
while [ &quot;$number&quot; -le $FLOOR ]
do
  number=$RANDOM
  let &quot;number %= $RANGE&quot;  # Ограничение &quot;сверху&quot; числом $RANGE.
done
echo &quot;Случайное число в диапазоне от $FLOOR до $RANGE ---  $number&quot;
echo


# Генерация случайных &quot;true&quot; и &quot;false&quot; значений.
BINARY=2
number=$RANDOM
T=1

let &quot;number %= $BINARY&quot;
# let &quot;number &gt;&gt;= 14&quot;    дает более равномерное распределение
# (сдвиг вправо смещает старший бит на нулевую позицию, остальные биты обнуляются).
if [ &quot;$number&quot; -eq $T ]
then
  echo &quot;TRUE&quot;
else
  echo &quot;FALSE&quot;
fi

echo


# Можно имитировать бросание 2-х игровых кубиков.
SPOTS=7   # остаток от деления на 7 дает диапазон 0 - 6.
ZERO=0
die1=0
die2=0

# Кубики &quot;выбрасываются&quot; раздельно.

  while [ &quot;$die1&quot; -eq $ZERO ]     # Пока на &quot;кубике&quot; ноль.
  do
    let &quot;die1 = $RANDOM % $SPOTS&quot; # Имитировать бросок первого кубика.
  done

  while [ &quot;$die2&quot; -eq $ZERO ]
  do
    let &quot;die2 = $RANDOM % $SPOTS&quot; # Имитировать бросок второго кубика.
  done

let &quot;throw = $die1 + $die2&quot;
echo &quot;Результат броска кубиков = $throw&quot;
echo


exit 0
</pre>
      </div>

      <div
       class="EXAMPLE">
        <a
         name="x4812_html_PICKCARD"></a>

        <p><strong>Пример 9-24. Выбор случайной карты из
        колоды</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# pick-card.sh

# Пример выбора случайного элемента массива.


# Выбор случайной карты из колоды.

Suites=&quot;Треф
Бубей
Червей
Пик&quot;

Denominations=&quot;2
3
4
5
6
7
8
9
10
Валет
Дама
Король
Туз&quot;

suite=($Suites)                # Инициализация массивов.
denomination=($Denominations)

num_suites=${#suite[*]}        # Количество элементов массивов.
num_denominations=${#denomination[*]}

echo -n &quot;${denomination[$((RANDOM%num_denominations))]} &quot;
echo ${suite[$((RANDOM%num_suites))]}


# $bozo sh pick-cards.sh
# Валет Треф


# Спасибо &quot;jipe,&quot; за пояснения по работе с $RANDOM.
exit 0
</pre>
      </div>

      <div
       class="NOTE">
        <table
         class="NOTE"
         width="100%"
         border="0">
          <tr>
            <td
             width="25"
             align="center"
             valign="top"><img
             src="misc/abs-book/images/note.gif"
             hspace="5"
             alt="Note"></td>

            <td
             align="left"
             valign="top">
              <p><span
               class="emphasis"><em
               class="EMPHASIS">Jipe</em></span> подсказал еще один
              способ генерации случайных чисел из заданного
              диапазона.</p>
<pre
 class="PROGRAMLISTING">
#  Генерация случайных чисел в диапазоне 6 - 30.
rnumber=$((RANDOM%25+6))

#  Генерируется случайное число из диапазона 6 - 30,
#+ но при этом число должно делиться на 3 без остатка.
rnumber=$(((RANDOM%30/3+1)*3))

#  Упражнение: Попробуйте разобраться с выражением самостоятельно.
</pre>
              <br>
              <br>
            </td>
          </tr>
        </table>
      </div>

      <p>Насколько случайны числа, возвращаемые функцией $RANDOM?
      Лучший способ оценить &quot;случайность&quot; генерируемых чисел
      -- это написать сценарий, который будет имитировать бросание
      игрального кубика достаточно большое число раз, а затем выведет
      количество выпадений каждой из граней...</p>

      <div
       class="EXAMPLE">
        <a
         name="x4812_html_RANDOMTEST"></a>

        <p><strong>Пример 9-25. Имитация бросания кубика с помощью
        RANDOM</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Случайные ли числа возвращает RANDOM?

RANDOM=$$       # Инициализация генератора случайных чисел числом PID процесса-сценария.

PIPS=6          # Кубик имеет 6 граней.
MAXTHROWS=600   # Можете увеличить, если не знаете куда девать свое время.
throw=0         # Счетчик бросков.

zeroes=0        # Обнулить счетчики выпадения отдельных граней.
ones=0          # т.к. неинициализированные переменные - &quot;пустые&quot;, и не равны нулю!.
twos=0
threes=0
fours=0
fives=0
sixes=0

print_result ()
{
echo
echo &quot;единиц   =   $ones&quot;
echo &quot;двоек    =   $twos&quot;
echo &quot;троек    =   $threes&quot;
echo &quot;четверок =   $fours&quot;
echo &quot;пятерок  =   $fives&quot;
echo &quot;шестерок =   $sixes&quot;
echo
}

update_count()
{
case &quot;$1&quot; in
  0) let &quot;ones += 1&quot;;;   # 0 соответствует грани &quot;1&quot;.
  1) let &quot;twos += 1&quot;;;   # 1 соответствует грани &quot;2&quot;, и так далее
  2) let &quot;threes += 1&quot;;;
  3) let &quot;fours += 1&quot;;;
  4) let &quot;fives += 1&quot;;;
  5) let &quot;sixes += 1&quot;;;
esac
}

echo


while [ &quot;$throw&quot; -lt &quot;$MAXTHROWS&quot; ]
do
  let &quot;die1 = RANDOM % $PIPS&quot;
  update_count $die1
  let &quot;throw += 1&quot;
done

print_result

# Количество выпадений каждой из граней должно быть примерно одинаковым, если считать RANDOM достаточно случайным.
# Для $MAXTHROWS = 600, каждая грань должна выпасть примерно 100 раз (плюс-минус 20).
#
# Имейте ввиду, что RANDOM - это генератор ПСЕВДОСЛУЧАЙНЫХ чисел,

# Упражнение:
# ---------------
# Перепишите этот сценарий так, чтобы он имитировал 1000 бросков монеты.
# На каждом броске возможен один из двух вариантов выпадения - &quot;ОРЕЛ&quot; или &quot;РЕШКА&quot;.

exit 0
</pre>
      </div>

      <p>Как видно из последнего примера, неплохо было бы производить
      переустановку начального числа генератора случайных чисел <tt
       class="VARNAME">RANDOM</tt> перед тем, как начать работу с ним.
      Если используется одно и то же начальное число, то генератор <tt
       class="VARNAME">RANDOM</tt> будет выдавать одну и ту же
      последовательность чисел. (Это совпадает с поведением функции <tt
       class="REPLACEABLE"><em>random()</em></tt> в языке C.)</p>

      <div
       class="EXAMPLE">
        <a
         name="x4812_html_SEEDINGRANDOM"></a>

        <p><strong>Пример 9-26. Переустановка RANDOM</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# seeding-random.sh: Переустановка переменной RANDOM.

MAXCOUNT=25       # Длина генерируемой последовательности чисел.

random_numbers ()
{
count=0
while [ &quot;$count&quot; -lt &quot;$MAXCOUNT&quot; ]
do
  number=$RANDOM
  echo -n &quot;$number &quot;
  let &quot;count += 1&quot;
done
}

echo; echo

RANDOM=1          # Переустановка начального числа генератора случайных чисел RANDOM.
random_numbers

echo; echo

RANDOM=1          # То же самое начальное число...
random_numbers    # ...в результате получается та же последовательность чисел.
                  #
                  # В каких случаях может оказаться полезной генерация совпадающих серий?

echo; echo

RANDOM=2          # Еще одна попытка, но с другим начальным числом...
random_numbers    # получим другую последовательность.

echo; echo

# RANDOM=$$  в качестве начального числа выбирается PID процесса-сценария.
# Вполне допустимо взять в качестве начального числа результат работы команд &#39;time&#39; или &#39;date&#39;.

# Немного воображения...
SEED=$(head -1 /dev/urandom | od -N 1 | awk &#39;{ print $2 }&#39;)
#  Псевдослучайное число забирается
#+ из системного генератора псевдослучайных чисел /dev/urandom ,
#+ затем конвертируется в восьмеричное число командой &quot;od&quot;,
#+ и наконец &quot;awk&quot; возвращает единственное число для переменной SEED.
RANDOM=$SEED
random_numbers

echo; echo

exit 0
</pre>
      </div>

      <p><a
       name="x4812_html_URANDOMREF"></a></p>

      <div
       class="NOTE">
        <table
         class="NOTE"
         width="100%"
         border="0">
          <tr>
            <td
             width="25"
             align="center"
             valign="top"><img
             src="misc/abs-book/images/note.gif"
             hspace="5"
             alt="Note"></td>

            <td
             align="left"
             valign="top">
              <p>Системный генератор <tt
               class="FILENAME">/dev/urandom</tt> дает
              последовательность псевдослучайных чисел с более
              равномерным распределением, чем <tt
               class="VARNAME">$RANDOM</tt>. Команда <tt
               class="USERINPUT"><strong>dd if=/dev/urandom
              of=targetfile bs=1 count=XX</strong></tt> создает файл,
              содержащий последовательность псевдослучайных чисел.
              Однако, эти числа требуют дополнительной обработки,
              например с помощью команды <a
               href="#x9307_html_ODREF">od</a> (этот прием используется
              в примере выше) или <a
               href="#x9307_html_DDREF">dd</a> (см. <a
               href="#x9307_html_BLOTOUT">Пример 12-42</a>).</p>

              <p><a
               name="x4812_html_AWKRANDOMREF"></a></p>

              <p>Есть и другие способы генерации псевдослучайных
              последовательностей в сценариях. <strong
               class="COMMAND">Awk</strong> имеет для этого достаточно
              удобные средства.</p>

              <div
               class="EXAMPLE">
                <a
                 name="x4812_html_RANDOM2"></a>

                <p><strong>Пример 9-27. Получение псевдослучайных чисел
                с помощью <a
                 href="#x14802_html_AWKREF">awk</a></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# random2.sh: Генерация псевдослучайных чисел в диапазоне 0 - 1.
# Используется функция rand() из awk.

AWKSCRIPT=&#39; { srand(); print rand() } &#39;
# Команды/параметры, передаваемые awk
# Обратите внимание, функция srand() переустанавливает начальное число генератора случайных чисел.

echo -n &quot;Случайное число в диапазоне от 0 до 1 = &quot;
echo | awk &quot;$AWKSCRIPT&quot;

exit 0


# Упражнения:
# ---------

# 1) С помощью оператора цикла выведите 10 различных случайных чисел.
#      (Подсказка: вам потребуется вызвать функцию &quot;srand()&quot;
#      в каждом цикле с разными начальными числами.
#      Что произойдет, если этого не сделать?)

# 2) Заставьте сценарий генерировать случайные числа в диапазоне 10 - 100
#      используя целочисленный множитель, как коэффициент масштабирования

# 3) То же самое, что и во втором упражнении,
#      но на этот раз случайные числа должны быть целыми.
</pre>
              </div>
            </td>
          </tr>
        </table>
      </div>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x4788_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x4862_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Косвенные ссылки на переменные</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c3270_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Двойные круглые скобки</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x4862_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x4812_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 9. К вопросу о переменных</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#c4875_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x4862_html_DBLPARENS"></a>9.7. Двойные круглые скобки</h1>

      <p>Эта конструкция во многом похожа на инструкцию <a
       href="#c5358_html_LETREF">let</a>, внутри <strong
       class="COMMAND">((...))</strong> вычисляются арифметические
      выражения и возвращается их результат. В простейшем случае,
      конструкция <tt
       class="USERINPUT"><strong>a=$(( 5 + 3 ))</strong></tt> присвоит
      переменной <span
       class="QUOTE">&quot;a&quot;</span> значение выражения <span
       class="QUOTE">&quot;5 + 3&quot;</span>, или 8. Но, кроме того,
      двойные круглые скобки позволяют работать с переменными в стиле
      языка C.</p>

      <div
       class="EXAMPLE">
        <a
         name="x4862_html_CVARS"></a>

        <p><strong>Пример 9-28. Работа с переменными в стиле языка
        C</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Работа с переменными в стиле языка C.


echo

(( a = 23 ))  # Присвоение переменной в стиле C, с обоих строн от &quot;=&quot; стоят пробелы.
echo &quot;a (начальное значение) = $a&quot;

(( a++ ))     # Пост-инкремент &#39;a&#39;, в стиле C.
echo &quot;a (после a++) = $a&quot;

(( a-- ))     # Пост-декремент &#39;a&#39;, в стиле C.
echo &quot;a (после a--) = $a&quot;


(( ++a ))     # Пред-инкремент &#39;a&#39;, в стиле C.
echo &quot;a (после ++a) = $a&quot;

(( --a ))     # Пред-декремент &#39;a&#39;, в стиле C.
echo &quot;a (после --a) = $a&quot;

echo

(( t = a&lt;45?7:11 ))   # Трехместный оператор в стиле языка C.
echo &quot;If a &lt; 45, then t = 7, else t = 11.&quot;
echo &quot;t = $t &quot;        # Да!

echo

# См. так же описание ((...))  в циклах &quot;for&quot; и &quot;while&quot;.

# Эта конструкция доступна в Bash, начиная с версии 2.04.

exit 0
</pre>
      </div>

      <p>См. так же <a
       href="#c4875_html_FORLOOPC">Пример 10-12</a>.</p>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x4812_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#c4875_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">$RANDOM: генерация псевдослучайных целых
          чисел</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c3270_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Циклы и ветвления</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x5140_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#c4875_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 10. Циклы и ветвления</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x5153_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x5140_html_NESTEDLOOPS"></a>10.2. Вложенные циклы</h1>

      <p>Цикл называется вложенным, если он размещается внутри другого
      цикла. На первом проходе, внешний цикл вызывает внутренний,
      который исполняется до своего завершения, после чего управление
      передается в тело внешнего цикла. На втором проходе внешний цикл
      опять вызывает внутренний. И так до тех пор, пока не завершится
      внешний цикл. Само собой, как внешний, так и внутренний циклы
      могут быть прерваны командой <strong
       class="COMMAND">break</strong>.</p>

      <div
       class="EXAMPLE">
        <a
         name="x5140_html_NESTEDLOOP"></a>

        <p><strong>Пример 10-19. Вложенный цикл</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Вложенные циклы &quot;for&quot;.

outer=1             # Счетчик внешнего цикла.

# Начало внешнего цикла.
for a in 1 2 3 4 5
do
  echo &quot;Итерация #$outer внешнего цикла.&quot;
  echo &quot;---------------------&quot;
  inner=1           # Сброс счетчика вложенного цикла.

  # Начало вложенного цикла.
  for b in 1 2 3 4 5
  do
    echo &quot;Итерация #$inner вложенного цикла.&quot;
    let &quot;inner+=1&quot;  # Увеличить счетчик итераций вложенного цикла.
  done
  # Конец вложенного цикла.

  let &quot;outer+=1&quot;    # Увеличить счетчик итераций внешнего цикла.
  echo              # Пустая строка для отделения итераций внешнего цикла.
done
# Конец внешнего цикла.

exit 0
</pre>
      </div>

      <p>Демонстрацию вложенных циклов <span
       class="QUOTE">&quot;while&quot;</span> вы найдете в <a
       href="#c12790_html_BUBBLE">Пример 25-6</a>, а вложение цикла
      <span
       class="QUOTE">&quot;while&quot;</span> в <span
       class="QUOTE">&quot;until&quot;</span> -- в <a
       href="#c12790_html_EX68">Пример 25-8</a>.</p>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#c4875_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x5153_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Циклы и ветвления</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c4875_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Управление ходом выполнения цикла</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x5153_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x5140_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 10. Циклы и ветвления</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x5210_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x5153_html_LOOPCONTROL"></a>10.3. Управление ходом выполнения
      цикла</h1>

      <div
       class="VARIABLELIST">
        <dl>
          <dt><strong
           class="COMMAND">break</strong>, <strong
           class="COMMAND">continue</strong></dt>

          <dd>
            <p>Для управления ходом выполнения цикла служат команды
            <strong
             class="COMMAND">break</strong> и <strong
             class="COMMAND">continue</strong> <a
             name="AEN5175"
             href="#x5153_html_FTN_AEN5175"><span
             class="footnote">[1]</span></a> и точно соответствуют
            своим аналогам в других языках программирования. Команда
            <strong
             class="COMMAND">break</strong> прерывает исполнение цикла,
            в то время как <strong
             class="COMMAND">continue</strong> передает управление в
            начало цикло, минуя все последующие команды в теле
            цикла.</p>

            <div
             class="EXAMPLE">
              <a
               name="x5153_html_EX28"></a>

              <p><strong>Пример 10-20. Команды break и continue в
              цикле</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

LIMIT=19  # Верхний предел

echo
echo &quot;Печать чисел от 1 до 20 (исключая 3 и 11).&quot;

a=0

while [ $a -le &quot;$LIMIT&quot; ]
do
 a=$(($a+1))

 if [ &quot;$a&quot; -eq 3 ] || [ &quot;$a&quot; -eq 11 ]  # Исключить 3 и 11
 then
   continue  # Переход в начало цикла.
 fi

 echo -n &quot;$a &quot;
done

# Упражнение:
# Почему число 20 тоже выводится?

echo; echo

echo Печать чисел от 1 до 20, но взгляните, что происходит после вывода числа 2

##################################################################

# Тот же цикл, только &#39;continue&#39; заменено на &#39;break&#39;.

a=0

while [ &quot;$a&quot; -le &quot;$LIMIT&quot; ]
do
 a=$(($a+1))

 if [ &quot;$a&quot; -gt 2 ]
 then
   break  # Завершение работы цикла.
 fi

 echo -n &quot;$a &quot;
done

echo; echo; echo

exit 0
</pre>
            </div>

            <p>Команде <strong
             class="COMMAND">break</strong> может быть передан
            необязательный параметр. Команда <strong
             class="COMMAND">break</strong> без параметра прерывает тот
            цикл, в который она вставлена, а <strong
             class="COMMAND">break N</strong> прерывает цикл, стоящий
            на N уровней выше (причем 1-й уровень -- это уровень
            текущего цикла, прим. перев.).</p>

            <div
             class="EXAMPLE">
              <a
               name="x5153_html_BREAKLEVELS"></a>

              <p><strong>Пример 10-21. Прерывание многоуровневых
              циклов</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# break-levels.sh: Прерывание циклов.

# &quot;break N&quot; прерывает исполнение цикла, стоящего на N уровней выше текущего.

for outerloop in 1 2 3 4 5
do
  echo -n &quot;Группа $outerloop:   &quot;

  for innerloop in 1 2 3 4 5
  do
    echo -n &quot;$innerloop &quot;

    if [ &quot;$innerloop&quot; -eq 3 ]
    then
      break  # Попробуйте &quot;break 2&quot;,
             # тогда будут прерываться как вложенный, так и внешний циклы
    fi
  done

  echo
done  

echo

exit 0
</pre>
            </div>

            <p>Команда <strong
             class="COMMAND">continue</strong>, как и команда <strong
             class="COMMAND">break</strong>, может иметь необязательный
            параметр. В простейшем случае, команда <strong
             class="COMMAND">continue</strong> передает управление в
            начало текущего цикла, а команда <strong
             class="COMMAND">continue N</strong> прерывает исполнение
            текущего цикла и передает управление в начало внешнего
            цикла, отстоящего от текущего на N уровней (причем 1-й
            уровень -- это уровень текущего цикла, прим. перев.).</p>

            <div
             class="EXAMPLE">
              <a
               name="x5153_html_CONTINUELEVELS"></a>

              <p><strong>Пример 10-22. Передача управление в начало
              внешнего цикла</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Команда &quot;continue N&quot; передает управление в начало внешнего цикла, отстоящего от текущего на N уровней.

for outer in I II III IV V           # внешний цикл
do
  echo; echo -n &quot;Группа $outer: &quot;

  for inner in 1 2 3 4 5 6 7 8 9 10  # вложенный цикл
  do

    if [ &quot;$inner&quot; -eq 7 ]
    then
      continue 2  # Передача управления в начало цикла 2-го уровня.
                  # попробуйте убрать параметр 2 команды &quot;continue&quot;
    fi

    echo -n &quot;$inner &quot;  # 8 9 10 никогда не будут напечатаны.
  done

done

echo; echo

# Упражнение:
# Подумайте, где реально можно использовать &quot;continue N&quot; в сценариях.

exit 0
</pre>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="x5153_html_CONTINUENEX"></a>

              <p><strong>Пример 10-23. Живой пример использования <span
               class="QUOTE">&quot;continue N&quot;</span></strong></p>
<pre
 class="PROGRAMLISTING">
# Albert Reiner привел пример использования &quot;continue N&quot;:
# ---------------------------------------------------------

#  Допустим, у меня есть большое количество задач, обрабатывающие некоторые данные,
#+ которые хранятся в некоторых файлах, с именами, задаваемыми по шаблону,
#+ в заданном каталоге.
#+ Есть несколько машин, которым открыт доступ к этому каталогу
#+ и я хочу распределить обработку информации между машинами.
#+ тогда я обычно для каждой машины пишу нечто подобное:

while true
do
  for n in .iso.*
  do
    [ &quot;$n&quot; = &quot;.iso.opts&quot; ] &amp;&amp; continue
    beta=${n#.iso.}
    [ -r .Iso.$beta ] &amp;&amp; continue
    [ -r .lock.$beta ] &amp;&amp; sleep 10 &amp;&amp; continue
    lockfile -r0 .lock.$beta || continue
    echo -n &quot;$beta: &quot; `date`
    run-isotherm $beta
    date
    ls -alF .Iso.$beta
    [ -r .Iso.$beta ] &amp;&amp; rm -f .lock.$beta
    continue 2
  done
  break
done

#  Конкретная реализация цикла, особенно sleep N, зависит от конкретных применений,
#+ но в общем случае он строится по такой схеме:

while true
do
  for job in {шаблон}
  do
    {файл уже обработан или обрабатывается} &amp;&amp; continue
    {пометить файл как обрабатываемый, обработать, пометить как обработанный}
    continue 2
  done
  break        # Или что нибудь подобное `sleep 600&#39;, чтобы избежать завершения.
done

#  Этот сценарий завершит работу после того как все данные будут обработаны
#+ (включая данные, которые поступили во время обработки). Использование
#+ соответствующих lock-файлоа позволяет вести обработку на нескольких машинах
#+ одновременно, не производя дублирующих вычислений [которые, в моем случае,
#+ выполняются в течении нескольких часов, так что для меня это очень важно].
#+ Кроме того, поскольку поиск необработанных файлов всегда начинается с
#+ самого начала, можно задавать приоритеты в именах файлов. Конечно, можно
#+ обойтись и без `continue 2&#39;, но тогда придется ввести дополнительную
#+ проверку -- действительно ли был обработан тот или иной файл
#+ (чтобы перейти к поиску следующего необработанного файла).
</pre>
            </div>

            <div
             class="CAUTION">
              <table
               class="CAUTION"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/caution.gif"
                   hspace="5"
                   alt="Caution"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Конструкция <strong
                     class="COMMAND">continue N</strong> довольно
                    сложна в понимании и применении, поэтому, вероятно
                    лучше будет постараться избегать ее
                    использования.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>
        </dl>
      </div>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN5175"
         href="#x5153_html_AEN5175"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Эти команды являются <a
           href="#c5358_html_BUILTINREF">встроенными командами</a> языка
          сценариев командной оболочки (shell), в то время как <a
           href="#c4875_html_WHILELOOPREF">while</a>, <a
           href="#x5210_html_CASEESAC1">case</a> и т.п. -- являются <a
           href="#c5358_html_KEYWORDREF">зарезервированными
          словами</a>.</p>
        </td>
      </tr>
    </table>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x5140_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x5210_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Вложенные циклы</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c4875_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Операторы выбора</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x5210_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x5153_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 10. Циклы и ветвления</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#c5358_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x5210_html_TESTBRANCH"></a>10.4. Операторы выбора</h1>

      <p>Инструкции <strong
       class="COMMAND">case</strong> и <strong
       class="COMMAND">select</strong> технически не являются циклами,
      поскольку не предусматривают многократное исполнение блока кода.
      Однако, они, как и циклы, управляют ходом исполнения программы, в
      зависимости от начальных или конечных условий.</p>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="x5210_html_CASEESAC1"></a></strong></p>

        <dl>
          <dt><strong
           class="COMMAND">case (in) / esac</strong></dt>

          <dd>
            <p>Конструкция <strong
             class="COMMAND">case</strong> эквивалентна конструкции
            <strong
             class="COMMAND">switch</strong> в языке C/C++. Она
            позволяет выполнять тот или иной участок кода, в
            зависимости от результатов проверки условий. Она является,
            своего рода, краткой формой записи большого количества
            операторов <span
             class="TOKEN">if/then/else</span> и может быть неплохим
            инструментом при создании разного рода меню.</p>

            <p><strong
             class="COMMAND">case</strong> &quot;$<tt
             class="REPLACEABLE"><em>variable</em></tt>&quot; in<br>
            <br>
              &quot;$<tt
             class="REPLACEABLE"><em>condition1</em></tt>&quot; )<br>
              <tt
             class="REPLACEABLE"><em>command</em></tt>...<br>
              ;;<br>
            <br>
              &quot;$<tt
             class="REPLACEABLE"><em>condition2</em></tt>&quot; )<br>
              <tt
             class="REPLACEABLE"><em>command</em></tt>...<br>
              ;;<br>
            <br>
             esac</p>
            <br>
            <br>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <ul>
                      <li>
                        <p>Заключать переменные в кавычки
                        необязательно, поскольку здесь не производится
                        разбиения на отдельные слова.</p>
                      </li>

                      <li>
                        <p>Каждая строка с условием должна завершаться
                        правой (закрывающей) круглой скобкой <span
                         class="TOKEN">)</span>.</p>
                      </li>

                      <li>
                        <p>Каждый блок команд, отрабатывающих по
                        заданному условию, должен завершаться <span
                         class="emphasis"><em
                         class="EMPHASIS">двумя</em></span> символами
                        точка-с-запятой <span
                         class="TOKEN">;;</span>.</p>
                      </li>

                      <li>
                        <p>Блок <strong
                         class="COMMAND">case</strong> должен
                        завершаться ключевым словом <strong
                         class="COMMAND">esac</strong> (<em
                         class="WORDASWORD">case</em> записанное в
                        обратном порядке).</p>
                      </li>
                    </ul>
                    <br>
                    <br>
                  </td>
                </tr>
              </table>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="x5210_html_EX29"></a>

              <p><strong>Пример 10-24. Использование case</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

echo; echo &quot;Нажмите клавишу и затем клавишу Return.&quot;
read Keypress

case &quot;$Keypress&quot; in
  [a-z]   ) echo &quot;буква в нижнем регистре&quot;;;
  [A-Z]   ) echo &quot;Буква в верхнем регистре&quot;;;
  [0-9]   ) echo &quot;Цифра&quot;;;
  *       ) echo &quot;Знак пунктуации, пробел или что-то другое&quot;;;
esac  # Допускается указыватль диапазоны символов в [квадратных скобках].

# Упражнение:
# --------
# Сейчас сценарий считывает нажатую клавишу и завершается.
# Измените его так, чтобы сценарий продолжал отвечать на нажатия клавиш,
# но завершался бы только после ввода символа &quot;X&quot;.
# Подсказка: заключите все в цикл &quot;while&quot;.

exit 0
</pre>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="x5210_html_EX30"></a>

              <p><strong>Пример 10-25. Создание меню с помощью
              case</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Грубый пример базы данных

clear # Очистка экрана

echo &quot;          Список&quot;
echo &quot;          ------&quot;
echo &quot;Выберите интересующую Вас персону:&quot;
echo
echo &quot;[E]vans, Roland&quot;
echo &quot;[J]ones, Mildred&quot;
echo &quot;[S]mith, Julie&quot;
echo &quot;[Z]ane, Morris&quot;
echo

read person

case &quot;$person&quot; in
# Обратите внимание: переменная взята в кавычки.

  &quot;E&quot; | &quot;e&quot; )
  # Пользователь может ввести как заглавную, так и строчную букву.
  echo
  echo &quot;Roland Evans&quot;
  echo &quot;4321 Floppy Dr.&quot;
  echo &quot;Hardscrabble, CO 80753&quot;
  echo &quot;(303) 734-9874&quot;
  echo &quot;(303) 734-9892 fax&quot;
  echo &quot;revans@zzy.net&quot;
  echo &quot;Старый друг и партнер по бизнесу&quot;
  ;;
# Обратите внимание: блок кода, анализирующий конкретный выбор, завершается
# двумя символами &quot;точка-с-запятой&quot;.

  &quot;J&quot; | &quot;j&quot; )
  echo
  echo &quot;Mildred Jones&quot;
  echo &quot;249 E. 7th St., Apt. 19&quot;
  echo &quot;New York, NY 10009&quot;
  echo &quot;(212) 533-2814&quot;
  echo &quot;(212) 533-9972 fax&quot;
  echo &quot;milliej@loisaida.com&quot;
  echo &quot;Подружка&quot;
  echo &quot;День рождения: 11 февраля&quot;
  ;;

# Информация о Smith и Zane будет добавлена позднее.

          * )
   # Выбор по-умолчанию.
   # &quot;Пустой&quot; ввод тоже обрабатывается здесь.
   echo
   echo &quot;Нет данных.&quot;
  ;;

esac

echo

#  Упражнение:
#  --------
#  Измените этот сценарий таким образом, чтобы он не завершал работу
#+ после вывода информации о персоне, а переходил на ожидание нового
#+ ввода от пользователя.

exit 0
</pre>
            </div>

            <p>Очень хороший пример использования <strong
             class="COMMAND">case</strong> для анализа аргументов,
            переданных из командной строки.</p>
<pre
 class="PROGRAMLISTING">
#! /bin/bash

case &quot;$1&quot; in
&quot;&quot;) echo &quot;Порядок использования: ${0##*/} &lt;filename&gt;&quot;; exit 65;;  # Параметры командной строки отсутствуют,
                                                  # или первый параметр -- &quot;пустой&quot;.
# Обратите внимание на ${0##*/} это подстановка параметра ${var##pattern}. В результате получается $0.

-*) FILENAME=./$1;;   # Если имя файла (аргумент $1) начинается с &quot;-&quot;,
                      # то заменить его на ./$1
                      # тогда параметр не будет восприниматься как ключ команды.

* ) FILENAME=$1;;     # В противном случае -- $1.
esac
</pre>
            <br>
            <br>

            <div
             class="EXAMPLE">
              <a
               name="x5210_html_CASECMD"></a>

              <p><strong>Пример 10-26. Оператор case допускает
              использовать подстановку команд вместо анализируемой
              переменной</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Подстановка команд в &quot;case&quot;.

case $( arch ) in # команда &quot;arch&quot; возвращает строку, описывающую аппаратную апхитектуру.
i386 ) echo &quot;Машина на базе процессора 80386&quot;;;
i486 ) echo &quot;Машина на базе процессора 80486&quot;;;
i586 ) echo &quot;Машина на базе процессора Pentium&quot;;;
i686 ) echo &quot;Машина на базе процессора Pentium2 или выше&quot;;;
*    ) echo &quot;Машина на другом типе процессора&quot;;;
esac

exit 0
</pre>
            </div>

            <p>Оператор <strong
             class="COMMAND">case</strong> допускает использование
            шаблонных конструкций.</p>

            <div
             class="EXAMPLE">
              <a
               name="x5210_html_MATCHSTRING"></a>

              <p><strong>Пример 10-27. Простой пример сравнения
              строк</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# match-string.sh: простое сравнение строк

match_string ()
{
  MATCH=0
  NOMATCH=90
  PARAMS=2     # Функция требует два входных аргумента.
  BAD_PARAMS=91

  [ $# -eq $PARAMS ] || return $BAD_PARAMS

  case &quot;$1&quot; in
  &quot;$2&quot;) return $MATCH;;
  *   ) return $NOMATCH;;
  esac

}


a=one
b=two
c=three
d=two


match_string $a     # неверное число аргументов
echo $?             # 91

match_string $a $b  # не равны
echo $?             # 90

match_string $b $d  # равны
echo $?             # 0


exit 0
</pre>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="x5210_html_ISALPHA"></a>

              <p><strong>Пример 10-28. Проверка ввода</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# isalpha.sh: Использование &quot;case&quot; для анализа строк.

SUCCESS=0
FAILURE=-1

isalpha ()  # Проверка - является ли первый символ строки символом алфавита.
{
if [ -z &quot;$1&quot; ]                # Вызов функции без входного аргумента?
then
  return $FAILURE
fi

case &quot;$1&quot; in
[a-zA-Z]*) return $SUCCESS;;  # Первый символ - буква?
*        ) return $FAILURE;;
esac
}             # Сравните с функцией &quot;isalpha ()&quot; в языке C.


isalpha2 ()   # Проверка - состоит ли вся строка только из символов алфавита.
{
  [ $# -eq 1 ] || return $FAILURE

  case $1 in
  *[!a-zA-Z]*|&quot;&quot;) return $FAILURE;;
               *) return $SUCCESS;;
  esac
}

isdigit ()    # Проверка - состоит ли вся строка только из цифр.
{             # Другими словами - является ли строка целым числом.
  [ $# -eq 1 ] || return $FAILURE

  case $1 in
  *[!0-9]*|&quot;&quot;) return $FAILURE;;
            *) return $SUCCESS;;
  esac
}



check_var ()  # Интерфейс к isalpha
{
if isalpha &quot;$@&quot;
then
  echo &quot;\&quot;$*\&quot; начинается с алфавитного символа.&quot;
  if isalpha2 &quot;$@&quot;
  then        # Дальнейшая проверка не имеет смысла, если первй символ не буква.
    echo &quot;\&quot;$*\&quot; содержит только алфавитные символы.&quot;
  else
    echo &quot;\&quot;$*\&quot; содержит по меньшей мере один не алфавитный символ.&quot;
  fi
else
  echo &quot;\&quot;$*\&quot; начинсется с не алфавитного символа .&quot;
              #  Если функция вызвана без входного параметра,
              #+ то считается, что строка содержит &quot;не алфавитной&quot; символ.
fi

echo

}

digit_check ()  # Интерфейс к isdigit ().
{
if isdigit &quot;$@&quot;
then
  echo &quot;\&quot;$*\&quot; содержит только цифры [0 - 9].&quot;
else
  echo &quot;\&quot;$*\&quot; содержит по меньшей мере один не цифровой символ.&quot;
fi

echo

}

a=23skidoo
b=H3llo
c=-What?
d=What?
e=`echo $b`   # Подстановка команды.
f=AbcDef
g=27234
h=27a34
i=27.34

check_var $a
check_var $b
check_var $c
check_var $d
check_var $e
check_var $f
check_var     # Вызов без параметра, что произойдет?
#
digit_check $g
digit_check $h
digit_check $i


exit 0        # Сценарий дополнен S.C.

# Упражнение:
# --------
#  Напишите функцию &#39;isfloat ()&#39;, которая проверяла бы вещественные числа.
#  Подсказка: Эта функция подобна функции &#39;isdigit ()&#39;,
#+ надо лишь добавить анализ наличия десятичной точки.
</pre>
            </div>
          </dd>

          <dt><a
           name="x5210_html_SELECTREF"></a><strong
           class="COMMAND">select</strong></dt>

          <dd>
            <p>Оператор <strong
             class="COMMAND">select</strong> был заимствован из Korn
            Shell, и является еще одним инструментом, используемым при
            создании меню.</p>

            <p><strong
             class="COMMAND">select</strong> <tt
             class="REPLACEABLE"><em>variable</em></tt> [in <tt
             class="REPLACEABLE"><em>list</em></tt>]<br>
             do<br>
              <tt
             class="REPLACEABLE"><em>command</em></tt>...<br>
              break<br>
             done</p>
            <br>
            <br>

            <p>Этот оператор предлагает пользователю выбрать один из
            представленных вариантов. Примечательно, что <strong
             class="COMMAND">select</strong> по-умолчанию использует в
            качестве приглашения к вводу (prompt) -- <tt
             class="VARNAME">PS3</tt> (<tt
             class="PROMPT">#?</tt> ), который легко изменить.</p>

            <div
             class="EXAMPLE">
              <a
               name="x5210_html_EX31"></a>

              <p><strong>Пример 10-29. Создание меню с помощью
              select</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

PS3=&#39;Выберите ваш любимый овощ: &#39; # строка приглашения к вводу (prompt)

echo

select vegetable in &quot;бобы&quot; &quot;морковь&quot; &quot;картофель&quot; &quot;лук&quot; &quot;брюква&quot;
do
  echo
  echo &quot;Вы предпочитаете $vegetable.&quot;
  echo &quot;;-))&quot;
  echo
  break  # если &#39;break&#39; убрать, то получится бесконечный цикл.
done

exit 0
</pre>
            </div>

            <p>Если в операторе <strong
             class="COMMAND">select</strong> список <tt
             class="USERINPUT"><strong>in <tt
             class="REPLACEABLE"><em>list</em></tt></strong></tt> не
            задан, то в качестве списка будет использоваться список
            аргументов (<tt
             class="VARNAME">$@</tt>), передаваемый сценарию или
            функции.</p>

            <p>Сравните это с поведением оператора цикла</p>

            <p><strong
             class="COMMAND">for</strong> <tt
             class="REPLACEABLE"><em>variable</em></tt> [in <tt
             class="REPLACEABLE"><em>list</em></tt>]</p>
            в котором не задан список аргументов.<br>
            <br>

            <div
             class="EXAMPLE">
              <a
               name="x5210_html_EX32"></a>

              <p><strong>Пример 10-30. Создание меню с помощью select в
              функции</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

PS3=&#39;Выберите ваш любимый овощ: &#39;

echo

choice_of()
{
select vegetable
# список выбора [in list] отсутствует, поэтому &#39;select&#39; использует входные аргументы функции.
do
  echo
  echo &quot;Вы предпочитаете $vegetable.&quot;
  echo &quot;;-))&quot;
  echo
  break
done
}

choice_of бобы рис морковь редис томат шпинат
#         $1   $2  $3      $4    $5    $6
#         передача списка выбора в функцию choice_of()

exit 0
</pre>
            </div>

            <p>См. так же <a
             href="#c13936_html_RESISTOR">Пример 34-3</a>.</p>
          </dd>
        </dl>
      </div>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x5153_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#c5358_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Управление ходом выполнения цикла</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c4875_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Внутренние команды</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x6646_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#c6407_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 12. Внешние команды, программы и
          утилиты</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x6837_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x6646_html_MOREADV"></a>12.2. Более сложные команды</h1>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="x6646_html_CCLISTING1"></a>Команды для более опытных
        пользователей</strong></p>

        <dl>
          <dt><a
           name="x6646_html_FINDREF"></a><strong
           class="COMMAND">find</strong></dt>

          <dd>
            <p>-exec <tt
             class="REPLACEABLE"><em>COMMAND</em></tt> \;</p>

            <p>Для каждого найденного файла, соответствующего заданному
            шаблону поиска, выполняет команду <tt
             class="REPLACEABLE"><em>COMMAND</em></tt>. Командная
            строка должна завершаться последовательностью символов
            <span
             class="TOKEN">\;</span> (здесь символ <span
             class="QUOTE">&quot;;&quot;</span> экранирован обратным
            слэшем, чтобы информировать командную оболочку о том, что
            символ <span
             class="QUOTE">&quot;;&quot;</span> должен быть передан
            команде <strong
             class="COMMAND">find</strong> как обычный символ). Если
            <tt
             class="REPLACEABLE"><em>COMMAND</em></tt> содержит <span
             class="TOKEN">{}</span>, то <strong
             class="COMMAND">find</strong> подставляет полное имя
            найденного файла вместо <span
             class="QUOTE">&quot;{}&quot;</span>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>find ~/ -name &#39;*.txt&#39;</strong></tt>
<tt
 class="COMPUTEROUTPUT">/home/bozo/.kde/share/apps/karm/karmdata.txt
/home/bozo/misc/irmeyc.txt
/home/bozo/test-scripts/1.txt</tt>
             
</pre>
            <br>
            <br>
<pre
 class="PROGRAMLISTING">
find /home/bozo/projects -mtime 1
#  Найти все файлы в каталоге /home/bozo/projects и вложенных подкаталогах,
#+ которые изменялись в течение последних суток.
#
#  mtime = время последнего изменения файла
#  ctime = время последнего изменения атрибутов файла (через &#39;chmod&#39; или как-то иначе)
#  atime = время последнего обращения к файлу

DIR=/home/bozo/junk_files
find &quot;$DIR&quot; -type f -atime +5 -exec rm {} \;
#  Удалить все файлы в каталоге &quot;/home/bozo/junk_files&quot;
#+ к которым не было обращений в течение последних 5 дней.
#
#  &quot;-type filetype&quot;, где
#  f = обычный файл
#  d = каталог, и т.п.
#  (Полный список ключей вы найдете в &#39;man find&#39;.)
</pre>
            <br>
            <br>
<pre
 class="PROGRAMLISTING">
find /etc -exec grep &#39;[0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*&#39; {} \;

# Поиск всех IP-адресов (xxx.xxx.xxx.xxx) в файлах каталога  /etc.
# Однако эта команда выводит не только IP-адреса, как этого избежать?

# Примерно так:

find /etc -type f -exec cat &#39;{}&#39; \; | tr -c &#39;.[:digit:]&#39; &#39;\n&#39; \
 | grep &#39;^[^.][^.]*\.[^.][^.]*\.[^.][^.]*\.[^.][^.]*$&#39;
# [:digit:] -- один из символьных классов
# введен в стандарт POSIX 1003.2.

# Спасибо S.C.
</pre>
            <br>
            <br>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Не следует путать опцию <tt
                     class="OPTION">-exec</tt> команды <strong
                     class="COMMAND">find</strong> с внутренней
                    командой Bash -- <a
                     href="#c5358_html_EXECREF">exec</a>.</p>
                  </td>
                </tr>
              </table>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="x6646_html_EX57"></a>

              <p><strong>Пример 12-2. Badname, удаление файлов в
              текущем каталоге, имена которых содержат недопустимые
              символы и <a
               href="#c301_html_WHITESPACEREF">пробелы</a>.</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Удаление файлов в текущем каталоге, чьи имена содержат недопустимые символы.

for filename in *
do
badname=`echo &quot;$filename&quot; | sed -n /[\+\{\;\&quot;\\\=\?~\(\)\&lt;\&gt;\&amp;\*\|\$]/p`
# Недопустимые символы в именах файлов:     + { ; &quot; \ = ? ~ ( ) &lt; &gt; &amp; * | $
rm $badname 2&gt;/dev/null    # Сообщения об ошибках &quot;выстреливаются&quot; в никуда.
done

# Теперь &quot;позаботимся&quot; о файлах, чьи имена содержат пробельные символы.
find . -name &quot;* *&quot; -exec rm -f {} \;
# На место &quot;{}&quot;, find подставит полное имя файла.
# Символ &#39;\&#39; указывает на то, что &#39;;&#39; интерпретируется как обычный символ, а не как конец команды.

exit 0

#---------------------------------------------------------------------
# Строки, приведенные ниже, не будут выполнены, т.к. выше стоит команда &quot;exit&quot;.

# Альтернативный вариант сценария:
find . -name &#39;*[+{;&quot;\\=?~()&lt;&gt;&amp;*|$ ]*&#39; -exec rm -f &#39;{}&#39; \;
exit 0
# (Спасибо S.C.)
</pre>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="x6646_html_IDELETE"></a>

              <p><strong>Пример 12-3. Удаление файла по его номеру
              <span
               class="emphasis"><em
               class="EMPHASIS">inode</em></span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# idelete.sh: Удаление файла по номеру inode.

#  Этот прием используется в тех случаях, когда имя файла начинается с недопустимого символа,
#+ например, ? или -.

ARGCOUNT=1                      # Имя файла должно быть передано в сценарий.
E_WRONGARGS=70
E_FILE_NOT_EXIST=71
E_CHANGED_MIND=72

if [ $# -ne &quot;$ARGCOUNT&quot; ]
then
  echo &quot;Порядок использования: `basename $0` filename&quot;
  exit $E_WRONGARGS
fi

if [ ! -e &quot;$1&quot; ]
then
  echo &quot;Файл \&quot;&quot;$1&quot;\&quot; не найден.&quot;
  exit $E_FILE_NOT_EXIST
fi

inum=`ls -i | grep &quot;$1&quot; | awk &#39;{print $1}&#39;`
# inum = номер inode (index node) файла
# Каждый файл имеет свой inode, где хранится информация о физическом расположении файла.

echo; echo -n &quot;Вы совершенно уверены в том, что желаете удалить \&quot;$1\&quot; (y/n)? &quot;
# Ключ &#39;-v&#39; в команде &#39;rm&#39; тоже заставит команду вывести подобный запрос.
read answer
case &quot;$answer&quot; in
[nN]) echo &quot;Передумали?&quot;
      exit $E_CHANGED_MIND
      ;;
*)    echo &quot;Удаление файла \&quot;$1\&quot;.&quot;;;
esac

find . -inum $inum -exec rm {} \;
echo &quot;Файл &quot;\&quot;$1&quot;\&quot; удален!&quot;

exit 0
</pre>
            </div>

            <p>Дополнительные примеры по использованию команды <strong
             class="COMMAND">find</strong> вы найдете в <a
             href="#x7794_html_EX48">Пример 12-22</a>, <a
             href="#c301_html_EX58">Пример 3-4</a> и <a
             href="#c4875_html_FINDSTRING">Пример 10-9</a>. В страницах
            справочного ркуоводства (man find) вы найдете более
            подробную информацию об этой достаточно сложной и мощной
            команде.</p>
          </dd>

          <dt><strong
           class="COMMAND">xargs</strong></dt>

          <dd>
            <p>Команда передачи аргументов указанной команде. Она
            разбивает поток аргументов на отдельные составляющие и
            поочередно передает их заданной команде для обработки. Эта
            команда может рассматриваться как мощная замена обратным
            одиничным кавычкам. Зачастую, когда команды, заключенные в
            обратные одиночные кавычки, завершаются с ошибкой <span
             class="ERRORNAME">too many arguments</span> (слишком много
            аргументов), использование <strong
             class="COMMAND">xargs</strong> позволяет обойти это
            ограничение. Обычно, <strong
             class="COMMAND">xargs</strong> считывает список аргументов
            со стандартного устройства ввода <tt
             class="FILENAME">stdin</tt> или из канала (конвейера), но
            может считывать информацию и из файла.</p>

            <p>Если команда не задана, то по-умолчанию выполняется <a
             href="#c5358_html_ECHOREF">echo</a>. При передаче
            аргументов по конвейеру, <strong
             class="COMMAND">xargs</strong> допускает наличие
            пробельных символов и символов перевода строки, которые
            затем автоматически отбрасываются.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ls -l</strong></tt>
<tt
 class="COMPUTEROUTPUT">total 0
-rw-rw-r--    1 bozo  bozo         0 Jan 29 23:58 file1
-rw-rw-r--    1 bozo  bozo         0 Jan 29 23:58 file2</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ls -l | xargs</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">total 0 -rw-rw-r-- 1 bozo bozo 0 Jan 29 23:58 file1 -rw-rw-r-- 1 bozo bozo 0 Jan 29 23:58 file2</tt>
             
</pre>
            <br>
            <br>

            <p><tt
             class="USERINPUT"><strong>ls | xargs -p -l
            gzip</strong></tt> -- упакует с помощью <a
             href="#x7794_html_GZIPREF">gzip</a> все файлы в текущем
            каталоге, выводя запрос на подтверждение для каждого
            файла.</p>

            <div
             class="TIP">
              <table
               class="TIP"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/tip.gif"
                   hspace="5"
                   alt="Tip"></td>

                  <td
                   align="left"
                   valign="top">
                    <p><strong
                     class="COMMAND">xargs</strong> имеет очень
                    любопытный ключ <tt
                     class="OPTION">-n <tt
                     class="REPLACEABLE"><em>NN</em></tt></tt>, который
                    ограничивает количество передаваемых аргументов за
                    один &quot;присест&quot; числом <tt
                     class="REPLACEABLE"><em>NN</em></tt>.</p>

                    <p><tt
                     class="USERINPUT"><strong>ls | xargs -n 8
                    echo</strong></tt> -- выведет список файлов
                    текущего каталога в <tt
                     class="LITERAL">8</tt> колонок.</p>
                  </td>
                </tr>
              </table>
            </div>

            <div
             class="TIP">
              <table
               class="TIP"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/tip.gif"
                   hspace="5"
                   alt="Tip"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Еще одна полезная опция -- <tt
                     class="OPTION">-0</tt>, в комбинации с <strong
                     class="COMMAND">find -print0</strong> или <strong
                     class="COMMAND">grep -lZ</strong> позволяет
                    обрабатывать аргументы, содержащие пробелы и
                    кавычки.</p>

                    <p><tt
                     class="USERINPUT"><strong>find / -type f -print0 |
                    xargs -0 grep -liwZ GUI | xargs -0 rm
                    -f</strong></tt></p>

                    <p><tt
                     class="USERINPUT"><strong>grep -rliwZ GUI / |
                    xargs -0 rm -f</strong></tt></p>

                    <p>Обе вышеприведенные команды удалят все файлы,
                    содержащие в своем имени комбинацию символов <span
                     class="QUOTE">&quot;GUI&quot;</span>. <span
                     class="emphasis"><em
                     class="EMPHASIS">(Спасибо S.C.)</em></span></p>
                  </td>
                </tr>
              </table>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="x6646_html_EX41"></a>

              <p><strong>Пример 12-4. Использование команды xargs для
              мониторинга системного журнала</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Создание временного файла мониторинга в текщем каталоге,
# куда переписываются несколько последних строк из /var/log/messages.

# Обратите внимание: если сценарий запускается обычным пользователем,
# то файл /var/log/messages должен быть доступен на чтение этому пользователю.
#         #root chmod 644 /var/log/messages

LINES=5

( date; uname -a ) &gt;&gt;logfile
# Время и информация о системе
echo --------------------------------------------------------------------- &gt;&gt;logfile
tail -$LINES /var/log/messages | xargs |  fmt -s &gt;&gt;logfile
echo &gt;&gt;logfile
echo &gt;&gt;logfile

exit 0

# Упражнение:
# --------
#  Измените сценарий таким образом, чтобы он мог отслеживать изменения в /var/log/messages
#+ с интервалом в 20 минут.
#  Подсказка: воспользуйтесь командой &quot;watch&quot;.
</pre>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="x6646_html_EX42"></a>

              <p><strong>Пример 12-5. copydir, копирование файлов из
              текущего каталога в другое место, с помощью
              xargs</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Копирует все файлы из текущего каталога
# в каталог, указанный в командной строке.

if [ -z &quot;$1&quot; ]   # Выход, если каталог назначения не задан.
then
  echo &quot;Порядок использования: `basename $0` directory-to-copy-to&quot;
  exit 65
fi

ls . | xargs -i -t cp ./{} $1
# Этот сценария является точным эквивалентом
#    cp * $1
# если в именах файлов не содержатся пробельные символы.

exit 0
</pre>
            </div>
          </dd>

          <dt><a
           name="x6646_html_EXPRREF"></a><tt
           class="USERINPUT"><strong>expr</strong></tt></dt>

          <dd>
            <p>Универсальный обработчик выражений: вычисляет заданное
            выражение (аргументы должны отделяться пробелами).
            Выражения могут быть арифметическими, логическими или
            строковыми.</p>

            <div
             class="VARIABLELIST">
              <dl>
                <dt><tt
                 class="USERINPUT"><strong>expr 3 +
                5</strong></tt></dt>

                <dd>
                  <p>возвратит <tt
                   class="LITERAL">8</tt></p>
                </dd>

                <dt><tt
                 class="USERINPUT"><strong>expr 5 %
                3</strong></tt></dt>

                <dd>
                  <p>возвратит 2</p>
                </dd>

                <dt><tt
                 class="USERINPUT"><strong>expr 5 \*
                3</strong></tt></dt>

                <dd>
                  <p>возвратит 15</p>

                  <p>В арифметических выражениях, оператор умножения
                  обязательно должен экранироваться обратным
                  слэшем.</p>
                </dd>

                <dt><tt
                 class="USERINPUT"><strong>y=`expr $y +
                1`</strong></tt></dt>

                <dd>
                  <p>Операция инкремента переменной, то же самое, что и
                  <tt
                   class="USERINPUT"><strong>let y=y+1</strong></tt>,
                  или <tt
                   class="USERINPUT"><strong>y=$(($y+1))</strong></tt>.
                  Пример <a
                   href="#c11565_html_ARITHEXPREF">подстановки
                  арифметических выражений</a>.</p>
                </dd>

                <dt><a
                 name="x6646_html_EXPEXTRSUB"></a><tt
                 class="USERINPUT"><strong>z=`expr substr $string
                $position $length`</strong></tt></dt>

                <dd>
                  <p>Извлекает подстроку длиной $length символов,
                  начиная с позиции $position.</p>
                </dd>
              </dl>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="x6646_html_EX45"></a>

              <p><strong>Пример 12-6. Пример работы с expr</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Демонстрация некоторых приемов работы с командой &#39;expr&#39;
# =======================================

echo

# Арифметические операции
# -------------- --------

echo &quot;Арифметические операции&quot;
echo
a=`expr 5 + 3`
echo &quot;5 + 3 = $a&quot;

a=`expr $a + 1`
echo
echo &quot;a + 1 = $a&quot;
echo &quot;(инкремент переменной)&quot;

a=`expr 5 % 3`
# остаток от деления (деление по модулю)
echo
echo &quot;5 mod 3 = $a&quot;

echo
echo

# Логические операции
# ---------- --------

#  Возвращает 1 если выражение истинноо, 0 -- если ложно,
#+ в противоположность соглашениям, принятым в Bash.

echo &quot;Логические операции&quot;
echo

x=24
y=25
b=`expr $x = $y`         # Сравнение.
echo &quot;b = $b&quot;            # 0  ( $x -ne $y )
echo

a=3
b=`expr $a \&gt; 10`
echo &#39;b=`expr $a \&gt; 10`, поэтому...&#39;
echo &quot;Если a &gt; 10, то b = 0 (ложь)&quot;
echo &quot;b = $b&quot;            # 0  ( 3 ! -gt 10 )
echo

b=`expr $a \&lt; 10`
echo &quot;Если a &lt; 10, то b = 1 (истина)&quot;
echo &quot;b = $b&quot;            # 1  ( 3 -lt 10 )
echo
# Обратите внимание на необходимость экранирования операторов.

b=`expr $a \&lt;= 3`
echo &quot;Если a &lt;= 3, то b = 1 (истина)&quot;
echo &quot;b = $b&quot;            # 1  ( 3 -le 3 )
# Существует еще оператор &quot;\&gt;=&quot; (больше или равно).


echo
echo

# Операции сравнения
# -------- ---------

echo &quot;Операции сравнения&quot;
echo
a=zipper
echo &quot;a is $a&quot;
if [ `expr $a = snap` ]
then
   echo &quot;a -- это не zipper&quot;
fi

echo
echo



# Операции со строками
# -------- -- --------

echo &quot;Операции со строками&quot;
echo

a=1234zipper43231
echo &quot;Строка над которой производятся операции: \&quot;$a\&quot;.&quot;

# length: длина строки
b=`expr length $a`
echo &quot;длина строки \&quot;$a\&quot; равна $b.&quot;

# index: позиция первого символа подстроки в строке
b=`expr index $a 23`
echo &quot;Позиция первого символа \&quot;2\&quot; в строке \&quot;$a\&quot; : \&quot;$b\&quot;.&quot;

# substr: извлечение подстроки, начиная с заданной позиции, указанной длины
b=`expr substr $a 2 6`
echo &quot;Подстрока в строке \&quot;$a\&quot;, начиная с позиции 2,\
и длиной в 6 символов: \&quot;$b\&quot;.&quot;


#  При выполнении поиска по шаблону, по-умолчанию поиск
#+ начинается с ***начала*** строки.
#
#        Использование регулярных выражений
b=`expr match &quot;$a&quot; &#39;[0-9]*&#39;`               #  Подсчет количества цифр.
echo Количество цифр с начала строки \&quot;$a\&quot; : $b.
b=`expr match &quot;$a&quot; &#39;\([0-9]*\)&#39;`           #  Обратите внимание на экранирование круглых скобок
#                   ==      ==
echo &quot;Цифры, стоящие в начале строки \&quot;$a\&quot; : \&quot;$b\&quot;.&quot;

echo

exit 0
</pre>
            </div>

            <div
             class="IMPORTANT">
              <table
               class="IMPORTANT"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/important.gif"
                   hspace="5"
                   alt="Important"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Вместо оператора <strong
                     class="COMMAND">match</strong> можно использовать
                    оператор <a
                     href="#c301_html_NULLREF">:</a>. Например, команда
                    <tt
                     class="USERINPUT"><strong>b=`expr $a :
                    [0-9]*`</strong></tt> является точным эквивалентом
                    для <tt
                     class="USERINPUT"><strong>b=`expr match $a
                    [0-9]*`</strong></tt> в примере, рассмотренном
                    выше.</p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

echo
echo &quot;Операции над строками с использованием конструкции \&quot;expr \$string : \&quot; &quot;
echo &quot;========================================================================&quot;
echo

a=1234zipper5FLIPPER43231

echo &quot;Строка, над которой выполняются операции: \&quot;`expr &quot;$a&quot; : &#39;\(.*\)&#39;`\&quot;.&quot;
#     Экранирование круглых скобок в шаблоне                    ==  ==


#  Если скобки не экранировать...
#+ то &#39;expr&#39; преобразует строковый операнд в целое число.

echo &quot;Длина строки \&quot;$a\&quot; равна `expr &quot;$a&quot; : &#39;.*&#39;`.&quot;   # Длина строки

echo &quot;Количество цифр с начала строки \&quot;$a\&quot; равно `expr &quot;$a&quot; : &#39;[0-9]*&#39;`.&quot;

# ------------------------------------------------------------------------- #

echo

echo &quot;Цифры, стоящие в начале строки \&quot;$a\&quot; : `expr &quot;$a&quot; : &#39;\([0-9]*\)&#39;`.&quot;
#                                                             ==      ==
echo &quot;Первые 7 символов в строке \&quot;$a\&quot; : `expr &quot;$a&quot; : &#39;\(.......\)&#39;`.&quot;
#     ======                                          ==       ==
# Опять же, необходимо экранировать круглые скобки в шаблоне.
#
echo &quot;Последние 7 символов в строке \&quot;$a\&quot; : `expr &quot;$a&quot; : &#39;.*\(.......\)&#39;`.&quot;
#     =========                  оператор конца строки     ^^
#  (фактически означает переход через любое количество символов, пока
#+  не будет найдена требуемая подстрока)

echo

exit 0
</pre>
                    <br>
                    <br>
                  </td>
                </tr>
              </table>
            </div>
          </dd>
        </dl>
      </div>

      <p>Этот пример демонстрирует необходимость <span
       class="emphasis"><em
       class="EMPHASIS">экранирования оператора группировки -- \( ...
      \)</em></span> в <a
       href="#c11895_html_REGEXREF">регулярных выражениях</a>, при
      поиске по шаблону командой <strong
       class="COMMAND">expr</strong>.</p>

      <p><a
       href="#x13541_html_PERLREF">Perl</a>, <a
       href="#a14586_html_SEDREF">sed</a> и <a
       href="#x14802_html_AWKREF">awk</a> имеют в своем распоряжении
      более мощный аппарат анализа строк. Коротенький скрипт на <strong
       class="COMMAND">sed</strong> или <strong
       class="COMMAND">awk</strong>, внутри сценария (см. <a
       href="#x13541_html">Section 33.2</a>) -- значительно более
      привлекательная альтернатива использованию <strong
       class="COMMAND">expr</strong> при анализе строк.</p>

      <p>Дополнительные примеры, по обработке строк, вы найдете в <a
       href="#x4171_html">Section 9.2</a>.</p>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#c6407_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x6837_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Внешние команды, программы и утилиты</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c6407_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Команды для работы с датой и временем</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x6837_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x6646_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 12. Внешние команды, программы и
          утилиты</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x7050_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x6837_html_TIMEDATE"></a>12.3. Команды для работы с датой и
      временем</h1>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="x6837_html_TDLISTING1"></a>Время/дата и измерение интервалов
        времени</strong></p>

        <dl>
          <dt><a
           name="x6837_html_DATEREF"></a><strong
           class="COMMAND">date</strong></dt>

          <dd>
            <p>Команда <strong
             class="COMMAND">date</strong> без параметров выводит дату
            и время на стандартное устройство вывода <tt
             class="FILENAME">stdout</tt>. Она становится гораздо
            интереснее при использовании дополнительных ключей
            форматирования вывода.</p>

            <div
             class="EXAMPLE">
              <a
               name="x6837_html_EX51"></a>

              <p><strong>Пример 12-7. Команда date</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Примеры использования команды &#39;date&#39;

echo &quot;Количество дней, прошедших с начала года: `date +%j`.&quot;
# Символ &#39;+&#39; обязателен при использовании форматирующего аргумента
# %j,  возвращающего количество дней, прошедших с начала года.

echo &quot;Количество секунд, прошедших с 01/01/1970 : `date +%s`.&quot;
#  %s количество секунд, прошедших с начала &quot;эпохи UNIX&quot;,
#+ но насколько этот ключ полезен?

prefix=temp
suffix=`eval date +%s`  # Ключ &quot;+%s&quot; характерен для GNU-версии &#39;date&#39;.
filename=$prefix.$suffix
echo $filename
#  Прекрасный способ получения &quot;уникального&quot; имени для временного файла,
#+ даже лучше, чем с использованием $$.

# Дополнительную информацию вы найдете в &#39;man date&#39;.

exit 0
</pre>
            </div>

            <p>Ключ <tt
             class="OPTION">-u</tt> дает UTC время (Universal
            Coordinated Time -- время по Гринвичу).</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>date</strong></tt>
<tt
 class="COMPUTEROUTPUT">Fri Mar 29 21:07:39 MST 2002</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>date -u</strong></tt>
<tt
 class="COMPUTEROUTPUT">Sat Mar 30 04:07:42 UTC 2002</tt>
             
</pre>
            <br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">zdump</strong></dt>

          <dd>
            <p>Отображает время для указанной временной зоны.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>zdump EST</strong></tt>
<tt
 class="COMPUTEROUTPUT">EST  Tue Sep 18 22:09:22 2001 EST</tt>
             
</pre>
            <br>
            <br>
          </dd>

          <dt><a
           name="x6837_html_TIMREF"></a><strong
           class="COMMAND">time</strong></dt>

          <dd>
            <p>Выводит подробную статистику по исполнению некоторой
            команды.</p>

            <p><tt
             class="USERINPUT"><strong>time ls -l /</strong></tt> даст
            нечто подобное:</p>
<pre
 class="SCREEN">
<tt
 class=
"COMPUTEROUTPUT">0.00user 0.01system 0:00.05elapsed 16%CPU (0avgtext+0avgdata 0maxresident)k
 0inputs+0outputs (149major+27minor)pagefaults 0swaps</tt>
</pre>
            <br>
            <br>

            <p>См. так же очень похожую команду <a
             href="#c5358_html_TIMESREF">times</a>, обсуждавшуюся в
            предыдущем разделе.</p>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Начиная с <a
                     href="#c13936_html_BASH2REF">версии 2.0</a> Bash,
                    команда <strong
                     class="COMMAND">time</strong> стала
                    зарезервированным словом интерпретатора, с
                    несколько измененным поведением в конвейере.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><a
           name="x6837_html_TOUCHREF"></a><strong
           class="COMMAND">touch</strong></dt>

          <dd>
            <p>Утилита устанавливает время последнего
            обращения/изменения файла в текущее системное время или в
            заданное время, но так же может использоваться для создания
            нового пустого файла. Команда <tt
             class="USERINPUT"><strong>touch zzz</strong></tt> создаст
            новый пустой файл с именем <tt
             class="FILENAME">zzz</tt>, если перед этим файл <tt
             class="FILENAME">zzz</tt> отсутствовал. Кроме того, такие
            пустые файлы могут использоваться для индикации, например,
            времени последнего изменения в проекте.</p>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Эквивалентом команды <strong
                     class="COMMAND">touch</strong> могут служить <tt
                     class="USERINPUT"><strong>: &gt;&gt;
                    newfile</strong></tt> или <tt
                     class="USERINPUT"><strong>&gt;&gt;
                    newfile</strong></tt> (для обычных файлов).</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><a
           name="x6837_html_ATREF"></a><strong
           class="COMMAND">at</strong></dt>

          <dd>
            <p>Команда <strong
             class="COMMAND">at</strong> -- используется для запуска
            заданий в заданное время. В общих чертах она напоминает <a
             href="#c9708_html_CRONREF">crond</a>, однако, <strong
             class="COMMAND">at</strong> используется для однократного
            запуска набора команд.</p>

            <p><tt
             class="USERINPUT"><strong>at 2pm January 15</strong></tt>
            -- попросит ввести набор команд, которые необходимо
            запустить в указанное время. Эти команды должны быть
            совместимыми со сценариями командной оболочки. Ввод
            завершается нажатием комбинации клавиш <a
             href="#c301_html_CTLDREF">Ctl-D</a>.</p>

            <p>Ключ <tt
             class="OPTION">-f</tt> или операция перенаправления ввода
            (<span
             class="TOKEN">&lt;</span>), заставляет <strong
             class="COMMAND">at</strong> прочитать список команд из
            файла. Этот файл должен представлять из себя обычный
            сценарий, на языке командной оболочки и, само собой
            разумеется, такой сценарий должен быть неинтерактивным.
            Может использоваться совместно с командой <a
             href="#x9307_html_RUNPARTSREF">run-parts</a> для запуска
            различных наборов сценариев.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>at 2:30 am Friday &lt; at-jobs.list</strong></tt>
<tt
 class="COMPUTEROUTPUT">job 2 at 2000-10-27 02:30</tt>
             
</pre>
            <br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">batch</strong></dt>

          <dd>
            <p>Команда <strong
             class="COMMAND">batch</strong>, управляющая запуском
            заданий, напоминает команду <strong
             class="COMMAND">at</strong>, но запускает список команд
            только тогда, когда загруженность системы упадет ниже <tt
             class="LITERAL">.8</tt>. Подобно команде <strong
             class="COMMAND">at</strong>, с ключом <tt
             class="OPTION">-f</tt>, может считывать набор команд из
            файла.</p>
          </dd>

          <dt><strong
           class="COMMAND">cal</strong></dt>

          <dd>
            <p>Выводит на <tt
             class="FILENAME">stdout</tt> аккуратно отформатированный
            календарь на текущий месяц. Может выводить календарь за
            определенный год.</p>
          </dd>

          <dt><strong
           class="COMMAND">sleep</strong></dt>

          <dd>
            <p>Приостанавливает исполнение сценария на заданное
            количество секунд, ничего не делая. Может использоваться
            для синхронизации процессов, запущенных в фоне, проверяя
            наступление ожидаемого события так часто, как это
            необходимо. Например, <a
             href="#c13099_html_ONLINE">Пример 29-6</a>.</p>
<pre
 class="PROGRAMLISTING">
sleep 3
# Пауза, длительностью в 3 секунды.
</pre>
            <br>
            <br>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Команда <strong
                     class="COMMAND">sleep</strong> по-умолчанию
                    принимает количество секунд, но ей можно передать и
                    количество часов и минут и даже дней.</p>
<pre
 class="PROGRAMLISTING">
sleep 3 h
# Приостановка на 3 часа!
</pre>
                    <br>
                    <br>
                  </td>
                </tr>
              </table>
            </div>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Для запуска команд через заданные интервалы
                    времени лучше использовать <a
                     href="#c9708_html_WATCHREF">watch</a> .</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">usleep</strong></dt>

          <dd>
            <p><span
             class="emphasis"><em
             class="EMPHASIS">Microsleep</em></span> (здесь символ
            <span
             class="QUOTE">&quot;u&quot;</span> должен читаться как
            буква греческого алфавита -- <span
             class="QUOTE">&quot;мю&quot;</span>, или префикс микро).
            Это то же самое, что и <strong
             class="COMMAND">sleep</strong>, только интервал времени
            задается в микросекундах. Может использоваться для очень
            тонкой синхронизации процессов.</p>
<pre
 class="PROGRAMLISTING">
usleep 30
# Приостановка на 30 микросекунд.
</pre>
            <br>
            <br>

            <p>Эта команда является частью пакета <span
             class="emphasis"><em
             class="EMPHASIS">initscripts/rc-scripts</em></span> в
            дистрибутиве Red Hat.</p>

            <div
             class="CAUTION">
              <table
               class="CAUTION"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/caution.gif"
                   hspace="5"
                   alt="Caution"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Команда <strong
                     class="COMMAND">usleep</strong> не обеспечивает
                    особую точность соблюдения интервалов, и поэтому
                    она не подходит для применений, критичных ко
                    времени.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">hwclock</strong>, <strong
           class="COMMAND">clock</strong></dt>

          <dd>
            <p>Команда <strong
             class="COMMAND">hwclock</strong> используется для
            получения доступа или коррекции аппаратных часов
            компьютера. С некоторыми ключами требует наличия привилегий
            root. Сенарий <tt
             class="FILENAME">/etc/rc.d/rc.sysinit</tt> использует
            команду <strong
             class="COMMAND">hwclock</strong> для установки системного
            времени во время загрузки.</p>

            <p>Команда <strong
             class="COMMAND">clock</strong> -- это синоним команды
            <strong
             class="COMMAND">hwclock</strong>.</p>
          </dd>
        </dl>
      </div>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x6646_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x7050_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Более сложные команды</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c6407_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Команды обработки текста</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x7050_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x6837_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 12. Внешние команды, программы и
          утилиты</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x7794_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x7050_html_TEXTPROC"></a>12.4. Команды обработки текста</h1>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="x7050_html_TPCOMMANDLISTING1"></a></strong></p>

        <dl>
          <dt><a
           name="x7050_html_SORTREF"></a><strong
           class="COMMAND">sort</strong></dt>

          <dd>
            <p>Сортирует содержимое файла, часто используется как
            промежуточный фильтр в конвейерах. Эта команда сортирует
            поток текста в порядке убывания или возрастания, в
            зависимости от заданных опций. Ключ <tt
             class="OPTION">-m</tt> используется для сортировки и
            объединения входных файлов. В <span
             class="emphasis"><em
             class="EMPHASIS">странице info</em></span> перечислено
            большое количество возможных вариантов ключей. См. <a
             href="#c4875_html_FINDSTRING">Пример 10-9</a>, <a
             href="#c4875_html_SYMLINKS">Пример 10-10</a> и <a
             href="#a14477_html_MAKEDICT">Пример A-9</a>.</p>
          </dd>

          <dt><strong
           class="COMMAND">tsort</strong></dt>

          <dd>
            <p>Топологическая сортировка, считывает пары строк,
            разделенных пробельными символами, и выполняет сортировку,
            в зависимости от заданного шаблона.</p>
          </dd>

          <dt><a
           name="x7050_html_UNIQREF"></a><strong
           class="COMMAND">uniq</strong></dt>

          <dd>
            <p>Удаляет повторяющиеся строки из отсортированного файла.
            Эту команду часто можно встретить в конвейере с командой <a
             href="#x7050_html_SORTREF">sort</a>.</p>
<pre
 class="PROGRAMLISTING">
cat list-1 list-2 list-3 | sort | uniq &gt; final.list
# Содержимое файлов,
# сортируется,
# затем удаляются повторяющиеся строки,
# и результат записывается в выходной файл.
</pre>
            <br>
            <br>

            <p>Ключ <tt
             class="OPTION">-c</tt> выводит количество повторяющихся
            строк.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>cat testfile</strong></tt>
<tt
 class="COMPUTEROUTPUT">Эта строка встречается только один раз.
Эта строка встречается дважды.
Эта строка встречается дважды.
Эта строка встречается трижды.
Эта строка встречается трижды.
Эта строка встречается трижды.</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>uniq -c testfile</strong></tt>
<tt
 class="COMPUTEROUTPUT">1 Эта строка встречается только один раз.
2 Эта строка встречается дважды.
3 Эта строка встречается трижды.</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>sort testfile | uniq -c | sort -nr</strong></tt>
<tt
 class="COMPUTEROUTPUT">3 Эта строка встречается трижды.
2 Эта строка встречается дважды.
1 Эта строка встречается только один раз.</tt>
             
</pre>
            <br>
            <br>

            <p>Команда <tt
             class="USERINPUT"><strong>sort INPUTFILE | uniq -c | sort
            -nr</strong></tt> выводит <span
             class="emphasis"><em
             class="EMPHASIS">статистику встречаемости</em></span>
            строк в файле <tt
             class="FILENAME">INPUTFILE</tt> (ключ <tt
             class="OPTION">-nr</tt>, в команде <strong
             class="COMMAND">sort</strong>, означает сортировку в
            порядке убывания). Этот шаблон может с успехом
            использоваться при анализе файлов системного журнала,
            словарей и везде, где необходимо проанализировать
            лексическую структуру документа.</p>

            <div
             class="EXAMPLE">
              <a
               name="x7050_html_WF"></a>

              <p><strong>Пример 12-8. Частота встречаемости отдельных
              слов</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# wf.sh: &quot;Сырой&quot; анализ частоты встречаемости слова в текстовом файле.


ARGS=1
E_BADARGS=65
E_NOFILE=66

if [ $# -ne &quot;$ARGS&quot; ]  # Файл для анализа задан?
then
  echo &quot;Порядок использования: `basename $0` filename&quot;
  exit $E_BADARGS
fi

if [ ! -f &quot;$1&quot; ]       # Проверка существования файла.
then
  echo &quot;Файл \&quot;$1\&quot; не найден.&quot;
  exit $E_NOFILE
fi



########################################################
# main ()
sed -e &#39;s/\.//g&#39;  -e &#39;s/ /\
/g&#39; &quot;$1&quot; | tr &#39;A-Z&#39; &#39;a-z&#39; | sort | uniq -c | sort -nr
#                           =========================
#                         Подсчет количества вхождений

#  Точки и пробелы заменяются
#+ символами перевода строки,
#+ затем символы переводятся в нижний регистр
#+ и наконец подсчитывается количество вхождений,
#+ и выполняется сортировка по числу вхождений.
########################################################

# Упражнения:
# ---------
# 1) Добавьте команду &#39;sed&#39; для отсечения других знаков пунктуации, например, запятых.
# 2) Добавьте удаление лишних пробелов и других пробельных символов.
# 3) Добавьте дополнительную сортировку так, чтобы слова с одинаковой частотой встречаемости
#+   сортировались бы в алфавитном порядке.

exit 0
</pre>
            </div>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>cat testfile</strong></tt>
<tt
 class="COMPUTEROUTPUT">Эта строка встречается только один раз.
Эта строка встречается дважды.
Эта строка встречается дважды.
Эта строка встречается трижды.
Эта строка встречается трижды.
Эта строка встречается трижды.</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>./wf.sh testfile</strong></tt>
 <tt
 class="COMPUTEROUTPUT">      6 Эта
       6 встречается
       6 строка
       3 трижды
       2 дважды
       1 только
       1 один
       1 раз
                        </tt> 
              
</pre>
            <br>
            <br>
          </dd>

          <dt><a
           name="x7050_html_EXPANDREF"></a><strong
           class="COMMAND">expand</strong>, <strong
           class="COMMAND">unexpand</strong></dt>

          <dd>
            <p>Команда <strong
             class="COMMAND">expand</strong> преобразует символы
            табуляции в пробелы. Часто используется в конвейерной
            обработке текста.</p>

            <p>Команда <strong
             class="COMMAND">unexpand</strong> преобразует пробелы в
            символы табуляции. Т.е. она является обратной по отношению
            к команде <strong
             class="COMMAND">expand</strong>.</p>
          </dd>

          <dt><a
           name="x7050_html_CUTREF"></a><strong
           class="COMMAND">cut</strong></dt>

          <dd>
            <p>Предназначена для извлечения отдельных полей из
            текстовых файлов. Напоминает команду <tt
             class="USERINPUT"><strong>print $N</strong></tt> в <a
             href="#x14802_html_AWKREF">awk</a>, но более ограничена в
            своих возможностях. В простейших случаях может быть
            неплохой заменой <strong
             class="COMMAND">awk</strong> в сценариях. Особую
            значимость, для команды <strong
             class="COMMAND">cut</strong>, представляют ключи <tt
             class="OPTION">-d</tt> (разделитель полей) и <tt
             class="OPTION">-f</tt> (номер(а) поля(ей)).</p>

            <p>Использование команды <strong
             class="COMMAND">cut</strong> для получения списка
            смонтированных файловых систем:</p>
<pre
 class="PROGRAMLISTING">
cat /etc/mtab | cut -d &#39; &#39; -f1,2
</pre>
            <br>
            <br>

            <p>Использование команды <strong
             class="COMMAND">cut</strong> для получения версии ОС и
            ядра:</p>
<pre
 class="PROGRAMLISTING">
uname -a | cut -d&quot; &quot; -f1,3,11,12
</pre>
            <br>
            <br>

            <p>Использование команды <strong
             class="COMMAND">cut</strong> для извлечения заголовков
            сообщений из электронных писем:</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>grep &#39;^Subject:&#39; read-messages | cut -c10-80</strong></tt>
<tt
 class="COMPUTEROUTPUT">Re: Linux suitable for mission-critical apps?
 MAKE MILLIONS WORKING AT HOME3
 Spam complaint
 Re: Spam complaint</tt>
</pre>
            <br>
            <br>

            <p>Использование команды <strong
             class="COMMAND">cut</strong> при разборе текстового
            файла:</p>
<pre
 class="PROGRAMLISTING">
# Список пользователей в /etc/passwd.

FILENAME=/etc/passwd

for user in $(cut -d: -f1 $FILENAME)
do
  echo $user
done

# Спсибо Oleg Philon за этот пример.
</pre>
            <br>
            <br>

            <p><tt
             class="USERINPUT"><strong>cut -d &#39; &#39; -f2,3
            filename</strong></tt> эквивалентно <tt
             class="USERINPUT"><strong>awk -F&#39;[ ]&#39; &#39;{ print
            $2, $3 }&#39; filename</strong></tt></p>

            <p>См. также <a
             href="#x9199_html_BASE">Пример 12-33</a>.</p>
          </dd>

          <dt><strong
           class="COMMAND">paste</strong></dt>

          <dd>
            <p>Используется для объединения нескольких файлов в один
            многоколоночный файл.</p>
          </dd>

          <dt><strong
           class="COMMAND">join</strong></dt>

          <dd>
            <p>Может рассматриваться как команда, родственная команде
            <strong
             class="COMMAND">paste</strong>. Эта мощная утилита
            позволяет объединять два файла по общему полю, что
            представляет собой упрощенную версию реляционной базы
            данных.</p>

            <p>Команда <strong
             class="COMMAND">join</strong> оперирует только двумя
            файлами и объедияет только те строки, которые имеют общее
            поле (обычно числовое), результат объединения выводится на
            <tt
             class="FILENAME">stdout</tt>. Объединяемые файлы должны
            быть отсортированы по ключевому полю.</p>
<pre
 class="PROGRAMLISTING">
File: 1.data

100 Shoes
200 Laces
300 Socks
</pre>
            <br>
            <br>
<pre
 class="PROGRAMLISTING">
File: 2.data

100 $40.00
200 $1.00
300 $2.00
</pre>
            <br>
            <br>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>join 1.data 2.data</strong></tt>
<tt
 class="COMPUTEROUTPUT">File: 1.data 2.data

100 Shoes $40.00
200 Laces $1.00
300 Socks $2.00</tt>
             
</pre>
            <br>
            <br>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>На выходе ключевое поле встречается только один
                    раз.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">head</strong></dt>

          <dd>
            <p>Выводит начальные строки из файла на <tt
             class="FILENAME">stdout</tt> (по-умолчанию -- <tt
             class="LITERAL">10</tt> строк, но это число можно задать
            иным). Эта команда имеет ряд интересных ключей.</p>

            <div
             class="EXAMPLE">
              <a
               name="x7050_html_SCRIPTDETECTOR"></a>

              <p><strong>Пример 12-9. Какие из файлов являются
              сценариями?</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# script-detector.sh: Отыскивает файлы сценариев в каталоге.

TESTCHARS=2    # Проверяются первые два символа.
SHABANG=&#39;#!&#39;   # Сценарии как правило начинаются с &quot;sha-bang.&quot;

for file in *  # Обход всех файлов в каталоге.
do
  if [[ `head -c$TESTCHARS &quot;$file&quot;` = &quot;$SHABANG&quot; ]]
  #      head -c2                      #!
  #  Ключ &#39;-c&#39; в команде &quot;head&quot; выводит заданное
  #+ количество символов, а не строк.
  then
    echo &quot;Файл \&quot;$file\&quot; -- сценарий.&quot;
  else
    echo &quot;Файл \&quot;$file\&quot; не является сценарием.&quot;
  fi
done
  
exit 0
</pre>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="x7050_html_RND"></a>

              <p><strong>Пример 12-10. Генератор 10-значных случайных
              чисел</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# rnd.sh: Генератор 10-значных случайных чисел

# Автор: Stephane Chazelas.

head -c4 /dev/urandom | od -N4 -tu4 | sed -ne &#39;1s/.* //p&#39;


# =================================================================== #

# Описание
# --------

# head:
# -c4 -- первые 4 байта.

# od:
# -N4 ограничивает вывод 4-мя байтами.
# -tu4 беззнаковый десятичный формат вывода.

# sed:
# -n, в комбинации с флагом &quot;p&quot;, в команде &quot;s&quot;,
# выводит только совпадающие с шаблоном строки.



# Автор сценария описывает действия &#39;sed&#39; таким образом:

# head -c4 /dev/urandom | od -N4 -tu4 | sed -ne &#39;1s/.* //p&#39;
# ----------------------------------&gt; |

# Передает вывод в &quot;sed&quot;    --------&gt; |
# пусть это будет 0000000 1198195154\n

# sed начинает читать символы: 0000000 1198195154\n.
# Здесь он находит символ перевода строки,
# таким образом он получает строку (0000000 1198195154).
# Затем он просматривает &lt;диапазон&gt;&lt;действие&gt;. Первый и единственный -- это

#   диапазон  действие
#   1         s/.* //p

# Номер строки попадает в заданный лиапазон, так что теперь он приступает к выполнению действия:
# пытается заменить наибольшую подстроку, заканчивающуюся пробелом
# (&quot;0000000 &quot;) &quot;ничем&quot; (//), и если замена произведена -- выводит результат
# (&quot;p&quot; -- это флаг команды &quot;s&quot;, а не команда &quot;p&quot;, которая имеет иное значение).

# теперь sed готов продолжить чтение входного потока. (Обратите внимание:
# если опустить ключ -n, то sed выведет строку еще раз)

# Теперь sed дочитывает остаток строки.
# Он готов приступить к анализу 2-й строки (которая отмечена &#39;$&#39;
# как последняя).
# Поскольку строка не попадает в заданный &lt;диапазон&gt;, на этом обработка прекращается.

# Проще говоря, команда sed означает:
# &quot;В первой строке удалить любые символы, вплоть до последнего встреченного пробела,
# и затем вывести остаток.&quot;

# Сделать это можно более простым способом:
#           sed -e &#39;s/.* //;q&#39;

# Где, заданы два &lt;диапазона&gt;&lt;действия&gt; (можно записать и по другому
#           sed -e &#39;s/.* //&#39; -e q):

#   диапазон                          действие
#   ничего (для совпадающих строк)    s/.* //
#   ничего (для совпадающих строк)    q (quit)

# Здесь sed считывает только первую строку.
# Выполняет оба действия, и выводит строку перед завершением
# (действие &quot;q&quot;), поскольку ключ &quot;-n&quot; опущен.

# =================================================================== #

# Простая альтернатива:
#           head -c4 /dev/urandom| od -An -tu4

exit 0
</pre>
            </div>
            См. также <a
             href="#x7794_html_EX52">Пример 12-30</a>.<br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">tail</strong></dt>

          <dd>
            <p>Выводит последние строки из файла на <tt
             class="FILENAME">stdout</tt> (по-умолчанию -- 10 строк).
            Обычно используется для мониторинга системных журналов.
            Ключ <tt
             class="OPTION">-f</tt>, позволяет вести непрерывное
            наблюдение за добавляемыми строками в файл.</p>

            <div
             class="EXAMPLE">
              <a
               name="x7050_html_EX12"></a>

              <p><strong>Пример 12-11. Мониторинг системного журнала с
              помощью tail</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

filename=sys.log

cat /dev/null &gt; $filename; echo &quot;Создание / очистка временного файла.&quot;
#  Если файл отсутствует, то он создается,
#+ и очищается, если существует.
#  : &gt; filename   и   &gt; filename дают тот же эффект.

tail /var/log/messages &gt; $filename
# Файл /var/log/messages должен быть доступен для чтения.

echo &quot;В файл $filename записаны последние строки из /var/log/messages.&quot;

exit 0
</pre>
            </div>

            <p>См. также <a
             href="#x6646_html_EX41">Пример 12-4</a>, <a
             href="#x7794_html_EX52">Пример 12-30</a> и <a
             href="#c13099_html_ONLINE">Пример 29-6</a>.</p>
          </dd>

          <dt><a
           name="x7050_html_GREPREF"></a><strong
           class="COMMAND">grep</strong></dt>

          <dd>
            <p>Многоцелевая поисковая утилита, использующая <a
             href="#c11895_html_REGEXREF">регулярные выражения</a>.
            Изначально это была команда в древнем строчном редакторе
            <strong
             class="COMMAND">ed</strong>, <tt
             class="USERINPUT"><strong>g/re/p</strong></tt>, что
            означает -- <span
             class="emphasis"><em
             class="EMPHASIS">global - regular expression -
            print</em></span>.</p>

            <p><strong
             class="COMMAND">grep</strong> <tt
             class="REPLACEABLE"><em>pattern</em></tt> [<tt
             class="REPLACEABLE"><em>file</em></tt>...]</p>
            Поиск участков текста в файле(ах), соответствующих шаблону
            <tt
             class="REPLACEABLE"><em>pattern</em></tt>, где <tt
             class="REPLACEABLE"><em>pattern</em></tt> может быть как
            обычной строкой, так и регулярным выражением.<br>
            <br>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>grep &#39;[rst]ystem.$&#39; osinfo.txt</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">The GPL governs the distribution of the Linux operating system.</tt>
             
</pre>
            <br>
            <br>

            <p>Если файл(ы) для поиска не задан, то команда <strong
             class="COMMAND">grep</strong> работает как фильтр для
            устройства <tt
             class="FILENAME">stdout</tt>, например в <a
             href="#c301_html_PIPEREF">конвейере</a>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ps ax | grep clock</strong></tt>
<tt
 class="COMPUTEROUTPUT">765 tty1     S      0:00 xclock
 901 pts/1    S      0:00 grep clock</tt>
             
</pre>
            <br>
            <br>

            <p><tt
             class="OPTION">-i</tt> -- выполняется поиск без учета
            регистра символов.</p>

            <p><tt
             class="OPTION">-w</tt> -- поиск совпадений целого
            слова.</p>

            <p><tt
             class="OPTION">-l</tt> -- вывод только имен файлов, в
            которых найдены участки, совпадающие с заданным
            образцом/шаблоном, без вывода совпадающих строк.</p>

            <p><tt
             class="OPTION">-r</tt> -- (рекурсивный поиск) поиск
            выполняется в текущем каталоге и всех вложенных
            подкаталогах.</p>

            <p>The <tt
             class="OPTION">-n</tt> option lists the matching lines,
            together with line numbers.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>grep -n Linux osinfo.txt</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">2:This is a file containing information about Linux.
 6:The GPL governs the distribution of the Linux operating system.</tt>
             
</pre>
            <br>
            <br>

            <p><tt
             class="OPTION">-v</tt> (или <tt
             class="OPTION">--invert-match</tt>) -- выводит только
            строки, не содержащие совпадений.</p>
<pre
 class="PROGRAMLISTING">
grep pattern1 *.txt | grep -v pattern2

# Выводятся строки из &quot;*.txt&quot;, совпадающие с &quot;pattern1&quot;,
# но ***не*** совпадающие с &quot;pattern2&quot;.
</pre>
            <br>
            <br>

            <p><tt
             class="OPTION">-c</tt> (<tt
             class="OPTION">--count</tt>) -- выводит количество
            совпадений без вывода самих совпадений.</p>
<pre
 class="PROGRAMLISTING">
grep -c txt *.sgml   # (количество совпадений с &quot;txt&quot; в &quot;*.sgml&quot; файлах)


#   grep -cz .
#            ^ точка
# означает подсчет (-c) непустых (&quot;.&quot; -- содержащих хотя бы один символ) элементов,
# разделенных нулевыми байтами (-z)
#
printf &#39;a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf&#39; | grep -cz .     # 4
printf &#39;a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf&#39; | grep -cz &#39;$&#39;   # 5
printf &#39;a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf&#39; | grep -cz &#39;^&#39;   # 5
#
printf &#39;a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf&#39; | grep -c &#39;$&#39;    # 9
# По-умолчанию, в качестве разделителя, принимается символ перевода строки (\n).

# Обратите внимание: ключ -z характерен для GNU-версии &quot;grep&quot;.


# Спасибо S.C.
</pre>
            <br>
            <br>

            <p>Если <strong
             class="COMMAND">grep</strong> вызывается для поиска по
            группе файлов, то вывод будет содержать указание на имена
            файлов, в которых найдены совпадения.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>grep Linux osinfo.txt misc.txt</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">osinfo.txt:This is a file containing information about Linux.
 osinfo.txt:The GPL governs the distribution of the Linux operating system.
 misc.txt:The Linux operating system is steadily gaining in popularity.</tt>
             
</pre>
            <br>
            <br>

            <div
             class="TIP">
              <table
               class="TIP"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/tip.gif"
                   hspace="5"
                   alt="Tip"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Для того, чтобы заставить <strong
                     class="COMMAND">grep</strong> выводить имя файла,
                    когда поиск производится по одному-единственному
                    файлу, достаточно указать устройство <tt
                     class="FILENAME">/dev/null</tt> в качестве второго
                    файла.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>grep Linux osinfo.txt /dev/null</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">osinfo.txt:This is a file containing information about Linux.
 osinfo.txt:The GPL governs the distribution of the Linux operating system.</tt>
             
</pre>
                    <br>
                    <br>
                  </td>
                </tr>
              </table>
            </div>

            <p>Если совпадение было найдено, то <strong
             class="COMMAND">grep</strong> возвращает <a
             href="#c2105_html_EXITSTATUSREF">код завершения</a> -- 0,
            это может оказаться полезным при выполнении поиска в
            условных операторах ( в таких случаях особый интерес может
            представлять ключ <tt
             class="OPTION">-q</tt>, который подавляет вывод).</p>
<pre
 class="PROGRAMLISTING">
SUCCESS=0                      # если найдено совпадение
word=Linux
filename=data.file

grep -q &quot;$word&quot; &quot;$filename&quot;    # &quot;-q&quot; -- подавляет вывод на stdout.

if [ $? -eq $SUCCESS ]
then
  echo &quot;Образец $word найден в $filename&quot;
else
  echo &quot;Образец $word в файле $filename не найден&quot;
fi
</pre>
            <br>
            <br>

            <p><a
             href="#c13099_html_ONLINE">Пример 29-6</a> -- пример поиска
            заданного образца в системном журнале, с помощью <strong
             class="COMMAND">grep</strong>.</p>

            <div
             class="EXAMPLE">
              <a
               name="x7050_html_GRP"></a>

              <p><strong>Пример 12-12. Сценарий-эмулятор <span
               class="QUOTE">&quot;grep&quot;</span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# grp.sh: Очень &quot;грубая&quot; реализация &#39;grep&#39;.

E_BADARGS=65

if [ -z &quot;$1&quot; ]    # Проверка наличия аргументов.
then
  echo &quot;Порядок использования: `basename $0` pattern&quot;
  exit $E_BADARGS
fi

echo

for file in *     # Обход всех файлов в $PWD.
do
  output=$(sed -n /&quot;$1&quot;/p $file)  # Подстановка команд.

  if [ ! -z &quot;$output&quot; ]           # Что произойдет, если кавычки вокруг &quot;$output&quot; убрать?
  then
    echo -n &quot;$file: &quot;
    echo $output
  fi              #  эквивалент: sed -ne &quot;/$1/s|^|${file}: |p&quot;

  echo
done

echo

exit 0

# Упражнения:
# ---------
# 1) Добавьте вывод символов перевода строки, если найдено более одного совпадения в любом из файлов.
# 2) Добавьте обработку различных ключей.
</pre>
            </div>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p><a
                     name="x7050_html_EGREPREF"></a><strong
                     class="COMMAND">egrep</strong> -- то же самое, что
                    и <strong
                     class="COMMAND">grep -E</strong>. Эта команда
                    использует несколько отличающийся, расширенный
                    набор <a
                     href="#c11895_html_REGEXREF">регулярных
                    выражений</a>, что позволяет выполнять поиск более
                    гибко.</p>

                    <p><strong
                     class="COMMAND">fgrep</strong> -- то же самое, что
                    и <strong
                     class="COMMAND">grep -F</strong>. Эта команда
                    выполняет поиск строк символов (не регулярных
                    выражений), что несколько увеличивает скорость
                    поиска.</p>

                    <p>Утилита <strong
                     class="COMMAND">agrep</strong> имеет более широкие
                    возможности поиска приблизительных совпадений.
                    Образец поиска может отличаться от найденной строки
                    на указанное число символов.</p>
                  </td>
                </tr>
              </table>
            </div>

            <div
             class="TIP">
              <table
               class="TIP"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/tip.gif"
                   hspace="5"
                   alt="Tip"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Для поиска по сжатым файлам следует использовать
                    утилиты <strong
                     class="COMMAND">zgrep</strong>, <strong
                     class="COMMAND">zegrep</strong> или <strong
                     class="COMMAND">zfgrep</strong>. Они с успехом
                    могут использоваться и для не сжатых файлов, но в
                    этом случае они уступают в скорости обычным <strong
                     class="COMMAND">grep</strong>, <strong
                     class="COMMAND">egrep</strong> и <strong
                     class="COMMAND">fgrep</strong>. Они очень удобны
                    при выполнении поиска по смешенному набору файлов
                    -- когда одни файлы сжаты, а другие нет.</p>

                    <p>Для поиска по <a
                     href="#x7794_html_BZIPREF">bzip</a>-файлам
                    используйте <strong
                     class="COMMAND">bzgrep</strong>.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">look</strong></dt>

          <dd>
            <p>Команда <strong
             class="COMMAND">look</strong> очень похожа на <strong
             class="COMMAND">grep</strong>, и предназначена для поиска
            по <span
             class="QUOTE">&quot;словарям&quot;</span> --
            отсортированным файлам. По-умолчанию, поиск выполняется в
            файле <tt
             class="FILENAME">/usr/dict/words</tt>, но может быть
            указан и другой словарь.</p>

            <div
             class="EXAMPLE">
              <a
               name="x7050_html_LOOKUP"></a>

              <p><strong>Пример 12-13. Поиск слов в
              словаре</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# lookup: Выполняется поиск каждого слова из файла в словаре.

file=words.data  # Файл с искомыми словами.

echo

while [ &quot;$word&quot; != end ]  # Последнее слово в файле.
do
  read word      # Из файла, потому, что выполнено перенаправление в конце цикла.
  look $word &gt; /dev/null  # Подавление вывода строк из словаря.
  lookup=$?      # Код возврата команды &#39;look&#39;.

  if [ &quot;$lookup&quot; -eq 0 ]
  then
    echo &quot;Слово \&quot;$word\&quot; найдено.&quot;
  else
    echo &quot;Слово \&quot;$word\&quot; не найдено.&quot;
  fi

done &lt;&quot;$file&quot;    # Перенаправление ввода из файла $file, так что &quot;чтение&quot; производится оттуда.

echo

exit 0

# ----------------------------------------------------------------
# Строки, расположенные ниже не будут исполнены, поскольку выше стоит команда &quot;exit&quot;.


# Stephane Chazelas предложил более короткий вариант:

while read word &amp;&amp; [[ $word != end ]]
do if look &quot;$word&quot; &gt; /dev/null
   then echo &quot;Слово \&quot;$word\&quot; найдено.&quot;
   else echo &quot;Слово \&quot;$word\&quot; не найдено.&quot;
   fi
done &lt;&quot;$file&quot;

exit 0
</pre>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">sed</strong>, <strong
           class="COMMAND">awk</strong></dt>

          <dd>
            <p>Скриптовые языки, специально разработанные для анализа
            текстовых данных.</p>
          </dd>

          <dt><strong
           class="COMMAND"><a
           href="#a14586_html_SEDREF">sed</a></strong></dt>

          <dd>
            <p>Неинтерактивный <span
             class="QUOTE">&quot;потоковый редактор&quot;</span>.
            Широко используется в сценариях на языке командной
            оболочки.</p>
          </dd>

          <dt><strong
           class="COMMAND"><a
           href="#x14802_html_AWKREF">awk</a></strong></dt>

          <dd>
            <p>Утилита контекстного поиска и преобразования текста,
            замечательный инструмент для извлечения и/или обработки
            полей (колонок) в структурированных текстовых файлах.
            Синтаксис awk напоминает язык C.</p>
          </dd>

          <dt><strong
           class="COMMAND">wc</strong></dt>

          <dd>
            <p><span
             class="emphasis"><em
             class="EMPHASIS">wc</em></span> -- <span
             class="QUOTE">&quot;word count&quot;</span>, счетчик слов
            в файле или в потоке:</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash $</tt> <tt
 class="USERINPUT"><strong>wc /usr/doc/sed-3.02/README</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">20     127     838 /usr/doc/sed-3.02/README</tt>
[20 строк  127 слов  838 символов]
</pre>
            <br>
            <br>

            <p><tt
             class="USERINPUT"><strong>wc -w</strong></tt> подсчитывает
            только слова.</p>

            <p><tt
             class="USERINPUT"><strong>wc -l</strong></tt> подсчитывает
            только строки.</p>

            <p><tt
             class="USERINPUT"><strong>wc -c</strong></tt> подсчитывает
            только символы.</p>

            <p><tt
             class="USERINPUT"><strong>wc -L</strong></tt> возвращает
            длину наибольшей строки.</p>

            <p>Подсчет количества <span
             class="emphasis"><em
             class="EMPHASIS">.txt</em></span>-файлов в текущем
            каталоге с помощью <strong
             class="COMMAND">wc</strong>:</p>
<pre
 class="PROGRAMLISTING">
$ ls *.txt | wc -l
# Эта команда будет работать, если ни в одном из имен файлов &quot;*.txt&quot; нет символа перевода строки.

# Альтернативный вариант:
#      find . -maxdepth 1 -name \*.txt -print0 | grep -cz .
#      (shopt -s nullglob; set -- *.txt; echo $#)

# Спасибо S.C.
</pre>
            <br>
            <br>

            <p>Подсчет общего размера файлов, чьи имена начинаются с
            символов, в диапазоне d - h</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>wc [d-h]* | grep total | awk &#39;{print $3}&#39;</strong></tt>
<tt
 class="COMPUTEROUTPUT">71832</tt>
             
</pre>
            <br>
            <br>

            <p>От переводчика: в случае, если у вас локаль отлична от
            &quot;C&quot;, то вышеприведенная команда может не дать
            результата, поскольку <strong
             class="COMMAND">wc</strong> вернет не слово
            &quot;total&quot;, в конце вывода, а &quot;итого&quot;.
            Тогда можно попробовать несколько измененный вариант:</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>wc [d-h]* | grep итого | awk &#39;{print $3}&#39;</strong></tt>
<tt
 class="COMPUTEROUTPUT">71832</tt>
             
</pre>
            <br>
            <br>

            <p>Использование <strong
             class="COMMAND">wc</strong> для подсчета количества
            вхождений слова <span
             class="QUOTE">&quot;Linux&quot;</span> в основной исходный
            файл с текстом этого руководства.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>grep Linux abs-book.sgml | wc -l</strong></tt>
<tt
 class="COMPUTEROUTPUT">50</tt>
             
</pre>
            <br>
            <br>

            <p>См. также <a
             href="#x7794_html_EX52">Пример 12-30</a> и <a
             href="#x11731_html_REDIR4">Пример 16-7</a>.</p>

            <p>Отдельные команды располагают функциональностью <strong
             class="COMMAND">wc</strong> в виде своих ключей.</p>
<pre
 class="PROGRAMLISTING">
... | grep foo | wc -l
# Часто встречающаяся конструкция, которая может быть сокращена.

... | grep -c foo
# Ключ &quot;-c&quot; (&quot;--count&quot;) команды grep.

# Спасибо S.C.
</pre>
            <br>
            <br>
          </dd>

          <dt><a
           name="x7050_html_TRREF"></a><strong
           class="COMMAND">tr</strong></dt>

          <dd>
            <p>Замена одних символов на другие.</p>

            <div
             class="CAUTION">
              <table
               class="CAUTION"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/caution.gif"
                   hspace="5"
                   alt="Caution"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>В отдельных случаях <a
                     href="#c301_html_UCREF">символы необходимо
                    заключать в кавычки и/или квадратные скобки</a>.
                    Кавычки предотвращают интерпретацию специальных
                    символов командной оболочкой. Квадратные скобки
                    должны заключаться в кавычки.</p>
                  </td>
                </tr>
              </table>
            </div>

            <p>Команда <tt
             class="USERINPUT"><strong>tr &quot;A-Z&quot; &quot;*&quot;
            &lt;filename</strong></tt> или <tt
             class="USERINPUT"><strong>tr A-Z \*
            &lt;filename</strong></tt> заменяет все символы верхнего
            регистра в <tt
             class="FILENAME">filename</tt> на звездочки (вывод
            производится на <tt
             class="FILENAME">stdout</tt>). В некоторых системах этот
            вариант может оказаться неработоспособным, тогда попробуйте
            <tt
             class="USERINPUT"><strong>tr A-Z
            &#39;[**]&#39;</strong></tt>.</p>

            <p>Ключ <tt
             class="OPTION">-d</tt> удаляет символы из заданного
            диапазона.</p>
<pre
 class="PROGRAMLISTING">
echo &quot;abcdef&quot;                 # abcdef
echo &quot;abcdef&quot; | tr -d b-d     # aef


tr -d 0-9 &lt;filename
# Удалит все цифровые символы из файла &quot;filename&quot;.
</pre>
            <br>
            <br>

            <p>Ключ <tt
             class="OPTION">--squeeze-repeats</tt> (<tt
             class="OPTION">-s</tt>) удалит все повторяющиеся
            последовательности символов. Может использоваться для
            удаления лишних <a
             href="#c301_html_WHITESPACEREF">пробельных
            символов</a>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>echo &quot;XXXXX&quot; | tr --squeeze-repeats &#39;X&#39;</strong></tt>
<tt
 class="COMPUTEROUTPUT">X</tt>
</pre>
            <br>
            <br>

            <p>Ключ <tt
             class="OPTION">-c</tt> <span
             class="QUOTE">&quot;complement&quot;</span> <span
             class="emphasis"><em
             class="EMPHASIS">заменит</em></span> символы в
            соответствии с шаблоном. Этот ключ воздействует только на
            те символы, которые НЕ соответствуют заданному шаблону.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>echo &quot;acfdeb123&quot; | tr -c b-d +</strong></tt>
<tt
 class="COMPUTEROUTPUT">+c+d+b++++</tt>
</pre>
            <br>
            <br>

            <p>Обратите внимание: команда <strong
             class="COMMAND">tr</strong> корректно распознает <a
             href="#c11895_html_POSIXREF">символьные классы POSIX</a>.
            <a
             name="AEN7520"
             href="#x7050_html_FTN_AEN7520"><span
             class="footnote">[1]</span></a></p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>echo &quot;abcd2ef1&quot; | tr &#39;[:alpha:]&#39; -</strong></tt>
<tt
 class="COMPUTEROUTPUT">----2--1</tt>
             
</pre>
            <br>
            <br>

            <div
             class="EXAMPLE">
              <a
               name="x7050_html_EX49"></a>

              <p><strong>Пример 12-14. toupper: Преобразование символов
              в верхний регистр.</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Преобразование символов в верхний регистр.

E_BADARGS=65

if [ -z &quot;$1&quot; ]  # Стандартная проверка командной строки.
then
  echo &quot;Порядок использования: `basename $0` filename&quot;
  exit $E_BADARGS
fi

tr a-z A-Z &lt;&quot;$1&quot;

# Тот же эффект можно получить при использовании символьных классов POSIX:
#        tr &#39;[:lower:]&#39; &#39;[:upper:]&#39; &lt;&quot;$1&quot;
# Спасибо S.C.

exit 0
</pre>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="x7050_html_LOWERCASE"></a>

              <p><strong>Пример 12-15. lowercase: Изменение имен всех
              файлов в текущем каталоге в нижний регистр.</strong></p>
<pre
 class="PROGRAMLISTING">
#! /bin/bash
#
# Изменит все имена файлов в текущем каталоге в нижнй регистр.
#


for filename in *                # Обход всех файлов в каталоге.
do
   fname=`basename $filename`
   n=`echo $fname | tr A-Z a-z`  # Перевести символы в нижний регистр.
   if [ &quot;$fname&quot; != &quot;$n&quot; ]       # Переименовать только те файлы, имена которых изменились.
   then
     mv $fname $n
   fi
done

exit 0


# Сироки приведенные ниже не будут исполняться, поскольку выше стоит команда &quot;exit&quot;.
#--------------------------------------------------------#
# Запустите эту часть сценария, удалив строки , стоящие выше.

# Сценарий, приведенный выше, не работает с именами файлов, содержащими пробелы или символы перевода строки.

# В связи с этим, Stephane Chazelas предложил следующий вариант:


for filename in *    # Нет необходимости использовать basename,
                     # поскольку &quot;*&quot; возвращает имена, не содержащие &quot;/&quot;.
do n=`echo &quot;$filename/&quot; | tr &#39;[:upper:]&#39; &#39;[:lower:]&#39;`
#                             символьные классы POSIX.
#                    Завершающий слэш добавлен для того, чтобы символ перевода строки
#                    не был удален при подстановке команды.
   # Подстановка переменной:
   n=${n%/}          # Удаление завершающего слэша, добавленного выше.
   [[ $filename == $n ]] || mv &quot;$filename&quot; &quot;$n&quot;
                     # Проверка -- действительно ли изменилось имя файла.
done

exit 0
</pre>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="x7050_html_DU"></a>

              <p><strong>Пример 12-16. du: Преобразование текстового
              файла из формата DOS в формат UNIX.</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# du.sh: Преобразование текстового файла из формата DOS в формат UNIX.

E_WRONGARGS=65

if [ -z &quot;$1&quot; ]
then
  echo &quot;Порядок использования: `basename $0` filename-to-convert&quot;
  exit $E_WRONGARGS
fi

NEWFILENAME=$1.unx

CR=&#39;\015&#39;  # Возврат каретки.
# Строки в текстовых файлах DOS завершаются комбинацией символов CR-LF.

tr -d $CR &lt; $1 &gt; $NEWFILENAME
# Удалить символы CR и записать в новый файл.

echo &quot;Исходный текстовый файл: \&quot;$1\&quot;.&quot;
echo &quot;Преобразованный файл: \&quot;$NEWFILENAME\&quot;.&quot;

exit 0
</pre>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="x7050_html_ROT13"></a>

              <p><strong>Пример 12-17. rot13: Сверхслабое шифрование по
              алгоритму rot13.</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# rot13.sh: Классический алгоритм шифрования rot13,
#           который способен &quot;расколоть&quot; даже 3-х летний ребенок.

# Порядок использования: ./rot13.sh filename
# или                    ./rot13.sh &lt;filename
# или                    ./rot13.sh и ввести текст с клавиатуры (stdin)

cat &quot;$@&quot; | tr &#39;a-zA-Z&#39; &#39;n-za-mN-ZA-M&#39;   # &quot;a&quot; заменяется на &quot;n&quot;, &quot;b&quot; на &quot;o&quot;, и т.д.
#  Конструкция &#39;cat &quot;$@&quot;&#39;
#+ позволяет вводить данные как со stdin, так и из файла.

exit 0
</pre>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="x7050_html_CRYPTOQUOTE"></a>

              <p><strong>Пример 12-18. Более <span
               class="QUOTE">&quot;сложный&quot;</span>
              шифр</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# crypto-quote.sh: Ограниченное шифрование

# Шифрование ограничивается простой заменой одних алфавитных символов другими.
#  Результат очень похож на шифры-загадки


key=ETAOINSHRDLUBCFGJMQPVWZYXK
# Здесь, &quot;key&quot; -- ни что иное, как &quot;перемешанный&quot; алфавит.
# Изменение ключа &quot;key&quot; приведет к изменению шифра.

# Конструкция &#39;cat &quot;$@&quot;&#39; позволяет вводить данные как со stdin, так и из файла.
# Если используется stdin, то ввод должен завершаться комбинацией Control-D.
# Иначе,  в командной строке, сценарию должно быть передано имя файла.

cat &quot;$@&quot; |  tr &quot;a-z&quot; &quot;A-Z&quot;   | tr &quot;A-Z&quot; &quot;$key&quot;
#        | в верхний регистр |    шифрование
# Такой прием позволяет шифровать как символы в верхнем регистре, так и в нижнем.
# Неалфавитные символы остаются без изменений.


# Попробуйте зашифровать какой либо текст, например
# &quot;Nothing so needs reforming as other people&#39;s habits.&quot;
# --Mark Twain
#
# Результат будет:
# &quot;CFPHRCS QF CIIOQ MINFMBRCS EQ FPHIM GIFGUI&#39;Q HETRPQ.&quot;
# --BEML PZERC

# Для дешифрации можно использовать следующую комбинацию:
# cat &quot;$@&quot; | tr &quot;$key&quot; &quot;A-Z&quot;


#  Этот нехитрый шифр может быть &quot;взломан&quot; 12-ти летним ребенком
#+ с помощью карандаша и бумаги.

exit 0
</pre>
            </div>

            <table
             class="SIDEBAR"
             border="1"
             cellpadding="5">
              <tr>
                <td>
                  <div
                   class="SIDEBAR">
                    <a
                     name="x7050_html_AEN7548"></a>

                    <p><strong>Различные версии tr</strong></p>

                    <p>Утилита <strong
                     class="COMMAND">tr</strong> имеет две, исторически
                    сложившиеся, версии. BSD-версия не использует
                    квадратные скобки (<tt
                     class="USERINPUT"><strong>tr a-z
                    A-Z</strong></tt>), в то время как SysV-версия
                    использует их (<tt
                     class="USERINPUT"><strong>tr &#39;[a-z]&#39;
                    &#39;[A-Z]&#39;</strong></tt>). GNU-версия утилиты
                    <strong
                     class="COMMAND">tr</strong> напоминает версию BSD,
                    но диапазоны символов обязательно должны
                    заключаться в квадратные скобки.</p>
                  </div>
                </td>
              </tr>
            </table>
          </dd>

          <dt><a
           name="x7050_html_FOLDREF"></a><strong
           class="COMMAND">fold</strong></dt>

          <dd>
            <p>Выравнивает текст по ширине, разрывая, если это
            необходимо, слова. Особый интерес представляет ключ <tt
             class="OPTION">-s</tt>, который производит перенос строк
            по пробелам, стараясь не разрывать слова. (см. <a
             href="#x7050_html_EX50">Пример 12-19</a> и <a
             href="#a14477_html_MAILFORMAT">Пример A-2</a>).</p>
          </dd>

          <dt><strong
           class="COMMAND">fmt</strong></dt>

          <dd>
            <p>Очень простая утилита форматирования текста, чаще всего
            используемая как фильтр в конвейерах для того, чтобы
            выполнить <span
             class="QUOTE">&quot;перенос&quot;</span> длинных строк
            текста.</p>

            <div
             class="EXAMPLE">
              <a
               name="x7050_html_EX50"></a>

              <p><strong>Пример 12-19. Отформатированный список
              файлов.</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

WIDTH=40                    # 40 символов в строке.

b=`ls /usr/local/bin`       # Получить список файлов...

echo $b | fmt -w $WIDTH

# То же самое можно выполнить командой
#  echo $b | fold - -s -w $WIDTH
 
exit 0
</pre>
            </div>

            <p>См. также <a
             href="#x6646_html_EX41">Пример 12-4</a>.</p>

            <div
             class="TIP">
              <table
               class="TIP"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/tip.gif"
                   hspace="5"
                   alt="Tip"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Очень мощной альтернативой утилите <strong
                     class="COMMAND">fmt</strong>, является утилита
                    <strong
                     class="COMMAND">par</strong> (автор Kamil Toman),
                    которую вы сможете найти на <a
                     href="http://www.cs.berkeley.edu/~amc/Par/"
                     target=
                    "_top">http://www.cs.berkeley.edu/~amc/Par/</a>.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">col</strong></dt>

          <dd>
            <p>Эта утилита с обманчивым названием удаляет из входного
            потока символы обратной подачи бумаги (код ESC 7). Она так
            же пытается заменить пробелы на табуляции. Основная область
            применения утилиты <strong
             class="COMMAND">col</strong> -- фильтрация вывода
            отдельных утилит обработки текста, таких как <strong
             class="COMMAND">groff</strong> и <strong
             class="COMMAND">tbl</strong>.</p>
          </dd>

          <dt><strong
           class="COMMAND">column</strong></dt>

          <dd>
            <p>Форматирование по столбцам. Эта утилита преобразует
            текст, например какой либо список, в табличное, более <span
             class="QUOTE">&quot;удобочитаемое&quot;</span>,
            представление, вставляя символы табуляции по мере
            необходимости.</p>

            <div
             class="EXAMPLE">
              <a
               name="x7050_html_COL"></a>

              <p><strong>Пример 12-20. Пример форматирования списка
              файлов в каталоге</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# За основу сценария взят пример &quot;man column&quot;.


(printf &quot;PERMISSIONS LINKS OWNER GROUP SIZE DATE TIME PROG-NAME\n&quot; \
; ls -l | sed 1d) | column -t

#  Команда &quot;sed 1d&quot; удаляет первую строку, выводимую командой ls,
#+ (для локали &quot;С&quot; это строка:  &quot;total        N&quot;,
#+ где &quot;N&quot; -- общее количество файлов.

# Ключ -t, команды &quot;column&quot;, означает &quot;табличное&quot; представление.

exit 0
</pre>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">colrm</strong></dt>

          <dd>
            <p>Утилита удаления колонок. Удаляет колонки (столбцы)
            сиволов из файла и выводит результат на <tt
             class="FILENAME">stdout</tt>. <tt
             class="USERINPUT"><strong>colrm 2 4
            &lt;filename</strong></tt> -- удалит символы со 2-го по 4-й
            включительно, в каждой строке в файле <tt
             class="FILENAME">filename</tt>.</p>

            <div
             class="WARNING">
              <table
               class="WARNING"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/warning.gif"
                   hspace="5"
                   alt="Warning"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Если файл содержит символы табуляции или
                    непечатаемые символы, то результат может получиться
                    самым неожиданным. В таких случаях, как правило,
                    утилиту <strong
                     class="COMMAND">colrm</strong>, в конвейере,
                    окружают командами <a
                     href="#x7050_html_EXPANDREF">expand</a> и <strong
                     class="COMMAND">unexpand</strong>.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">nl</strong></dt>

          <dd>
            <p>Нумерует строки в файле. <tt
             class="USERINPUT"><strong>nl filename</strong></tt> --
            выведет файл <tt
             class="FILENAME">filename</tt> на <tt
             class="FILENAME">stdout</tt>, и в начале каждой строки
            вставит ее порядковый номер, счет начинается с первой
            непустой строки. Если файл не указывается, то принимается
            ввод со <tt
             class="FILENAME">stdin.</tt></p>

            <p>Вывод команды <strong
             class="COMMAND">nl</strong> очень напоминает <tt
             class="USERINPUT"><strong>cat -n</strong></tt>, однако,
            по-умолчанию <strong
             class="COMMAND">nl</strong> не нумерует пустые строки.</p>

            <div
             class="EXAMPLE">
              <a
               name="x7050_html_LNUM"></a>

              <p><strong>Пример 12-21. nl: Самонумерующийся
              сценарий.</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Сценарий выводит себя сам на stdout дважды, нумеруя строки сценария.

# &#39;nl&#39; вставит для этой строки номер 3, поскольку она не нумерует пустые строки.
# &#39;cat -n&#39; вставит для этой строки номер 5.

nl `basename $0`

echo; echo  # А теперь попробуем вывести текст сценария с помощью &#39;cat -n&#39;

cat -n `basename $0`
# Различия состоят в том, что &#39;cat -n&#39; нумерует все строки.
# Обратите внимание: &#39;nl -ba&#39; -- сделает то же самое.

exit 0
</pre>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">pr</strong></dt>

          <dd>
            <p>Подготовка файла к печати. Утилита производит разбивку
            файла на страницы, приводя его в вид пригодный для печати
            или для вывода на экран. Разнообразные ключи позволяют
            выполнять различные манипуляции над строками и колонками,
            соединять строки, устанавливать поля, нумеровать строки,
            добавлять колонтитулы и многое, многое другое. Утилита
            <strong
             class="COMMAND">pr</strong> соединяет в себе
            функциональность таких команд, как <strong
             class="COMMAND">nl</strong>, <strong
             class="COMMAND">paste</strong>, <strong
             class="COMMAND">fold</strong>, <strong
             class="COMMAND">column</strong> и <strong
             class="COMMAND">expand</strong>.</p>

            <p><tt
             class="USERINPUT"><strong>pr -o 5 --width=65 fileZZZ |
            more</strong></tt> -- выдаст хорошо оформленное и разбитое
            на страницы содержимое файла <tt
             class="FILENAME">fileZZZ</tt>.</p>

            <p>Хочу особо отметить ключ <tt
             class="OPTION">-d</tt>, который выводит строки с двойным
            интервалом (тот же эффект, что и <strong
             class="COMMAND">sed -G</strong>).</p>
          </dd>

          <dt><a
           name="x7050_html_GETTEXTREF"></a><strong
           class="COMMAND">gettext</strong></dt>

          <dd>
            <p>GNU утилита, предназначена для нужд <a
             href="#a15021_html">локализации</a> и перевода сообщений
            программ, выводимых на экран, на язык пользователя. Не
            смотря на то, что это актуально, прежде всего, для программ
            на языке C, тем не менее <strong
             class="COMMAND">gettext</strong> с успехом может
            использоваться в сценариях командной оболочки для тех же
            целей. См. <tt
             class="REPLACEABLE"><em>info page</em></tt>.</p>
          </dd>

          <dt><strong
           class="COMMAND">iconv</strong></dt>

          <dd>
            <p>Утилита преобразования текста из одной кодировки в
            другую. В основном используется для нужд локализации.</p>
          </dd>

          <dt><strong
           class="COMMAND">recode</strong></dt>

          <dd>
            <p>Может рассматриваться как разновилность утилиты <strong
             class="COMMAND">iconv</strong>, описанной выше.
            Универсальная утилита для преобразования текстовой
            информации в различные кодировки.</p>
          </dd>

          <dt><strong
           class="COMMAND">TeX</strong>, <strong
           class="COMMAND">gs</strong></dt>

          <dd>
            <p><strong
             class="COMMAND">TeX</strong> и <strong
             class="COMMAND">Postscript</strong> -- языки разметки
            текста, используемые для подготовки текста к печати или
            выводу на экран.</p>

            <p><strong
             class="COMMAND">TeX</strong> -- это сложная система
            подготовки к печати, разработанная Дональдом Кнутом (Donald
            Knuth). Эту утилиту удобнее использовать внутри сценария,
            чем в командной строке, поскольку в сценарии проще один раз
            записать все необходимые параметры, передаваемые утилите,
            для получения необходимого результата.</p>

            <p><span
             class="emphasis"><em
             class="EMPHASIS">Ghostscript</em></span> (<strong
             class="COMMAND">gs</strong>) -- это GPL-версия
            интерпретатора Postscript.</p>
          </dd>

          <dt><strong
           class="COMMAND">groff</strong>, <strong
           class="COMMAND">tbl</strong>, <strong
           class="COMMAND">eqn</strong></dt>

          <dd>
            <p><strong
             class="COMMAND">groff</strong> -- это еще один язык
            разметки текста и форматированного вывода. Является
            расширенной GNU-версией пакета <strong
             class="COMMAND">roff/troff</strong> в UNIX-системах.</p>

            <p><strong
             class="COMMAND">tbl</strong> -- утилита обработки таблиц,
            должна рассматриваться как составная часть <strong
             class="COMMAND">groff</strong>, так как ее задачей
            является преобразование таблиц в команды <strong
             class="COMMAND">groff</strong>.</p>

            <p><strong
             class="COMMAND">eqn</strong> -- утилита преобразования
            математических выражений в команды <strong
             class="COMMAND">groff</strong>.</p>
          </dd>

          <dt><strong
           class="COMMAND">lex</strong>, <strong
           class="COMMAND">yacc</strong></dt>

          <dd>
            <p><strong
             class="COMMAND">lex</strong> -- утилита лексического
            разбора текста. В Linux-системах заменена на свободно
            распространяемую утилиту <strong
             class="COMMAND">flex</strong>.</p>

            <p><strong
             class="COMMAND">yacc</strong> -- утилита для создания
            синтаксических анализаторов, на основе набора грамматик,
            задаваемых разработчиком. В Linux-системах, эта утилита
            заменена на свободно распространяемую утилиту <strong
             class="COMMAND">bison</strong>.</p>
          </dd>
        </dl>
      </div>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN7520"
         href="#x7050_html_AEN7520"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Это верно только для GNU-версии команды <strong
           class="COMMAND">tr</strong>, поведение этой команды, в
          коммерческих UNIX-системах, может несколько отличаться.</p>
        </td>
      </tr>
    </table>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x6837_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x7794_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Команды для работы с датой и временем</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c6407_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Команды для работы с файлами и архивами</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x7794_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x7050_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 12. Внешние команды, программы и
          утилиты</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x8707_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x7794_html_FILEARCHIV"></a>12.5. Команды для работы с файлами и
      архивами</h1>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="x7794_html_FAARCHIVING1"></a>Архивация</strong></p>

        <dl>
          <dt><a
           name="x7794_html_TARREF"></a><strong
           class="COMMAND">tar</strong></dt>

          <dd>
            <p>Стандартная, для UNIX, утилита архивирования.
            Первоначально -- это была программа <em
             class="WORDASWORD">Tape ARchiving</em>, которая
            впоследствии переросла в универсальный пакет, который может
            работать с любыми типами устройств (см. <a
             href="#c301_html_EX58">Пример 3-4</a>). В GNU-версию tar
            была добавлена возможность одновременно производить сжатие
            tar-архива, например команда <strong
             class="COMMAND">tar czvf archive_name.tar.gz *</strong>
            создает tar-архив дерева подкаталогов и вызывает <a
             href="#x7794_html_GZIPREF">gzip</a> для выполнения сжатия,
            исключение составляют <a
             href="#c6407_html_DOTFILESREF">скрытые файлы</a> в текущем
            каталоге (<strong
             class="COMMAND">$PWD</strong>). <a
             name="AEN7816"
             href="#x7794_html_FTN_AEN7816"><span
             class="footnote">[1]</span></a></p>

            <p>Некоторые, часто используемые, ключи команды <strong
             class="COMMAND">tar</strong>:</p>

            <ol
             type="1">
              <li>
                <p><tt
                 class="OPTION">-c</tt> -- создать (create) новый
                архив</p>
              </li>

              <li>
                <p><tt
                 class="OPTION">-x</tt> -- извлечь (extract) файлы из
                архива</p>
              </li>

              <li>
                <p><tt
                 class="OPTION">--delete</tt> -- удалить (delete) файлы
                из архива</p>

                <div
                 class="CAUTION">
                  <table
                   class="CAUTION"
                   width="90%"
                   border="0">
                    <tr>
                      <td
                       width="25"
                       align="center"
                       valign="top"><img
                       src="misc/abs-book/images/caution.gif"
                       hspace="5"
                       alt="Caution"></td>

                      <td
                       align="left"
                       valign="top">
                        <p>Этот ключ игнорируется для накопителей на
                        магнитной ленте.</p>
                      </td>
                    </tr>
                  </table>
                </div>
              </li>

              <li>
                <p><tt
                 class="OPTION">-r</tt> -- добавить (append) файлы в
                существующий архив</p>
              </li>

              <li>
                <p><tt
                 class="OPTION">-A</tt> -- добавить (append) <span
                 class="emphasis"><em
                 class="EMPHASIS">tar</em></span>-файлы в существующий
                архив</p>
              </li>

              <li>
                <p><tt
                 class="OPTION">-t</tt> -- список файлов в архиве
                (содержимое архива)</p>
              </li>

              <li>
                <p><tt
                 class="OPTION">-u</tt> -- обновить (update) архив</p>
              </li>

              <li>
                <p><tt
                 class="OPTION">-d</tt> -- операция сравнения архива с
                заданной файловой системой</p>
              </li>

              <li>
                <p><tt
                 class="OPTION">-z</tt> -- обработка архива с помощью
                <a
                 href="#x7794_html_GZIPREF">gzip</a></p>

                <p>(Сжатие или разжатие, в зависимости от комбинации
                сопутствующих ключей <tt
                 class="OPTION">-c</tt> или <tt
                 class="OPTION">-x</tt>)</p>
              </li>

              <li>
                <p><tt
                 class="OPTION">-j</tt> -- обработка архива с помошью
                <a
                 href="#x7794_html_BZIPREF">bzip2</a></p>
              </li>
            </ol>
            <br>
            <br>

            <div
             class="CAUTION">
              <table
               class="CAUTION"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/caution.gif"
                   hspace="5"
                   alt="Caution"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>При восстановлении &quot;битых&quot; <span
                     class="emphasis"><em
                     class="EMPHASIS">tar.gz</em></span> архивов могут
                    возникнуть определенные сложности, поэтому делайте
                    несколько резервных копий.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">shar</strong></dt>

          <dd>
            <p>Утилита создания shell-архива. Архивируемые файлы
            объединяются в единый файл без выполнения сжатия, в
            результате получается архив -- по сути полноценный сценарий
            на языке командной оболочки, начинающийся со строки <span
             class="TOKEN">#!/bin/sh</span>, который содержит полный
            набор команд, необходимый для разархивирования. Такого рода
            архивы до сих пор можно найти в некоторых телеконференциях
            в Internet, но в последнее время они активно вытесняются
            связкой <strong
             class="COMMAND">tar</strong>/<strong
             class="COMMAND">gzip</strong>. Для распаковки shar-архивов
            предназначена команда <strong
             class="COMMAND">unshar</strong>.</p>
          </dd>

          <dt><strong
           class="COMMAND">ar</strong></dt>

          <dd>
            <p>Утилита создания и обслуживания архивов, главным образом
            применяется к двоичным файлам библиотек.</p>
          </dd>

          <dt><a
           name="x7794_html_RPMREF"></a><strong
           class="COMMAND">rpm</strong></dt>

          <dd>
            <p><span
             class="emphasis"><em
             class="EMPHASIS">Red Hat Package Manager</em></span>, или
            <strong
             class="COMMAND">rpm</strong> -- набор утилит,
            предназначенных для построения и обслуживания пакетов
            программного обеспечения как в исходном коде, так и в
            собранном (откомпилированном) виде. Среди всего прочего,
            включает в себя утилиты, производящие установку ПО,
            проверку зависимостей пакетов и проверку их
            целостности.</p>

            <p>Самый простой вариант установки ПО из rpm -- выполнить
            команду <strong
             class="COMMAND">rpm -i package_name.rpm</strong>.</p>

            <div
             class="TIP">
              <table
               class="TIP"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/tip.gif"
                   hspace="5"
                   alt="Tip"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Команда <tt
                     class="USERINPUT"><strong>rpm -qa</strong></tt>
                    выдаст полный список всех установленных <span
                     class="emphasis"><em
                     class="EMPHASIS">rpm</em></span>-пакетов в данной
                    системе. Команда <tt
                     class="USERINPUT"><strong>rpm -qa
                    package_name</strong></tt> выведет только пакет(ы)
                    с именем, содержащим комбинацию символов <tt
                     class="FILENAME">package_name</tt>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>rpm -qa</strong></tt>
<tt
 class="COMPUTEROUTPUT">redhat-logos-1.1.3-1
 glibc-2.2.4-13
 cracklib-2.7-12
 dosfstools-2.7-1
 gdbm-1.8.0-10
 ksymoops-2.4.1-1
 mktemp-1.5-11
 perl-5.6.0-17
 reiserfs-utils-3.x.0j-2
 ...</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>rpm -qa docbook-utils</strong></tt>
<tt
 class="COMPUTEROUTPUT">docbook-utils-0.6.9-2</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>rpm -qa docbook | grep docbook</strong></tt>
<tt
 class="COMPUTEROUTPUT">docbook-dtd31-sgml-1.0-10
 docbook-style-dsssl-1.64-3
 docbook-dtd30-sgml-1.0-10
 docbook-dtd40-sgml-1.0-11
 docbook-utils-pdf-0.6.9-2
 docbook-dtd41-sgml-1.0-10
 docbook-utils-0.6.9-2</tt>
             
</pre>
                    <br>
                    <br>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">cpio</strong></dt>

          <dd>
            <p>Специализированная утилита архивации и копирования
            (<strong
             class="COMMAND">c</strong>o<strong
             class="COMMAND">p</strong>y <strong
             class="COMMAND">i</strong>nput and <strong
             class="COMMAND">o</strong>utput). Используется все реже и
            реже, поскольку вытесняется более мощным архиватором
            <strong
             class="COMMAND">tar</strong>/<strong
             class="COMMAND">gzip</strong>. Наиболее употребительна для
            таких операций, как перемещение дерева каталогов.</p>

            <div
             class="EXAMPLE">
              <a
               name="x7794_html_EX48"></a>

              <p><strong>Пример 12-22. Пример перемещения дерева
              каталогов с помощью cpio</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Копирование дерева каталогов с помощью cpio.

ARGS=2
E_BADARGS=65

if [ $# -ne &quot;$ARGS&quot; ]
then
  echo &quot;Порядок использования: `basename $0` source destination&quot;
  exit $E_BADARGS
fi

source=$1
destination=$2

find &quot;$source&quot; -depth | cpio -admvp &quot;$destination&quot;
# Информацию по ключам утилиты cpio вы найдете в страницах руководства &quot;man cpio&quot;.

exit 0
</pre>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">rpm2cpio</strong></dt>

          <dd>
            <p>Эта утилита конвертирует <a
             href="#x7794_html_RPMREF">rpm</a>-пакет в архив <strong
             class="COMMAND">cpio</strong>.</p>

            <div
             class="EXAMPLE">
              <a
               name="x7794_html_DERPM"></a>

              <p><strong>Пример 12-23. Распаковка архива <span
               class="emphasis"><em
               class="EMPHASIS">rpm</em></span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# de-rpm.sh: Распаковка архива &#39;rpm&#39;

: ${1?&quot;Порядок использования: `basename $0` target-file&quot;}
# Сценарию должно быть передано имя архива &#39;rpm&#39;.


TEMPFILE=$$.cpio                         # Временный файл с &quot;уникальным&quot; именем.
                                         # $$ -- PID процесса сценария.

rpm2cpio &lt; $1 &gt; $TEMPFILE                # Конверсия из rpm в cpio.
cpio --make-directories -F $TEMPFILE -i  # Рапсковка cpio-архива.
rm -f $TEMPFILE                          # Удаление cpio-архива.

exit 0

#  Упражнение:
#  Добавьте проверку на: 1) Существование &quot;target-file&quot;
#+                       2) Действительно ли &quot;target-file&quot; является rpm-архивом.
#  Подсказка:               используйте комсанду &#39;file&#39;.
</pre>
            </div>
          </dd>
        </dl>
      </div>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="x7794_html_FACOMPRESSION1"></a>Сжатие</strong></p>

        <dl>
          <dt><a
           name="x7794_html_GZIPREF"></a><strong
           class="COMMAND">gzip</strong></dt>

          <dd>
            <p>Стандартная GNU/UNIX утилита сжатия, заменившая более
            слабую, и к тому же проприетарную, утилиту <strong
             class="COMMAND">compress</strong>. Соответствующая утилита
            декомпрессии (разжатия) -- <strong
             class="COMMAND">gunzip</strong>, которая является
            эквивалентом команды <strong
             class="COMMAND">gzip -d</strong>.</p>

            <p>Для работы со сжатыми файлами в конвейере используется
            фильтр <strong
             class="COMMAND">zcat</strong>, который выводит результат
            своей работы на <tt
             class="FILENAME">stdout</tt>, допускает перенаправление
            вывода. Фактически это та же команда <strong
             class="COMMAND">cat</strong>, только приспособленная для
            работы со сжатыми файлами (включая файлы, сжатые утилитой
            <strong
             class="COMMAND">compress</strong>). Эквивалент команды
            <strong
             class="COMMAND">zcat</strong> -- <strong
             class="COMMAND">gzip -dc</strong>.</p>

            <div
             class="CAUTION">
              <table
               class="CAUTION"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/caution.gif"
                   hspace="5"
                   alt="Caution"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>В некоторых коммерческих версиях UNIX, команда
                    <strong
                     class="COMMAND">zcat</strong> является синонимом
                    команды <strong
                     class="COMMAND">uncompress -c</strong>, и не может
                    работать с файлами, сжатыми с помощью <span
                     class="emphasis"><em
                     class="EMPHASIS">gzip</em></span>.</p>
                  </td>
                </tr>
              </table>
            </div>

            <p>См. также <a
             href="#x2565_html_EX14">Пример 7-7</a>.</p>
          </dd>

          <dt><a
           name="x7794_html_BZIPREF"></a><strong
           class="COMMAND">bzip2</strong></dt>

          <dd>
            <p>Альтернативная утилита сжатия, обычно дает более высокую
            степень сжатия (но при этом работает медленнее), чем
            <strong
             class="COMMAND">gzip</strong>, особенно это проявляется на
            больших файлах. Соответствующая утилита декомпрессии --
            <strong
             class="COMMAND">bunzip2</strong>.</p>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>В современные версии <a
                     href="#x7794_html_TARREF">tar</a> добавлена
                    поддержка <strong
                     class="COMMAND">bzip2</strong>.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">compress</strong>, <strong
           class="COMMAND">uncompress</strong></dt>

          <dd>
            <p>Устаревшие проприетарные утилиты для работы с архивами,
            входящие в состав некоторых коммерческих дистрибутивов
            UNIX. В последнее время вытесняются более мощной утилитой
            <strong
             class="COMMAND">gzip</strong>. Linux-дистрибутивы, как
            правило, включают в свой состав эти утилиты для обратной
            совместимости, однако <strong
             class="COMMAND">gunzip</strong> корректно разархивирует
            файлы, обработанные с помощью <strong
             class="COMMAND">compress</strong>.</p>

            <div
             class="TIP">
              <table
               class="TIP"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/tip.gif"
                   hspace="5"
                   alt="Tip"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Утилита <strong
                     class="COMMAND">znew</strong> предназначена для
                    преобразования <span
                     class="emphasis"><em
                     class="EMPHASIS">compress</em></span>-архивов в
                    <span
                     class="emphasis"><em
                     class="EMPHASIS">gzip</em></span>-архивы.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">sq</strong></dt>

          <dd>
            <p>Еще одна утилита-фильтр сжатия, которая обслуживает
            только отсортированные списки слов. Использует стандартный,
            для фильтров, синтаксис вызова -- <strong
             class="COMMAND">sq &lt; input-file &gt;
            output-file</strong>. Быстрая, но не такая эффективная как
            <a
             href="#x7794_html_GZIPREF">gzip</a>. Соответствующая ей
            утилита декомпрессии называется <strong
             class="COMMAND">unsq</strong>, синтаксис вызова аналогичен
            утилите <strong
             class="COMMAND">sq</strong>.</p>

            <div
             class="TIP">
              <table
               class="TIP"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/tip.gif"
                   hspace="5"
                   alt="Tip"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Вывод от <strong
                     class="COMMAND">sq</strong> может быть передан по
                    конвейеру утилите <strong
                     class="COMMAND">gzip</strong>, для дальнейшего
                    сжатия.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">zip</strong>, <strong
           class="COMMAND">unzip</strong></dt>

          <dd>
            <p>Кроссплатформенная утилита архивирования и сжатия,
            совместимая, по формату архивного файла, с утилитой DOS --
            <span
             class="emphasis"><em
             class="EMPHASIS">pkzip.exe</em></span>. <span
             class="QUOTE">&quot;Zip&quot;</span>-архивы, по-моему,
            более приемлемый вариант для обмена данными через Internet,
            чем <span
             class="QUOTE">&quot;tarballs&quot;</span> (тарболлы, или
            tar-архивы).</p>
          </dd>

          <dt><strong
           class="COMMAND">unarc</strong>, <strong
           class="COMMAND">unarj</strong>, <strong
           class="COMMAND">unrar</strong></dt>

          <dd>
            <p>Этот набор утилит предназначен для распаковки архивов,
            созданных с помощью DOS архиваторов -- <span
             class="emphasis"><em
             class="EMPHASIS">arc.exe</em></span>, <span
             class="emphasis"><em
             class="EMPHASIS">arj.exe</em></span> и <span
             class="emphasis"><em
             class="EMPHASIS">rar.exe</em></span>.</p>
          </dd>
        </dl>
      </div>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="x7794_html_FAINFORMATION1"></a>Получение сведений о
        файлах</strong></p>

        <dl>
          <dt><a
           name="x7794_html_FILEREF"></a><strong
           class="COMMAND">file</strong></dt>

          <dd>
            <p>Утилита идентификации файлов. Команда <tt
             class="USERINPUT"><strong>file file-name</strong></tt>
            верне тип файла <tt
             class="FILENAME">file-name</tt>, например, <tt
             class="COMPUTEROUTPUT">ascii text</tt> или <tt
             class="COMPUTEROUTPUT">data</tt>. Для этого она
            анализирует сигнатуру, или <a
             href="#c178_html_MAGNUMREF">магическое число</a> и
            сопоставляет ее со списком известных сигнатур из <tt
             class="FILENAME">/usr/share/magic</tt>, <tt
             class="FILENAME">/etc/magic</tt> или <tt
             class="FILENAME">/usr/lib/magic</tt> (в зависимости от
            дистрибутива Linux/UNIX).</p>

            <p><tt
             class="OPTION">-f</tt> -- ключ пакетного режима работы
            утилиты <strong
             class="COMMAND">file</strong>, в этом случае утилита
            принимает список анализируемых имен файлов из заданного
            файла. Ключ <tt
             class="OPTION">-z</tt> используется для анализа файлов в
            архиве.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>file test.tar.gz</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">test.tar.gz: gzip compressed data, deflated, last modified: Sun Sep 16 13:34:51 2001, os: Unix</tt>

<tt
 class="PROMPT">bash</tt> <tt
 class="USERINPUT"><strong>file -z test.tar.gz</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">test.tar.gz: GNU tar archive (gzip compressed data, deflated, last modified: Sun Sep 16 13:34:51 2001, os: Unix)</tt>
             
</pre>
            <br>
            <br>

            <div
             class="EXAMPLE">
              <a
               name="x7794_html_STRIPC"></a>

              <p><strong>Пример 12-24. Удаление комментариев из файла с
              текстом программы на языке C</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# strip-comment.sh: Удаление комментариев (/* COMMENT */) из исходных текстов программ на языке C.

E_NOARGS=65
E_ARGERROR=66
E_WRONG_FILE_TYPE=67

if [ $# -eq &quot;$E_NOARGS&quot; ]
then
  echo &quot;Порядок использования: `basename $0` C-program-file&quot; &gt;&amp;2 # Вывод сообщения на stderr.
  exit $E_ARGERROR
fi

# Проверка типа файла.
type=`eval file $1 | awk &#39;{ print $2, $3, $4, $5 }&#39;`
# &quot;file $1&quot; -- выводит тип файла...
# затем awk удаляет первое поле -- имя файла...
# после этого результат записывается в переменную &quot;type&quot;.
correct_type=&quot;ASCII C program text&quot;

if [ &quot;$type&quot; != &quot;$correct_type&quot; ]
then
  echo
  echo &quot;Этот сценарий работает только с исходными текстами программ на языке C.&quot;
  echo
  exit $E_WRONG_FILE_TYPE
fi


# Довольно замысловатый сценарий sed :
#--------
sed &#39;
/^\/\*/d
/.*\/\*/d
&#39; $1
#--------
# Если вы потратите несколько часов на изучение основ sed, то он станет немного понятнее.


#  Следовало бы добавить еще обработку
#+ комментариев, расположенных в одной строке с кодом.
#  Оставляю это вам, в качестве упражнения.

# Кроме того, этот сценарий удалит все строки, которые содержат комбинации символов &quot;*/&quot; или &quot;/*&quot;,
# не всегда желаемый результат.

exit 0


# ----------------------------------------------------------------
# Строки, расположенные ниже не будут исполнены из-за стоящей выше команды &#39;exit 0&#39;.

# Stephane Chazelas предложил другой, альтернативный вариант:

usage() {
  echo &quot;Порядок использования: `basename $0` C-program-file&quot; &gt;&amp;2
  exit 1
}

WEIRD=`echo -n -e &#39;\377&#39;`   # или WEIRD=$&#39;\377&#39;
[[ $# -eq 1 ]] || usage
case `file &quot;$1&quot;` in
  *&quot;C program text&quot;*) sed -e &quot;s%/\*%${WEIRD}%g;s%\*/%${WEIRD}%g&quot; &quot;$1&quot; \
     | tr &#39;\377\n&#39; &#39;\n\377&#39; \
     | sed -ne &#39;p;n&#39; \
     | tr -d &#39;\n&#39; | tr &#39;\377&#39; &#39;\n&#39;;;
  *) usage;;
esac

# Этот вариант, все еще некорректно обрабатывает такие строки как:
# printf(&quot;/*&quot;);
# или
# /*  /* ошибочный вложенный комментарий */
#
# Для обработки специальных случаев (\&quot;, \\&quot; ...) придется написать синтаксический анализатор
# (может быть с помощью lex или yacc?).

exit 0
</pre>
            </div>
          </dd>

          <dt><a
           name="x7794_html_WHICHREF"></a><strong
           class="COMMAND">which</strong></dt>

          <dd>
            <p>Команда <strong
             class="COMMAND">which command-xxx</strong> вернет полный
            путь к <span
             class="QUOTE">&quot;command-xxx&quot;</span>. Очень
            полезна для того, чтобы узнать -- установлена ли та или
            иная утилита в системе.</p>

            <p><tt
             class="USERINPUT"><strong>$bash which rm</strong></tt></p>
<pre
 class="SCREEN">
<tt
 class="COMPUTEROUTPUT">/usr/bin/rm</tt>
</pre>
            <br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">whereis</strong></dt>

          <dd>
            <p>Очень похожа на <strong
             class="COMMAND">which</strong>, упоминавшуюся выше.
            Команда <strong
             class="COMMAND">whereis command-xxx</strong> вернет полный
            путь к <span
             class="QUOTE">&quot;command-xxx&quot;</span>, но кроме
            того, еще и путь к <span
             class="emphasis"><em
             class="EMPHASIS">manpage</em></span> -- файлу, странице
            справочника по заданной утилите.</p>

            <p><tt
             class="USERINPUT"><strong>$bash whereis
            rm</strong></tt></p>
<pre
 class="SCREEN">
<tt
 class="COMPUTEROUTPUT">rm: /bin/rm /usr/share/man/man1/rm.1.bz2</tt>
</pre>
            <br>
            <br>
          </dd>

          <dt><a
           name="x7794_html_WHATISREF"></a><strong
           class="COMMAND">whatis</strong></dt>

          <dd>
            <p>Утилита <strong
             class="COMMAND">whatis filexxx</strong> отыщет <span
             class="QUOTE">&quot;filexxx&quot;</span> в своей базе
            данных. Может рассматриваться как упрощенный вариант
            команды <strong
             class="COMMAND">man</strong>.</p>

            <p><tt
             class="USERINPUT"><strong>$bash whatis
            whatis</strong></tt></p>
<pre
 class="SCREEN">
<tt
 class=
"COMPUTEROUTPUT">whatis               (1)  - search the whatis database for complete words</tt>
</pre>
            <br>
            <br>

            <div
             class="EXAMPLE">
              <a
               name="x7794_html_WHAT"></a>

              <p><strong>Пример 12-25. Исследование каталога <tt
               class="FILENAME">/usr/X11R6/bin</tt></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Что находится в каталоге /usr/X11R6/bin?

DIRECTORY=&quot;/usr/X11R6/bin&quot;
# Попробуйте также &quot;/bin&quot;, &quot;/usr/bin&quot;, &quot;/usr/local/bin&quot;, и т.д.

for file in $DIRECTORY/*
do
  whatis `basename $file`   # Вывод информации о файле.
done

exit 0
# Вывод этого сценария можно перенаправить в файл:
# ./what.sh &gt;&gt;whatis.db
# или включить постраничный просмотр на экране,
# ./what.sh | less
</pre>
            </div>

            <p>См. также <a
             href="#c4875_html_FILEINFO">Пример 10-3</a>.</p>
          </dd>

          <dt><strong
           class="COMMAND">vdir</strong></dt>

          <dd>
            <p>Вывод списка файлов в каталоге. Тот же эффект имеет
            команда <a
             href="#c6407_html_LSREF">ls -l</a>.</p>

            <p>Это одна из утилит GNU <span
             class="emphasis"><em
             class="EMPHASIS">fileutils</em></span>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>vdir</strong></tt>
<tt
 class="COMPUTEROUTPUT">total 10
 -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.xrolo
 -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.xrolo.bak
 -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.xrolo</tt>

<tt
 class="PROMPT">bash</tt> <tt
 class="USERINPUT"><strong>ls -l</strong></tt>
<tt
 class="COMPUTEROUTPUT">total 10
 -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.xrolo
 -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.xrolo.bak
 -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.xrolo</tt>
             
</pre>
            <br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">locate</strong>, <strong
           class="COMMAND">slocate</strong></dt>

          <dd>
            <p>Команда <strong
             class="COMMAND">locate</strong> определяет местонахождение
            файла, используя свою базу данных, создаваемую специально
            для этих целей. Команда <strong
             class="COMMAND">slocate</strong> -- это защищенная версия
            <strong
             class="COMMAND">locate</strong> (которая может оказаться
            простым псевдонимом команды <strong
             class="COMMAND">slocate</strong>).</p>

            <p><tt
             class="USERINPUT"><strong>$bash locate
            hickson</strong></tt></p>
<pre
 class="SCREEN">
<tt
 class="COMPUTEROUTPUT">/usr/lib/xephem/catalogs/hickson.edb</tt>
</pre>
            <br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">readlink</strong></dt>

          <dd>
            <p>Возвращает имя файла, на который указывает символическая
            ссылка.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>readlink /usr/bin/awk</strong></tt>
<tt
 class="COMPUTEROUTPUT">../../bin/gawk</tt>
             
</pre>
            <br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">strings</strong></dt>

          <dd>
            <p>Команда <strong
             class="COMMAND">strings</strong> используется для поиска
            печатаемых строк в двоичных файлах. Она выводит
            последовательности печатаемых символов, обнаруженных в
            заданном файле. Может использоваться для прикидочного
            анализа дамп-файлов (core dump) или для отыскания
            информации о типе файла, например для графических файлов
            неизвестного формата (например, <tt
             class="USERINPUT"><strong>strings image-file |
            more</strong></tt> может вывести такую строчку: <tt
             class="COMPUTEROUTPUT">JFIF</tt>, что говорит о том, что
            мы имеем дело с графическим файлом в формате <span
             class="emphasis"><em
             class="EMPHASIS">jpeg</em></span>). В сценариях, вероятнее
            всего, вам придется использовать эту команду в связке с <a
             href="#x7050_html_GREPREF">grep</a> или <a
             href="#a14586_html_SEDREF">sed</a>. См. <a
             href="#c4875_html_BINGREP">Пример 10-7</a> и <a
             href="#c4875_html_FINDSTRING">Пример 10-9</a>.</p>

            <div
             class="EXAMPLE">
              <a
               name="x7794_html_WSTRINGS"></a>

              <p><strong>Пример 12-26. <span
               class="QUOTE">&quot;Расширенная&quot;</span> команда
              <span
               class="emphasis"><em
               class="EMPHASIS">strings</em></span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# wstrings.sh: &quot;word-strings&quot; (расширенная команда &quot;strings&quot;)
#
#  Этот сценарий фильтрует вывод команды &quot;strings&quot; путем проверки на соответствие
#+ выводимых слов по файлу словаря.
#  Таким способом эффективно &quot;отсекается&quot; весь &quot;мусор&quot;,
#+ и выводятся только распознанные слова.

# =================================================================
#                 Стандартная проверка входных аргументов
ARGS=1
E_BADARGS=65
E_NOFILE=66

if [ $# -ne $ARGS ]
then
  echo &quot;Порядок использования: `basename $0` filename&quot;
  exit $E_BADARGS
fi

if [ ! -f &quot;$1&quot; ]                      # Проверка наличия файла.
then
    echo &quot;Файл \&quot;$1\&quot; не найден.&quot;
    exit $E_NOFILE
fi
# =================================================================


MINSTRLEN=3                           #  Минимальная длина строки.
WORDFILE=/usr/share/dict/linux.words  #  Файл словаря.
                                      #  Можно указать иной
                                      #+ файл словаря
                                      #+ в формате -- &quot;одно слово на строке&quot;.


wlist=`strings &quot;$1&quot; | tr A-Z a-z | tr &#39;[:space:]&#39; Z | \
tr -cs &#39;[:alpha:]&#39; Z | tr -s &#39;\173-\377&#39; Z | tr Z &#39; &#39;`

# Трансляция вывода от &#39;strings&#39; с помощью нескольких &#39;tr&#39;.
#  &quot;tr A-Z a-z&quot;  -- перевод в нижний регистр.
#  &quot;tr &#39;[:space:]&#39;&quot;  -- конвертирует пробелы в символы Z.
#  &quot;tr -cs &#39;[:alpha:]&#39; Z&quot;  -- конвертирует неалфавитные символы в символы Z,
#+ и удаляет повторяющиеся символы Z.
#  &quot;tr -s &#39;\173-\377&#39; Z&quot;  -- Конвертирует все символы, с кодами выше &#39;z&#39; в Z
#+ и удаляет повторяющиеся символы Z,
#+ эта команда удалит все символы, которые не были распознаны предыдущими
#+ командами трансляции (tr).
#  Наконец, &quot;tr Z &#39; &#39;&quot; -- преобразует все символы Z в пробелы,
#+ которые будут рассматриваться в качестве разделителя слов в цикле, приведенном ниже.

#  Обратите внимание на технику многоуровневой обработки с помощью &#39;tr&#39;,
#+ каждый раз эта команда вызывается с различным набором аргументов.


for word in $wlist                    # Важно:
                                      # переменная $wlist не должна заключаться в кавычки.
                                      # &quot;$wlist&quot; -- не сработает.
                                      # Почему?
do

  strlen=${#word}                     # Дина строки.
  if [ &quot;$strlen&quot; -lt &quot;$MINSTRLEN&quot; ]   # Не рассматривать короткие строки.
  then
    continue
  fi

  grep -Fw $word &quot;$WORDFILE&quot;          # Проверка слова по словарю.

done


exit 0
</pre>
            </div>
          </dd>
        </dl>
      </div>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="x7794_html_COMPARISONN1"></a>Сравнение</strong></p>

        <dl>
          <dt><a
           name="x7794_html_DIFFREF"></a><strong
           class="COMMAND">diff</strong>, <strong
           class="COMMAND">patch</strong></dt>

          <dd>
            <p><strong
             class="COMMAND">diff</strong>: очень гибкая утилита
            сравнения файлов. Она выполняет построчное сравнение
            файлов. В отдельных случаях, таких как поиск по словарю,
            может оказаться полезной фильтрация файлов с помощью <a
             href="#x7050_html_SORTREF">sort</a> и <strong
             class="COMMAND">uniq</strong> перед тем как отдать поток
            данных через конвейер утилите <strong
             class="COMMAND">diff</strong>. <tt
             class="USERINPUT"><strong>diff file-1 file-2</strong></tt>
            -- выведет строки, имеющие отличия, указывая -- какому
            файлу, какая строка принадлежит.</p>

            <p>С ключом <tt
             class="OPTION">--side-by-side</tt>, команда <strong
             class="COMMAND">diff</strong> выведет сравниваемые файлы в
            две колонки, с указанием несовпадающих строк. Ключи <tt
             class="OPTION">-c</tt> и <tt
             class="OPTION">-u</tt> так же служат для облегчения
            интерпретации результатов работы <strong
             class="COMMAND">diff</strong>.</p>

            <p>Существует ряд интерфейсных оболочек для утилиты <strong
             class="COMMAND">diff</strong>, среди них можно назвать:
            <strong
             class="COMMAND">spiff</strong>, <strong
             class="COMMAND">wdiff</strong>, <strong
             class="COMMAND">xdiff</strong> и <strong
             class="COMMAND">mgdiff</strong>.</p>

            <div
             class="TIP">
              <table
               class="TIP"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/tip.gif"
                   hspace="5"
                   alt="Tip"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Команда <strong
                     class="COMMAND">diff</strong> возвращает код
                    завершения 0, если сравниваемые файлы идентичны и
                    1, если они отличаются. Это позволяет использовать
                    <strong
                     class="COMMAND">diff</strong> в условных
                    операторах внутри сценариев на языке командной
                    оболочки (см. ниже).</p>
                  </td>
                </tr>
              </table>
            </div>

            <p>В общем случае, <strong
             class="COMMAND">diff</strong> используется для генерации
            файла различий, который используется как аргумент команды
            <strong
             class="COMMAND">patch</strong>. Ключ <tt
             class="OPTION">-e</tt> отвечает за вывод файла различий в
            формате, пригодном для использования с <strong
             class="COMMAND">ed</strong> или <strong
             class="COMMAND">ex</strong>.</p>

            <p><strong
             class="COMMAND">patch</strong>: гибкая утилита для
            &quot;наложения заплат&quot;. С помощью файла различий,
            сгенерированного утилитой <strong
             class="COMMAND">diff</strong>, утилита <strong
             class="COMMAND">patch</strong> может использоваться для
            обновления устаревших версий файлов. Это позволяет
            распространять относительно небольшие <span
             class="QUOTE">&quot;diff&quot;</span>-файлы вместо целых
            пакетов. Распространение <span
             class="QUOTE">&quot;заплат&quot;</span> к ядру стало
            наиболее предпочтительным методом распространения более
            новых версий ядра Linux.</p>
<pre
 class="PROGRAMLISTING">
patch -p1 &lt;patch-file
# Применит все изменения из &#39;patch-file&#39;
# к файлам, описанным там же.
# Так выполняется обновление пакетов до более высоких версий.
</pre>
            <br>
            <br>

            <p>Наложение &quot;заплат&quot; на ядро:</p>
<pre
 class="PROGRAMLISTING">
cd /usr/src
gzip -cd patchXX.gz | patch -p0
# Обновление исходных текстов ядра с помощью &#39;patch&#39;.
# Пример взят из файла &quot;README&quot;,
# автор не известен (Alan Cox?).
</pre>
            <br>
            <br>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Кроме того, утилита <strong
                     class="COMMAND">diff</strong> в состоянии
                    выполнять рекурсивный обход каталогов.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>diff -r ~/notes1 ~/notes2</strong></tt>
<tt
 class="COMPUTEROUTPUT">Only in /home/bozo/notes1: file02
 Only in /home/bozo/notes1: file03
 Only in /home/bozo/notes2: file04</tt>
             
</pre>
                    <br>
                    <br>
                  </td>
                </tr>
              </table>
            </div>

            <div
             class="TIP">
              <table
               class="TIP"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/tip.gif"
                   hspace="5"
                   alt="Tip"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Утилита <strong
                     class="COMMAND">zdiff</strong> сравнивает сжатые,
                    с помощью <span
                     class="emphasis"><em
                     class="EMPHASIS">gzip</em></span>, файлы.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">diff3</strong></dt>

          <dd>
            <p>Расширенная версия <strong
             class="COMMAND">diff</strong>, которая сравнивает сразу 3
            файла. В случае успеха возвращает 0, но, к сожалению, не
            дает никакой информации о результатах сравнения.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>diff3 file-1 file-2 file-3</strong></tt>
<tt
 class="COMPUTEROUTPUT">====
 1:1c
   This is line 1 of &quot;file-1&quot;.
 2:1c
   This is line 1 of &quot;file-2&quot;.
 3:1c
   This is line 1 of &quot;file-3&quot;</tt>
             
</pre>
            <br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">sdiff</strong></dt>

          <dd>
            <p>Сравнение и/или редактирование двух файлов перед
            объединением их в один файл. Это интерактивная утилита, по
            своей природе, и из-за этого она довольно редко
            используется в сценариях.</p>
          </dd>

          <dt><strong
           class="COMMAND">cmp</strong></dt>

          <dd>
            <p>Утилита <strong
             class="COMMAND">cmp</strong> -- это упрощенная версия
            <strong
             class="COMMAND">diff</strong>. В то время, как <strong
             class="COMMAND">diff</strong> выводит подробную информацию
            об имеющихся различиях, утилита <strong
             class="COMMAND">cmp</strong> лишь показывет номер строки и
            позицию в строке, где было встречено различие.</p>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Подобно команде <strong
                     class="COMMAND">diff</strong>, команда <strong
                     class="COMMAND">cmp</strong> возвращает код
                    завершения 0, если файлы идентичны и 1, если они
                    различны. Это позволяет использовать команду
                    <strong
                     class="COMMAND">cmp</strong> в условных
                    операторах.</p>
                  </td>
                </tr>
              </table>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="x7794_html_FILECOMP"></a>

              <p><strong>Пример 12-27. Пример сравнения двух файлов с
              помощью cmp.</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

ARGS=2  # Ожидаются два аргумента командной строки.
E_BADARGS=65
E_UNREADABLE=66

if [ $# -ne &quot;$ARGS&quot; ]
then
  echo &quot;Порядок использования: `basename $0` file1 file2&quot;
  exit $E_BADARGS
fi

if [[ ! -r &quot;$1&quot; || ! -r &quot;$2&quot; ]]
then
  echo &quot;Оба файла должны существовать и должны быть доступны для чтения.&quot;
  exit $E_UNREADABLE
fi

cmp $1 $2 &amp;&gt; /dev/null  # /dev/null -- &quot;похоронит&quot; вывод от команды &quot;cmp&quot;.
#   cmp -s $1 $2  даст тот же результат (&quot;-s&quot; -- флаг &quot;тишины&quot; для &quot;cmp&quot;)
#   Спасибо Anders Gustavsson за замечание.
#
# Также применимо к &#39;diff&#39;, т.е.,   diff $1 $2 &amp;&gt; /dev/null

if [ $? -eq 0 ]         # Проверка кода возврата команды &quot;cmp&quot;.
then
  echo &quot;Файл \&quot;$1\&quot; идентичен файлу \&quot;$2\&quot;.&quot;
else
  echo &quot;Файл \&quot;$1\&quot; отличается от файла \&quot;$2\&quot;.&quot;
fi

exit 0
</pre>
            </div>

            <div
             class="TIP">
              <table
               class="TIP"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/tip.gif"
                   hspace="5"
                   alt="Tip"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Для работы с <span
                     class="emphasis"><em
                     class="EMPHASIS">gzip</em></span> файлами
                    используется утилита <strong
                     class="COMMAND">zcmp</strong>.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">comm</strong></dt>

          <dd>
            <p>Универсальная утилита сравнения. Работает с
            отсортированными файлами.</p>

            <p><strong
             class="COMMAND">comm <tt
             class="REPLACEABLE"><em>-options</em></tt> <tt
             class="REPLACEABLE"><em>first-file</em></tt> <tt
             class="REPLACEABLE"><em>second-file</em></tt></strong></p>

            <p><tt
             class="USERINPUT"><strong>comm file-1 file-2</strong></tt>
            -- вывод в три колонки:</p>

            <ul>
              <li>
                <p>колонка 1 = уникальные строки для <tt
                 class="FILENAME">file-1</tt></p>
              </li>

              <li>
                <p>колонка 2 = уникальные строки для <tt
                 class="FILENAME">file-2</tt></p>
              </li>

              <li>
                <p>колонка 3 = одинаковые строки.</p>
              </li>
            </ul>
            <br>
            <br>

            <p>Ключи, подавляющие вывод в одной или более колонках.</p>

            <ul>
              <li>
                <p><tt
                 class="OPTION">-1</tt> -- подавление вывода в колонку
                <tt
                 class="LITERAL">1</tt></p>
              </li>

              <li>
                <p><tt
                 class="OPTION">-2</tt> -- подавление вывода в колонку
                <tt
                 class="LITERAL">2</tt></p>
              </li>

              <li>
                <p><tt
                 class="OPTION">-3</tt> -- подавление вывода в колонку
                <tt
                 class="LITERAL">3</tt></p>
              </li>

              <li>
                <p><tt
                 class="OPTION">-12</tt> -- подавление вывода в колонки
                <tt
                 class="LITERAL">1</tt> и <tt
                 class="LITERAL">2</tt>, и т.д.</p>
              </li>
            </ul>
            <br>
            <br>
          </dd>
        </dl>
      </div>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="x7794_html_FAUTILS1"></a>Утилиты</strong></p>

        <dl>
          <dt><strong
           class="COMMAND">basename</strong></dt>

          <dd>
            <p>Выводит только название файла, без каталога размещения.
            Конструкция <tt
             class="USERINPUT"><strong>basename $0</strong></tt> --
            позволяет сценарию узнать свое имя, то есть имя файла,
            который был запущен. Это имя может быть использовано для
            вывода сообщений, напрмиер:</p>
<pre
 class="PROGRAMLISTING">
echo &quot;Порядок использования: `basename $0` arg1 arg2 ... argn&quot;
</pre>
            <br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">dirname</strong></dt>

          <dd>
            <p>Отсекает <strong
             class="COMMAND">basename</strong> от полного имени файла и
            выводит только путь к файлу.</p>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Утилитам <strong
                     class="COMMAND">basename</strong> и <strong
                     class="COMMAND">dirname</strong> может быть
                    передана любая строка, в качестве аргумента. Этот
                    аргумент необязательно должен быть именем
                    существующего файла (см. <a
                     href="#a14477_html_DAYSBETWEEN">Пример
                    A-8</a>).</p>
                  </td>
                </tr>
              </table>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="x7794_html_EX35"></a>

              <p><strong>Пример 12-28. Утилиты basename и
              dirname</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

a=/home/bozo/daily-journal.txt

echo &quot;Basename для /home/bozo/daily-journal.txt = `basename $a`&quot;
echo &quot;Dirname для /home/bozo/daily-journal.txt = `dirname $a`&quot;
echo
echo &quot;Мой домашний каталог `basename ~/`.&quot;             # Можно указать просто ~.
echo &quot;Каталог моего домашнего каталога `dirname ~/`.&quot;  # Можно указать просто ~.

exit 0
</pre>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">split</strong></dt>

          <dd>
            <p>Утилита разбивает файл на несколько частей. Обычно
            используется для разбиения больших файлов, чтобы их можно
            было записать на дискеты или передать по электронной почте
            по частям.</p>
          </dd>

          <dt><strong
           class="COMMAND">sum</strong>, <strong
           class="COMMAND">cksum</strong>, <a
           name="x7794_html_MD5SUMREF"></a><strong
           class="COMMAND">md5sum</strong></dt>

          <dd>
            <p>Эти утилиты предназначены для вычисления контрольных
            сумм. Контрольная сумма -- это некоторое число, вычисляемое
            исходя из содержимого файла, и служит для контроля
            целостности информации в файле. Сценарий может выполнять
            проверку контрольных сумм для того, чтобы убедиться, что
            файл не был изменен или поврежден. Для большей
            безопасности, рекомендуется использовать 128-битную сумму,
            генерируемую утилитой <strong
             class="COMMAND">md5sum</strong> (<strong
             class="COMMAND">m</strong>essage <strong
             class="COMMAND">d</strong>igest check<strong
             class="COMMAND">sum</strong>).</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>cksum /boot/vmlinuz</strong></tt>
<tt
 class="COMPUTEROUTPUT">1670054224 804083 /boot/vmlinuz</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>md5sum /boot/vmlinuz</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">0f43eccea8f09e0a0b2b5cf1dcf333ba  /boot/vmlinuz</tt>
             
</pre>
            <br>
            <br>

            <p>Обратите внимание: утилита <strong
             class="COMMAND">cksum</strong> выводит контрольную сумму и
            размер файла в байтах.</p>

            <div
             class="EXAMPLE">
              <a
               name="x7794_html_FILEINTEGRITY"></a>

              <p><strong>Пример 12-29. Проверка целостности
              файла</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# file-integrity.sh: Проверка целостности файлов в заданном каталоге

E_DIR_NOMATCH=70
E_BAD_DBFILE=71

dbfile=File_record.md5
# Файл для хранения контрольных сумм.


set_up_database ()
{
  echo &quot;&quot;$directory&quot;&quot; &gt; &quot;$dbfile&quot;
  # Записать название каталога в первую строку файла.
  md5sum &quot;$directory&quot;/* &gt;&gt; &quot;$dbfile&quot;
  # Записать контрольные суммы md5 и имена файлов.
}

check_database ()
{
  local n=0
  local filename
  local checksum

  # ------------------------------------------- #
  #  Возможно эта проверка и не нужна,
  #+ но лучше перестраховаться сейчас, чем жалеть об этом потом.

  if [ ! -r &quot;$dbfile&quot; ]
  then
    echo &quot;Не могу прочитать файл с контрольными суммами!&quot;
    exit $E_BAD_DBFILE
  fi
  # ------------------------------------------- #

  while read record[n]
  do

    directory_checked=&quot;${record[0]}&quot;
    if [ &quot;$directory_checked&quot; != &quot;$directory&quot; ]
    then
      echo &quot;Имя каталога не совпадает с записаным в файле!&quot;
      # Попытка использовать файл контрольных сумм для другого каталога.
      exit $E_DIR_NOMATCH
    fi

    if [ &quot;$n&quot; -gt 0 ]   # Не имя каталога.
    then
      filename[n]=$( echo ${record[$n]} | awk &#39;{ print $2 }&#39; )
      #  md5sum записывает в обратном порядке,
      #+ сначала контрольную сумму, затем имя файла.
      checksum[n]=$( md5sum &quot;${filename[n]}&quot; )

      if [ &quot;${record[n]}&quot; = &quot;${checksum[n]}&quot; ]
      then
        echo &quot;Файл ${filename[n]} не был изменен.&quot;
      else
        echo &quot;ОШИБКА КОНТРОЛЬНОЙ СУММЫ для файла ${filename[n]}!&quot;
        # Файл был изменен со времени последней проверки.
      fi

    fi


    let &quot;n+=1&quot;
  done &lt;&quot;$dbfile&quot;       # Чтение контрольных сумм из файла.

}

# =================================================== #
# main ()

if [ -z  &quot;$1&quot; ]
then
  directory=&quot;$PWD&quot;      #  Если каталог не задан,
else                    #+ то используется текущий каталог.
  directory=&quot;$1&quot;
fi

clear                   # Очистка экрана.

# ------------------------------------------------------------------ #
  if [ ! -r &quot;$dbfile&quot; ] # Необходимо создать файл с контрольными суммами?
  then
    echo &quot;Создание файла с контрольными суммами, \&quot;&quot;$directory&quot;/&quot;$dbfile&quot;\&quot;.&quot;; echo
    set_up_database
  fi
# ------------------------------------------------------------------ #

check_database          # Выполнить проверку.

echo

#  Вывод этого сценария можно перенаправить в файл,
#+ это особенно полезно при проверке большого количества файлов.

#  Более строгая проверка целостности файлов,
#+ может быть выполнена с помощью пакета &quot;Tripwire&quot;,
#+ http://sourceforge.net/projects/tripwire/.

exit 0
</pre>
            </div>

            <p>Более творческий подход к использованию <strong
             class="COMMAND">md5sum</strong> вы нйдете в <a
             href="#a14477_html_DIRECTORYINFO">Пример A-21</a>.</p>
          </dd>

          <dt><a
           name="x7794_html_SHREDREF"></a><strong
           class="COMMAND">shred</strong></dt>

          <dd>
            <p>Надежное, с точки зрения безопасности, стирание файла,
            посредством предварительной, многократной записи в файл
            случайной информации, перед тем как удалить его. Эта
            команда имеет тот же эффект, что и <a
             href="#x9307_html_BLOTOUT">Пример 12-42</a>, но делает это
            более изящным и безопасным способом.</p>

            <p>Является составной частью пакета GNU <span
             class="emphasis"><em
             class="EMPHASIS">fileutils</em></span>.</p>

            <div
             class="CAUTION">
              <table
               class="CAUTION"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/caution.gif"
                   hspace="5"
                   alt="Caution"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Имеется ряд технологий, с помощью которых
                    все-таки возможно восстановить файлы, удаленные
                    утилитой <strong
                     class="COMMAND">shred</strong>.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>
        </dl>
      </div>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="x7794_html_FAENCENCR1"></a>Кодирование и шифрование</strong></p>

        <dl>
          <dt><strong
           class="COMMAND">uuencode</strong></dt>

          <dd>
            <p>Эта утилита используется для кодирования двоичных файлов
            в символы ASCII, после такого кодирования файлы могут, с
            достаточной степенью безопасности, передаваться по сети,
            вкладываться в электронные письма и т.п..</p>
          </dd>

          <dt><strong
           class="COMMAND">uudecode</strong></dt>

          <dd>
            <p>Утилита декодирования файлов, прошедших обработку
            утилитой uuencode.</p>

            <div
             class="EXAMPLE">
              <a
               name="x7794_html_EX52"></a>

              <p><strong>Пример 12-30. Декодирование
              файлов</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

lines=35        # 35 строк для заголовка (более чем достаточно).

for File in *   # Обход всех файлов в текущем каталоге...
do
  search1=`head -$lines $File | grep begin | wc -w`
  search2=`tail -$lines $File | grep end | wc -w`
  #  Закодированные файлы начинаются со слова &quot;begin&quot;,
  #+ и заканчиваются словом &quot;end&quot;.
  if [ &quot;$search1&quot; -gt 0 ]
  then
    if [ &quot;$search2&quot; -gt 0 ]
    then
      echo &quot;декодируется файл - $File -&quot;
      uudecode $File
    fi
  fi
done

#  Обратите внимание: если передать сценарию самого себя, для декодирования,
#+ то это введет его в заблуждение
#+ поскольку в тексте сценария встречаются слова &quot;begin&quot; и &quot;end&quot;.

exit 0
</pre>
            </div>

            <div
             class="TIP">
              <table
               class="TIP"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/tip.gif"
                   hspace="5"
                   alt="Tip"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>При декодировании и выводе длинных текстовых
                    сообщений из новостных групп Usenet, очень нелишним
                    будет передать текст, по конвейеру, команде <a
                     href="#x7050_html_FOLDREF">fold -s</a>.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">mimencode</strong>, <strong
           class="COMMAND">mmencode</strong></dt>

          <dd>
            <p>Утилиты <strong
             class="COMMAND">mimencode</strong> и <strong
             class="COMMAND">mmencode</strong> предназначены для
            обработки закодированных мультимедийных вложений в
            электронные письма. Хотя <span
             class="emphasis"><em
             class="EMPHASIS">почтовые программы</em></span> (такие как
            <strong
             class="COMMAND">pine</strong> или <strong
             class="COMMAND">kmail</strong>) имеют возможность
            автоматической обработки таких вложений, тем не менее эти
            утилиты позволяют обрабатывать вложения вручную, из
            командной строки или в пакетном режиме, из сценария на
            языке командной оболочки.</p>
          </dd>

          <dt><strong
           class="COMMAND">crypt</strong></dt>

          <dd>
            <p>Одно время, это была стандартная, для UNIX, утилита
            шифрования файлов. <a
             name="AEN8616"
             href="#x7794_html_FTN_AEN8616"><span
             class="footnote">[2]</span></a> Политически
            мотивированные, правительственные постановления ряда стран,
            напрямую запрещают экспорт программного обеспечения для
            шифрования, что, в результате, привело практически к
            полному исчезновению <strong
             class="COMMAND">crypt</strong> из большинства UNIX-систем
            (в том числе и Linux). К счастью, программистами было
            разработано множество вполне приличных альтернатив, и среди
            них <a
             href=
            "ftp://metalab.unc.edu/pub/Linux/utils/file/cruft-0.2.tar.gz"
             target="_top">cruft</a> (см. <a
             href="#a14477_html_ENCRYPTEDPW">Пример A-5</a>).</p>
          </dd>
        </dl>
      </div>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="x7794_html_FAMISC1"></a>Прочее</strong></p>

        <dl>
          <dt><a
           name="x7794_html_MKTEMPREF"></a><strong
           class="COMMAND">mktemp</strong></dt>

          <dd>
            <p>Создает временный файл с <span
             class="QUOTE">&quot;уникальным&quot;</span> именем.</p>
<pre
 class="PROGRAMLISTING">
PREFIX=filename
tempfile=`mktemp $PREFIX.XXXXXX`
#                        ^^^^^^ Необходимо по меньшей мере 6 заполнителей
echo &quot;имя временного файла = $tempfile&quot;
# имя временного файла = filename.QA2ZpY
#                 или нечто подобное...
</pre>
            <br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">make</strong></dt>

          <dd>
            <p>Утилита для компиляции и сборки программ. Но может
            использоваться для выполнения любых других операций,
            основанных на анализе наличия изменений в исходных
            файлах.</p>

            <p><a
             name="x7794_html_MAKEFILEREF"></a></p>

            <p>Команда <strong
             class="COMMAND">make</strong> использует в своей работе
            <tt
             class="FILENAME">Makefile</tt>, который содержит перечень
            зависимостей и операций, которые необходимо выполнить для
            удовлетворения этих зависимостей.</p>
          </dd>

          <dt><strong
           class="COMMAND">install</strong></dt>

          <dd>
            <p>Своего рода -- утилита копирования файлов, похожа на
            <strong
             class="COMMAND">cp</strong>, но дополнительно позволяет
            изменять права доступа и атрибуты копируемых файлов.
            Напрямую эта команда практически не используется, чаще
            всего она встречается в <tt
             class="FILENAME">Makefile</tt> (в разделе <tt
             class="REPLACEABLE"><em>make install :</em></tt>). Она
            может использоваться в сценариях установки ПО.</p>
          </dd>

          <dt><strong
           class="COMMAND">dos2unix</strong></dt>

          <dd>
            <p>Автор утилиты -- Benjamin Lin со-товарищи. Предназначена
            для преобразования текстовых файлов из формата DOS (в
            котором строки завершаются комбинацией символов CR-LF) в
            формат UNIX (в котором строки завершаются одним символом
            LF) и обратно.</p>
          </dd>

          <dt><strong
           class="COMMAND">ptx</strong></dt>

          <dd>
            <p>Команда <strong
             class="COMMAND">ptx [targetfile]</strong> выводит a
            упорядоченный предметный указатель для targetfile, который
            можно обработать, по мере необходимости, какой либо
            утилитой форматирования, в конвейере.</p>
          </dd>

          <dt><strong
           class="COMMAND">more</strong>, <strong
           class="COMMAND">less</strong></dt>

          <dd>
            <p>Команды постраничного просмотра текстовых файлов или
            потоков на <tt
             class="FILENAME">stdout</tt>. Могут использоваться в
            сценариях в качестве фильтров.</p>
          </dd>
        </dl>
      </div>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN7816"
         href="#x7794_html_AEN7816"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Команда <strong
           class="COMMAND">tar czvf archive_name.tar.gz *</strong>
          <span
           class="emphasis"><em
           class="EMPHASIS">включит</em></span> в архив все скрытые
          файлы (имена которых начинаются с точки) из <span
           class="emphasis"><em
           class="EMPHASIS">вложенных подкаталогов</em></span>. Это
          недокументированная <span
           class="QUOTE">&quot;особенность&quot;</span> GNU-версии
          <strong
           class="COMMAND">tar</strong>.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN8616"
         href="#x7794_html_AEN8616"><span
         class="footnote">[2]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Она реализует алгоритм симметричного блочного шифрования,
          в противоположность алгоритмам шифрования с <span
           class="QUOTE">&quot;открытым ключом&quot;</span>, из которых
          широко известен <strong
           class="COMMAND">pgp</strong>.</p>
        </td>
      </tr>
    </table>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x7050_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x8707_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Команды обработки текста</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c6407_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Команды для работы с сетью</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x8707_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x7794_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 12. Внешние команды, программы и
          утилиты</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x9117_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x8707_html_COMMUNICATIONS"></a>12.6. Команды для работы с сетью</h1>

      <p>Команды, описываемые в этом разделе, могут найти применение
      при исследовании и анализе процессов передачи данных по сети, а
      также могут использоваться в <a
       href="#x15542_html_CSPAMMERS">борьбе со спамерами</a>.</p>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="x8707_html_COMMUNINFO1"></a>Информация и статистика</strong></p>

        <dl>
          <dt><strong
           class="COMMAND">host</strong></dt>

          <dd>
            <p>Возвращает информацию об узле Интернета, по заданному
            имени или IP адресу, выполняя поиск с помощью службы
            DNS.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>host surfacemail.com</strong></tt>
<tt
 class="COMPUTEROUTPUT">surfacemail.com. has address 202.92.42.236</tt>
             
</pre>
            <br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">ipcalc</strong></dt>

          <dd>
            <p>Производит поиск IP адреса. С ключом <tt
             class="OPTION">-h</tt>, <strong
             class="COMMAND">ipcalc</strong> выполняет поиск имени
            хоста в DNS, по заданному IP адресу.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ipcalc -h 202.92.42.236</strong></tt>
<tt
 class="COMPUTEROUTPUT">HOSTNAME=surfacemail.com</tt>
             
</pre>
            <br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">nslookup</strong></dt>

          <dd>
            <p>Выполняет <span
             class="QUOTE">&quot;поиск имени узла&quot;</span>
            Интернета по заданному IP адресу. По сути, эквивалентна
            командам <strong
             class="COMMAND">ipcalc -h</strong> и <strong
             class="COMMAND">dig -x</strong>. Команда может исполняться
            как в интерактивном, так и в неинтерактивном режиме, т.е. в
            пределах сценария.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>nslookup -sil 66.97.104.180</strong></tt>
<tt
 class="COMPUTEROUTPUT">nslookup kuhleersparnis.ch
 Server:         135.116.137.2
 Address:        135.116.137.2#53

 Non-authoritative answer:
 Name:   kuhleersparnis.ch</tt>
             
</pre>
            <br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">dig</strong></dt>

          <dd>
            <p>Подобно команде <strong
             class="COMMAND">nslookup</strong>, выполняет <span
             class="QUOTE">&quot;поиск имени узла&quot;</span> в
            Интернете.</p>

            <p>Сравните вывод команды <strong
             class="COMMAND">dig -x</strong> с выводом команд <strong
             class="COMMAND">ipcalc -h</strong> и <strong
             class="COMMAND">nslookup</strong>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>dig -x 81.9.6.2</strong></tt>
<tt
 class="COMPUTEROUTPUT">;; Got answer:
 ;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NXDOMAIN, id: 11649
 ;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 0

 ;; QUESTION SECTION:
 ;2.6.9.81.in-addr.arpa.         IN      PTR

 ;; AUTHORITY SECTION:
 6.9.81.in-addr.arpa.    3600    IN      SOA     ns.eltel.net. noc.eltel.net.
 2002031705 900 600 86400 3600

 ;; Query time: 537 msec
 ;; SERVER: 135.116.137.2#53(135.116.137.2)
 ;; WHEN: Wed Jun 26 08:35:24 2002
 ;; MSG SIZE  rcvd: 91</tt>
             
</pre>
            <br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">traceroute</strong></dt>

          <dd>
            <p>Утилита предназначена для исследования топологии сети
            посредством передачи ICMP пакетов удаленному узлу. Эта
            программа может работать в LAN, WAN и в Интернет. Удаленный
            узел может быть указан как по имени, так и по IP адресу.
            Вывод команды traceroute может быть передан по конвейеру
            утилитам <a
             href="#x7050_html_GREPREF">grep</a> или <a
             href="#a14586_html_SEDREF">sed</a>, для дальнейшего
            анализа.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>traceroute 81.9.6.2</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">traceroute to 81.9.6.2 (81.9.6.2), 30 hops max, 38 byte packets
 1  tc43.xjbnnbrb.com (136.30.178.8)  191.303 ms  179.400 ms  179.767 ms
 2  or0.xjbnnbrb.com (136.30.178.1)  179.536 ms  179.534 ms  169.685 ms
 3  192.168.11.101 (192.168.11.101)  189.471 ms  189.556 ms *
 ...</tt>
             
</pre>
            <br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">ping</strong></dt>

          <dd>
            <p>Выполняет передачу пакета <span
             class="QUOTE">&quot;ICMP ECHO_REQUEST&quot;</span> другой
            системе в сети. Чаще всего служит в качестве инструмента
            диагностики соединений, должна использоваться с большой
            осторожностью.</p>

            <p>В случае успеха, <strong
             class="COMMAND">ping</strong> возвращает <a
             href="#c2105_html_EXITSTATUSREF">код завершения</a> <span
             class="ERRORCODE">0</span>, поэтому команда ping может
            использоваться в условных операторах.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ping localhost</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">PING localhost.localdomain (127.0.0.1) from 127.0.0.1 : 56(84) bytes of data.
 Warning: time of day goes back, taking countermeasures.
 64 bytes from localhost.localdomain (127.0.0.1): icmp_seq=0 ttl=255 time=709 usec
 64 bytes from localhost.localdomain (127.0.0.1): icmp_seq=1 ttl=255 time=286 usec

 --- localhost.localdomain ping statistics ---
 2 packets transmitted, 2 packets received, 0% packet loss
 round-trip min/avg/max/mdev = 0.286/0.497/0.709/0.212 ms</tt>
             
</pre>
            <br>
            <br>
          </dd>

          <dt><a
           name="x8707_html_WHOISREF"></a><strong
           class="COMMAND">whois</strong></dt>

          <dd>
            <p>Выполняет поиск в DNS (Domain Name System). Ключом <tt
             class="OPTION">-h</tt> можно указать какой из <span
             class="emphasis"><em
             class="EMPHASIS">whois</em></span> серверов будет
            запрошен. См. <a
             href="#x1716_html_EX18">Пример 4-6</a>.</p>
          </dd>

          <dt><strong
           class="COMMAND">finger</strong></dt>

          <dd>
            <p>Возвращает информацию о пользователях в сети. По
            желанию, эта команда может выводить содержимое файлов <tt
             class="FILENAME">~/.plan</tt>, <tt
             class="FILENAME">~/.project</tt> и <tt
             class="FILENAME">~/.forward</tt>, указанного
            пользователя.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>finger</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">Login  Name           Tty      Idle  Login Time   Office     Office Phone
 bozo   Bozo Bozeman   tty1        8  Jun 25 16:59
 bozo   Bozo Bozeman   ttyp0          Jun 25 16:59
 bozo   Bozo Bozeman   ttyp1          Jun 25 17:07</tt>



<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>finger bozo</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">Login: bozo                             Name: Bozo Bozeman
 Directory: /home/bozo                   Shell: /bin/bash
 On since Fri Aug 31 20:13 (MST) on tty1    1 hour 38 minutes idle
 On since Fri Aug 31 20:13 (MST) on pts/0   12 seconds idle
 On since Fri Aug 31 20:13 (MST) on pts/1
 On since Fri Aug 31 20:31 (MST) on pts/2   1 hour 16 minutes idle
 No mail.
 No Plan.</tt>
             
</pre>
            <br>
            <br>

            <p>По соображениям безопасности, в большинстве сетей служба
            <strong
             class="COMMAND">finger</strong>, и соответствующий демон,
            отключена. <a
             name="AEN8859"
             href="#x8707_html_FTN_AEN8859"><span
             class="footnote">[1]</span></a></p>
          </dd>

          <dt><strong
           class="COMMAND">vrfy</strong></dt>

          <dd>
            <p>Проверка адреса электронной почты.</p>
          </dd>
        </dl>
      </div>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="x8707_html_COMMREMOTE1"></a>Доступ к удаленным
        системам</strong></p>

        <dl>
          <dt><strong
           class="COMMAND">sx</strong>, <strong
           class="COMMAND">rx</strong></dt>

          <dd>
            <p>Команды <strong
             class="COMMAND">sx</strong> и <strong
             class="COMMAND">rx</strong> служат для приема/передачи
            файлов на/из удаленный узел в сети, по протоколу <span
             class="emphasis"><em
             class="EMPHASIS">xmodem</em></span>. Входят в состав
            пакета <strong
             class="COMMAND">minicom</strong>.</p>
          </dd>

          <dt><strong
           class="COMMAND">sz</strong>, <strong
           class="COMMAND">rz</strong></dt>

          <dd>
            <p>Команды <strong
             class="COMMAND">sz</strong> и <strong
             class="COMMAND">rz</strong> служат для приема/передачи
            файлов на/из удаленный узел в сети, по протоколу <span
             class="emphasis"><em
             class="EMPHASIS">zmodem</em></span>. Протокол <span
             class="emphasis"><em
             class="EMPHASIS">zmodem</em></span> имеет некоторые
            преимущества перед протоколом <span
             class="emphasis"><em
             class="EMPHASIS">xmodem</em></span>, в качестве такого
            преимущества можно назвать более высокую скорость передачи
            и возможность возобновления передачи, в случае ее разрыва.
            Входят в состав пакета <strong
             class="COMMAND">minicom</strong>.</p>
          </dd>

          <dt><a
           name="x8707_html_FTPREF"></a><strong
           class="COMMAND">ftp</strong></dt>

          <dd>
            <p>Под этим именем подразумевается утилита и протокол
            передачи файлов. Сеансы ftp могут устанавливаться из
            сценариев (см. <a
             href="#c11785_html_EX72">Пример 17-7</a>, <a
             href="#a14477_html_ENCRYPTEDPW">Пример A-5</a> и <a
             href="#a14477_html_FTPGET">Пример A-14</a>).</p>
          </dd>

          <dt><strong
           class="COMMAND">uucp</strong></dt>

          <dd>
            <p><span
             class="emphasis"><em
             class="EMPHASIS">UNIX to UNIX copy</em></span>. Это
            коммуникационный пакет для передачи файлов между UNIX
            серверами. Сценарий на языке командной оболочки -- один из
            самых эффективных способов автоматизации такого обмена.</p>

            <p>Похоже, что с появлением Интернет и электронной почты,
            <strong
             class="COMMAND">uucp</strong> постепенно уходит в небытие,
            однако, она с успехом может использоваться в изолированных,
            не имеющих выхода в Интернет, сетях.</p>
          </dd>

          <dt><strong
           class="COMMAND">cu</strong></dt>

          <dd>
            <p><span
             class="emphasis"><em
             class="EMPHASIS">C</em></span>all <span
             class="emphasis"><em
             class="EMPHASIS">U</em></span>p -- выполняет соединение с
            удаленной системой, как простой терминал. Эта команда
            является частью пакета <strong
             class="COMMAND">uucp</strong> и, своего рода, упрощенным
            вариантом команды <a
             href="#x8707_html_TELNETREF">telnet</a>.</p>
          </dd>

          <dt><a
           name="x8707_html_TELNETREF"></a><strong
           class="COMMAND">telnet</strong></dt>

          <dd>
            <p>Утилита и протокол для подключения к удаленной
            системе.</p>

            <div
             class="CAUTION">
              <table
               class="CAUTION"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/caution.gif"
                   hspace="5"
                   alt="Caution"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Протокол telnet небезопасен по своей природе,
                    поэтому следует воздерживаться от его
                    использования.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">wget</strong></dt>

          <dd>
            <p><strong
             class="COMMAND">wget</strong> -- <span
             class="emphasis"><em
             class="EMPHASIS">неинтерактивная</em></span> утилита для
            скачивания файлов с Web или ftp сайтов.</p>
<pre
 class="PROGRAMLISTING">
wget -p http://www.xyz23.com/file01.html
wget -r ftp://ftp.xyz24.net/~bozo/project_files/ -o $SAVEFILE
</pre>
            <br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">lynx</strong></dt>

          <dd>
            <p><strong
             class="COMMAND">lynx</strong> -- Web браузер, внутри
            сценариев (с ключом <tt
             class="OPTION">-dump</tt>) может использоваться для
            скачивания файлов с Web или ftp сайтов, в неинтерактивном
            режиме.</p>
<pre
 class="PROGRAMLISTING">
lynx -dump http://www.xyz23.com/file01.html &gt;$SAVEFILE
</pre>
            <br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">rlogin</strong></dt>

          <dd>
            <p><tt
             class="REPLACEABLE"><em>Remote login</em></tt> --
            инициирует сессию с удаленной системой. Эта команда
            небезопасна, вместо нее лучше использовать <a
             href="#x8707_html_SSHREF">ssh</a>.</p>
          </dd>

          <dt><strong
           class="COMMAND">rsh</strong></dt>

          <dd>
            <p><tt
             class="REPLACEABLE"><em>Remote shell</em></tt> --
            исполняет команду на удаленной системе. Эта команда
            небезопасна, вместо нее лучше использовать <a
             href="#x8707_html_SSHREF">ssh</a>.</p>
          </dd>

          <dt><strong
           class="COMMAND">rcp</strong></dt>

          <dd>
            <p><tt
             class="REPLACEABLE"><em>Remote copy</em></tt> --
            копирование файлов между двумя машинами через сеть. Подобно
            прочим r* утилитам, команда <strong
             class="COMMAND">rcp</strong> небезопасна и потому,
            использовать ее в сценариях нежелательно. В качестве замены
            можно порекомендовать <strong
             class="COMMAND">ssh</strong> или <strong
             class="COMMAND">expect</strong>.</p>
          </dd>

          <dt><a
           name="x8707_html_SSHREF"></a><strong
           class="COMMAND">ssh</strong></dt>

          <dd>
            <p><tt
             class="REPLACEABLE"><em>Secure shell</em></tt> --
            устанавливает сеанс связи и выполняет команды на удаленной
            системе. Выступает в качестве защищенной замены для <strong
             class="COMMAND">telnet</strong>, <strong
             class="COMMAND">rlogin</strong>, <strong
             class="COMMAND">rcp</strong> и <strong
             class="COMMAND">rsh</strong>. Использует идентификацию,
            аутентификацию и шифрование информации, передаваемой через
            сеть. Подробности вы найдете в <span
             class="emphasis"><em
             class="EMPHASIS">man ssh</em></span>.</p>
          </dd>
        </dl>
      </div>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="x8707_html_COMMLOCAL1"></a>Локальная сеть</strong></p>

        <dl>
          <dt><a
           name="x8707_html_WRITEREF"></a><strong
           class="COMMAND">write</strong></dt>

          <dd>
            <p>Эта утилита позволяет передать текст сообщения на другой
            терминал (console или xterm). Разрешить или запретить
            доступ к терминалу можно с помощью команды <a
             href="#c9708_html_MESGREF">mesg</a>.</p>

            <p>Поскольку команда <strong
             class="COMMAND">write</strong> работает в интерактивном
            режиме, то, как правило, она не употребляется в
            сценариях.</p>
          </dd>
        </dl>
      </div>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="x8707_html_COMMMAIL1"></a>Mail</strong></p>

        <dl>
          <dt><strong
           class="COMMAND">mail</strong></dt>

          <dd>
            <p>Чтение или передача электронной почты.</p>

            <p>Этот почтовый клиент командной строки с успехом может
            использоваться в сценариях.</p>

            <div
             class="EXAMPLE">
              <a
               name="x8707_html_SELFMAILER"></a>

              <p><strong>Пример 12-31. Сценарий, отправляющий себя
              самого по электронной почте</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/sh
# self-mailer.sh: Сценарий отправляет себя самого по электронной почте

adr=${1:-`whoami`}     # Если пользователь не указан, то -- себе самому.
#  Вызов &#39;self-mailer.sh wiseguy@superdupergenius.com&#39;
#+ приведет к передаче электронного письма по указанному адресу.
#  Вызов &#39;self-mailer.sh&#39; (без аргументов) -- отправит письмо
#+ пользователю, запустившему сценарий, например, bozo@localhost.localdomain.
#
#  Дополнительно о конструкции ${parameter:-default},
#+ см. раздел &quot;Подстановка параметров&quot;
#+ в главе &quot;К вопросу о переменных&quot;.

# ============================================================================
  cat $0 | mail -s &quot;Сценарий \&quot;`basename $0`\&quot; отправил себя сам.&quot; &quot;$adr&quot;
# ============================================================================

# --------------------------------------------
#  Поздравляю!
#  Этот сценарий запустила какая-то &quot;редиска&quot;,
#+ и заставила отправить этот текст к Вам.
#  Очевидно кто-то не знает
#+ куда девать свое время.
# --------------------------------------------

echo &quot;`date`, сценарий \&quot;`basename $0`\&quot; отправлен &quot;$adr&quot;.&quot;

exit 0
</pre>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">mailto</strong></dt>

          <dd>
            <p>Команда <strong
             class="COMMAND">mailto</strong>, похожа на <strong
             class="COMMAND">mail</strong>, она также отправляет
            сообщения по электронной почте. Однако, кроме этого,
            <strong
             class="COMMAND">mailto</strong> позволяет отправлять MIME
            (multimedia) сообщения.</p>
          </dd>

          <dt><strong
           class="COMMAND">vacation</strong></dt>

          <dd>
            <p>Эта утилита предназначена для автоматической передачи
            ответов на электронные письма, например для того, чтобы
            уведомить отправителя о том, что получатель временно
            отсутствует. Работает совместно с <strong
             class="COMMAND">sendmail</strong> и не может
            использоваться для передачи сообщений через коммутируемые
            линии (по модему).</p>
          </dd>
        </dl>
      </div>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN8859"
         href="#x8707_html_AEN8859"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p><a
           name="x8707_html_DAEMONREF"></a></p>

          <p><span
           class="emphasis"><em
           class="EMPHASIS">Демон</em></span> -- это некий фоновый
          процесс, не привязанный ни к одной из терминальных сессий.
          Демоны предназначены для выполнения определенного круга задач
          либо через заданные промежутки времени, либо по наступлению
          какого либо события.</p>

          <p>Слово <span
           class="QUOTE">&quot;демон&quot;</span> (<span
           class="QUOTE">&quot;daemon&quot;</span>), в греческой
          мифологии, употреблялось для обозначения призраков, духов,
          чего-то мистического, сверхестественного. В мире UNIX -- под
          словом демон подразумевается процесс, который
          &quot;тихо&quot; и &quot;незаметно&quot; выполняет свою
          работу.</p>
        </td>
      </tr>
    </table>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x7794_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x9117_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Команды для работы с файлами и архивами</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c6407_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Команды управления терминалом</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x9117_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x8707_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 12. Внешние команды, программы и
          утилиты</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x9199_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x9117_html_TERMINALCCMDS"></a>12.7. Команды управления
      терминалом</h1>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="x9117_html_TERMCOMMANDLISTING1"></a>Команды, имеющие отношение к
        консоли или терминалу</strong></p>

        <dl>
          <dt><strong
           class="COMMAND">tput</strong></dt>

          <dd>
            <p>инициализация терминала или выполнение запроса к базе
            данных терминалов <tt
             class="FILENAME">terminfo</tt>. С помощью <strong
             class="COMMAND">tput</strong> можно выполнять различные
            операции. <strong
             class="COMMAND">tput clear</strong> -- эквивалентно
            команде <strong
             class="COMMAND">clear</strong>. <strong
             class="COMMAND">tput reset</strong> -- эквивалентно
            команде <strong
             class="COMMAND">reset</strong>. <strong
             class="COMMAND">tput sgr0</strong> -- так же сбрасывет
            настройки терминал, но без очистки экрана.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>tput longname</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">xterm terminal emulator (XFree86 4.0 Window System)</tt>
             
</pre>
            <br>
            <br>

            <p>Команда <strong
             class="COMMAND">tput cup X Y</strong> перемещает курсор в
            координаты (X,Y). Обычно этой команде предшествует <strong
             class="COMMAND">clear</strong>, очищающая экран.</p>

            <p>Обратите внимание: <a
             href="#c9708_html_STTYREF">stty</a> предлагает более
            широкий диапазон возможностей.</p>
          </dd>

          <dt><strong
           class="COMMAND">infocmp</strong></dt>

          <dd>
            <p>Cравнение или печать информации о характеристиках
            терминалов, хранящейся в базе данных <span
             class="emphasis"><em
             class="EMPHASIS">terminfo</em></span>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>infocmp</strong></tt>
<tt
 class="COMPUTEROUTPUT">#       Reconstructed via infocmp from file:
 /usr/share/terminfo/r/rxvt
 rxvt|rxvt terminal emulator (X Window System),
         am, bce, eo, km, mir, msgr, xenl, xon,
         colors#8, cols#80, it#8, lines#24, pairs#64,
         acsc=``aaffggjjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~,
         bel=^G, blink=\E[5m, bold=\E[1m,
         civis=\E[?25l,
         clear=\E[H\E[2J, cnorm=\E[?25h, cr=^M,
         ...</tt>
             
</pre>
            <br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">reset</strong></dt>

          <dd>
            <p>Сбрасывает настройки терминала и очищает экран. Как и в
            случае команды <strong
             class="COMMAND">clear</strong>, курсор и приглашение к
            вводу (prompt) выводятся в верхнем левом углу
            терминала.</p>
          </dd>

          <dt><a
           name="x9117_html_CLEARREF"></a><strong
           class="COMMAND">clear</strong></dt>

          <dd>
            <p>Команда <strong
             class="COMMAND">clear</strong> просто очищает экран
            терминала или окно xterm. Курсор и приглашение к вводу
            (prompt) выводятся в верхнем левом углу терминала. Эта
            команда может запускаться как из командной строки, так и из
            сценария. См. <a
             href="#x5210_html_EX30">Пример 10-25</a>.</p>
          </dd>

          <dt><strong
           class="COMMAND">script</strong></dt>

          <dd>
            <p>Эта утилита позволяет сохранять в файле все символы,
            введенные пользователем c клавиатуры (вывод тоже). Получая,
            фактически, подробнейший синхронный протокол сессии.</p>
          </dd>
        </dl>
      </div>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x8707_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x9199_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Команды для работы с сетью</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c6407_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Команды выполнения математических операций</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x9199_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x9117_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 12. Внешние команды, программы и
          утилиты</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#x9307_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x9199_html_MATHC"></a>12.8. Команды выполнения математических
      операций</h1>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="x9199_html_MATHCOMMANDLISTING1"></a></strong></p>

        <dl>
          <dt><strong
           class="COMMAND">factor</strong></dt>

          <dd>
            <p>Разложение целого числа на простые множители.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>factor 27417</strong></tt>
<tt
 class="COMPUTEROUTPUT">27417: 3 13 19 37</tt>
             
</pre>
            <br>
            <br>
          </dd>

          <dt><a
           name="x9199_html_BCREF"></a><strong
           class="COMMAND">bc</strong></dt>

          <dd>
            <p>Bash не в состоянии выполнять действия над числами с
            плавающей запятой и не содержит многих важных
            математических функций. К счастью существует <strong
             class="COMMAND">bc</strong>.</p>

            <p>Универсальная, выполняющая вычисления с произвольной
            точностью, утилита <strong
             class="COMMAND">bc</strong> обладает некоторыми
            возможностями, характерными для языков
            программирования.</p>

            <p>Синтаксис <strong
             class="COMMAND">bc</strong> немного напоминает язык C.</p>

            <p>Поскольку это утилита UNIX, то она может достаточно
            широко использоваться в сценариях на языке командной
            оболочки, в том числе и в <a
             href="#c301_html_PIPEREF">конвейерной</a> обработке
            данных.</p>

            <p>Ниже приводится простой шаблон работы с утилитой <strong
             class="COMMAND">bc</strong> в сценарии. Здесь используется
            прием <a
             href="#c11441_html_COMMANDSUBREF">подстановки
            команд</a>.</p>
<pre
 class="SCREEN">
             <tt
 class=
"USERINPUT"><strong>variable=$(echo &quot;OPTIONS; OPERATIONS&quot; | bc)</strong></tt>
             
</pre>
            <br>
            <br>

            <div
             class="EXAMPLE">
              <a
               name="x9199_html_MONTHLYPMT"></a>

              <p><strong>Пример 12-32. Ежемесячные выплаты по
              займу</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# monthlypmt.sh: Расчет ежемесячных выплат по займу.


#  Это измененный вариант пакета &quot;mcalc&quot; (mortgage calculator),
#+ написанного Jeff Schmidt и Mendel Cooper (ваш покорный слуга).
#   http://www.ibiblio.org/pub/Linux/apps/financial/mcalc-1.6.tar.gz  [15k]

echo
echo &quot;Введите сумму займа, процентную ставку и срок займа,&quot;
echo &quot;для расчета суммы ежемесячных выплат.&quot;

bottom=1.0

echo
echo -n &quot;Сумма займа (без запятых -- с точностью до доллара) &quot;
read principal
echo -n &quot;Процентная ставка (процент) &quot;  # Если 12%, то нужно вводить &quot;12&quot;, а не &quot;.12&quot;.
read interest_r
echo -n &quot;Срок займа (месяцев) &quot;
read term


 interest_r=$(echo &quot;scale=9; $interest_r/100.0&quot; | bc) # Здесь &quot;scale&quot; -- точность вычислений.


 interest_rate=$(echo &quot;scale=9; $interest_r/12 + 1.0&quot; | bc)


 top=$(echo &quot;scale=9; $principal*$interest_rate^$term&quot; | bc)

 echo; echo &quot;Прошу подождать. Вычисления потребуют некоторого времени.&quot;

 let &quot;months = $term - 1&quot;
# ====================================================================
 for ((x=$months; x &gt; 0; x--))
 do
   bot=$(echo &quot;scale=9; $interest_rate^$x&quot; | bc)
   bottom=$(echo &quot;scale=9; $bottom+$bot&quot; | bc)
#  bottom = $(($bottom + $bot&quot;))
 done
# --------------------------------------------------------------------
#  Rick Boivie предложил более эффективную реализацию
#+ цикла вычислений, который дает выигрыш по времени на 2/3.

# for ((x=1; x &lt;= $months; x++))
# do
#   bottom=$(echo &quot;scale=9; $bottom * $interest_rate + 1&quot; | bc)
# done


#  А затем нашел еще более эффективную альтернативу,
#+ которая выполняется в 20 раз быстрее !!!

# bottom=`{
#     echo &quot;scale=9; bottom=$bottom; interest_rate=$interest_rate&quot;
#     for ((x=1; x &lt;= $months; x++))
#     do
#          echo &#39;bottom = bottom * interest_rate + 1&#39;
#     done
#     echo &#39;bottom&#39;
#     } | bc`       # Внедрить цикл &#39;for&#39; в конструкцию подстановки команд.

# ====================================================================

 # let &quot;payment = $top/$bottom&quot;
 payment=$(echo &quot;scale=2; $top/$bottom&quot; | bc)
 # Два знака после запятой, чтобы показать доллары и центы.

 echo
 echo &quot;ежемесячные выплаты = \$$payment&quot;  # Вывести знак &quot;доллара&quot; перед числом.
 echo


 exit 0

 # Упражнения:
 #   1) Добавьте возможность ввода суммы с точностью до цента.
 #   2) Добавьте возможность ввода процентной ставки как в виде процентов, так и в виде десятичного числа -- доли целого.
 #   3) Если вы действительно честолюбивы,
 #      добавьте в сценарий вывод полной таблицы помесячных выплат.
</pre>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="x9199_html_BASE"></a>

              <p><strong>Пример 12-33. Перевод чисел из одной системы
              счисления в другую</strong></p>
<pre
 class="PROGRAMLISTING">
:
##########################################################################
# Shellscript:  base.sh - вывод чисел в разных системах счисления (Bourne Shell)
# Author     :  Heiner Steven (heiner.steven@odn.de)
# Date       :  07-03-95
# Category   :  Desktop
# $Id: base.sh,v 1.2 2000/02/06 19:55:35 heiner Exp $
##########################################################################
# Description
#
# Changes
# 21-03-95 stv  исправлена ошибка, возникающая при вводе числа 0xb (0.2)
##########################################################################

# ==&gt; Используется в данном документе с разрешения автора.
# ==&gt; Комментарии добавлены автором документа.

NOARGS=65
PN=`basename &quot;$0&quot;`                             # Имя программы
VER=`echo &#39;$Revision: 1.2 $&#39; | cut -d&#39; &#39; -f2`  # ==&gt; VER=1.2

Usage () {
    echo &quot;$PN - вывод чисел в различных системах счисления, $VER (stv &#39;95)
Порядок использования: $PN [number ...]

Если число не задано, то производится ввод со stdin.
Число может быть:
    двоичное            должно начинаться с комбинации символов 0b (например 0b1100)
    восьмеричное        должно начинаться с 0  (например 014)
    шестнадцатиричное   должно начинаться с комбинации символов 0x (например 0xc)
    десятичное          в любом другом случае (например 12)&quot; &gt;&amp;2
    exit $NOARGS
}   # ==&gt; Функция вывода сообщения о порядке использования.

Msg () {
    for i   # ==&gt; [список] параметров опущен.
    do echo &quot;$PN: $i&quot; &gt;&amp;2
    done
}

Fatal () { Msg &quot;$@&quot;; exit 66; }

PrintBases () {
    # Определение системы счисления
    for i      # ==&gt; [список] параметров опущен...
    do         # ==&gt; поэтому работает с аргументами командной строки.
        case &quot;$i&quot; in
            0b*)                ibase=2;;       # двоичная
            0x*|[a-f]*|[A-F]*)  ibase=16;;      # шестнадцатиричная
            0*)                 ibase=8;;       # восьмеричная
            [1-9]*)             ibase=10;;      # десятичная
            *)
                Msg &quot;Ошибка в числе $i - число проигнорировано&quot;
                continue;;
        esac

        # Удалить префикс и преобразовать шестнадцатиричные цифры в верхний регистр (этого требует bc)
        number=`echo &quot;$i&quot; | sed -e &#39;s:^0[bBxX]::&#39; | tr &#39;[a-f]&#39; &#39;[A-F]&#39;`
        # ==&gt; вместо &quot;/&quot;, здесь используется символ &quot;:&quot; как разделитель для sed.

        # Преобразование в десятичную систему счисления
        dec=`echo &quot;ibase=$ibase; $number&quot; | bc`  # ==&gt; &#39;bc&#39; используется как калькулятор.
        case &quot;$dec&quot; in
            [0-9]*)     ;;       # все в порядке
            *)          continue;; # ошибка: игнорировать
        esac

        # Напечатать все преобразования в одну строку.
        # ==&gt; &#39;вложенный документ&#39; -- список команд для &#39;bc&#39;.
        echo `bc &lt;&lt;!
            obase=16; &quot;hex=&quot;; $dec
            obase=10; &quot;dec=&quot;; $dec
            obase=8;  &quot;oct=&quot;; $dec
            obase=2;  &quot;bin=&quot;; $dec
!
    ` | sed -e &#39;s: :    :g&#39;

    done
}

while [ $# -gt 0 ]
do
    case &quot;$1&quot; in
        --)     shift; break;;
        -h)     Usage;;          # ==&gt; Вывод справочного сообщения.
        -*)     Usage;;
        *)      break;;          # первое число
    esac   # ==&gt; Хорошо бы расширить анализ вводимых символов.
    shift
done

if [ $# -gt 0 ]
then
    PrintBases &quot;$@&quot;
else                                    # чтение со stdin
    while read line
    do
        PrintBases $line
    done
fi
</pre>
            </div>

            <p>Один из вариантов вызова <strong
             class="COMMAND">bc</strong> -- использование <a
             href="#c11785_html_HEREDOCREF">вложенного документа</a>,
            внедряемого в блок с <a
             href="#c11441_html_COMMANDSUBREF">подстановкой команд</a>.
            Это особенно актуально, когда сценарий должен передать
            <strong
             class="COMMAND">bc</strong> значительный по объему список
            команд и аргументов.</p>
<pre
 class="PROGRAMLISTING">
variable=`bc &lt;&lt; LIMIT_STRING
options
statements
operations
LIMIT_STRING
`
</pre>
            ...или... 
<pre
 class="PROGRAMLISTING">
variable=$(bc &lt;&lt; LIMIT_STRING
options
statements
operations
LIMIT_STRING
)
</pre>
            <br>
            <br>

            <div
             class="EXAMPLE">
              <a
               name="x9199_html_ALTBC"></a>

              <p><strong>Пример 12-34. Пример взаимодействия bc со
              <span
               class="QUOTE">&quot;встроенным
              документом&quot;</span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Комбинирование &#39;bc&#39; с
# &#39;вложенным документом&#39;.


var1=`bc &lt;&lt; EOF
18.33 * 19.78
EOF
`
echo $var1       # 362.56


#  запись $( ... ) тоже работает.
v1=23.53
v2=17.881
v3=83.501
v4=171.63

var2=$(bc &lt;&lt; EOF
scale = 4
a = ( $v1 + $v2 )
b = ( $v3 * $v4 )
a * b + 15.35
EOF
)
echo $var2       # 593487.8452


var3=$(bc -l &lt;&lt; EOF
scale = 9
s ( 1.7 )
EOF
)
# Возвращается значение синуса от 1.7 радиана.
# Ключом &quot;-l&quot; вызывается математическая библиотека &#39;bc&#39;.
echo $var3       # .991664810


# Попробуем функции...
hyp=             # Объявление глобальной переменной.
hypotenuse ()    # Расчет гипотенузы прямоугольного треугольника.
{
hyp=$(bc -l &lt;&lt; EOF
scale = 9
sqrt ( $1 * $1 + $2 * $2 )
EOF
)
# К сожалению, функции Bash не могут возвращать числа с плавающей запятой.
}

hypotenuse 3.68 7.31
echo &quot;гипотенуза = $hyp&quot;    # 8.184039344


exit 0
</pre>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="x9199_html_CANNON"></a>

              <p><strong>Пример 12-35. Вычисление числа
              &quot;пи&quot;</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# cannon.sh: Аппроксимация числа &quot;пи&quot;.

# Это очень простой вариант реализации метода &quot;Monte Carlo&quot;,
#+ математическое моделирование событий реальной жизни,
#+ для эмуляции случайного события используются псевдослучайные числа.

#  Допустим, что мы располагаем картой квадратного участка поверхности со стороной квадрата 10000 единиц.
#  На этом участке, в центре, находится совершенно круглое озеро,
#+ с диаметром в 10000 единиц.
#  Т.е. озеро покрывает почти всю карту, кроме ее углов.
#  (Фактически -- это квадрат со вписанным кругом.)
#
#  Пусть по этому участку ведется стрельба железными ядрами из древней пушки
#  Все ядра падают где-то в пределах данного участка,
#+ т.е. либо в озеро, либо на сушу, по углам участка.
#  Поскольку озеро покрывает большую часть участка,
#+ то большинство ядер будет падать в воду.
#  Незначительная часть ядер будет падать на твердую почву.
#
#  Если произвести достаточно большое число неприцельных выстрелов по данному участку,
#+ то отношение попаданий в воду к общему числу выстрелов будет примерно равно
#+ значению PI/4.
#
#  По той простой причине, что стрельба фактически ведется только
#+ по правому верхнему квадранту карты.
#  (Предыдущее описание было несколько упрощено.)
#
#  Теоретически, чем больше будет произведено выстрелов, тем точнее будет результат.
#  Однако, сценарий на языке командной оболочки, в отличие от других языков программирования,
#+ в которых доступны операции с плавающей запятой, имеет некоторые ограничения.
#  К сожалению, это делает вычисления менее точными.


DIMENSION=10000  # Длина стороны квадратного участка поверхности.
                 # Он же -- верхний предел для генератора случайных чисел.

MAXSHOTS=1000    # Количество выстрелов.
                 # 10000 выстрелов (или больше) даст лучший результат,
                                                                 # но потребует значительного количества времени.
PMULTIPLIER=4.0  # Масштабирующий коэффициент.

get_random ()
{
SEED=$(head -1 /dev/urandom | od -N 1 | awk &#39;{ print $2 }&#39;)
RANDOM=$SEED                                  #  Из примера &quot;seeding-random.sh&quot;

let &quot;rnum = $RANDOM % $DIMENSION&quot;             #  Число не более чем 10000.
echo $rnum
}

distance=        # Объявление глобальной переменной.
hypotenuse ()    # Расчет гипотенузы прямоугольного треугольника.
{                # Из примера &quot;alt-bc.sh&quot;.
distance=$(bc -l &lt;&lt; EOF
scale = 0
sqrt ( $1 * $1 + $2 * $2 )
EOF
)
#  Установка &quot;scale&quot; в ноль приводит к округлению результата &quot;вниз&quot;,
#+ это и есть то самое ограничение, накладываемое командной оболочкой.
#  Что, к сожалению, снижает точность аппроксимации.
}


# main() {

# Инициализация переменных.
shots=0
splashes=0
thuds=0
Pi=0

while [ &quot;$shots&quot; -lt  &quot;$MAXSHOTS&quot; ]           # Главный цикл.
do

  xCoord=$(get_random)                        # Получить случайные координаты X и Y.
  yCoord=$(get_random)
  hypotenuse $xCoord $yCoord                  #  Гипотенуза = расстоянию.
  ((shots++))

  printf &quot;#%4d   &quot; $shots
  printf &quot;Xc = %4d  &quot; $xCoord
  printf &quot;Yc = %4d  &quot; $yCoord
  printf &quot;Distance = %5d  &quot; $distance         #  Растояние от
                                              #+ центра озера,
                                              #+ с координатами (0,0).

  if [ &quot;$distance&quot; -le &quot;$DIMENSION&quot; ]
  then
    echo -n &quot;ШЛЕП!  &quot;                         # попадание в озеро
    ((splashes++))
  else
    echo -n &quot;БУХ!    &quot;                        # попадание на твердую почву
    ((thuds++))
  fi

  Pi=$(echo &quot;scale=9; $PMULTIPLIER*$splashes/$shots&quot; | bc)
  # Умножение на коэффициент 4.0.
  echo -n &quot;PI ~ $Pi&quot;
  echo

done

echo
echo &quot;После $shots выстрела, примерное значение числа \&quot;пи\&quot; равно $Pi.&quot;
# Имеет тенденцию к завышению...
# Вероятно из-за ошибок округления и несовершенства генератора случайных чисел.
echo

# }

exit 0

#  Самое время задуматься над тем, является ли сценарий удобным средством
#+ для выполнения большого количества столь сложных вычислений.
#
#  Тем не менее, этот пример может расцениваться как
#  1) Доказательство возможностей языка командной оболочки.
#  2) Прототип для &quot;обкатки&quot; алгоритма перед тем как перенести
#+    его на высокоуровневые языки программирования компилирующего типа.
</pre>
            </div>
          </dd>

          <dt><a
           name="x9199_html_DCREF"></a><strong
           class="COMMAND">dc</strong></dt>

          <dd>
            <p>Утилита <strong
             class="COMMAND">dc</strong> (<strong
             class="COMMAND">d</strong>esk <strong
             class="COMMAND">c</strong>alculator) -- это калькулятор,
            использующий &quot;Обратную Польскую Нотацию&quot;, и
            ориентированный на работу со стеком.</p>

            <p>Многие стараются избегать испоьзования <strong
             class="COMMAND">dc</strong>, из-за непривычной формы
            записи операндов и операций. Однако, <strong
             class="COMMAND">dc</strong> имеет и своих сторонников.</p>

            <div
             class="EXAMPLE">
              <a
               name="x9199_html_HEXCONVERT"></a>

              <p><strong>Пример 12-36. Преобразование чисел из
              десятичной в шестнадцатиричную систему
              счисления</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# hexconvert.sh: Преобразование чисел из десятичной в шестнадцатиричную систему счисления.

BASE=16     # Шестнадцатиричная.

if [ -z &quot;$1&quot; ]
then
  echo &quot;Порядок использования: $0 number&quot;
  exit $E_NOARGS
  # Необходим аргумент командной строки.
fi
# Упражнение: добавьте проверку корректности аргумента.


hexcvt ()
{
if [ -z &quot;$1&quot; ]
then
  echo 0
  return    # &quot;Return&quot; 0, если функции не был передан аргумент.
fi

echo &quot;&quot;$1&quot; &quot;$BASE&quot; o p&quot; | dc
#                 &quot;o&quot; устанавливает основание системы счисления для вывода.
#                   &quot;p&quot; выводит число, находящееся на вершине стека.
# См. &#39;man dc&#39;.
return
}

hexcvt &quot;$1&quot;

exit 0
</pre>
            </div>

            <p>Изучение страниц <span
             class="emphasis"><em
             class="EMPHASIS">info</em></span> <strong
             class="COMMAND">dc</strong> позволит детальнее разобраться
            с утилитой. Однако, отряд &quot;гуру&quot;, которые могут
            похвастать своим знанием этой мощной, но весьма запутанной
            утилиты, весьма немногочислен.</p>

            <div
             class="EXAMPLE">
              <a
               name="x9199_html_FACTR"></a>

              <p><strong>Пример 12-37. Разложение числа на простые
              множители</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# factr.sh: Разложение числа на простые множители

MIN=2       # Не работает с числами меньше 2.
E_NOARGS=65
E_TOOSMALL=66

if [ -z $1 ]
then
  echo &quot;Порядок использования: $0 number&quot;
  exit $E_NOARGS
fi

if [ &quot;$1&quot; -lt &quot;$MIN&quot; ]
then
  echo &quot;Исходное число должно быть больше или равно $MIN.&quot;
  exit $E_TOOSMALL
fi

# Упражнение: Добавьте проверку типа числа (не целые числа должны отвергаться).

echo &quot;Простые множители для числа $1:&quot;
# ---------------------------------------------------------------------------------
echo &quot;$1[p]s2[lip/dli%0=1dvsr]s12sid2%0=13sidvsr[dli%0=1lrli2+dsi!&gt;.]ds.xd1&lt;2&quot; | dc
# ---------------------------------------------------------------------------------
# Автор вышеприведенной строки: Michel Charpentier &lt;charpov@cs.unh.edu&gt;.
# Используется с его разрешения (спасибо).

 exit 0
</pre>
            </div>
          </dd>

          <dt><a
           name="x9199_html_AWKMATH"></a><strong
           class="COMMAND">awk</strong></dt>

          <dd>
            <p>Еще один способ выполнения математических операций, над
            числами с плавающей запятой, состоит в создании <a
             href="#x13541_html_SHWRAPPER">сценария-обертки</a>,
            использующего математические функции <a
             href="#x14802_html_AWKREF">awk</a>.</p>

            <div
             class="EXAMPLE">
              <a
               name="x9199_html_HYPOT"></a>

              <p><strong>Пример 12-38. Расчет гипотенузы прямоугольного
              треугольника</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# hypotenuse.sh: Возвращает &quot;гипотенузу&quot; прямоугольного треугольника.
#               ( корень квадратный от суммы квадратов катетов)

ARGS=2                # В сценарий необходимо передать два катета.
E_BADARGS=65          # Ошибка в аргументах.

if [ $# -ne &quot;$ARGS&quot; ] # Проверка количества аргументов.
then
  echo &quot;Порядок использования: `basename $0` катет_1 катет_2&quot;
  exit $E_BADARGS
fi


AWKSCRIPT=&#39; { printf( &quot;%3.7f\n&quot;, sqrt($1*$1 + $2*$2) ) } &#39;
#            команды и параметры, передаваемые в awk


echo -n &quot;Гипотенуза прямоугольного треугольника, с катетами $1 и $2, = &quot;
echo $1 $2 | awk &quot;$AWKSCRIPT&quot;

exit 0
</pre>
            </div>
          </dd>
        </dl>
      </div>
    </div>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x9117_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#x9307_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Команды управления терминалом</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c6407_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Прочие команды</td>
        </tr>
      </table>
    </div>
  
<hr>

<a name="x9307_html"></a>

      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="#x9199_html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 12. Внешние команды, программы и
          утилиты</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="#c9708_html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="x9307_html_EXTMISC"></a>12.9. Прочие команды</h1>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="x9307_html_MISCCOMMANDLISTING1"></a>Команды, которые нельзя отнести
        ни к одной из вышеперечисленных категорий</strong></p>

        <dl>
          <dt><strong
           class="COMMAND">jot</strong>, <strong
           class="COMMAND">seq</strong></dt>

          <dd>
            <p>Эти утилиты выводят последовательность целых чисел с
            шагом, заданным пользователем.</p>

            <p>По-умолчанию, выводимые числа отделяются друг от друга
            символом перевода строки, однако, с помощью ключа <tt
             class="OPTION">-s</tt> может быть задан другой
            разделитель.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>seq 5</strong></tt>
<tt
 class="COMPUTEROUTPUT">1
2
3
4
5</tt>



<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>seq -s : 5</strong></tt>
<tt
 class="COMPUTEROUTPUT">1:2:3:4:5</tt>
             
</pre>
            <br>
            <br>

            <p>Обе утилиты, и <strong
             class="COMMAND">jot</strong>, и <strong
             class="COMMAND">seq</strong>, очень удобно использовать
            для генерации списка аргументов в цикле <a
             href="#c4875_html_FORLOOPREF1">for</a>.</p>

            <div
             class="EXAMPLE">
              <a
               name="x9307_html_EX53"></a>

              <p><strong>Пример 12-39. Использование seq для генерации
              списка аргументов цикла for</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Утилита &quot;seq&quot;

echo

for a in `seq 80`  # или так:   for a in $( seq 80 )
# То же самое, что и   for a in 1 2 3 4 5 ... 80   (но как экономит время и силы!).
# Можно использовать и &#39;jot&#39; (если эта утилита имеется в системе).
do
  echo -n &quot;$a &quot;
done      # 1 2 3 4 5 ... 80
# Пример использования вывода команды для генерации
# [списка] аргументов цикла &quot;for&quot;.

echo; echo


COUNT=80  # Да, &#39;seq&#39; допускает указание переменных в качестве параметра.

for a in `seq $COUNT`  # или так:   for a in $( seq $COUNT )
do
  echo -n &quot;$a &quot;
done      # 1 2 3 4 5 ... 80

echo; echo

BEGIN=75
END=80

for a in `seq $BEGIN $END`
#  Если &quot;seq&quot; передаются два аргумента, то первый означает начальное число последовательности,
#+ второй -- последнее,
do
  echo -n &quot;$a &quot;
done      # 75 76 77 78 79 80

echo; echo

BEGIN=45
INTERVAL=5
END=80

for a in `seq $BEGIN $INTERVAL $END`
#  Если &quot;seq&quot; передется три аргумента, то первый аргумент -- начальное число в последовательности,
#+ второй -- шаг последовательности,
#+ и третий -- последнее число в последовательности.
do
  echo -n &quot;$a &quot;
done      # 45 50 55 60 65 70 75 80

echo; echo

exit 0
</pre>
            </div>
          </dd>

          <dt><a
           name="x9307_html_GETOPTY"></a><strong
           class="COMMAND">getopt</strong></dt>

          <dd>
            <p>Команда <strong
             class="COMMAND">getopt</strong> служит для разбора
            командной строки, выделяя из нее ключи -- символы, с
            предшествующим знаком <a
             href="#c301_html_DASHREF">дефис</a>. Этой утилите имеется,
            встроенный в Bash, аналог -- <a
             href="#c5358_html_GETOPTSX">getopts</a>, более мощная и
            универсальная команда.</p>

            <div
             class="EXAMPLE">
              <a
               name="x9307_html_EX33A"></a>

              <p><strong>Пример 12-40. Использование getopt для разбора
              аргументов командной строки</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# ex33a.sh

# Попробуйте следующие варианты вызова этого сценария.
#   sh ex33a -a
#   sh ex33a -abc
#   sh ex33a -a -b -c
#   sh ex33a -d
#   sh ex33a -dXYZ
#   sh ex33a -d XYZ
#   sh ex33a -abcd
#   sh ex33a -abcdZ
#   sh ex33a -z
#   sh ex33a a
# Объясните полученные результаты.

E_OPTERR=65

if [ &quot;$#&quot; -eq 0 ]
then   # Необходим по меньшей мере один аргумент.
  echo &quot;Порядок использования: $0 -[options a,b,c]&quot;
  exit $E_OPTERR
fi

set -- `getopt &quot;abcd:&quot; &quot;$@&quot;`
# Запись аргументов командной строки в позиционные параметры.
# Что произойдет, если вместо &quot;$@&quot; указать &quot;$*&quot;?

while [ ! -z &quot;$1&quot; ]
do
  case &quot;$1&quot; in
    -a) echo &quot;Опция \&quot;a\&quot;&quot;;;
    -b) echo &quot;Опция \&quot;b\&quot;&quot;;;
    -c) echo &quot;Опция \&quot;c\&quot;&quot;;;
    -d) echo &quot;Опция \&quot;d\&quot; $2&quot;;;
     *) break;;
  esac

  shift
done

#  Вместо &#39;getopt&#39; лучше использовать встроенную команду &#39;getopts&#39;,
#  См. &quot;ex33.sh&quot;.

exit 0
</pre>
            </div>
          </dd>

          <dt><a
           name="x9307_html_RUNPARTSREF"></a><strong
           class="COMMAND">run-parts</strong></dt>

          <dd>
            <p>Команда <strong
             class="COMMAND">run-parts</strong> <a
             name="AEN9380"
             href="#x9307_html_FTN_AEN9380"><span
             class="footnote">[1]</span></a> запускает на исполнение
            все сценарии, в порядке возрастания имен файлов-сценариев,
            в заданном каталоге. Естественно, файлы сценариев должны
            иметь права на исполнение.</p>

            <p><a
             href="#x8707_html_DAEMONREF">Демон</a> <a
             href="#c9708_html_CRONREF">crond</a> вызывает <strong
             class="COMMAND">run-parts</strong> для запуска сценариев
            из каталогов <tt
             class="FILENAME">/etc/cron.*</tt>.</p>
          </dd>

          <dt><strong
           class="COMMAND">yes</strong></dt>

          <dd>
            <p>По-умолчанию, команда <strong
             class="COMMAND">yes</strong> выводит на <tt
             class="FILENAME">stdout</tt> непрерывную
            последовательность символов <tt
             class="COMPUTEROUTPUT">y</tt>, разделенных символами
            перевода строки. Исполнение команды можно прервать
            комбинацией клавиш <strong
             class="KEYCAP">control</strong>-<strong
             class="KEYCAP">c</strong>. Команду <strong
             class="COMMAND">yes</strong> можно заставить выводить иную
            последовательность символов. Теперь самое время задаться
            вопросом о практической пользе этой команды. Основное
            применение этой команды состоит в том, что вывод от нее
            может быть передан, через конвейер, другой команде,
            ожидающей реакции пользователя. В результате получается,
            своего рода, слабенькая версия команды <strong
             class="COMMAND">expect</strong>.</p>

            <p><tt
             class="USERINPUT"><strong>yes | fsck
            /dev/hda1</strong></tt> запускает <strong
             class="COMMAND">fsck</strong> в неинтерактивном режиме
            (будьте осторожны!).</p>

            <p><tt
             class="USERINPUT"><strong>yes | rm -r
            dirname</strong></tt> имеет тот же эффект, что и <tt
             class="USERINPUT"><strong>rm -rf dirname</strong></tt>
            (будьте осторожны!).</p>

            <div
             class="WARNING">
              <table
               class="WARNING"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/warning.gif"
                   hspace="5"
                   alt="Warning"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Внимание! Передача вывода команды <strong
                     class="COMMAND">yes</strong> по конвейеру
                    потенциально опасным командам, таким как <a
                     href="#c9708_html_FSCKREF">fsck</a> или <a
                     href="#c9708_html_FDISKREF">fdisk</a> может дать
                    нежелательные побочные эффекты.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">banner</strong></dt>

          <dd>
            <p>Печатает на <tt
             class="FILENAME">stdout</tt> заданную строку символов (не
            более 10), рисуя каждый символ строки при помощи символа
            &#39;#&#39;. Вывод от команды может быть перенаправлен на
            принтер.</p>
          </dd>

          <dt><strong
           class="COMMAND">printenv</strong></dt>

          <dd>
            <p>Выводит все <a
             href="#x1716_html_ENVREF">переменные окружения</a> текущего
            пользователя.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>printenv | grep HOME</strong></tt>
<tt
 class="COMPUTEROUTPUT">HOME=/home/bozo</tt>
             
</pre>
            <br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">lp</strong></dt>

          <dd>
            <p>Команды <strong
             class="COMMAND">lp</strong> и <strong
             class="COMMAND">lpr</strong> отправляют файлы в очередь
            печати <a
             name="AEN9455"
             href="#x9307_html_FTN_AEN9455"><span
             class="footnote">[2]</span></a> для вывода на принтер.
            Названия этих команд произошли от &quot;line
            printers&quot;.</p>

            <p><tt
             class="PROMPT">bash$</tt> <tt
             class="USERINPUT"><strong>lp file1.txt</strong></tt> или
            <tt
             class="PROMPT">bash</tt> <tt
             class="USERINPUT"><strong>lp
            &lt;file1.txt</strong></tt></p>

            <p>Очень часто используются в комбинации с командой
            форматированного вывода <strong
             class="COMMAND">pr</strong>.</p>

            <p><tt
             class="PROMPT">bash$</tt> <tt
             class="USERINPUT"><strong>pr -options file1.txt |
            lp</strong></tt></p>

            <p>Программы подготовки текста к печати, такие как <strong
             class="COMMAND">groff</strong> и <span
             class="emphasis"><em
             class="EMPHASIS">Ghostscript</em></span>, так же могут
            напрямую взаимодействовать с <strong
             class="COMMAND">lp</strong>.</p>

            <p><tt
             class="PROMPT">bash$</tt> <tt
             class="USERINPUT"><strong>groff -Tascii file.tr |
            lp</strong></tt></p>

            <p><tt
             class="PROMPT">bash$</tt> <tt
             class="USERINPUT"><strong>gs -options | lp
            file.ps</strong></tt></p>

            <p>Команда <strong
             class="COMMAND">lpq</strong> предназначена для просмотра
            очереди заданий печати, а <strong
             class="COMMAND">lprm</strong> -- для удаления заданий из
            очереди.</p>
          </dd>

          <dt><strong
           class="COMMAND">tee</strong></dt>

          <dd>
            <p>[UNIX заимствовал эту идею из водопроводного дела.]</p>

            <p>Это опрератор перенаправления, но с некоторыми
            особенностями. Подобно водопроводным трубам, <span
             class="QUOTE">&quot;tee&quot;</span> позволяет <span
             class="QUOTE">&quot;направить поток&quot;</span> данных
            <span
             class="emphasis"><em
             class="EMPHASIS">в несколько файлов</em></span> и на
            stdout одновременно, никак не влияя на сами данные. Эта
            команда может оказаться очень полезной при отладке.</p>
<pre
 class="SCREEN">
                   tee
                 |------&gt; в файл
                 |
  ===============|===============
  command---&gt;----|-operator--&gt;---&gt; результат работы команд(ы)
  ===============================
             
</pre>
<pre
 class="PROGRAMLISTING">
cat listfile* | sort | tee check.file | uniq &gt; result.file
</pre>
            (Здесь, в файл <tt
             class="FILENAME">check.file</tt> будут записаны данные из
            всех <span
             class="QUOTE">&quot;listfile*&quot;</span>, в
            отсортированном виде до того, как повторяющиеся строки
            будут удалены командой <a
             href="#x7050_html_UNIQREF">uniq</a>.)<br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">mkfifo</strong></dt>

          <dd>
            <p><a
             name="x9307_html_NAMEDPIPEREF"></a>Эта, редко встречающаяся, команда
            создает <span
             class="emphasis"><em
             class="EMPHASIS">именованный канал</em></span> - очередь,
            через который производится обмен данными между процессами.
            <a
             name="AEN9514"
             href="#x9307_html_FTN_AEN9514"><span
             class="footnote">[3]</span></a> Как правило, один процесс
            записывает данные в очередь (FIFO), а другой читает данные
            из очереди. См. <a
             href="#a14477_html_FIFO">Пример A-17</a>.</p>
          </dd>

          <dt><strong
           class="COMMAND">pathchk</strong></dt>

          <dd>
            <p>Производит проверку полного имени файла -- проверяет,
            доступны ли на чтение, каталоги в пути к файлу, и не
            превышает ли длина полного имени файла 255 символов. При
            несоблюдении одного из условий -- возвращает сообщение об
            ошибке.</p>

            <p>К сожалению, <strong
             class="COMMAND">pathchk</strong> не возвращает
            соответствующего кода ошибки, и потому, в общем-то,
            бесполезна в сценариях. Вместо нее лучше использовать <a
             href="#x2389_html_RTIF">операторы проверки файлов</a>.</p>
          </dd>

          <dt><a
           name="x9307_html_DDREF"></a><strong
           class="COMMAND">dd</strong></dt>

          <dd>
            <p>Эта немного непонятная и &quot;страшная&quot; команда
            (<span
             class="QUOTE">&quot;data duplicator&quot;</span>)
            изначально использовалась для переноса данных на магнитной
            ленте между микрокомпьютерами с ОС UNIX и майнфреймами IBM.
            Команда <strong
             class="COMMAND">dd</strong> просто создает копию файла
            (или <tt
             class="FILENAME">stdin/stdout</tt>), выполняя по пути
            некоторые преобразования. Один из вариантов: преобразование
            из ASCII в EBCDIC, <a
             name="AEN9546"
             href="#x9307_html_FTN_AEN9546"><span
             class="footnote">[4]</span></a> <tt
             class="USERINPUT"><strong>dd --help</strong></tt> выведет
            список возможных вариантов преобразований и опций этой
            мощной утилиты.</p>
<pre
 class="PROGRAMLISTING">
# Изучаем &#39;dd&#39;.

n=3
p=5
input_file=project.txt
output_file=log.txt

dd if=$input_file of=$output_file bs=1 skip=$((n-1)) count=$((p-n+1)) 2&gt; /dev/null
# Извлечет из $input_file символы с n-го по p-й.




echo -n &quot;hello world&quot; | dd cbs=1 conv=unblock 2&gt; /dev/null
# Выведет &quot;hello world&quot; вертикально.


# Спасибо, S.C.
</pre>
            <br>
            <br>

            <p>Для демонстрации возможностей <strong
             class="COMMAND">dd</strong>, попробуем перехватить нажатия
            на клавиши.</p>

            <div
             class="EXAMPLE">
              <a
               name="x9307_html_DDKEYPRESS"></a>

              <p><strong>Пример 12-41. Захват нажатых
              клавиш</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Захват нажатых клавиш.


keypresses=4                      # Количество фиксируемых нажатий.


old_tty_setting=$(stty -g)        # Сохранить настройки терминала.

echo &quot;Нажмите $keypresses клавиши.&quot;
stty -icanon -echo                # Запретить канонический режим.
                                  # Запретить эхо-вывод.
keys=$(dd bs=1 count=$keypresses 2&gt; /dev/null)
# &#39;dd&#39; использует stdin, если &quot;if&quot; не задан.

stty &quot;$old_tty_setting&quot;           # Восстановить настройки терминала.

echo &quot;Вы нажали клавиши \&quot;$keys\&quot;.&quot;

# Спасибо S.C.
exit 0
</pre>
            </div>

            <p>Команда <strong
             class="COMMAND">dd</strong> имеет возможность
            произвольного доступа к данным в потоке.</p>
<pre
 class="PROGRAMLISTING">
echo -n . | dd bs=1 seek=4 of=file conv=notrunc
# Здесь, опция &quot;conv=notrunc&quot; означает, что выходной файлне будет усечен.

# Спасибо, S.C.
</pre>
            <br>
            <br>

            <p>Команда <strong
             class="COMMAND">dd</strong> может использоваться для
            создания образов дисков, считывая данные прямо с устройств,
            таких как дискеты, компакт диски, магнитные ленты (<a
             href="#a14477_html_COPYCD">Пример A-6</a>). Обычно она
            используется для создания загрузочных дискет.</p>

            <p><tt
             class="USERINPUT"><strong>dd if=kernel-image
            of=/dev/fd0H1440</strong></tt></p>

            <p>Точно так же, <strong
             class="COMMAND">dd</strong> может скопировать все
            содержимое дискеты, даже с неизвестной файловой системой,
            на жесткий диск в виде файла-образа.</p>

            <p><tt
             class="USERINPUT"><strong>dd if=/dev/fd0
            of=/home/bozo/projects/floppy.img</strong></tt></p>

            <p>Еще одно применение <strong
             class="COMMAND">dd</strong> -- создание временного
            swap-файла (<a
             href="#c13041_html_EX73">Пример 28-2</a>) и ram-дисков (<a
             href="#c13041_html_RAMDISK">Пример 28-3</a>). Она может
            создавать даже образы целых разделов жесткого диска, хотя и
            не рекомендуется делать это без особой на то
            необходимости.</p>

            <p>Многие (которые, вероятно, не знают чем себя занять)
            постоянно придумывают все новые и новые области применения
            команды <strong
             class="COMMAND">dd</strong>.</p>

            <div
             class="EXAMPLE">
              <a
               name="x9307_html_BLOTOUT"></a>

              <p><strong>Пример 12-42. Надежное удаление
              файла</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# blotout.sh: Надежно удаляет файл.

#  Этот суенарий записывает случайные данные в заданный файл,
#+ затем записывает туда нули и наконец удаляет файл.
#  После такого удаления даже анализ дисковых секторов
#+ не даст ровным счетом ничего.

PASSES=7         # Количество проходов по файлу.
BLOCKSIZE=1      #  операции ввода/вывода в/из /dev/urandom требуют указания размера блока,
                 #+ иначе вы не получите желаемого результата.
E_BADARGS=70
E_NOT_FOUND=71
E_CHANGED_MIND=72

if [ -z &quot;$1&quot; ]   # Имя файла не указано.
then
  echo &quot;Порядок использования: `basename $0` filename&quot;
  exit $E_BADARGS
fi

file=$1

if [ ! -e &quot;$file&quot; ]
then
  echo &quot;Файл \&quot;$file\&quot; не найден.&quot;
  exit $E_NOT_FOUND
fi

echo; echo -n &quot;Вы совершенно уверены в том, что желаете уничтожить \&quot;$file\&quot; (y/n)? &quot;
read answer
case &quot;$answer&quot; in
[nN]) echo &quot;Передумали? Операция отменена.&quot;
      exit $E_CHANGED_MIND
      ;;
*)    echo &quot;Уничтожается файл \&quot;$file\&quot;.&quot;;;
esac


flength=$(ls -l &quot;$file&quot; | awk &#39;{print $5}&#39;)  # Поле с номером 5 -- это длина файла.

pass_count=1

echo

while [ &quot;$pass_count&quot; -le &quot;$PASSES&quot; ]
do
  echo &quot;Проход #$pass_count&quot;
  sync         # Вытолкнуть буферы.
  dd if=/dev/urandom of=$file bs=$BLOCKSIZE count=$flength
               # Заполнить файл случайными данными.
  sync         # Снова вытолкнуть буферы.
  dd if=/dev/zero of=$file bs=$BLOCKSIZE count=$flength
               # Заполнить файл нулями.
  sync         # Снова вытолкнуть буферы.
  let &quot;pass_count += 1&quot;
  echo
done


rm -f $file    # Наконец удалить изрядно &quot;подпорченный&quot; файл.
sync           # Вытолкнуть буферы в последний раз.

echo &quot;Файл \&quot;$file\&quot; уничтожен.&quot;; echo


#  Это довольно надежный, хотя и достаточно медленный способ уничтожения файлов.
#+ Более эффективно это делает команда &quot;shred&quot;,
#+ входящая в состав пакета GNU &quot;fileutils&quot;.

#  Уничтоженный таким образом файл, не сможет быть восстановлен обычными методами.
#  Однако...
#+ эта метода вероятно НЕ сможет противостоять аналитическим службам
#+ из СООТВЕТСТВУЮЩИХ ОРГАНОВ


#  Tom Vier разработал пакет &quot;wipe&quot;, который более надежно стирает файлы
#+ чем этот простой сценарий.
#     http://www.ibiblio.org/pub/Linux/utils/file/wipe-2.0.0.tar.bz2

#  Для более глубоко изучения проблемы надежного удаления файлов,
#+ рекомендую обратиться к cnfnmt Peter Gutmann,
#+     &quot;Secure Deletion of Data From Magnetic and Solid-State Memory&quot;.
#         http://www.cs.auckland.ac.nz/~pgut001/pubs/secure_del.html


exit 0
</pre>
            </div>
          </dd>

          <dt><a
           name="x9307_html_ODREF"></a><strong
           class="COMMAND">od</strong></dt>

          <dd>
            <p>Команда <strong
             class="COMMAND">od</strong> (<span
             class="emphasis"><em
             class="EMPHASIS">octal dump</em></span>) производит
            преобразование ввода (или файла) в один или несколько
            форматов, в соответствии с указанными опциями. При
            отсутствии опций используется восьмеричный формат (опция
            -o). Эта команда полезна при просмотре или обработке файлов
            с двоичными данными, например <tt
             class="FILENAME">/dev/urandom</tt>. См. <a
             href="#x4812_html_SEEDINGRANDOM">Пример 9-26</a> и <a
             href="#x7050_html_RND">Пример 12-10</a>.</p>
          </dd>

          <dt><strong
           class="COMMAND">hexdump</strong></dt>

          <dd>
            <p>Выводит дамп двоичных данных из файла в восьмеричном,
            шестнадцатиричном, десятичном виде или в виде ASCII. Эту
            команду, с массой оговорок, можно назвать эквивалентом
            команды of <strong
             class="COMMAND">od</strong>.</p>
          </dd>

          <dt><strong
           class="COMMAND">objdump</strong></dt>

          <dd>
            <p>Отображает содержимое исполняемого или объектного файла
            либо в шестнадцатиричной форме, либо в виде
            дизассемблерного листинга (с ключом <tt
             class="OPTION">-d</tt>).</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>objdump -d /bin/ls</strong></tt>
<tt
 class="COMPUTEROUTPUT">/bin/ls:     file format elf32-i386

 Disassembly of section .init:

 080490bc &lt;.init&gt;:
  80490bc:       55                      push   %ebp
  80490bd:       89 e5                   mov    %esp,%ebp
  . . .</tt>
             
</pre>
            <br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">mcookie</strong></dt>

          <dd>
            <p>Эта команда создает псевдослучайные шестнадцатиричные
            128-битные числа, так называемые <span
             class="QUOTE">&quot;magic cookie&quot;</span>, обычно
            используется X-сервером в качестве <span
             class="QUOTE">&quot;сигнатуры&quot;</span> авторизации. В
            сценариях может использоваться как малоэффективный
            генератор случайных чисел.</p>
<pre
 class="PROGRAMLISTING">
random000=`mcookie | sed -e &#39;2p&#39;`
# &#39;sed&#39; удаляет посторонние символы.
</pre>
            <br>
            <br>

            <p>Конечно, для тех же целей, сценарий может использовать
            <a
             href="#x7794_html_MD5SUMREF">md5</a>.</p>
<pre
 class="PROGRAMLISTING">
# Сценарий вычисляет контрольную сумму для самого себя.
random001=`md5sum $0 | awk &#39;{print $1}&#39;`
# &#39;awk&#39; удаляет имя файла.
</pre>
            <br>
            <br>

            <p>С помощью <strong
             class="COMMAND">mcookie</strong> можно создавать <span
             class="QUOTE">&quot;уникальные&quot;</span> имена
            файлов.</p>

            <div
             class="EXAMPLE">
              <a
               name="x9307_html_TEMPFILENAME"></a>

              <p><strong>Пример 12-43. Генератор имен
              файлов</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# tempfile-name.sh:  Генератор имен временных файлов

BASE_STR=`mcookie`   # 32-символьный (128 бит) magic cookie.
POS=11               # Произвольная позиция в строке magic cookie.
LEN=5                # $LEN последовательных символов.

prefix=temp          #  В конце концов это временный (&quot;temp&quot;) файл.

suffix=${BASE_STR:POS:LEN}
                     # Извлечь строку, длиной в 5 символов, начиная с позиции 11.

temp_filename=$prefix.$suffix
                     # Сборка имени файла.

echo &quot;Имя временного файла = \&quot;$temp_filename\&quot;&quot;

# sh tempfile-name.sh
# Имя временного файла = temp.e19ea

exit 0
</pre>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">units</strong></dt>

          <dd>
            <p>Эта утилита производит преобразование величин из одних
            единиц измерения в другие. Как правило вызывается в
            интерактивном режиме, ниже приводится пример использования
            <strong
             class="COMMAND">units</strong> в сценарии.</p>

            <div
             class="EXAMPLE">
              <a
               name="x9307_html_UNITCONVERSION"></a>

              <p><strong>Пример 12-44. Преобразование метров в
              мили</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# unit-conversion.sh


convert_units ()  # Принимает в качестве входных параметров единицы измерения.
{
  cf=$(units &quot;$1&quot; &quot;$2&quot; | sed --silent -e &#39;1p&#39; | awk &#39;{print $2}&#39;)
  # Удаляет все кроме коэффициентов преобразования.
  echo &quot;$cf&quot;
}

Unit1=miles
Unit2=meters
cfactor=`convert_units $Unit1 $Unit2`
quantity=3.73

result=$(echo $quantity*$cfactor | bc)

echo &quot;В $quantity милях $result метров.&quot;

#  Что произойдет, если в функцию передать несовместимые единицы измерения,
#+ например &quot;acres&quot; (акры) and &quot;miles&quot; (мили)?

exit 0
</pre>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">m4</strong></dt>

          <dd>
            <p>Не команда, а клад, <strong
             class="COMMAND">m4</strong> -- это мощный фильтр обработки
            макроопределений, <a
             name="AEN9671"
             href="#x9307_html_FTN_AEN9671"><span
             class="footnote">[5]</span></a> фактически -- целый язык
            программирования. Изначально создававшаяся как препроцессор
            для <span
             class="emphasis"><em
             class="EMPHASIS">RatFor</em></span>, <strong
             class="COMMAND">m4</strong> оказалась очень полезной и как
            самостоятельная утилита. Фактически, <strong
             class="COMMAND">m4</strong> сочетает в себе функциональные
            возможности <a
             href="#c5358_html_EVALREF">eval</a>, <a
             href="#x7050_html_TRREF">tr</a>, <a
             href="#x14802_html_AWKREF">awk</a>, и дополнительно
            предоставляет обширные возможности по созданию новых
            макроопределений.</p>

            <p>В апрельском выпуске, за 2002 год, журнала <a
             href="http://www.linuxjournal.com"
             target="_top">Linux Journal</a> вы найдете замечательную
            статью, описывающую возможности утилиты <strong
             class="COMMAND">m4</strong>.</p>

            <div
             class="EXAMPLE">
              <a
               name="x9307_html_M4"></a>

              <p><strong>Пример 12-45. Пример работы с m4</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# m4.sh: Демонстрация некоторых возможносией макропроцессора m4

# Строки
string=abcdA01
echo &quot;len($string)&quot; | m4                           # 7
echo &quot;substr($string,4)&quot; | m4                      # A01
echo &quot;regexp($string,[0-1][0-1],\&amp;Z)&quot; | m4     # 01Z

# Арифметика
echo &quot;incr(22)&quot; | m4                               # 23
echo &quot;eval(99 / 3)&quot; | m4                           # 33

exit 0
</pre>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">doexec</strong></dt>

          <dd>
            <p>Команда <strong
             class="COMMAND">doexec</strong> предоставляет возможность
            передачи произвольного списка аргументов внешней программе.
            В частности, передавая <tt
             class="VARNAME">argv[0]</tt> (для сценариев соответствует
            специальной переменной <a
             href="#x1716_html_POSPARAMREF1">$0</a>), можно вызвать
            программу под другим именем, определяя тем самым, ее
            реакцию.</p>

            <p>Например, Пусть в каталоге <tt
             class="FILENAME">/usr/local/bin</tt> имеется программа с
            именем <span
             class="QUOTE">&quot;aaa&quot;</span>, которая при вызове
            <strong
             class="COMMAND">doexec /usr/local/bin/aaa list</strong>
            выведет список всех файлов в текущем каталоге, имена
            которых начинаются с символа <span
             class="QUOTE">&quot;a&quot;</span>, а при вызове той же
            самой программы как <strong
             class="COMMAND">doexec /usr/local/bin/aaa delete</strong>
            , она удалит эти файлы.</p>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Естественно, реакция программы на свое
                    собственное имя должна быть реализована в коде
                    программы, для сценария на языке командной оболочки
                    это может выглядеть примерно так:</p>
<pre
 class="PROGRAMLISTING">
case `basename $0` in
&quot;name1&quot; ) реакция на вызов под именем name1;;
&quot;name2&quot; ) реакция на вызов под именем name2;;
&quot;name3&quot; ) реакция на вызов под именем name3;;
*       ) действия по-умолчанию;;
esac
</pre>
                    <br>
                    <br>
                  </td>
                </tr>
              </table>
            </div>
          </dd>
        </dl>
      </div>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN9380"
         href="#x9307_html_AEN9380"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Фактически -- это сценарий, заимствованный из дистрибутива
          Debian Linux.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN9455"
         href="#x9307_html_AEN9455"><span
         class="footnote">[2]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p><span
           class="emphasis"><em
           class="EMPHASIS">Очередь печати</em></span> -- это группа
          заданий <span
           class="QUOTE">&quot;ожидающих вывода&quot;</span> на
          принтер.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN9514"
         href="#x9307_html_AEN9514"><span
         class="footnote">[3]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Эта тема прекрасно освещена в статье, которую написал Andy
          Vaught, <a
           href=
          "http://www2.linuxjournal.com/lj-issues/issue41/2156.html"
           target="_top">Introduction to Named Pipes</a>, в сентябре
          1997 для <a
           href="http://www.linuxjournal.com"
           target="_top">Linux Journal</a>.</p>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN9546"
         href="#x9307_html_AEN9546"><span
         class="footnote">[4]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>EBCDIC (произносится как <span
           class="QUOTE">&quot;ebb-sid-ic&quot;</span>) -- это
          аббревиатура от Extended Binary Coded Decimal Interchange
          Code (Расширенный Двоично-Десятичный Код Обмена Информацией).
          Это формат представления данных от IBM, не нашедший широкого
          применения. Не совсем обычное применение опции <tt
           class="OPTION">conv=ebcdic</tt> -- это использовать <strong
           class="COMMAND">dd</strong> для быстрого и легкого, но
          слабого, шифрования текстовых файлов.</p>
<pre
 class="PROGRAMLISTING">
cat $file | dd conv=swab,ebcdic &gt; $file_encrypted
# Зашифрованный файл будет выглядеть как &quot;абракадабра&quot;.
# опция swab добавлена для внесения большей неразберихи.

cat $file_encrypted | dd conv=swab,ascii &gt; $file_plaintext
# Декодирование.
</pre>
          <br>
          <br>
        </td>
      </tr>

      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN9671"
         href="#x9307_html_AEN9671"><span
         class="footnote">[5]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p><span
           class="emphasis"><em
           class="EMPHASIS">макроопределение</em></span> -- это
          идентификатор, символическая константа, которая представляет
          некоторую последовательность команд, операций и
          параметров.</p>
        </td>
      </tr>
    </table>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="#x9199_html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#index_html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="#c9708_html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Команды выполнения математических операций</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="#c6407_html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Команды системного администрирования</td>
        </tr>
      </table>
    </div>
  
<hr>

<!--#include virtual="/footer.raw"-->

</body></html>