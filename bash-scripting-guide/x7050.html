<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
  <head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
    <meta
     name="generator"
     content=
    "HTML Tidy for Linux/x86 (vers 1st July 2002), see www.w3.org">

    <title>Команды обработки текста</title>
    
    <meta
     name="GENERATOR"
     content="Modular DocBook HTML Stylesheet Version 1.7">
    <link
     rel="HOME"
     title="Advanced Bash-Scripting Guide"
     href="index.html">
    <link
     rel="UP"
     title="Внешние команды, программы и утилиты"
     href="c6407.html">
    <link
     rel="PREVIOUS"
     title="Команды для работы с датой и временем"
     href="x6837.html">
    <link
     rel="NEXT"
     title="Команды для работы с файлами и архивами"
     href="x7794.html">
  </head>

  <body bgcolor="#DDE1C2"><b><a href="http://www.opennet.ru/docs/">Архив документации OpenNet.ru</a> / 
Раздел "<a href="http://www.opennet.ru/docs/124.shtml">Программирование, языки</a>" /
<a href="index.html">Индекс</a>
</b>
<hr noshade size=1>

    <div
     class="NAVHEADER">
      <table
       summary="Header navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <th
           colspan="3"
           align="center">Advanced Bash-Scripting Guide: Искусство
          программирования на языке сценариев командной оболочки</th>
        </tr>

        <tr>
          <td
           width="10%"
           align="left"
           valign="bottom"><a
           href="x6837.html"
           accesskey="P">Назад</a></td>

          <td
           width="80%"
           align="center"
           valign="bottom">Глава 12. Внешние команды, программы и
          утилиты</td>

          <td
           width="10%"
           align="right"
           valign="bottom"><a
           href="x7794.html"
           accesskey="N">Вперед</a></td>
        </tr>
      </table>
      <hr
       align="left"
       width="100%">
    </div>

    <div
     class="SECT1">
      <h1
       class="SECT1"><a
       name="TEXTPROC"></a>12.4. Команды обработки текста</h1>

      <div
       class="VARIABLELIST">
        <p><strong><a
         name="TPCOMMANDLISTING1"></a></strong></p>

        <dl>
          <dt><a
           name="SORTREF"></a><strong
           class="COMMAND">sort</strong></dt>

          <dd>
            <p>Сортирует содержимое файла, часто используется как
            промежуточный фильтр в конвейерах. Эта команда сортирует
            поток текста в порядке убывания или возрастания, в
            зависимости от заданных опций. Ключ <tt
             class="OPTION">-m</tt> используется для сортировки и
            объединения входных файлов. В <span
             class="emphasis"><em
             class="EMPHASIS">странице info</em></span> перечислено
            большое количество возможных вариантов ключей. См. <a
             href="c4875.html#FINDSTRING">Пример 10-9</a>, <a
             href="c4875.html#SYMLINKS">Пример 10-10</a> и <a
             href="a14477.html#MAKEDICT">Пример A-9</a>.</p>
          </dd>

          <dt><strong
           class="COMMAND">tsort</strong></dt>

          <dd>
            <p>Топологическая сортировка, считывает пары строк,
            разделенных пробельными символами, и выполняет сортировку,
            в зависимости от заданного шаблона.</p>
          </dd>

          <dt><a
           name="UNIQREF"></a><strong
           class="COMMAND">uniq</strong></dt>

          <dd>
            <p>Удаляет повторяющиеся строки из отсортированного файла.
            Эту команду часто можно встретить в конвейере с командой <a
             href="x7050.html#SORTREF">sort</a>.</p>
<pre
 class="PROGRAMLISTING">
cat list-1 list-2 list-3 | sort | uniq &gt; final.list
# Содержимое файлов,
# сортируется,
# затем удаляются повторяющиеся строки,
# и результат записывается в выходной файл.
</pre>
            <br>
            <br>

            <p>Ключ <tt
             class="OPTION">-c</tt> выводит количество повторяющихся
            строк.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>cat testfile</strong></tt>
<tt
 class="COMPUTEROUTPUT">Эта строка встречается только один раз.
Эта строка встречается дважды.
Эта строка встречается дважды.
Эта строка встречается трижды.
Эта строка встречается трижды.
Эта строка встречается трижды.</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>uniq -c testfile</strong></tt>
<tt
 class="COMPUTEROUTPUT">1 Эта строка встречается только один раз.
2 Эта строка встречается дважды.
3 Эта строка встречается трижды.</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>sort testfile | uniq -c | sort -nr</strong></tt>
<tt
 class="COMPUTEROUTPUT">3 Эта строка встречается трижды.
2 Эта строка встречается дважды.
1 Эта строка встречается только один раз.</tt>
             
</pre>
            <br>
            <br>

            <p>Команда <tt
             class="USERINPUT"><strong>sort INPUTFILE | uniq -c | sort
            -nr</strong></tt> выводит <span
             class="emphasis"><em
             class="EMPHASIS">статистику встречаемости</em></span>
            строк в файле <tt
             class="FILENAME">INPUTFILE</tt> (ключ <tt
             class="OPTION">-nr</tt>, в команде <strong
             class="COMMAND">sort</strong>, означает сортировку в
            порядке убывания). Этот шаблон может с успехом
            использоваться при анализе файлов системного журнала,
            словарей и везде, где необходимо проанализировать
            лексическую структуру документа.</p>

            <div
             class="EXAMPLE">
              <a
               name="WF"></a>

              <p><strong>Пример 12-8. Частота встречаемости отдельных
              слов</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# wf.sh: &quot;Сырой&quot; анализ частоты встречаемости слова в текстовом файле.


ARGS=1
E_BADARGS=65
E_NOFILE=66

if [ $# -ne &quot;$ARGS&quot; ]  # Файл для анализа задан?
then
  echo &quot;Порядок использования: `basename $0` filename&quot;
  exit $E_BADARGS
fi

if [ ! -f &quot;$1&quot; ]       # Проверка существования файла.
then
  echo &quot;Файл \&quot;$1\&quot; не найден.&quot;
  exit $E_NOFILE
fi



########################################################
# main ()
sed -e &#39;s/\.//g&#39;  -e &#39;s/ /\
/g&#39; &quot;$1&quot; | tr &#39;A-Z&#39; &#39;a-z&#39; | sort | uniq -c | sort -nr
#                           =========================
#                         Подсчет количества вхождений

#  Точки и пробелы заменяются
#+ символами перевода строки,
#+ затем символы переводятся в нижний регистр
#+ и наконец подсчитывается количество вхождений,
#+ и выполняется сортировка по числу вхождений.
########################################################

# Упражнения:
# ---------
# 1) Добавьте команду &#39;sed&#39; для отсечения других знаков пунктуации, например, запятых.
# 2) Добавьте удаление лишних пробелов и других пробельных символов.
# 3) Добавьте дополнительную сортировку так, чтобы слова с одинаковой частотой встречаемости
#+   сортировались бы в алфавитном порядке.

exit 0
</pre>
            </div>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>cat testfile</strong></tt>
<tt
 class="COMPUTEROUTPUT">Эта строка встречается только один раз.
Эта строка встречается дважды.
Эта строка встречается дважды.
Эта строка встречается трижды.
Эта строка встречается трижды.
Эта строка встречается трижды.</tt>


<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>./wf.sh testfile</strong></tt>
 <tt
 class="COMPUTEROUTPUT">      6 Эта
       6 встречается
       6 строка
       3 трижды
       2 дважды
       1 только
       1 один
       1 раз
                        </tt> 
              
</pre>
            <br>
            <br>
          </dd>

          <dt><a
           name="EXPANDREF"></a><strong
           class="COMMAND">expand</strong>, <strong
           class="COMMAND">unexpand</strong></dt>

          <dd>
            <p>Команда <strong
             class="COMMAND">expand</strong> преобразует символы
            табуляции в пробелы. Часто используется в конвейерной
            обработке текста.</p>

            <p>Команда <strong
             class="COMMAND">unexpand</strong> преобразует пробелы в
            символы табуляции. Т.е. она является обратной по отношению
            к команде <strong
             class="COMMAND">expand</strong>.</p>
          </dd>

          <dt><a
           name="CUTREF"></a><strong
           class="COMMAND">cut</strong></dt>

          <dd>
            <p>Предназначена для извлечения отдельных полей из
            текстовых файлов. Напоминает команду <tt
             class="USERINPUT"><strong>print $N</strong></tt> в <a
             href="x14802.html#AWKREF">awk</a>, но более ограничена в
            своих возможностях. В простейших случаях может быть
            неплохой заменой <strong
             class="COMMAND">awk</strong> в сценариях. Особую
            значимость, для команды <strong
             class="COMMAND">cut</strong>, представляют ключи <tt
             class="OPTION">-d</tt> (разделитель полей) и <tt
             class="OPTION">-f</tt> (номер(а) поля(ей)).</p>

            <p>Использование команды <strong
             class="COMMAND">cut</strong> для получения списка
            смонтированных файловых систем:</p>
<pre
 class="PROGRAMLISTING">
cat /etc/mtab | cut -d &#39; &#39; -f1,2
</pre>
            <br>
            <br>

            <p>Использование команды <strong
             class="COMMAND">cut</strong> для получения версии ОС и
            ядра:</p>
<pre
 class="PROGRAMLISTING">
uname -a | cut -d&quot; &quot; -f1,3,11,12
</pre>
            <br>
            <br>

            <p>Использование команды <strong
             class="COMMAND">cut</strong> для извлечения заголовков
            сообщений из электронных писем:</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>grep &#39;^Subject:&#39; read-messages | cut -c10-80</strong></tt>
<tt
 class="COMPUTEROUTPUT">Re: Linux suitable for mission-critical apps?
 MAKE MILLIONS WORKING AT HOME3
 Spam complaint
 Re: Spam complaint</tt>
</pre>
            <br>
            <br>

            <p>Использование команды <strong
             class="COMMAND">cut</strong> при разборе текстового
            файла:</p>
<pre
 class="PROGRAMLISTING">
# Список пользователей в /etc/passwd.

FILENAME=/etc/passwd

for user in $(cut -d: -f1 $FILENAME)
do
  echo $user
done

# Спсибо Oleg Philon за этот пример.
</pre>
            <br>
            <br>

            <p><tt
             class="USERINPUT"><strong>cut -d &#39; &#39; -f2,3
            filename</strong></tt> эквивалентно <tt
             class="USERINPUT"><strong>awk -F&#39;[ ]&#39; &#39;{ print
            $2, $3 }&#39; filename</strong></tt></p>

            <p>См. также <a
             href="x9199.html#BASE">Пример 12-33</a>.</p>
          </dd>

          <dt><strong
           class="COMMAND">paste</strong></dt>

          <dd>
            <p>Используется для объединения нескольких файлов в один
            многоколоночный файл.</p>
          </dd>

          <dt><strong
           class="COMMAND">join</strong></dt>

          <dd>
            <p>Может рассматриваться как команда, родственная команде
            <strong
             class="COMMAND">paste</strong>. Эта мощная утилита
            позволяет объединять два файла по общему полю, что
            представляет собой упрощенную версию реляционной базы
            данных.</p>

            <p>Команда <strong
             class="COMMAND">join</strong> оперирует только двумя
            файлами и объедияет только те строки, которые имеют общее
            поле (обычно числовое), результат объединения выводится на
            <tt
             class="FILENAME">stdout</tt>. Объединяемые файлы должны
            быть отсортированы по ключевому полю.</p>
<pre
 class="PROGRAMLISTING">
File: 1.data

100 Shoes
200 Laces
300 Socks
</pre>
            <br>
            <br>
<pre
 class="PROGRAMLISTING">
File: 2.data

100 $40.00
200 $1.00
300 $2.00
</pre>
            <br>
            <br>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>join 1.data 2.data</strong></tt>
<tt
 class="COMPUTEROUTPUT">File: 1.data 2.data

100 Shoes $40.00
200 Laces $1.00
300 Socks $2.00</tt>
             
</pre>
            <br>
            <br>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>На выходе ключевое поле встречается только один
                    раз.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">head</strong></dt>

          <dd>
            <p>Выводит начальные строки из файла на <tt
             class="FILENAME">stdout</tt> (по-умолчанию -- <tt
             class="LITERAL">10</tt> строк, но это число можно задать
            иным). Эта команда имеет ряд интересных ключей.</p>

            <div
             class="EXAMPLE">
              <a
               name="SCRIPTDETECTOR"></a>

              <p><strong>Пример 12-9. Какие из файлов являются
              сценариями?</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# script-detector.sh: Отыскивает файлы сценариев в каталоге.

TESTCHARS=2    # Проверяются первые два символа.
SHABANG=&#39;#!&#39;   # Сценарии как правило начинаются с &quot;sha-bang.&quot;

for file in *  # Обход всех файлов в каталоге.
do
  if [[ `head -c$TESTCHARS &quot;$file&quot;` = &quot;$SHABANG&quot; ]]
  #      head -c2                      #!
  #  Ключ &#39;-c&#39; в команде &quot;head&quot; выводит заданное
  #+ количество символов, а не строк.
  then
    echo &quot;Файл \&quot;$file\&quot; -- сценарий.&quot;
  else
    echo &quot;Файл \&quot;$file\&quot; не является сценарием.&quot;
  fi
done
  
exit 0
</pre>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="RND"></a>

              <p><strong>Пример 12-10. Генератор 10-значных случайных
              чисел</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# rnd.sh: Генератор 10-значных случайных чисел

# Автор: Stephane Chazelas.

head -c4 /dev/urandom | od -N4 -tu4 | sed -ne &#39;1s/.* //p&#39;


# =================================================================== #

# Описание
# --------

# head:
# -c4 -- первые 4 байта.

# od:
# -N4 ограничивает вывод 4-мя байтами.
# -tu4 беззнаковый десятичный формат вывода.

# sed:
# -n, в комбинации с флагом &quot;p&quot;, в команде &quot;s&quot;,
# выводит только совпадающие с шаблоном строки.



# Автор сценария описывает действия &#39;sed&#39; таким образом:

# head -c4 /dev/urandom | od -N4 -tu4 | sed -ne &#39;1s/.* //p&#39;
# ----------------------------------&gt; |

# Передает вывод в &quot;sed&quot;    --------&gt; |
# пусть это будет 0000000 1198195154\n

# sed начинает читать символы: 0000000 1198195154\n.
# Здесь он находит символ перевода строки,
# таким образом он получает строку (0000000 1198195154).
# Затем он просматривает &lt;диапазон&gt;&lt;действие&gt;. Первый и единственный -- это

#   диапазон  действие
#   1         s/.* //p

# Номер строки попадает в заданный лиапазон, так что теперь он приступает к выполнению действия:
# пытается заменить наибольшую подстроку, заканчивающуюся пробелом
# (&quot;0000000 &quot;) &quot;ничем&quot; (//), и если замена произведена -- выводит результат
# (&quot;p&quot; -- это флаг команды &quot;s&quot;, а не команда &quot;p&quot;, которая имеет иное значение).

# теперь sed готов продолжить чтение входного потока. (Обратите внимание:
# если опустить ключ -n, то sed выведет строку еще раз)

# Теперь sed дочитывает остаток строки.
# Он готов приступить к анализу 2-й строки (которая отмечена &#39;$&#39;
# как последняя).
# Поскольку строка не попадает в заданный &lt;диапазон&gt;, на этом обработка прекращается.

# Проще говоря, команда sed означает:
# &quot;В первой строке удалить любые символы, вплоть до последнего встреченного пробела,
# и затем вывести остаток.&quot;

# Сделать это можно более простым способом:
#           sed -e &#39;s/.* //;q&#39;

# Где, заданы два &lt;диапазона&gt;&lt;действия&gt; (можно записать и по другому
#           sed -e &#39;s/.* //&#39; -e q):

#   диапазон                          действие
#   ничего (для совпадающих строк)    s/.* //
#   ничего (для совпадающих строк)    q (quit)

# Здесь sed считывает только первую строку.
# Выполняет оба действия, и выводит строку перед завершением
# (действие &quot;q&quot;), поскольку ключ &quot;-n&quot; опущен.

# =================================================================== #

# Простая альтернатива:
#           head -c4 /dev/urandom| od -An -tu4

exit 0
</pre>
            </div>
            См. также <a
             href="x7794.html#EX52">Пример 12-30</a>.<br>
            <br>
          </dd>

          <dt><strong
           class="COMMAND">tail</strong></dt>

          <dd>
            <p>Выводит последние строки из файла на <tt
             class="FILENAME">stdout</tt> (по-умолчанию -- 10 строк).
            Обычно используется для мониторинга системных журналов.
            Ключ <tt
             class="OPTION">-f</tt>, позволяет вести непрерывное
            наблюдение за добавляемыми строками в файл.</p>

            <div
             class="EXAMPLE">
              <a
               name="EX12"></a>

              <p><strong>Пример 12-11. Мониторинг системного журнала с
              помощью tail</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

filename=sys.log

cat /dev/null &gt; $filename; echo &quot;Создание / очистка временного файла.&quot;
#  Если файл отсутствует, то он создается,
#+ и очищается, если существует.
#  : &gt; filename   и   &gt; filename дают тот же эффект.

tail /var/log/messages &gt; $filename
# Файл /var/log/messages должен быть доступен для чтения.

echo &quot;В файл $filename записаны последние строки из /var/log/messages.&quot;

exit 0
</pre>
            </div>

            <p>См. также <a
             href="x6646.html#EX41">Пример 12-4</a>, <a
             href="x7794.html#EX52">Пример 12-30</a> и <a
             href="c13099.html#ONLINE">Пример 29-6</a>.</p>
          </dd>

          <dt><a
           name="GREPREF"></a><strong
           class="COMMAND">grep</strong></dt>

          <dd>
            <p>Многоцелевая поисковая утилита, использующая <a
             href="c11895.html#REGEXREF">регулярные выражения</a>.
            Изначально это была команда в древнем строчном редакторе
            <strong
             class="COMMAND">ed</strong>, <tt
             class="USERINPUT"><strong>g/re/p</strong></tt>, что
            означает -- <span
             class="emphasis"><em
             class="EMPHASIS">global - regular expression -
            print</em></span>.</p>

            <p><strong
             class="COMMAND">grep</strong> <tt
             class="REPLACEABLE"><em>pattern</em></tt> [<tt
             class="REPLACEABLE"><em>file</em></tt>...]</p>
            Поиск участков текста в файле(ах), соответствующих шаблону
            <tt
             class="REPLACEABLE"><em>pattern</em></tt>, где <tt
             class="REPLACEABLE"><em>pattern</em></tt> может быть как
            обычной строкой, так и регулярным выражением.<br>
            <br>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>grep &#39;[rst]ystem.$&#39; osinfo.txt</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">The GPL governs the distribution of the Linux operating system.</tt>
             
</pre>
            <br>
            <br>

            <p>Если файл(ы) для поиска не задан, то команда <strong
             class="COMMAND">grep</strong> работает как фильтр для
            устройства <tt
             class="FILENAME">stdout</tt>, например в <a
             href="c301.html#PIPEREF">конвейере</a>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>ps ax | grep clock</strong></tt>
<tt
 class="COMPUTEROUTPUT">765 tty1     S      0:00 xclock
 901 pts/1    S      0:00 grep clock</tt>
             
</pre>
            <br>
            <br>

            <p><tt
             class="OPTION">-i</tt> -- выполняется поиск без учета
            регистра символов.</p>

            <p><tt
             class="OPTION">-w</tt> -- поиск совпадений целого
            слова.</p>

            <p><tt
             class="OPTION">-l</tt> -- вывод только имен файлов, в
            которых найдены участки, совпадающие с заданным
            образцом/шаблоном, без вывода совпадающих строк.</p>

            <p><tt
             class="OPTION">-r</tt> -- (рекурсивный поиск) поиск
            выполняется в текущем каталоге и всех вложенных
            подкаталогах.</p>

            <p>The <tt
             class="OPTION">-n</tt> option lists the matching lines,
            together with line numbers.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>grep -n Linux osinfo.txt</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">2:This is a file containing information about Linux.
 6:The GPL governs the distribution of the Linux operating system.</tt>
             
</pre>
            <br>
            <br>

            <p><tt
             class="OPTION">-v</tt> (или <tt
             class="OPTION">--invert-match</tt>) -- выводит только
            строки, не содержащие совпадений.</p>
<pre
 class="PROGRAMLISTING">
grep pattern1 *.txt | grep -v pattern2

# Выводятся строки из &quot;*.txt&quot;, совпадающие с &quot;pattern1&quot;,
# но ***не*** совпадающие с &quot;pattern2&quot;.
</pre>
            <br>
            <br>

            <p><tt
             class="OPTION">-c</tt> (<tt
             class="OPTION">--count</tt>) -- выводит количество
            совпадений без вывода самих совпадений.</p>
<pre
 class="PROGRAMLISTING">
grep -c txt *.sgml   # (количество совпадений с &quot;txt&quot; в &quot;*.sgml&quot; файлах)


#   grep -cz .
#            ^ точка
# означает подсчет (-c) непустых (&quot;.&quot; -- содержащих хотя бы один символ) элементов,
# разделенных нулевыми байтами (-z)
#
printf &#39;a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf&#39; | grep -cz .     # 4
printf &#39;a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf&#39; | grep -cz &#39;$&#39;   # 5
printf &#39;a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf&#39; | grep -cz &#39;^&#39;   # 5
#
printf &#39;a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf&#39; | grep -c &#39;$&#39;    # 9
# По-умолчанию, в качестве разделителя, принимается символ перевода строки (\n).

# Обратите внимание: ключ -z характерен для GNU-версии &quot;grep&quot;.


# Спасибо S.C.
</pre>
            <br>
            <br>

            <p>Если <strong
             class="COMMAND">grep</strong> вызывается для поиска по
            группе файлов, то вывод будет содержать указание на имена
            файлов, в которых найдены совпадения.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class="USERINPUT"><strong>grep Linux osinfo.txt misc.txt</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">osinfo.txt:This is a file containing information about Linux.
 osinfo.txt:The GPL governs the distribution of the Linux operating system.
 misc.txt:The Linux operating system is steadily gaining in popularity.</tt>
             
</pre>
            <br>
            <br>

            <div
             class="TIP">
              <table
               class="TIP"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/tip.gif"
                   hspace="5"
                   alt="Tip"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Для того, чтобы заставить <strong
                     class="COMMAND">grep</strong> выводить имя файла,
                    когда поиск производится по одному-единственному
                    файлу, достаточно указать устройство <tt
                     class="FILENAME">/dev/null</tt> в качестве второго
                    файла.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>grep Linux osinfo.txt /dev/null</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">osinfo.txt:This is a file containing information about Linux.
 osinfo.txt:The GPL governs the distribution of the Linux operating system.</tt>
             
</pre>
                    <br>
                    <br>
                  </td>
                </tr>
              </table>
            </div>

            <p>Если совпадение было найдено, то <strong
             class="COMMAND">grep</strong> возвращает <a
             href="c2105.html#EXITSTATUSREF">код завершения</a> -- 0,
            это может оказаться полезным при выполнении поиска в
            условных операторах ( в таких случаях особый интерес может
            представлять ключ <tt
             class="OPTION">-q</tt>, который подавляет вывод).</p>
<pre
 class="PROGRAMLISTING">
SUCCESS=0                      # если найдено совпадение
word=Linux
filename=data.file

grep -q &quot;$word&quot; &quot;$filename&quot;    # &quot;-q&quot; -- подавляет вывод на stdout.

if [ $? -eq $SUCCESS ]
then
  echo &quot;Образец $word найден в $filename&quot;
else
  echo &quot;Образец $word в файле $filename не найден&quot;
fi
</pre>
            <br>
            <br>

            <p><a
             href="c13099.html#ONLINE">Пример 29-6</a> -- пример поиска
            заданного образца в системном журнале, с помощью <strong
             class="COMMAND">grep</strong>.</p>

            <div
             class="EXAMPLE">
              <a
               name="GRP"></a>

              <p><strong>Пример 12-12. Сценарий-эмулятор <span
               class="QUOTE">&quot;grep&quot;</span></strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# grp.sh: Очень &quot;грубая&quot; реализация &#39;grep&#39;.

E_BADARGS=65

if [ -z &quot;$1&quot; ]    # Проверка наличия аргументов.
then
  echo &quot;Порядок использования: `basename $0` pattern&quot;
  exit $E_BADARGS
fi

echo

for file in *     # Обход всех файлов в $PWD.
do
  output=$(sed -n /&quot;$1&quot;/p $file)  # Подстановка команд.

  if [ ! -z &quot;$output&quot; ]           # Что произойдет, если кавычки вокруг &quot;$output&quot; убрать?
  then
    echo -n &quot;$file: &quot;
    echo $output
  fi              #  эквивалент: sed -ne &quot;/$1/s|^|${file}: |p&quot;

  echo
done

echo

exit 0

# Упражнения:
# ---------
# 1) Добавьте вывод символов перевода строки, если найдено более одного совпадения в любом из файлов.
# 2) Добавьте обработку различных ключей.
</pre>
            </div>

            <div
             class="NOTE">
              <table
               class="NOTE"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/note.gif"
                   hspace="5"
                   alt="Note"></td>

                  <td
                   align="left"
                   valign="top">
                    <p><a
                     name="EGREPREF"></a><strong
                     class="COMMAND">egrep</strong> -- то же самое, что
                    и <strong
                     class="COMMAND">grep -E</strong>. Эта команда
                    использует несколько отличающийся, расширенный
                    набор <a
                     href="c11895.html#REGEXREF">регулярных
                    выражений</a>, что позволяет выполнять поиск более
                    гибко.</p>

                    <p><strong
                     class="COMMAND">fgrep</strong> -- то же самое, что
                    и <strong
                     class="COMMAND">grep -F</strong>. Эта команда
                    выполняет поиск строк символов (не регулярных
                    выражений), что несколько увеличивает скорость
                    поиска.</p>

                    <p>Утилита <strong
                     class="COMMAND">agrep</strong> имеет более широкие
                    возможности поиска приблизительных совпадений.
                    Образец поиска может отличаться от найденной строки
                    на указанное число символов.</p>
                  </td>
                </tr>
              </table>
            </div>

            <div
             class="TIP">
              <table
               class="TIP"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/tip.gif"
                   hspace="5"
                   alt="Tip"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Для поиска по сжатым файлам следует использовать
                    утилиты <strong
                     class="COMMAND">zgrep</strong>, <strong
                     class="COMMAND">zegrep</strong> или <strong
                     class="COMMAND">zfgrep</strong>. Они с успехом
                    могут использоваться и для не сжатых файлов, но в
                    этом случае они уступают в скорости обычным <strong
                     class="COMMAND">grep</strong>, <strong
                     class="COMMAND">egrep</strong> и <strong
                     class="COMMAND">fgrep</strong>. Они очень удобны
                    при выполнении поиска по смешенному набору файлов
                    -- когда одни файлы сжаты, а другие нет.</p>

                    <p>Для поиска по <a
                     href="x7794.html#BZIPREF">bzip</a>-файлам
                    используйте <strong
                     class="COMMAND">bzgrep</strong>.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">look</strong></dt>

          <dd>
            <p>Команда <strong
             class="COMMAND">look</strong> очень похожа на <strong
             class="COMMAND">grep</strong>, и предназначена для поиска
            по <span
             class="QUOTE">&quot;словарям&quot;</span> --
            отсортированным файлам. По-умолчанию, поиск выполняется в
            файле <tt
             class="FILENAME">/usr/dict/words</tt>, но может быть
            указан и другой словарь.</p>

            <div
             class="EXAMPLE">
              <a
               name="LOOKUP"></a>

              <p><strong>Пример 12-13. Поиск слов в
              словаре</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# lookup: Выполняется поиск каждого слова из файла в словаре.

file=words.data  # Файл с искомыми словами.

echo

while [ &quot;$word&quot; != end ]  # Последнее слово в файле.
do
  read word      # Из файла, потому, что выполнено перенаправление в конце цикла.
  look $word &gt; /dev/null  # Подавление вывода строк из словаря.
  lookup=$?      # Код возврата команды &#39;look&#39;.

  if [ &quot;$lookup&quot; -eq 0 ]
  then
    echo &quot;Слово \&quot;$word\&quot; найдено.&quot;
  else
    echo &quot;Слово \&quot;$word\&quot; не найдено.&quot;
  fi

done &lt;&quot;$file&quot;    # Перенаправление ввода из файла $file, так что &quot;чтение&quot; производится оттуда.

echo

exit 0

# ----------------------------------------------------------------
# Строки, расположенные ниже не будут исполнены, поскольку выше стоит команда &quot;exit&quot;.


# Stephane Chazelas предложил более короткий вариант:

while read word &amp;&amp; [[ $word != end ]]
do if look &quot;$word&quot; &gt; /dev/null
   then echo &quot;Слово \&quot;$word\&quot; найдено.&quot;
   else echo &quot;Слово \&quot;$word\&quot; не найдено.&quot;
   fi
done &lt;&quot;$file&quot;

exit 0
</pre>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">sed</strong>, <strong
           class="COMMAND">awk</strong></dt>

          <dd>
            <p>Скриптовые языки, специально разработанные для анализа
            текстовых данных.</p>
          </dd>

          <dt><strong
           class="COMMAND"><a
           href="a14586.html#SEDREF">sed</a></strong></dt>

          <dd>
            <p>Неинтерактивный <span
             class="QUOTE">&quot;потоковый редактор&quot;</span>.
            Широко используется в сценариях на языке командной
            оболочки.</p>
          </dd>

          <dt><strong
           class="COMMAND"><a
           href="x14802.html#AWKREF">awk</a></strong></dt>

          <dd>
            <p>Утилита контекстного поиска и преобразования текста,
            замечательный инструмент для извлечения и/или обработки
            полей (колонок) в структурированных текстовых файлах.
            Синтаксис awk напоминает язык C.</p>
          </dd>

          <dt><strong
           class="COMMAND">wc</strong></dt>

          <dd>
            <p><span
             class="emphasis"><em
             class="EMPHASIS">wc</em></span> -- <span
             class="QUOTE">&quot;word count&quot;</span>, счетчик слов
            в файле или в потоке:</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash $</tt> <tt
 class="USERINPUT"><strong>wc /usr/doc/sed-3.02/README</strong></tt>
<tt
 class=
"COMPUTEROUTPUT">20     127     838 /usr/doc/sed-3.02/README</tt>
[20 строк  127 слов  838 символов]
</pre>
            <br>
            <br>

            <p><tt
             class="USERINPUT"><strong>wc -w</strong></tt> подсчитывает
            только слова.</p>

            <p><tt
             class="USERINPUT"><strong>wc -l</strong></tt> подсчитывает
            только строки.</p>

            <p><tt
             class="USERINPUT"><strong>wc -c</strong></tt> подсчитывает
            только символы.</p>

            <p><tt
             class="USERINPUT"><strong>wc -L</strong></tt> возвращает
            длину наибольшей строки.</p>

            <p>Подсчет количества <span
             class="emphasis"><em
             class="EMPHASIS">.txt</em></span>-файлов в текущем
            каталоге с помощью <strong
             class="COMMAND">wc</strong>:</p>
<pre
 class="PROGRAMLISTING">
$ ls *.txt | wc -l
# Эта команда будет работать, если ни в одном из имен файлов &quot;*.txt&quot; нет символа перевода строки.

# Альтернативный вариант:
#      find . -maxdepth 1 -name \*.txt -print0 | grep -cz .
#      (shopt -s nullglob; set -- *.txt; echo $#)

# Спасибо S.C.
</pre>
            <br>
            <br>

            <p>Подсчет общего размера файлов, чьи имена начинаются с
            символов, в диапазоне d - h</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>wc [d-h]* | grep total | awk &#39;{print $3}&#39;</strong></tt>
<tt
 class="COMPUTEROUTPUT">71832</tt>
             
</pre>
            <br>
            <br>

            <p>От переводчика: в случае, если у вас локаль отлична от
            &quot;C&quot;, то вышеприведенная команда может не дать
            результата, поскольку <strong
             class="COMMAND">wc</strong> вернет не слово
            &quot;total&quot;, в конце вывода, а &quot;итого&quot;.
            Тогда можно попробовать несколько измененный вариант:</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>wc [d-h]* | grep итого | awk &#39;{print $3}&#39;</strong></tt>
<tt
 class="COMPUTEROUTPUT">71832</tt>
             
</pre>
            <br>
            <br>

            <p>Использование <strong
             class="COMMAND">wc</strong> для подсчета количества
            вхождений слова <span
             class="QUOTE">&quot;Linux&quot;</span> в основной исходный
            файл с текстом этого руководства.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>grep Linux abs-book.sgml | wc -l</strong></tt>
<tt
 class="COMPUTEROUTPUT">50</tt>
             
</pre>
            <br>
            <br>

            <p>См. также <a
             href="x7794.html#EX52">Пример 12-30</a> и <a
             href="x11731.html#REDIR4">Пример 16-7</a>.</p>

            <p>Отдельные команды располагают функциональностью <strong
             class="COMMAND">wc</strong> в виде своих ключей.</p>
<pre
 class="PROGRAMLISTING">
... | grep foo | wc -l
# Часто встречающаяся конструкция, которая может быть сокращена.

... | grep -c foo
# Ключ &quot;-c&quot; (&quot;--count&quot;) команды grep.

# Спасибо S.C.
</pre>
            <br>
            <br>
          </dd>

          <dt><a
           name="TRREF"></a><strong
           class="COMMAND">tr</strong></dt>

          <dd>
            <p>Замена одних символов на другие.</p>

            <div
             class="CAUTION">
              <table
               class="CAUTION"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/caution.gif"
                   hspace="5"
                   alt="Caution"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>В отдельных случаях <a
                     href="c301.html#UCREF">символы необходимо
                    заключать в кавычки и/или квадратные скобки</a>.
                    Кавычки предотвращают интерпретацию специальных
                    символов командной оболочкой. Квадратные скобки
                    должны заключаться в кавычки.</p>
                  </td>
                </tr>
              </table>
            </div>

            <p>Команда <tt
             class="USERINPUT"><strong>tr &quot;A-Z&quot; &quot;*&quot;
            &lt;filename</strong></tt> или <tt
             class="USERINPUT"><strong>tr A-Z \*
            &lt;filename</strong></tt> заменяет все символы верхнего
            регистра в <tt
             class="FILENAME">filename</tt> на звездочки (вывод
            производится на <tt
             class="FILENAME">stdout</tt>). В некоторых системах этот
            вариант может оказаться неработоспособным, тогда попробуйте
            <tt
             class="USERINPUT"><strong>tr A-Z
            &#39;[**]&#39;</strong></tt>.</p>

            <p>Ключ <tt
             class="OPTION">-d</tt> удаляет символы из заданного
            диапазона.</p>
<pre
 class="PROGRAMLISTING">
echo &quot;abcdef&quot;                 # abcdef
echo &quot;abcdef&quot; | tr -d b-d     # aef


tr -d 0-9 &lt;filename
# Удалит все цифровые символы из файла &quot;filename&quot;.
</pre>
            <br>
            <br>

            <p>Ключ <tt
             class="OPTION">--squeeze-repeats</tt> (<tt
             class="OPTION">-s</tt>) удалит все повторяющиеся
            последовательности символов. Может использоваться для
            удаления лишних <a
             href="c301.html#WHITESPACEREF">пробельных
            символов</a>.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>echo &quot;XXXXX&quot; | tr --squeeze-repeats &#39;X&#39;</strong></tt>
<tt
 class="COMPUTEROUTPUT">X</tt>
</pre>
            <br>
            <br>

            <p>Ключ <tt
             class="OPTION">-c</tt> <span
             class="QUOTE">&quot;complement&quot;</span> <span
             class="emphasis"><em
             class="EMPHASIS">заменит</em></span> символы в
            соответствии с шаблоном. Этот ключ воздействует только на
            те символы, которые НЕ соответствуют заданному шаблону.</p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>echo &quot;acfdeb123&quot; | tr -c b-d +</strong></tt>
<tt
 class="COMPUTEROUTPUT">+c+d+b++++</tt>
</pre>
            <br>
            <br>

            <p>Обратите внимание: команда <strong
             class="COMMAND">tr</strong> корректно распознает <a
             href="c11895.html#POSIXREF">символьные классы POSIX</a>.
            <a
             name="AEN7520"
             href="#FTN.AEN7520"><span
             class="footnote">[1]</span></a></p>
<pre
 class="SCREEN">
<tt
 class="PROMPT">bash$</tt> <tt
 class=
"USERINPUT"><strong>echo &quot;abcd2ef1&quot; | tr &#39;[:alpha:]&#39; -</strong></tt>
<tt
 class="COMPUTEROUTPUT">----2--1</tt>
             
</pre>
            <br>
            <br>

            <div
             class="EXAMPLE">
              <a
               name="EX49"></a>

              <p><strong>Пример 12-14. toupper: Преобразование символов
              в верхний регистр.</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# Преобразование символов в верхний регистр.

E_BADARGS=65

if [ -z &quot;$1&quot; ]  # Стандартная проверка командной строки.
then
  echo &quot;Порядок использования: `basename $0` filename&quot;
  exit $E_BADARGS
fi

tr a-z A-Z &lt;&quot;$1&quot;

# Тот же эффект можно получить при использовании символьных классов POSIX:
#        tr &#39;[:lower:]&#39; &#39;[:upper:]&#39; &lt;&quot;$1&quot;
# Спасибо S.C.

exit 0
</pre>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="LOWERCASE"></a>

              <p><strong>Пример 12-15. lowercase: Изменение имен всех
              файлов в текущем каталоге в нижний регистр.</strong></p>
<pre
 class="PROGRAMLISTING">
#! /bin/bash
#
# Изменит все имена файлов в текущем каталоге в нижнй регистр.
#


for filename in *                # Обход всех файлов в каталоге.
do
   fname=`basename $filename`
   n=`echo $fname | tr A-Z a-z`  # Перевести символы в нижний регистр.
   if [ &quot;$fname&quot; != &quot;$n&quot; ]       # Переименовать только те файлы, имена которых изменились.
   then
     mv $fname $n
   fi
done

exit 0


# Сироки приведенные ниже не будут исполняться, поскольку выше стоит команда &quot;exit&quot;.
#--------------------------------------------------------#
# Запустите эту часть сценария, удалив строки , стоящие выше.

# Сценарий, приведенный выше, не работает с именами файлов, содержащими пробелы или символы перевода строки.

# В связи с этим, Stephane Chazelas предложил следующий вариант:


for filename in *    # Нет необходимости использовать basename,
                     # поскольку &quot;*&quot; возвращает имена, не содержащие &quot;/&quot;.
do n=`echo &quot;$filename/&quot; | tr &#39;[:upper:]&#39; &#39;[:lower:]&#39;`
#                             символьные классы POSIX.
#                    Завершающий слэш добавлен для того, чтобы символ перевода строки
#                    не был удален при подстановке команды.
   # Подстановка переменной:
   n=${n%/}          # Удаление завершающего слэша, добавленного выше.
   [[ $filename == $n ]] || mv &quot;$filename&quot; &quot;$n&quot;
                     # Проверка -- действительно ли изменилось имя файла.
done

exit 0
</pre>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="DU"></a>

              <p><strong>Пример 12-16. du: Преобразование текстового
              файла из формата DOS в формат UNIX.</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# du.sh: Преобразование текстового файла из формата DOS в формат UNIX.

E_WRONGARGS=65

if [ -z &quot;$1&quot; ]
then
  echo &quot;Порядок использования: `basename $0` filename-to-convert&quot;
  exit $E_WRONGARGS
fi

NEWFILENAME=$1.unx

CR=&#39;\015&#39;  # Возврат каретки.
# Строки в текстовых файлах DOS завершаются комбинацией символов CR-LF.

tr -d $CR &lt; $1 &gt; $NEWFILENAME
# Удалить символы CR и записать в новый файл.

echo &quot;Исходный текстовый файл: \&quot;$1\&quot;.&quot;
echo &quot;Преобразованный файл: \&quot;$NEWFILENAME\&quot;.&quot;

exit 0
</pre>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="ROT13"></a>

              <p><strong>Пример 12-17. rot13: Сверхслабое шифрование по
              алгоритму rot13.</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# rot13.sh: Классический алгоритм шифрования rot13,
#           который способен &quot;расколоть&quot; даже 3-х летний ребенок.

# Порядок использования: ./rot13.sh filename
# или                    ./rot13.sh &lt;filename
# или                    ./rot13.sh и ввести текст с клавиатуры (stdin)

cat &quot;$@&quot; | tr &#39;a-zA-Z&#39; &#39;n-za-mN-ZA-M&#39;   # &quot;a&quot; заменяется на &quot;n&quot;, &quot;b&quot; на &quot;o&quot;, и т.д.
#  Конструкция &#39;cat &quot;$@&quot;&#39;
#+ позволяет вводить данные как со stdin, так и из файла.

exit 0
</pre>
            </div>

            <div
             class="EXAMPLE">
              <a
               name="CRYPTOQUOTE"></a>

              <p><strong>Пример 12-18. Более <span
               class="QUOTE">&quot;сложный&quot;</span>
              шифр</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# crypto-quote.sh: Ограниченное шифрование

# Шифрование ограничивается простой заменой одних алфавитных символов другими.
#  Результат очень похож на шифры-загадки


key=ETAOINSHRDLUBCFGJMQPVWZYXK
# Здесь, &quot;key&quot; -- ни что иное, как &quot;перемешанный&quot; алфавит.
# Изменение ключа &quot;key&quot; приведет к изменению шифра.

# Конструкция &#39;cat &quot;$@&quot;&#39; позволяет вводить данные как со stdin, так и из файла.
# Если используется stdin, то ввод должен завершаться комбинацией Control-D.
# Иначе,  в командной строке, сценарию должно быть передано имя файла.

cat &quot;$@&quot; |  tr &quot;a-z&quot; &quot;A-Z&quot;   | tr &quot;A-Z&quot; &quot;$key&quot;
#        | в верхний регистр |    шифрование
# Такой прием позволяет шифровать как символы в верхнем регистре, так и в нижнем.
# Неалфавитные символы остаются без изменений.


# Попробуйте зашифровать какой либо текст, например
# &quot;Nothing so needs reforming as other people&#39;s habits.&quot;
# --Mark Twain
#
# Результат будет:
# &quot;CFPHRCS QF CIIOQ MINFMBRCS EQ FPHIM GIFGUI&#39;Q HETRPQ.&quot;
# --BEML PZERC

# Для дешифрации можно использовать следующую комбинацию:
# cat &quot;$@&quot; | tr &quot;$key&quot; &quot;A-Z&quot;


#  Этот нехитрый шифр может быть &quot;взломан&quot; 12-ти летним ребенком
#+ с помощью карандаша и бумаги.

exit 0
</pre>
            </div>

            <table
             class="SIDEBAR"
             border="1"
             cellpadding="5">
              <tr>
                <td>
                  <div
                   class="SIDEBAR">
                    <a
                     name="AEN7548"></a>

                    <p><strong>Различные версии tr</strong></p>

                    <p>Утилита <strong
                     class="COMMAND">tr</strong> имеет две, исторически
                    сложившиеся, версии. BSD-версия не использует
                    квадратные скобки (<tt
                     class="USERINPUT"><strong>tr a-z
                    A-Z</strong></tt>), в то время как SysV-версия
                    использует их (<tt
                     class="USERINPUT"><strong>tr &#39;[a-z]&#39;
                    &#39;[A-Z]&#39;</strong></tt>). GNU-версия утилиты
                    <strong
                     class="COMMAND">tr</strong> напоминает версию BSD,
                    но диапазоны символов обязательно должны
                    заключаться в квадратные скобки.</p>
                  </div>
                </td>
              </tr>
            </table>
          </dd>

          <dt><a
           name="FOLDREF"></a><strong
           class="COMMAND">fold</strong></dt>

          <dd>
            <p>Выравнивает текст по ширине, разрывая, если это
            необходимо, слова. Особый интерес представляет ключ <tt
             class="OPTION">-s</tt>, который производит перенос строк
            по пробелам, стараясь не разрывать слова. (см. <a
             href="x7050.html#EX50">Пример 12-19</a> и <a
             href="a14477.html#MAILFORMAT">Пример A-2</a>).</p>
          </dd>

          <dt><strong
           class="COMMAND">fmt</strong></dt>

          <dd>
            <p>Очень простая утилита форматирования текста, чаще всего
            используемая как фильтр в конвейерах для того, чтобы
            выполнить <span
             class="QUOTE">&quot;перенос&quot;</span> длинных строк
            текста.</p>

            <div
             class="EXAMPLE">
              <a
               name="EX50"></a>

              <p><strong>Пример 12-19. Отформатированный список
              файлов.</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

WIDTH=40                    # 40 символов в строке.

b=`ls /usr/local/bin`       # Получить список файлов...

echo $b | fmt -w $WIDTH

# То же самое можно выполнить командой
#  echo $b | fold - -s -w $WIDTH
 
exit 0
</pre>
            </div>

            <p>См. также <a
             href="x6646.html#EX41">Пример 12-4</a>.</p>

            <div
             class="TIP">
              <table
               class="TIP"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/tip.gif"
                   hspace="5"
                   alt="Tip"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Очень мощной альтернативой утилите <strong
                     class="COMMAND">fmt</strong>, является утилита
                    <strong
                     class="COMMAND">par</strong> (автор Kamil Toman),
                    которую вы сможете найти на <a
                     href="http://www.cs.berkeley.edu/~amc/Par/"
                     target=
                    "_top">http://www.cs.berkeley.edu/~amc/Par/</a>.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">col</strong></dt>

          <dd>
            <p>Эта утилита с обманчивым названием удаляет из входного
            потока символы обратной подачи бумаги (код ESC 7). Она так
            же пытается заменить пробелы на табуляции. Основная область
            применения утилиты <strong
             class="COMMAND">col</strong> -- фильтрация вывода
            отдельных утилит обработки текста, таких как <strong
             class="COMMAND">groff</strong> и <strong
             class="COMMAND">tbl</strong>.</p>
          </dd>

          <dt><strong
           class="COMMAND">column</strong></dt>

          <dd>
            <p>Форматирование по столбцам. Эта утилита преобразует
            текст, например какой либо список, в табличное, более <span
             class="QUOTE">&quot;удобочитаемое&quot;</span>,
            представление, вставляя символы табуляции по мере
            необходимости.</p>

            <div
             class="EXAMPLE">
              <a
               name="COL"></a>

              <p><strong>Пример 12-20. Пример форматирования списка
              файлов в каталоге</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash
# За основу сценария взят пример &quot;man column&quot;.


(printf &quot;PERMISSIONS LINKS OWNER GROUP SIZE DATE TIME PROG-NAME\n&quot; \
; ls -l | sed 1d) | column -t

#  Команда &quot;sed 1d&quot; удаляет первую строку, выводимую командой ls,
#+ (для локали &quot;С&quot; это строка:  &quot;total        N&quot;,
#+ где &quot;N&quot; -- общее количество файлов.

# Ключ -t, команды &quot;column&quot;, означает &quot;табличное&quot; представление.

exit 0
</pre>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">colrm</strong></dt>

          <dd>
            <p>Утилита удаления колонок. Удаляет колонки (столбцы)
            сиволов из файла и выводит результат на <tt
             class="FILENAME">stdout</tt>. <tt
             class="USERINPUT"><strong>colrm 2 4
            &lt;filename</strong></tt> -- удалит символы со 2-го по 4-й
            включительно, в каждой строке в файле <tt
             class="FILENAME">filename</tt>.</p>

            <div
             class="WARNING">
              <table
               class="WARNING"
               width="90%"
               border="0">
                <tr>
                  <td
                   width="25"
                   align="center"
                   valign="top"><img
                   src="misc/abs-book/images/warning.gif"
                   hspace="5"
                   alt="Warning"></td>

                  <td
                   align="left"
                   valign="top">
                    <p>Если файл содержит символы табуляции или
                    непечатаемые символы, то результат может получиться
                    самым неожиданным. В таких случаях, как правило,
                    утилиту <strong
                     class="COMMAND">colrm</strong>, в конвейере,
                    окружают командами <a
                     href="x7050.html#EXPANDREF">expand</a> и <strong
                     class="COMMAND">unexpand</strong>.</p>
                  </td>
                </tr>
              </table>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">nl</strong></dt>

          <dd>
            <p>Нумерует строки в файле. <tt
             class="USERINPUT"><strong>nl filename</strong></tt> --
            выведет файл <tt
             class="FILENAME">filename</tt> на <tt
             class="FILENAME">stdout</tt>, и в начале каждой строки
            вставит ее порядковый номер, счет начинается с первой
            непустой строки. Если файл не указывается, то принимается
            ввод со <tt
             class="FILENAME">stdin.</tt></p>

            <p>Вывод команды <strong
             class="COMMAND">nl</strong> очень напоминает <tt
             class="USERINPUT"><strong>cat -n</strong></tt>, однако,
            по-умолчанию <strong
             class="COMMAND">nl</strong> не нумерует пустые строки.</p>

            <div
             class="EXAMPLE">
              <a
               name="LNUM"></a>

              <p><strong>Пример 12-21. nl: Самонумерующийся
              сценарий.</strong></p>
<pre
 class="PROGRAMLISTING">
#!/bin/bash

# Сценарий выводит себя сам на stdout дважды, нумеруя строки сценария.

# &#39;nl&#39; вставит для этой строки номер 3, поскольку она не нумерует пустые строки.
# &#39;cat -n&#39; вставит для этой строки номер 5.

nl `basename $0`

echo; echo  # А теперь попробуем вывести текст сценария с помощью &#39;cat -n&#39;

cat -n `basename $0`
# Различия состоят в том, что &#39;cat -n&#39; нумерует все строки.
# Обратите внимание: &#39;nl -ba&#39; -- сделает то же самое.

exit 0
</pre>
            </div>
          </dd>

          <dt><strong
           class="COMMAND">pr</strong></dt>

          <dd>
            <p>Подготовка файла к печати. Утилита производит разбивку
            файла на страницы, приводя его в вид пригодный для печати
            или для вывода на экран. Разнообразные ключи позволяют
            выполнять различные манипуляции над строками и колонками,
            соединять строки, устанавливать поля, нумеровать строки,
            добавлять колонтитулы и многое, многое другое. Утилита
            <strong
             class="COMMAND">pr</strong> соединяет в себе
            функциональность таких команд, как <strong
             class="COMMAND">nl</strong>, <strong
             class="COMMAND">paste</strong>, <strong
             class="COMMAND">fold</strong>, <strong
             class="COMMAND">column</strong> и <strong
             class="COMMAND">expand</strong>.</p>

            <p><tt
             class="USERINPUT"><strong>pr -o 5 --width=65 fileZZZ |
            more</strong></tt> -- выдаст хорошо оформленное и разбитое
            на страницы содержимое файла <tt
             class="FILENAME">fileZZZ</tt>.</p>

            <p>Хочу особо отметить ключ <tt
             class="OPTION">-d</tt>, который выводит строки с двойным
            интервалом (тот же эффект, что и <strong
             class="COMMAND">sed -G</strong>).</p>
          </dd>

          <dt><a
           name="GETTEXTREF"></a><strong
           class="COMMAND">gettext</strong></dt>

          <dd>
            <p>GNU утилита, предназначена для нужд <a
             href="a15021.html">локализации</a> и перевода сообщений
            программ, выводимых на экран, на язык пользователя. Не
            смотря на то, что это актуально, прежде всего, для программ
            на языке C, тем не менее <strong
             class="COMMAND">gettext</strong> с успехом может
            использоваться в сценариях командной оболочки для тех же
            целей. См. <tt
             class="REPLACEABLE"><em>info page</em></tt>.</p>
          </dd>

          <dt><strong
           class="COMMAND">iconv</strong></dt>

          <dd>
            <p>Утилита преобразования текста из одной кодировки в
            другую. В основном используется для нужд локализации.</p>
          </dd>

          <dt><strong
           class="COMMAND">recode</strong></dt>

          <dd>
            <p>Может рассматриваться как разновилность утилиты <strong
             class="COMMAND">iconv</strong>, описанной выше.
            Универсальная утилита для преобразования текстовой
            информации в различные кодировки.</p>
          </dd>

          <dt><strong
           class="COMMAND">TeX</strong>, <strong
           class="COMMAND">gs</strong></dt>

          <dd>
            <p><strong
             class="COMMAND">TeX</strong> и <strong
             class="COMMAND">Postscript</strong> -- языки разметки
            текста, используемые для подготовки текста к печати или
            выводу на экран.</p>

            <p><strong
             class="COMMAND">TeX</strong> -- это сложная система
            подготовки к печати, разработанная Дональдом Кнутом (Donald
            Knuth). Эту утилиту удобнее использовать внутри сценария,
            чем в командной строке, поскольку в сценарии проще один раз
            записать все необходимые параметры, передаваемые утилите,
            для получения необходимого результата.</p>

            <p><span
             class="emphasis"><em
             class="EMPHASIS">Ghostscript</em></span> (<strong
             class="COMMAND">gs</strong>) -- это GPL-версия
            интерпретатора Postscript.</p>
          </dd>

          <dt><strong
           class="COMMAND">groff</strong>, <strong
           class="COMMAND">tbl</strong>, <strong
           class="COMMAND">eqn</strong></dt>

          <dd>
            <p><strong
             class="COMMAND">groff</strong> -- это еще один язык
            разметки текста и форматированного вывода. Является
            расширенной GNU-версией пакета <strong
             class="COMMAND">roff/troff</strong> в UNIX-системах.</p>

            <p><strong
             class="COMMAND">tbl</strong> -- утилита обработки таблиц,
            должна рассматриваться как составная часть <strong
             class="COMMAND">groff</strong>, так как ее задачей
            является преобразование таблиц в команды <strong
             class="COMMAND">groff</strong>.</p>

            <p><strong
             class="COMMAND">eqn</strong> -- утилита преобразования
            математических выражений в команды <strong
             class="COMMAND">groff</strong>.</p>
          </dd>

          <dt><strong
           class="COMMAND">lex</strong>, <strong
           class="COMMAND">yacc</strong></dt>

          <dd>
            <p><strong
             class="COMMAND">lex</strong> -- утилита лексического
            разбора текста. В Linux-системах заменена на свободно
            распространяемую утилиту <strong
             class="COMMAND">flex</strong>.</p>

            <p><strong
             class="COMMAND">yacc</strong> -- утилита для создания
            синтаксических анализаторов, на основе набора грамматик,
            задаваемых разработчиком. В Linux-системах, эта утилита
            заменена на свободно распространяемую утилиту <strong
             class="COMMAND">bison</strong>.</p>
          </dd>
        </dl>
      </div>
    </div>

    <h3
     class="FOOTNOTES">Примечания</h3>

    <table
     border="0"
     class="FOOTNOTES"
     width="100%">
      <tr>
        <td
         align="left"
         valign="top"
         width="5%"><a
         name="FTN.AEN7520"
         href="x7050.html#AEN7520"><span
         class="footnote">[1]</span></a></td>

        <td
         align="left"
         valign="top"
         width="95%">
          <p>Это верно только для GNU-версии команды <strong
           class="COMMAND">tr</strong>, поведение этой команды, в
          коммерческих UNIX-системах, может несколько отличаться.</p>
        </td>
      </tr>
    </table>

    <div
     class="NAVFOOTER">
      <hr
       align="left"
       width="100%">

      <table
       summary="Footer navigation table"
       width="100%"
       border="0"
       cellpadding="0"
       cellspacing="0">
        <tr>
          <td
           width="33%"
           align="left"
           valign="top"><a
           href="x6837.html"
           accesskey="P">Назад</a></td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="index.html"
           accesskey="H">К началу</a></td>

          <td
           width="33%"
           align="right"
           valign="top"><a
           href="x7794.html"
           accesskey="N">Вперед</a></td>
        </tr>

        <tr>
          <td
           width="33%"
           align="left"
           valign="top">Команды для работы с датой и временем</td>

          <td
           width="34%"
           align="center"
           valign="top"><a
           href="c6407.html"
           accesskey="U">Наверх</a></td>

          <td
           width="33%"
           align="right"
           valign="top">Команды для работы с файлами и архивами</td>
        </tr>
      </table>
    </div>
  <hr noshade size=1>
<b><a href="http://www.opennet.ru/docs/">Архив документации на OpenNet.ru</a>
</body>
</html>

